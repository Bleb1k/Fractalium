/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/gpu.js/dist/gpu-browser.js":
/*!*************************************************!*\
  !*** ./node_modules/gpu.js/dist/gpu-browser.js ***!
  \*************************************************/
/***/ ((module) => {

/**
 * gpu.js
 * http://gpu.rocks/
 *
 * GPU Accelerated JavaScript
 *
 * @version 2.15.2
 * @date Mon Mar 28 2022 10:51:06 GMT-0400 (Eastern Daylight Time)
 *
 * @license MIT
 * The MIT License
 *
 * Copyright (c) 2022 gpu.js Team
 */(function(f){if(true){module.exports=f()}else { var g; }})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=undefined;if(!f&&c)return require(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=undefined,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = global || self, factory(global.acorn = {}));
}(this, (function (exports) { 'use strict';


  var reservedWords = {
    3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
    5: "class enum extends super const export import",
    6: "enum",
    strict: "implements interface let package private protected public static yield",
    strictBind: "eval arguments"
  };


  var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";

  var keywords = {
    5: ecma5AndLessKeywords,
    "5module": ecma5AndLessKeywords + " export import",
    6: ecma5AndLessKeywords + " const class extends export import super"
  };

  var keywordRelationalOperator = /^in(stanceof)?$/;


  var nonASCIIidentifierStartChars = "\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u037f\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u052f\u0531-\u0556\u0559\u0560-\u0588\u05d0-\u05ea\u05ef-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u0860-\u086a\u08a0-\u08b4\u08b6-\u08c7\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u09fc\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0af9\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d\u0c58-\u0c5a\u0c60\u0c61\u0c80\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d04-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d54-\u0d56\u0d5f-\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e86-\u0e8a\u0e8c-\u0ea3\u0ea5\u0ea7-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1878\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191e\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1c80-\u1c88\u1c90-\u1cba\u1cbd-\u1cbf\u1ce9-\u1cec\u1cee-\u1cf3\u1cf5\u1cf6\u1cfa\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2118-\u211d\u2124\u2126\u2128\u212a-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309b-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312f\u3131-\u318e\u31a0-\u31bf\u31f0-\u31ff\u3400-\u4dbf\u4e00-\u9ffc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua69d\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua7bf\ua7c2-\ua7ca\ua7f5-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua8fd\ua8fe\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\ua9e0-\ua9e4\ua9e6-\ua9ef\ua9fa-\ua9fe\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa7e-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab69\uab70-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc";
  var nonASCIIidentifierChars = "\u200c\u200d\xb7\u0300-\u036f\u0387\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u0669\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u06f0-\u06f9\u0711\u0730-\u074a\u07a6-\u07b0\u07c0-\u07c9\u07eb-\u07f3\u07fd\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u08d3-\u08e1\u08e3-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u09e6-\u09ef\u09fe\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0ae6-\u0aef\u0afa-\u0aff\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b55-\u0b57\u0b62\u0b63\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c00-\u0c04\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c66-\u0c6f\u0c81-\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0ce6-\u0cef\u0d00-\u0d03\u0d3b\u0d3c\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d66-\u0d6f\u0d81-\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0de6-\u0def\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0e50-\u0e59\u0eb1\u0eb4-\u0ebc\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102b-\u103e\u1040-\u1049\u1056-\u1059\u105e-\u1060\u1062-\u1064\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u1369-\u1371\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b4-\u17d3\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u18a9\u1920-\u192b\u1930-\u193b\u1946-\u194f\u19d0-\u19da\u1a17-\u1a1b\u1a55-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1ab0-\u1abd\u1abf\u1ac0\u1b00-\u1b04\u1b34-\u1b44\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1b82\u1ba1-\u1bad\u1bb0-\u1bb9\u1be6-\u1bf3\u1c24-\u1c37\u1c40-\u1c49\u1c50-\u1c59\u1cd0-\u1cd2\u1cd4-\u1ce8\u1ced\u1cf4\u1cf7-\u1cf9\u1dc0-\u1df9\u1dfb-\u1dff\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua620-\ua629\ua66f\ua674-\ua67d\ua69e\ua69f\ua6f0\ua6f1\ua802\ua806\ua80b\ua823-\ua827\ua82c\ua880\ua881\ua8b4-\ua8c5\ua8d0-\ua8d9\ua8e0-\ua8f1\ua8ff-\ua909\ua926-\ua92d\ua947-\ua953\ua980-\ua983\ua9b3-\ua9c0\ua9d0-\ua9d9\ua9e5\ua9f0-\ua9f9\uaa29-\uaa36\uaa43\uaa4c\uaa4d\uaa50-\uaa59\uaa7b-\uaa7d\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uaaeb-\uaaef\uaaf5\uaaf6\uabe3-\uabea\uabec\uabed\uabf0-\uabf9\ufb1e\ufe00-\ufe0f\ufe20-\ufe2f\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f";

  var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
  var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");

  nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;


  var astralIdentifierStartCodes = [0,11,2,25,2,18,2,1,2,14,3,13,35,122,70,52,268,28,4,48,48,31,14,29,6,37,11,29,3,35,5,7,2,4,43,157,19,35,5,35,5,39,9,51,157,310,10,21,11,7,153,5,3,0,2,43,2,1,4,0,3,22,11,22,10,30,66,18,2,1,11,21,11,25,71,55,7,1,65,0,16,3,2,2,2,28,43,28,4,28,36,7,2,27,28,53,11,21,11,18,14,17,111,72,56,50,14,50,14,35,349,41,7,1,79,28,11,0,9,21,107,20,28,22,13,52,76,44,33,24,27,35,30,0,3,0,9,34,4,0,13,47,15,3,22,0,2,0,36,17,2,24,85,6,2,0,2,3,2,14,2,9,8,46,39,7,3,1,3,21,2,6,2,1,2,4,4,0,19,0,13,4,159,52,19,3,21,2,31,47,21,1,2,0,185,46,42,3,37,47,21,0,60,42,14,0,72,26,230,43,117,63,32,7,3,0,3,7,2,1,2,23,16,0,2,0,95,7,3,38,17,0,2,0,29,0,11,39,8,0,22,0,12,45,20,0,35,56,264,8,2,36,18,0,50,29,113,6,2,1,2,37,22,0,26,5,2,1,2,31,15,0,328,18,190,0,80,921,103,110,18,195,2749,1070,4050,582,8634,568,8,30,114,29,19,47,17,3,32,20,6,18,689,63,129,74,6,0,67,12,65,1,2,0,29,6135,9,1237,43,8,8952,286,50,2,18,3,9,395,2309,106,6,12,4,8,8,9,5991,84,2,70,2,1,3,0,3,1,3,3,2,11,2,0,2,6,2,64,2,3,3,7,2,6,2,27,2,3,2,4,2,0,4,6,2,339,3,24,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,7,2357,44,11,6,17,0,370,43,1301,196,60,67,8,0,1205,3,2,26,2,1,2,0,3,0,2,9,2,3,2,0,2,0,7,0,5,0,2,0,2,0,2,2,2,1,2,0,3,0,2,0,2,0,2,0,2,0,2,1,2,0,3,3,2,6,2,3,2,3,2,0,2,9,2,16,6,2,2,4,2,16,4421,42717,35,4148,12,221,3,5761,15,7472,3104,541,1507,4938];

  var astralIdentifierCodes = [509,0,227,0,150,4,294,9,1368,2,2,1,6,3,41,2,5,0,166,1,574,3,9,9,370,1,154,10,176,2,54,14,32,9,16,3,46,10,54,9,7,2,37,13,2,9,6,1,45,0,13,2,49,13,9,3,2,11,83,11,7,0,161,11,6,9,7,3,56,1,2,6,3,1,3,2,10,0,11,1,3,6,4,4,193,17,10,9,5,0,82,19,13,9,214,6,3,8,28,1,83,16,16,9,82,12,9,9,84,14,5,9,243,14,166,9,71,5,2,1,3,3,2,0,2,1,13,9,120,6,3,6,4,0,29,9,41,6,2,3,9,0,10,10,47,15,406,7,2,7,17,9,57,21,2,13,123,5,4,0,2,1,2,6,2,0,9,9,49,4,2,1,2,4,9,9,330,3,19306,9,135,4,60,6,26,9,1014,0,2,54,8,3,82,0,12,1,19628,1,5319,4,4,5,9,7,3,6,31,3,149,2,1418,49,513,54,5,49,9,0,15,0,23,4,2,14,1361,6,2,16,3,6,2,1,2,4,262,6,10,9,419,13,1495,6,110,6,6,9,4759,9,787719,239];

  function isInAstralSet(code, set) {
    var pos = 0x10000;
    for (var i = 0; i < set.length; i += 2) {
      pos += set[i];
      if (pos > code) { return false }
      pos += set[i + 1];
      if (pos >= code) { return true }
    }
  }


  function isIdentifierStart(code, astral) {
    if (code < 65) { return code === 36 }
    if (code < 91) { return true }
    if (code < 97) { return code === 95 }
    if (code < 123) { return true }
    if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code)) }
    if (astral === false) { return false }
    return isInAstralSet(code, astralIdentifierStartCodes)
  }


  function isIdentifierChar(code, astral) {
    if (code < 48) { return code === 36 }
    if (code < 58) { return true }
    if (code < 65) { return false }
    if (code < 91) { return true }
    if (code < 97) { return code === 95 }
    if (code < 123) { return true }
    if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code)) }
    if (astral === false) { return false }
    return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes)
  }





  var TokenType = function TokenType(label, conf) {
    if ( conf === void 0 ) conf = {};

    this.label = label;
    this.keyword = conf.keyword;
    this.beforeExpr = !!conf.beforeExpr;
    this.startsExpr = !!conf.startsExpr;
    this.isLoop = !!conf.isLoop;
    this.isAssign = !!conf.isAssign;
    this.prefix = !!conf.prefix;
    this.postfix = !!conf.postfix;
    this.binop = conf.binop || null;
    this.updateContext = null;
  };

  function binop(name, prec) {
    return new TokenType(name, {beforeExpr: true, binop: prec})
  }
  var beforeExpr = {beforeExpr: true}, startsExpr = {startsExpr: true};


  var keywords$1 = {};

  function kw(name, options) {
    if ( options === void 0 ) options = {};

    options.keyword = name;
    return keywords$1[name] = new TokenType(name, options)
  }

  var types = {
    num: new TokenType("num", startsExpr),
    regexp: new TokenType("regexp", startsExpr),
    string: new TokenType("string", startsExpr),
    name: new TokenType("name", startsExpr),
    eof: new TokenType("eof"),

    bracketL: new TokenType("[", {beforeExpr: true, startsExpr: true}),
    bracketR: new TokenType("]"),
    braceL: new TokenType("{", {beforeExpr: true, startsExpr: true}),
    braceR: new TokenType("}"),
    parenL: new TokenType("(", {beforeExpr: true, startsExpr: true}),
    parenR: new TokenType(")"),
    comma: new TokenType(",", beforeExpr),
    semi: new TokenType(";", beforeExpr),
    colon: new TokenType(":", beforeExpr),
    dot: new TokenType("."),
    question: new TokenType("?", beforeExpr),
    questionDot: new TokenType("?."),
    arrow: new TokenType("=>", beforeExpr),
    template: new TokenType("template"),
    invalidTemplate: new TokenType("invalidTemplate"),
    ellipsis: new TokenType("...", beforeExpr),
    backQuote: new TokenType("`", startsExpr),
    dollarBraceL: new TokenType("${", {beforeExpr: true, startsExpr: true}),


    eq: new TokenType("=", {beforeExpr: true, isAssign: true}),
    assign: new TokenType("_=", {beforeExpr: true, isAssign: true}),
    incDec: new TokenType("++/--", {prefix: true, postfix: true, startsExpr: true}),
    prefix: new TokenType("!/~", {beforeExpr: true, prefix: true, startsExpr: true}),
    logicalOR: binop("||", 1),
    logicalAND: binop("&&", 2),
    bitwiseOR: binop("|", 3),
    bitwiseXOR: binop("^", 4),
    bitwiseAND: binop("&", 5),
    equality: binop("==/!=/===/!==", 6),
    relational: binop("</>/<=/>=", 7),
    bitShift: binop("<</>>/>>>", 8),
    plusMin: new TokenType("+/-", {beforeExpr: true, binop: 9, prefix: true, startsExpr: true}),
    modulo: binop("%", 10),
    star: binop("*", 10),
    slash: binop("/", 10),
    starstar: new TokenType("**", {beforeExpr: true}),
    coalesce: binop("??", 1),

    _break: kw("break"),
    _case: kw("case", beforeExpr),
    _catch: kw("catch"),
    _continue: kw("continue"),
    _debugger: kw("debugger"),
    _default: kw("default", beforeExpr),
    _do: kw("do", {isLoop: true, beforeExpr: true}),
    _else: kw("else", beforeExpr),
    _finally: kw("finally"),
    _for: kw("for", {isLoop: true}),
    _function: kw("function", startsExpr),
    _if: kw("if"),
    _return: kw("return", beforeExpr),
    _switch: kw("switch"),
    _throw: kw("throw", beforeExpr),
    _try: kw("try"),
    _var: kw("var"),
    _const: kw("const"),
    _while: kw("while", {isLoop: true}),
    _with: kw("with"),
    _new: kw("new", {beforeExpr: true, startsExpr: true}),
    _this: kw("this", startsExpr),
    _super: kw("super", startsExpr),
    _class: kw("class", startsExpr),
    _extends: kw("extends", beforeExpr),
    _export: kw("export"),
    _import: kw("import", startsExpr),
    _null: kw("null", startsExpr),
    _true: kw("true", startsExpr),
    _false: kw("false", startsExpr),
    _in: kw("in", {beforeExpr: true, binop: 7}),
    _instanceof: kw("instanceof", {beforeExpr: true, binop: 7}),
    _typeof: kw("typeof", {beforeExpr: true, prefix: true, startsExpr: true}),
    _void: kw("void", {beforeExpr: true, prefix: true, startsExpr: true}),
    _delete: kw("delete", {beforeExpr: true, prefix: true, startsExpr: true})
  };


  var lineBreak = /\r\n?|\n|\u2028|\u2029/;
  var lineBreakG = new RegExp(lineBreak.source, "g");

  function isNewLine(code, ecma2019String) {
    return code === 10 || code === 13 || (!ecma2019String && (code === 0x2028 || code === 0x2029))
  }

  var nonASCIIwhitespace = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/;

  var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;

  var ref = Object.prototype;
  var hasOwnProperty = ref.hasOwnProperty;
  var toString = ref.toString;


  function has(obj, propName) {
    return hasOwnProperty.call(obj, propName)
  }

  var isArray = Array.isArray || (function (obj) { return (
    toString.call(obj) === "[object Array]"
  ); });

  function wordsRegexp(words) {
    return new RegExp("^(?:" + words.replace(/ /g, "|") + ")$")
  }


  var Position = function Position(line, col) {
    this.line = line;
    this.column = col;
  };

  Position.prototype.offset = function offset (n) {
    return new Position(this.line, this.column + n)
  };

  var SourceLocation = function SourceLocation(p, start, end) {
    this.start = start;
    this.end = end;
    if (p.sourceFile !== null) { this.source = p.sourceFile; }
  };


  function getLineInfo(input, offset) {
    for (var line = 1, cur = 0;;) {
      lineBreakG.lastIndex = cur;
      var match = lineBreakG.exec(input);
      if (match && match.index < offset) {
        ++line;
        cur = match.index + match[0].length;
      } else {
        return new Position(line, offset - cur)
      }
    }
  }


  var defaultOptions = {
    ecmaVersion: 10,
    sourceType: "script",
    onInsertedSemicolon: null,
    onTrailingComma: null,
    allowReserved: null,
    allowReturnOutsideFunction: false,
    allowImportExportEverywhere: false,
    allowAwaitOutsideFunction: false,
    allowHashBang: false,
    locations: false,
    onToken: null,
    onComment: null,
    ranges: false,
    program: null,
    sourceFile: null,
    directSourceFile: null,
    preserveParens: false
  };


  function getOptions(opts) {
    var options = {};

    for (var opt in defaultOptions)
      { options[opt] = opts && has(opts, opt) ? opts[opt] : defaultOptions[opt]; }

    if (options.ecmaVersion >= 2015)
      { options.ecmaVersion -= 2009; }

    if (options.allowReserved == null)
      { options.allowReserved = options.ecmaVersion < 5; }

    if (isArray(options.onToken)) {
      var tokens = options.onToken;
      options.onToken = function (token) { return tokens.push(token); };
    }
    if (isArray(options.onComment))
      { options.onComment = pushComment(options, options.onComment); }

    return options
  }

  function pushComment(options, array) {
    return function(block, text, start, end, startLoc, endLoc) {
      var comment = {
        type: block ? "Block" : "Line",
        value: text,
        start: start,
        end: end
      };
      if (options.locations)
        { comment.loc = new SourceLocation(this, startLoc, endLoc); }
      if (options.ranges)
        { comment.range = [start, end]; }
      array.push(comment);
    }
  }

  var
      SCOPE_TOP = 1,
      SCOPE_FUNCTION = 2,
      SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION,
      SCOPE_ASYNC = 4,
      SCOPE_GENERATOR = 8,
      SCOPE_ARROW = 16,
      SCOPE_SIMPLE_CATCH = 32,
      SCOPE_SUPER = 64,
      SCOPE_DIRECT_SUPER = 128;

  function functionFlags(async, generator) {
    return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0)
  }

  var
      BIND_NONE = 0, 
      BIND_VAR = 1, 
      BIND_LEXICAL = 2, 
      BIND_FUNCTION = 3, 
      BIND_SIMPLE_CATCH = 4, 
      BIND_OUTSIDE = 5; 

  var Parser = function Parser(options, input, startPos) {
    this.options = options = getOptions(options);
    this.sourceFile = options.sourceFile;
    this.keywords = wordsRegexp(keywords[options.ecmaVersion >= 6 ? 6 : options.sourceType === "module" ? "5module" : 5]);
    var reserved = "";
    if (options.allowReserved !== true) {
      for (var v = options.ecmaVersion;; v--)
        { if (reserved = reservedWords[v]) { break } }
      if (options.sourceType === "module") { reserved += " await"; }
    }
    this.reservedWords = wordsRegexp(reserved);
    var reservedStrict = (reserved ? reserved + " " : "") + reservedWords.strict;
    this.reservedWordsStrict = wordsRegexp(reservedStrict);
    this.reservedWordsStrictBind = wordsRegexp(reservedStrict + " " + reservedWords.strictBind);
    this.input = String(input);

    this.containsEsc = false;


    if (startPos) {
      this.pos = startPos;
      this.lineStart = this.input.lastIndexOf("\n", startPos - 1) + 1;
      this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;
    } else {
      this.pos = this.lineStart = 0;
      this.curLine = 1;
    }

    this.type = types.eof;
    this.value = null;
    this.start = this.end = this.pos;
    this.startLoc = this.endLoc = this.curPosition();

    this.lastTokEndLoc = this.lastTokStartLoc = null;
    this.lastTokStart = this.lastTokEnd = this.pos;

    this.context = this.initialContext();
    this.exprAllowed = true;

    this.inModule = options.sourceType === "module";
    this.strict = this.inModule || this.strictDirective(this.pos);

    this.potentialArrowAt = -1;

    this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;
    this.labels = [];
    this.undefinedExports = {};

    if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === "#!")
      { this.skipLineComment(2); }

    this.scopeStack = [];
    this.enterScope(SCOPE_TOP);

    this.regexpState = null;
  };

  var prototypeAccessors = { inFunction: { configurable: true },inGenerator: { configurable: true },inAsync: { configurable: true },allowSuper: { configurable: true },allowDirectSuper: { configurable: true },treatFunctionsAsVar: { configurable: true } };

  Parser.prototype.parse = function parse () {
    var node = this.options.program || this.startNode();
    this.nextToken();
    return this.parseTopLevel(node)
  };

  prototypeAccessors.inFunction.get = function () { return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0 };
  prototypeAccessors.inGenerator.get = function () { return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0 };
  prototypeAccessors.inAsync.get = function () { return (this.currentVarScope().flags & SCOPE_ASYNC) > 0 };
  prototypeAccessors.allowSuper.get = function () { return (this.currentThisScope().flags & SCOPE_SUPER) > 0 };
  prototypeAccessors.allowDirectSuper.get = function () { return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0 };
  prototypeAccessors.treatFunctionsAsVar.get = function () { return this.treatFunctionsAsVarInScope(this.currentScope()) };

  Parser.prototype.inNonArrowFunction = function inNonArrowFunction () { return (this.currentThisScope().flags & SCOPE_FUNCTION) > 0 };

  Parser.extend = function extend () {
      var plugins = [], len = arguments.length;
      while ( len-- ) plugins[ len ] = arguments[ len ];

    var cls = this;
    for (var i = 0; i < plugins.length; i++) { cls = plugins[i](cls); }
    return cls
  };

  Parser.parse = function parse (input, options) {
    return new this(options, input).parse()
  };

  Parser.parseExpressionAt = function parseExpressionAt (input, pos, options) {
    var parser = new this(options, input, pos);
    parser.nextToken();
    return parser.parseExpression()
  };

  Parser.tokenizer = function tokenizer (input, options) {
    return new this(options, input)
  };

  Object.defineProperties( Parser.prototype, prototypeAccessors );

  var pp = Parser.prototype;


  var literal = /^(?:'((?:\\.|[^'])*?)'|"((?:\\.|[^"])*?)")/;
  pp.strictDirective = function(start) {
    for (;;) {
      skipWhiteSpace.lastIndex = start;
      start += skipWhiteSpace.exec(this.input)[0].length;
      var match = literal.exec(this.input.slice(start));
      if (!match) { return false }
      if ((match[1] || match[2]) === "use strict") {
        skipWhiteSpace.lastIndex = start + match[0].length;
        var spaceAfter = skipWhiteSpace.exec(this.input), end = spaceAfter.index + spaceAfter[0].length;
        var next = this.input.charAt(end);
        return next === ";" || next === "}" ||
          (lineBreak.test(spaceAfter[0]) &&
           !(/[(`.[+\-/*%<>=,?^&]/.test(next) || next === "!" && this.input.charAt(end + 1) === "="))
      }
      start += match[0].length;

      skipWhiteSpace.lastIndex = start;
      start += skipWhiteSpace.exec(this.input)[0].length;
      if (this.input[start] === ";")
        { start++; }
    }
  };


  pp.eat = function(type) {
    if (this.type === type) {
      this.next();
      return true
    } else {
      return false
    }
  };


  pp.isContextual = function(name) {
    return this.type === types.name && this.value === name && !this.containsEsc
  };


  pp.eatContextual = function(name) {
    if (!this.isContextual(name)) { return false }
    this.next();
    return true
  };


  pp.expectContextual = function(name) {
    if (!this.eatContextual(name)) { this.unexpected(); }
  };


  pp.canInsertSemicolon = function() {
    return this.type === types.eof ||
      this.type === types.braceR ||
      lineBreak.test(this.input.slice(this.lastTokEnd, this.start))
  };

  pp.insertSemicolon = function() {
    if (this.canInsertSemicolon()) {
      if (this.options.onInsertedSemicolon)
        { this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc); }
      return true
    }
  };


  pp.semicolon = function() {
    if (!this.eat(types.semi) && !this.insertSemicolon()) { this.unexpected(); }
  };

  pp.afterTrailingComma = function(tokType, notNext) {
    if (this.type === tokType) {
      if (this.options.onTrailingComma)
        { this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc); }
      if (!notNext)
        { this.next(); }
      return true
    }
  };


  pp.expect = function(type) {
    this.eat(type) || this.unexpected();
  };


  pp.unexpected = function(pos) {
    this.raise(pos != null ? pos : this.start, "Unexpected token");
  };

  function DestructuringErrors() {
    this.shorthandAssign =
    this.trailingComma =
    this.parenthesizedAssign =
    this.parenthesizedBind =
    this.doubleProto =
      -1;
  }

  pp.checkPatternErrors = function(refDestructuringErrors, isAssign) {
    if (!refDestructuringErrors) { return }
    if (refDestructuringErrors.trailingComma > -1)
      { this.raiseRecoverable(refDestructuringErrors.trailingComma, "Comma is not permitted after the rest element"); }
    var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;
    if (parens > -1) { this.raiseRecoverable(parens, "Parenthesized pattern"); }
  };

  pp.checkExpressionErrors = function(refDestructuringErrors, andThrow) {
    if (!refDestructuringErrors) { return false }
    var shorthandAssign = refDestructuringErrors.shorthandAssign;
    var doubleProto = refDestructuringErrors.doubleProto;
    if (!andThrow) { return shorthandAssign >= 0 || doubleProto >= 0 }
    if (shorthandAssign >= 0)
      { this.raise(shorthandAssign, "Shorthand property assignments are valid only in destructuring patterns"); }
    if (doubleProto >= 0)
      { this.raiseRecoverable(doubleProto, "Redefinition of __proto__ property"); }
  };

  pp.checkYieldAwaitInDefaultParams = function() {
    if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos))
      { this.raise(this.yieldPos, "Yield expression cannot be a default value"); }
    if (this.awaitPos)
      { this.raise(this.awaitPos, "Await expression cannot be a default value"); }
  };

  pp.isSimpleAssignTarget = function(expr) {
    if (expr.type === "ParenthesizedExpression")
      { return this.isSimpleAssignTarget(expr.expression) }
    return expr.type === "Identifier" || expr.type === "MemberExpression"
  };

  var pp$1 = Parser.prototype;



  pp$1.parseTopLevel = function(node) {
    var exports = {};
    if (!node.body) { node.body = []; }
    while (this.type !== types.eof) {
      var stmt = this.parseStatement(null, true, exports);
      node.body.push(stmt);
    }
    if (this.inModule)
      { for (var i = 0, list = Object.keys(this.undefinedExports); i < list.length; i += 1)
        {
          var name = list[i];

          this.raiseRecoverable(this.undefinedExports[name].start, ("Export '" + name + "' is not defined"));
        } }
    this.adaptDirectivePrologue(node.body);
    this.next();
    node.sourceType = this.options.sourceType;
    return this.finishNode(node, "Program")
  };

  var loopLabel = {kind: "loop"}, switchLabel = {kind: "switch"};

  pp$1.isLet = function(context) {
    if (this.options.ecmaVersion < 6 || !this.isContextual("let")) { return false }
    skipWhiteSpace.lastIndex = this.pos;
    var skip = skipWhiteSpace.exec(this.input);
    var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
    if (nextCh === 91) { return true } 
    if (context) { return false }

    if (nextCh === 123) { return true } 
    if (isIdentifierStart(nextCh, true)) {
      var pos = next + 1;
      while (isIdentifierChar(this.input.charCodeAt(pos), true)) { ++pos; }
      var ident = this.input.slice(next, pos);
      if (!keywordRelationalOperator.test(ident)) { return true }
    }
    return false
  };

  pp$1.isAsyncFunction = function() {
    if (this.options.ecmaVersion < 8 || !this.isContextual("async"))
      { return false }

    skipWhiteSpace.lastIndex = this.pos;
    var skip = skipWhiteSpace.exec(this.input);
    var next = this.pos + skip[0].length;
    return !lineBreak.test(this.input.slice(this.pos, next)) &&
      this.input.slice(next, next + 8) === "function" &&
      (next + 8 === this.input.length || !isIdentifierChar(this.input.charAt(next + 8)))
  };


  pp$1.parseStatement = function(context, topLevel, exports) {
    var starttype = this.type, node = this.startNode(), kind;

    if (this.isLet(context)) {
      starttype = types._var;
      kind = "let";
    }


    switch (starttype) {
    case types._break: case types._continue: return this.parseBreakContinueStatement(node, starttype.keyword)
    case types._debugger: return this.parseDebuggerStatement(node)
    case types._do: return this.parseDoStatement(node)
    case types._for: return this.parseForStatement(node)
    case types._function:
      if ((context && (this.strict || context !== "if" && context !== "label")) && this.options.ecmaVersion >= 6) { this.unexpected(); }
      return this.parseFunctionStatement(node, false, !context)
    case types._class:
      if (context) { this.unexpected(); }
      return this.parseClass(node, true)
    case types._if: return this.parseIfStatement(node)
    case types._return: return this.parseReturnStatement(node)
    case types._switch: return this.parseSwitchStatement(node)
    case types._throw: return this.parseThrowStatement(node)
    case types._try: return this.parseTryStatement(node)
    case types._const: case types._var:
      kind = kind || this.value;
      if (context && kind !== "var") { this.unexpected(); }
      return this.parseVarStatement(node, kind)
    case types._while: return this.parseWhileStatement(node)
    case types._with: return this.parseWithStatement(node)
    case types.braceL: return this.parseBlock(true, node)
    case types.semi: return this.parseEmptyStatement(node)
    case types._export:
    case types._import:
      if (this.options.ecmaVersion > 10 && starttype === types._import) {
        skipWhiteSpace.lastIndex = this.pos;
        var skip = skipWhiteSpace.exec(this.input);
        var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
        if (nextCh === 40 || nextCh === 46) 
          { return this.parseExpressionStatement(node, this.parseExpression()) }
      }

      if (!this.options.allowImportExportEverywhere) {
        if (!topLevel)
          { this.raise(this.start, "'import' and 'export' may only appear at the top level"); }
        if (!this.inModule)
          { this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'"); }
      }
      return starttype === types._import ? this.parseImport(node) : this.parseExport(node, exports)

    default:
      if (this.isAsyncFunction()) {
        if (context) { this.unexpected(); }
        this.next();
        return this.parseFunctionStatement(node, true, !context)
      }

      var maybeName = this.value, expr = this.parseExpression();
      if (starttype === types.name && expr.type === "Identifier" && this.eat(types.colon))
        { return this.parseLabeledStatement(node, maybeName, expr, context) }
      else { return this.parseExpressionStatement(node, expr) }
    }
  };

  pp$1.parseBreakContinueStatement = function(node, keyword) {
    var isBreak = keyword === "break";
    this.next();
    if (this.eat(types.semi) || this.insertSemicolon()) { node.label = null; }
    else if (this.type !== types.name) { this.unexpected(); }
    else {
      node.label = this.parseIdent();
      this.semicolon();
    }

    var i = 0;
    for (; i < this.labels.length; ++i) {
      var lab = this.labels[i];
      if (node.label == null || lab.name === node.label.name) {
        if (lab.kind != null && (isBreak || lab.kind === "loop")) { break }
        if (node.label && isBreak) { break }
      }
    }
    if (i === this.labels.length) { this.raise(node.start, "Unsyntactic " + keyword); }
    return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement")
  };

  pp$1.parseDebuggerStatement = function(node) {
    this.next();
    this.semicolon();
    return this.finishNode(node, "DebuggerStatement")
  };

  pp$1.parseDoStatement = function(node) {
    this.next();
    this.labels.push(loopLabel);
    node.body = this.parseStatement("do");
    this.labels.pop();
    this.expect(types._while);
    node.test = this.parseParenExpression();
    if (this.options.ecmaVersion >= 6)
      { this.eat(types.semi); }
    else
      { this.semicolon(); }
    return this.finishNode(node, "DoWhileStatement")
  };


  pp$1.parseForStatement = function(node) {
    this.next();
    var awaitAt = (this.options.ecmaVersion >= 9 && (this.inAsync || (!this.inFunction && this.options.allowAwaitOutsideFunction)) && this.eatContextual("await")) ? this.lastTokStart : -1;
    this.labels.push(loopLabel);
    this.enterScope(0);
    this.expect(types.parenL);
    if (this.type === types.semi) {
      if (awaitAt > -1) { this.unexpected(awaitAt); }
      return this.parseFor(node, null)
    }
    var isLet = this.isLet();
    if (this.type === types._var || this.type === types._const || isLet) {
      var init$1 = this.startNode(), kind = isLet ? "let" : this.value;
      this.next();
      this.parseVar(init$1, true, kind);
      this.finishNode(init$1, "VariableDeclaration");
      if ((this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual("of"))) && init$1.declarations.length === 1) {
        if (this.options.ecmaVersion >= 9) {
          if (this.type === types._in) {
            if (awaitAt > -1) { this.unexpected(awaitAt); }
          } else { node.await = awaitAt > -1; }
        }
        return this.parseForIn(node, init$1)
      }
      if (awaitAt > -1) { this.unexpected(awaitAt); }
      return this.parseFor(node, init$1)
    }
    var refDestructuringErrors = new DestructuringErrors;
    var init = this.parseExpression(true, refDestructuringErrors);
    if (this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
      if (this.options.ecmaVersion >= 9) {
        if (this.type === types._in) {
          if (awaitAt > -1) { this.unexpected(awaitAt); }
        } else { node.await = awaitAt > -1; }
      }
      this.toAssignable(init, false, refDestructuringErrors);
      this.checkLVal(init);
      return this.parseForIn(node, init)
    } else {
      this.checkExpressionErrors(refDestructuringErrors, true);
    }
    if (awaitAt > -1) { this.unexpected(awaitAt); }
    return this.parseFor(node, init)
  };

  pp$1.parseFunctionStatement = function(node, isAsync, declarationPosition) {
    this.next();
    return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync)
  };

  pp$1.parseIfStatement = function(node) {
    this.next();
    node.test = this.parseParenExpression();
    node.consequent = this.parseStatement("if");
    node.alternate = this.eat(types._else) ? this.parseStatement("if") : null;
    return this.finishNode(node, "IfStatement")
  };

  pp$1.parseReturnStatement = function(node) {
    if (!this.inFunction && !this.options.allowReturnOutsideFunction)
      { this.raise(this.start, "'return' outside of function"); }
    this.next();


    if (this.eat(types.semi) || this.insertSemicolon()) { node.argument = null; }
    else { node.argument = this.parseExpression(); this.semicolon(); }
    return this.finishNode(node, "ReturnStatement")
  };

  pp$1.parseSwitchStatement = function(node) {
    this.next();
    node.discriminant = this.parseParenExpression();
    node.cases = [];
    this.expect(types.braceL);
    this.labels.push(switchLabel);
    this.enterScope(0);


    var cur;
    for (var sawDefault = false; this.type !== types.braceR;) {
      if (this.type === types._case || this.type === types._default) {
        var isCase = this.type === types._case;
        if (cur) { this.finishNode(cur, "SwitchCase"); }
        node.cases.push(cur = this.startNode());
        cur.consequent = [];
        this.next();
        if (isCase) {
          cur.test = this.parseExpression();
        } else {
          if (sawDefault) { this.raiseRecoverable(this.lastTokStart, "Multiple default clauses"); }
          sawDefault = true;
          cur.test = null;
        }
        this.expect(types.colon);
      } else {
        if (!cur) { this.unexpected(); }
        cur.consequent.push(this.parseStatement(null));
      }
    }
    this.exitScope();
    if (cur) { this.finishNode(cur, "SwitchCase"); }
    this.next(); 
    this.labels.pop();
    return this.finishNode(node, "SwitchStatement")
  };

  pp$1.parseThrowStatement = function(node) {
    this.next();
    if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start)))
      { this.raise(this.lastTokEnd, "Illegal newline after throw"); }
    node.argument = this.parseExpression();
    this.semicolon();
    return this.finishNode(node, "ThrowStatement")
  };


  var empty = [];

  pp$1.parseTryStatement = function(node) {
    this.next();
    node.block = this.parseBlock();
    node.handler = null;
    if (this.type === types._catch) {
      var clause = this.startNode();
      this.next();
      if (this.eat(types.parenL)) {
        clause.param = this.parseBindingAtom();
        var simple = clause.param.type === "Identifier";
        this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);
        this.checkLVal(clause.param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);
        this.expect(types.parenR);
      } else {
        if (this.options.ecmaVersion < 10) { this.unexpected(); }
        clause.param = null;
        this.enterScope(0);
      }
      clause.body = this.parseBlock(false);
      this.exitScope();
      node.handler = this.finishNode(clause, "CatchClause");
    }
    node.finalizer = this.eat(types._finally) ? this.parseBlock() : null;
    if (!node.handler && !node.finalizer)
      { this.raise(node.start, "Missing catch or finally clause"); }
    return this.finishNode(node, "TryStatement")
  };

  pp$1.parseVarStatement = function(node, kind) {
    this.next();
    this.parseVar(node, false, kind);
    this.semicolon();
    return this.finishNode(node, "VariableDeclaration")
  };

  pp$1.parseWhileStatement = function(node) {
    this.next();
    node.test = this.parseParenExpression();
    this.labels.push(loopLabel);
    node.body = this.parseStatement("while");
    this.labels.pop();
    return this.finishNode(node, "WhileStatement")
  };

  pp$1.parseWithStatement = function(node) {
    if (this.strict) { this.raise(this.start, "'with' in strict mode"); }
    this.next();
    node.object = this.parseParenExpression();
    node.body = this.parseStatement("with");
    return this.finishNode(node, "WithStatement")
  };

  pp$1.parseEmptyStatement = function(node) {
    this.next();
    return this.finishNode(node, "EmptyStatement")
  };

  pp$1.parseLabeledStatement = function(node, maybeName, expr, context) {
    for (var i$1 = 0, list = this.labels; i$1 < list.length; i$1 += 1)
      {
      var label = list[i$1];

      if (label.name === maybeName)
        { this.raise(expr.start, "Label '" + maybeName + "' is already declared");
    } }
    var kind = this.type.isLoop ? "loop" : this.type === types._switch ? "switch" : null;
    for (var i = this.labels.length - 1; i >= 0; i--) {
      var label$1 = this.labels[i];
      if (label$1.statementStart === node.start) {
        label$1.statementStart = this.start;
        label$1.kind = kind;
      } else { break }
    }
    this.labels.push({name: maybeName, kind: kind, statementStart: this.start});
    node.body = this.parseStatement(context ? context.indexOf("label") === -1 ? context + "label" : context : "label");
    this.labels.pop();
    node.label = expr;
    return this.finishNode(node, "LabeledStatement")
  };

  pp$1.parseExpressionStatement = function(node, expr) {
    node.expression = expr;
    this.semicolon();
    return this.finishNode(node, "ExpressionStatement")
  };


  pp$1.parseBlock = function(createNewLexicalScope, node, exitStrict) {
    if ( createNewLexicalScope === void 0 ) createNewLexicalScope = true;
    if ( node === void 0 ) node = this.startNode();

    node.body = [];
    this.expect(types.braceL);
    if (createNewLexicalScope) { this.enterScope(0); }
    while (this.type !== types.braceR) {
      var stmt = this.parseStatement(null);
      node.body.push(stmt);
    }
    if (exitStrict) { this.strict = false; }
    this.next();
    if (createNewLexicalScope) { this.exitScope(); }
    return this.finishNode(node, "BlockStatement")
  };


  pp$1.parseFor = function(node, init) {
    node.init = init;
    this.expect(types.semi);
    node.test = this.type === types.semi ? null : this.parseExpression();
    this.expect(types.semi);
    node.update = this.type === types.parenR ? null : this.parseExpression();
    this.expect(types.parenR);
    node.body = this.parseStatement("for");
    this.exitScope();
    this.labels.pop();
    return this.finishNode(node, "ForStatement")
  };


  pp$1.parseForIn = function(node, init) {
    var isForIn = this.type === types._in;
    this.next();

    if (
      init.type === "VariableDeclaration" &&
      init.declarations[0].init != null &&
      (
        !isForIn ||
        this.options.ecmaVersion < 8 ||
        this.strict ||
        init.kind !== "var" ||
        init.declarations[0].id.type !== "Identifier"
      )
    ) {
      this.raise(
        init.start,
        ((isForIn ? "for-in" : "for-of") + " loop variable declaration may not have an initializer")
      );
    } else if (init.type === "AssignmentPattern") {
      this.raise(init.start, "Invalid left-hand side in for-loop");
    }
    node.left = init;
    node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();
    this.expect(types.parenR);
    node.body = this.parseStatement("for");
    this.exitScope();
    this.labels.pop();
    return this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement")
  };


  pp$1.parseVar = function(node, isFor, kind) {
    node.declarations = [];
    node.kind = kind;
    for (;;) {
      var decl = this.startNode();
      this.parseVarId(decl, kind);
      if (this.eat(types.eq)) {
        decl.init = this.parseMaybeAssign(isFor);
      } else if (kind === "const" && !(this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual("of")))) {
        this.unexpected();
      } else if (decl.id.type !== "Identifier" && !(isFor && (this.type === types._in || this.isContextual("of")))) {
        this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value");
      } else {
        decl.init = null;
      }
      node.declarations.push(this.finishNode(decl, "VariableDeclarator"));
      if (!this.eat(types.comma)) { break }
    }
    return node
  };

  pp$1.parseVarId = function(decl, kind) {
    decl.id = this.parseBindingAtom();
    this.checkLVal(decl.id, kind === "var" ? BIND_VAR : BIND_LEXICAL, false);
  };

  var FUNC_STATEMENT = 1, FUNC_HANGING_STATEMENT = 2, FUNC_NULLABLE_ID = 4;


  pp$1.parseFunction = function(node, statement, allowExpressionBody, isAsync) {
    this.initFunction(node);
    if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {
      if (this.type === types.star && (statement & FUNC_HANGING_STATEMENT))
        { this.unexpected(); }
      node.generator = this.eat(types.star);
    }
    if (this.options.ecmaVersion >= 8)
      { node.async = !!isAsync; }

    if (statement & FUNC_STATEMENT) {
      node.id = (statement & FUNC_NULLABLE_ID) && this.type !== types.name ? null : this.parseIdent();
      if (node.id && !(statement & FUNC_HANGING_STATEMENT))
        { this.checkLVal(node.id, (this.strict || node.generator || node.async) ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION); }
    }

    var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
    this.yieldPos = 0;
    this.awaitPos = 0;
    this.awaitIdentPos = 0;
    this.enterScope(functionFlags(node.async, node.generator));

    if (!(statement & FUNC_STATEMENT))
      { node.id = this.type === types.name ? this.parseIdent() : null; }

    this.parseFunctionParams(node);
    this.parseFunctionBody(node, allowExpressionBody, false);

    this.yieldPos = oldYieldPos;
    this.awaitPos = oldAwaitPos;
    this.awaitIdentPos = oldAwaitIdentPos;
    return this.finishNode(node, (statement & FUNC_STATEMENT) ? "FunctionDeclaration" : "FunctionExpression")
  };

  pp$1.parseFunctionParams = function(node) {
    this.expect(types.parenL);
    node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);
    this.checkYieldAwaitInDefaultParams();
  };


  pp$1.parseClass = function(node, isStatement) {
    this.next();

    var oldStrict = this.strict;
    this.strict = true;

    this.parseClassId(node, isStatement);
    this.parseClassSuper(node);
    var classBody = this.startNode();
    var hadConstructor = false;
    classBody.body = [];
    this.expect(types.braceL);
    while (this.type !== types.braceR) {
      var element = this.parseClassElement(node.superClass !== null);
      if (element) {
        classBody.body.push(element);
        if (element.type === "MethodDefinition" && element.kind === "constructor") {
          if (hadConstructor) { this.raise(element.start, "Duplicate constructor in the same class"); }
          hadConstructor = true;
        }
      }
    }
    this.strict = oldStrict;
    this.next();
    node.body = this.finishNode(classBody, "ClassBody");
    return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression")
  };

  pp$1.parseClassElement = function(constructorAllowsSuper) {
    var this$1 = this;

    if (this.eat(types.semi)) { return null }

    var method = this.startNode();
    var tryContextual = function (k, noLineBreak) {
      if ( noLineBreak === void 0 ) noLineBreak = false;

      var start = this$1.start, startLoc = this$1.startLoc;
      if (!this$1.eatContextual(k)) { return false }
      if (this$1.type !== types.parenL && (!noLineBreak || !this$1.canInsertSemicolon())) { return true }
      if (method.key) { this$1.unexpected(); }
      method.computed = false;
      method.key = this$1.startNodeAt(start, startLoc);
      method.key.name = k;
      this$1.finishNode(method.key, "Identifier");
      return false
    };

    method.kind = "method";
    method.static = tryContextual("static");
    var isGenerator = this.eat(types.star);
    var isAsync = false;
    if (!isGenerator) {
      if (this.options.ecmaVersion >= 8 && tryContextual("async", true)) {
        isAsync = true;
        isGenerator = this.options.ecmaVersion >= 9 && this.eat(types.star);
      } else if (tryContextual("get")) {
        method.kind = "get";
      } else if (tryContextual("set")) {
        method.kind = "set";
      }
    }
    if (!method.key) { this.parsePropertyName(method); }
    var key = method.key;
    var allowsDirectSuper = false;
    if (!method.computed && !method.static && (key.type === "Identifier" && key.name === "constructor" ||
        key.type === "Literal" && key.value === "constructor")) {
      if (method.kind !== "method") { this.raise(key.start, "Constructor can't have get/set modifier"); }
      if (isGenerator) { this.raise(key.start, "Constructor can't be a generator"); }
      if (isAsync) { this.raise(key.start, "Constructor can't be an async method"); }
      method.kind = "constructor";
      allowsDirectSuper = constructorAllowsSuper;
    } else if (method.static && key.type === "Identifier" && key.name === "prototype") {
      this.raise(key.start, "Classes may not have a static property named prototype");
    }
    this.parseClassMethod(method, isGenerator, isAsync, allowsDirectSuper);
    if (method.kind === "get" && method.value.params.length !== 0)
      { this.raiseRecoverable(method.value.start, "getter should have no params"); }
    if (method.kind === "set" && method.value.params.length !== 1)
      { this.raiseRecoverable(method.value.start, "setter should have exactly one param"); }
    if (method.kind === "set" && method.value.params[0].type === "RestElement")
      { this.raiseRecoverable(method.value.params[0].start, "Setter cannot use rest params"); }
    return method
  };

  pp$1.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {
    method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);
    return this.finishNode(method, "MethodDefinition")
  };

  pp$1.parseClassId = function(node, isStatement) {
    if (this.type === types.name) {
      node.id = this.parseIdent();
      if (isStatement)
        { this.checkLVal(node.id, BIND_LEXICAL, false); }
    } else {
      if (isStatement === true)
        { this.unexpected(); }
      node.id = null;
    }
  };

  pp$1.parseClassSuper = function(node) {
    node.superClass = this.eat(types._extends) ? this.parseExprSubscripts() : null;
  };


  pp$1.parseExport = function(node, exports) {
    this.next();
    if (this.eat(types.star)) {
      if (this.options.ecmaVersion >= 11) {
        if (this.eatContextual("as")) {
          node.exported = this.parseIdent(true);
          this.checkExport(exports, node.exported.name, this.lastTokStart);
        } else {
          node.exported = null;
        }
      }
      this.expectContextual("from");
      if (this.type !== types.string) { this.unexpected(); }
      node.source = this.parseExprAtom();
      this.semicolon();
      return this.finishNode(node, "ExportAllDeclaration")
    }
    if (this.eat(types._default)) { 
      this.checkExport(exports, "default", this.lastTokStart);
      var isAsync;
      if (this.type === types._function || (isAsync = this.isAsyncFunction())) {
        var fNode = this.startNode();
        this.next();
        if (isAsync) { this.next(); }
        node.declaration = this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);
      } else if (this.type === types._class) {
        var cNode = this.startNode();
        node.declaration = this.parseClass(cNode, "nullableID");
      } else {
        node.declaration = this.parseMaybeAssign();
        this.semicolon();
      }
      return this.finishNode(node, "ExportDefaultDeclaration")
    }
    if (this.shouldParseExportStatement()) {
      node.declaration = this.parseStatement(null);
      if (node.declaration.type === "VariableDeclaration")
        { this.checkVariableExport(exports, node.declaration.declarations); }
      else
        { this.checkExport(exports, node.declaration.id.name, node.declaration.id.start); }
      node.specifiers = [];
      node.source = null;
    } else { 
      node.declaration = null;
      node.specifiers = this.parseExportSpecifiers(exports);
      if (this.eatContextual("from")) {
        if (this.type !== types.string) { this.unexpected(); }
        node.source = this.parseExprAtom();
      } else {
        for (var i = 0, list = node.specifiers; i < list.length; i += 1) {
          var spec = list[i];

          this.checkUnreserved(spec.local);
          this.checkLocalExport(spec.local);
        }

        node.source = null;
      }
      this.semicolon();
    }
    return this.finishNode(node, "ExportNamedDeclaration")
  };

  pp$1.checkExport = function(exports, name, pos) {
    if (!exports) { return }
    if (has(exports, name))
      { this.raiseRecoverable(pos, "Duplicate export '" + name + "'"); }
    exports[name] = true;
  };

  pp$1.checkPatternExport = function(exports, pat) {
    var type = pat.type;
    if (type === "Identifier")
      { this.checkExport(exports, pat.name, pat.start); }
    else if (type === "ObjectPattern")
      { for (var i = 0, list = pat.properties; i < list.length; i += 1)
        {
          var prop = list[i];

          this.checkPatternExport(exports, prop);
        } }
    else if (type === "ArrayPattern")
      { for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {
        var elt = list$1[i$1];

          if (elt) { this.checkPatternExport(exports, elt); }
      } }
    else if (type === "Property")
      { this.checkPatternExport(exports, pat.value); }
    else if (type === "AssignmentPattern")
      { this.checkPatternExport(exports, pat.left); }
    else if (type === "RestElement")
      { this.checkPatternExport(exports, pat.argument); }
    else if (type === "ParenthesizedExpression")
      { this.checkPatternExport(exports, pat.expression); }
  };

  pp$1.checkVariableExport = function(exports, decls) {
    if (!exports) { return }
    for (var i = 0, list = decls; i < list.length; i += 1)
      {
      var decl = list[i];

      this.checkPatternExport(exports, decl.id);
    }
  };

  pp$1.shouldParseExportStatement = function() {
    return this.type.keyword === "var" ||
      this.type.keyword === "const" ||
      this.type.keyword === "class" ||
      this.type.keyword === "function" ||
      this.isLet() ||
      this.isAsyncFunction()
  };


  pp$1.parseExportSpecifiers = function(exports) {
    var nodes = [], first = true;
    this.expect(types.braceL);
    while (!this.eat(types.braceR)) {
      if (!first) {
        this.expect(types.comma);
        if (this.afterTrailingComma(types.braceR)) { break }
      } else { first = false; }

      var node = this.startNode();
      node.local = this.parseIdent(true);
      node.exported = this.eatContextual("as") ? this.parseIdent(true) : node.local;
      this.checkExport(exports, node.exported.name, node.exported.start);
      nodes.push(this.finishNode(node, "ExportSpecifier"));
    }
    return nodes
  };


  pp$1.parseImport = function(node) {
    this.next();
    if (this.type === types.string) {
      node.specifiers = empty;
      node.source = this.parseExprAtom();
    } else {
      node.specifiers = this.parseImportSpecifiers();
      this.expectContextual("from");
      node.source = this.type === types.string ? this.parseExprAtom() : this.unexpected();
    }
    this.semicolon();
    return this.finishNode(node, "ImportDeclaration")
  };


  pp$1.parseImportSpecifiers = function() {
    var nodes = [], first = true;
    if (this.type === types.name) {
      var node = this.startNode();
      node.local = this.parseIdent();
      this.checkLVal(node.local, BIND_LEXICAL);
      nodes.push(this.finishNode(node, "ImportDefaultSpecifier"));
      if (!this.eat(types.comma)) { return nodes }
    }
    if (this.type === types.star) {
      var node$1 = this.startNode();
      this.next();
      this.expectContextual("as");
      node$1.local = this.parseIdent();
      this.checkLVal(node$1.local, BIND_LEXICAL);
      nodes.push(this.finishNode(node$1, "ImportNamespaceSpecifier"));
      return nodes
    }
    this.expect(types.braceL);
    while (!this.eat(types.braceR)) {
      if (!first) {
        this.expect(types.comma);
        if (this.afterTrailingComma(types.braceR)) { break }
      } else { first = false; }

      var node$2 = this.startNode();
      node$2.imported = this.parseIdent(true);
      if (this.eatContextual("as")) {
        node$2.local = this.parseIdent();
      } else {
        this.checkUnreserved(node$2.imported);
        node$2.local = node$2.imported;
      }
      this.checkLVal(node$2.local, BIND_LEXICAL);
      nodes.push(this.finishNode(node$2, "ImportSpecifier"));
    }
    return nodes
  };

  pp$1.adaptDirectivePrologue = function(statements) {
    for (var i = 0; i < statements.length && this.isDirectiveCandidate(statements[i]); ++i) {
      statements[i].directive = statements[i].expression.raw.slice(1, -1);
    }
  };
  pp$1.isDirectiveCandidate = function(statement) {
    return (
      statement.type === "ExpressionStatement" &&
      statement.expression.type === "Literal" &&
      typeof statement.expression.value === "string" &&
      (this.input[statement.start] === "\"" || this.input[statement.start] === "'")
    )
  };

  var pp$2 = Parser.prototype;


  pp$2.toAssignable = function(node, isBinding, refDestructuringErrors) {
    if (this.options.ecmaVersion >= 6 && node) {
      switch (node.type) {
      case "Identifier":
        if (this.inAsync && node.name === "await")
          { this.raise(node.start, "Cannot use 'await' as identifier inside an async function"); }
        break

      case "ObjectPattern":
      case "ArrayPattern":
      case "RestElement":
        break

      case "ObjectExpression":
        node.type = "ObjectPattern";
        if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }
        for (var i = 0, list = node.properties; i < list.length; i += 1) {
          var prop = list[i];

        this.toAssignable(prop, isBinding);
          if (
            prop.type === "RestElement" &&
            (prop.argument.type === "ArrayPattern" || prop.argument.type === "ObjectPattern")
          ) {
            this.raise(prop.argument.start, "Unexpected token");
          }
        }
        break

      case "Property":
        if (node.kind !== "init") { this.raise(node.key.start, "Object pattern can't contain getter or setter"); }
        this.toAssignable(node.value, isBinding);
        break

      case "ArrayExpression":
        node.type = "ArrayPattern";
        if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }
        this.toAssignableList(node.elements, isBinding);
        break

      case "SpreadElement":
        node.type = "RestElement";
        this.toAssignable(node.argument, isBinding);
        if (node.argument.type === "AssignmentPattern")
          { this.raise(node.argument.start, "Rest elements cannot have a default value"); }
        break

      case "AssignmentExpression":
        if (node.operator !== "=") { this.raise(node.left.end, "Only '=' operator can be used for specifying default value."); }
        node.type = "AssignmentPattern";
        delete node.operator;
        this.toAssignable(node.left, isBinding);

      case "AssignmentPattern":
        break

      case "ParenthesizedExpression":
        this.toAssignable(node.expression, isBinding, refDestructuringErrors);
        break

      case "ChainExpression":
        this.raiseRecoverable(node.start, "Optional chaining cannot appear in left-hand side");
        break

      case "MemberExpression":
        if (!isBinding) { break }

      default:
        this.raise(node.start, "Assigning to rvalue");
      }
    } else if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }
    return node
  };


  pp$2.toAssignableList = function(exprList, isBinding) {
    var end = exprList.length;
    for (var i = 0; i < end; i++) {
      var elt = exprList[i];
      if (elt) { this.toAssignable(elt, isBinding); }
    }
    if (end) {
      var last = exprList[end - 1];
      if (this.options.ecmaVersion === 6 && isBinding && last && last.type === "RestElement" && last.argument.type !== "Identifier")
        { this.unexpected(last.argument.start); }
    }
    return exprList
  };


  pp$2.parseSpread = function(refDestructuringErrors) {
    var node = this.startNode();
    this.next();
    node.argument = this.parseMaybeAssign(false, refDestructuringErrors);
    return this.finishNode(node, "SpreadElement")
  };

  pp$2.parseRestBinding = function() {
    var node = this.startNode();
    this.next();

    if (this.options.ecmaVersion === 6 && this.type !== types.name)
      { this.unexpected(); }

    node.argument = this.parseBindingAtom();

    return this.finishNode(node, "RestElement")
  };


  pp$2.parseBindingAtom = function() {
    if (this.options.ecmaVersion >= 6) {
      switch (this.type) {
      case types.bracketL:
        var node = this.startNode();
        this.next();
        node.elements = this.parseBindingList(types.bracketR, true, true);
        return this.finishNode(node, "ArrayPattern")

      case types.braceL:
        return this.parseObj(true)
      }
    }
    return this.parseIdent()
  };

  pp$2.parseBindingList = function(close, allowEmpty, allowTrailingComma) {
    var elts = [], first = true;
    while (!this.eat(close)) {
      if (first) { first = false; }
      else { this.expect(types.comma); }
      if (allowEmpty && this.type === types.comma) {
        elts.push(null);
      } else if (allowTrailingComma && this.afterTrailingComma(close)) {
        break
      } else if (this.type === types.ellipsis) {
        var rest = this.parseRestBinding();
        this.parseBindingListItem(rest);
        elts.push(rest);
        if (this.type === types.comma) { this.raise(this.start, "Comma is not permitted after the rest element"); }
        this.expect(close);
        break
      } else {
        var elem = this.parseMaybeDefault(this.start, this.startLoc);
        this.parseBindingListItem(elem);
        elts.push(elem);
      }
    }
    return elts
  };

  pp$2.parseBindingListItem = function(param) {
    return param
  };


  pp$2.parseMaybeDefault = function(startPos, startLoc, left) {
    left = left || this.parseBindingAtom();
    if (this.options.ecmaVersion < 6 || !this.eat(types.eq)) { return left }
    var node = this.startNodeAt(startPos, startLoc);
    node.left = left;
    node.right = this.parseMaybeAssign();
    return this.finishNode(node, "AssignmentPattern")
  };


  pp$2.checkLVal = function(expr, bindingType, checkClashes) {
    if ( bindingType === void 0 ) bindingType = BIND_NONE;

    switch (expr.type) {
    case "Identifier":
      if (bindingType === BIND_LEXICAL && expr.name === "let")
        { this.raiseRecoverable(expr.start, "let is disallowed as a lexically bound name"); }
      if (this.strict && this.reservedWordsStrictBind.test(expr.name))
        { this.raiseRecoverable(expr.start, (bindingType ? "Binding " : "Assigning to ") + expr.name + " in strict mode"); }
      if (checkClashes) {
        if (has(checkClashes, expr.name))
          { this.raiseRecoverable(expr.start, "Argument name clash"); }
        checkClashes[expr.name] = true;
      }
      if (bindingType !== BIND_NONE && bindingType !== BIND_OUTSIDE) { this.declareName(expr.name, bindingType, expr.start); }
      break

    case "ChainExpression":
      this.raiseRecoverable(expr.start, "Optional chaining cannot appear in left-hand side");
      break

    case "MemberExpression":
      if (bindingType) { this.raiseRecoverable(expr.start, "Binding member expression"); }
      break

    case "ObjectPattern":
      for (var i = 0, list = expr.properties; i < list.length; i += 1)
        {
      var prop = list[i];

      this.checkLVal(prop, bindingType, checkClashes);
    }
      break

    case "Property":
      this.checkLVal(expr.value, bindingType, checkClashes);
      break

    case "ArrayPattern":
      for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {
        var elem = list$1[i$1];

      if (elem) { this.checkLVal(elem, bindingType, checkClashes); }
      }
      break

    case "AssignmentPattern":
      this.checkLVal(expr.left, bindingType, checkClashes);
      break

    case "RestElement":
      this.checkLVal(expr.argument, bindingType, checkClashes);
      break

    case "ParenthesizedExpression":
      this.checkLVal(expr.expression, bindingType, checkClashes);
      break

    default:
      this.raise(expr.start, (bindingType ? "Binding" : "Assigning to") + " rvalue");
    }
  };


  var pp$3 = Parser.prototype;


  pp$3.checkPropClash = function(prop, propHash, refDestructuringErrors) {
    if (this.options.ecmaVersion >= 9 && prop.type === "SpreadElement")
      { return }
    if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand))
      { return }
    var key = prop.key;
    var name;
    switch (key.type) {
    case "Identifier": name = key.name; break
    case "Literal": name = String(key.value); break
    default: return
    }
    var kind = prop.kind;
    if (this.options.ecmaVersion >= 6) {
      if (name === "__proto__" && kind === "init") {
        if (propHash.proto) {
          if (refDestructuringErrors) {
            if (refDestructuringErrors.doubleProto < 0)
              { refDestructuringErrors.doubleProto = key.start; }
          } else { this.raiseRecoverable(key.start, "Redefinition of __proto__ property"); }
        }
        propHash.proto = true;
      }
      return
    }
    name = "$" + name;
    var other = propHash[name];
    if (other) {
      var redefinition;
      if (kind === "init") {
        redefinition = this.strict && other.init || other.get || other.set;
      } else {
        redefinition = other.init || other[kind];
      }
      if (redefinition)
        { this.raiseRecoverable(key.start, "Redefinition of property"); }
    } else {
      other = propHash[name] = {
        init: false,
        get: false,
        set: false
      };
    }
    other[kind] = true;
  };




  pp$3.parseExpression = function(noIn, refDestructuringErrors) {
    var startPos = this.start, startLoc = this.startLoc;
    var expr = this.parseMaybeAssign(noIn, refDestructuringErrors);
    if (this.type === types.comma) {
      var node = this.startNodeAt(startPos, startLoc);
      node.expressions = [expr];
      while (this.eat(types.comma)) { node.expressions.push(this.parseMaybeAssign(noIn, refDestructuringErrors)); }
      return this.finishNode(node, "SequenceExpression")
    }
    return expr
  };


  pp$3.parseMaybeAssign = function(noIn, refDestructuringErrors, afterLeftParse) {
    if (this.isContextual("yield")) {
      if (this.inGenerator) { return this.parseYield(noIn) }
      else { this.exprAllowed = false; }
    }

    var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1;
    if (refDestructuringErrors) {
      oldParenAssign = refDestructuringErrors.parenthesizedAssign;
      oldTrailingComma = refDestructuringErrors.trailingComma;
      refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;
    } else {
      refDestructuringErrors = new DestructuringErrors;
      ownDestructuringErrors = true;
    }

    var startPos = this.start, startLoc = this.startLoc;
    if (this.type === types.parenL || this.type === types.name)
      { this.potentialArrowAt = this.start; }
    var left = this.parseMaybeConditional(noIn, refDestructuringErrors);
    if (afterLeftParse) { left = afterLeftParse.call(this, left, startPos, startLoc); }
    if (this.type.isAssign) {
      var node = this.startNodeAt(startPos, startLoc);
      node.operator = this.value;
      node.left = this.type === types.eq ? this.toAssignable(left, false, refDestructuringErrors) : left;
      if (!ownDestructuringErrors) {
        refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1;
      }
      if (refDestructuringErrors.shorthandAssign >= node.left.start)
        { refDestructuringErrors.shorthandAssign = -1; } 
      this.checkLVal(left);
      this.next();
      node.right = this.parseMaybeAssign(noIn);
      return this.finishNode(node, "AssignmentExpression")
    } else {
      if (ownDestructuringErrors) { this.checkExpressionErrors(refDestructuringErrors, true); }
    }
    if (oldParenAssign > -1) { refDestructuringErrors.parenthesizedAssign = oldParenAssign; }
    if (oldTrailingComma > -1) { refDestructuringErrors.trailingComma = oldTrailingComma; }
    return left
  };


  pp$3.parseMaybeConditional = function(noIn, refDestructuringErrors) {
    var startPos = this.start, startLoc = this.startLoc;
    var expr = this.parseExprOps(noIn, refDestructuringErrors);
    if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
    if (this.eat(types.question)) {
      var node = this.startNodeAt(startPos, startLoc);
      node.test = expr;
      node.consequent = this.parseMaybeAssign();
      this.expect(types.colon);
      node.alternate = this.parseMaybeAssign(noIn);
      return this.finishNode(node, "ConditionalExpression")
    }
    return expr
  };


  pp$3.parseExprOps = function(noIn, refDestructuringErrors) {
    var startPos = this.start, startLoc = this.startLoc;
    var expr = this.parseMaybeUnary(refDestructuringErrors, false);
    if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
    return expr.start === startPos && expr.type === "ArrowFunctionExpression" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, noIn)
  };


  pp$3.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, noIn) {
    var prec = this.type.binop;
    if (prec != null && (!noIn || this.type !== types._in)) {
      if (prec > minPrec) {
        var logical = this.type === types.logicalOR || this.type === types.logicalAND;
        var coalesce = this.type === types.coalesce;
        if (coalesce) {
          prec = types.logicalAND.binop;
        }
        var op = this.value;
        this.next();
        var startPos = this.start, startLoc = this.startLoc;
        var right = this.parseExprOp(this.parseMaybeUnary(null, false), startPos, startLoc, prec, noIn);
        var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical || coalesce);
        if ((logical && this.type === types.coalesce) || (coalesce && (this.type === types.logicalOR || this.type === types.logicalAND))) {
          this.raiseRecoverable(this.start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses");
        }
        return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn)
      }
    }
    return left
  };

  pp$3.buildBinary = function(startPos, startLoc, left, right, op, logical) {
    var node = this.startNodeAt(startPos, startLoc);
    node.left = left;
    node.operator = op;
    node.right = right;
    return this.finishNode(node, logical ? "LogicalExpression" : "BinaryExpression")
  };


  pp$3.parseMaybeUnary = function(refDestructuringErrors, sawUnary) {
    var startPos = this.start, startLoc = this.startLoc, expr;
    if (this.isContextual("await") && (this.inAsync || (!this.inFunction && this.options.allowAwaitOutsideFunction))) {
      expr = this.parseAwait();
      sawUnary = true;
    } else if (this.type.prefix) {
      var node = this.startNode(), update = this.type === types.incDec;
      node.operator = this.value;
      node.prefix = true;
      this.next();
      node.argument = this.parseMaybeUnary(null, true);
      this.checkExpressionErrors(refDestructuringErrors, true);
      if (update) { this.checkLVal(node.argument); }
      else if (this.strict && node.operator === "delete" &&
               node.argument.type === "Identifier")
        { this.raiseRecoverable(node.start, "Deleting local variable in strict mode"); }
      else { sawUnary = true; }
      expr = this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
    } else {
      expr = this.parseExprSubscripts(refDestructuringErrors);
      if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
      while (this.type.postfix && !this.canInsertSemicolon()) {
        var node$1 = this.startNodeAt(startPos, startLoc);
        node$1.operator = this.value;
        node$1.prefix = false;
        node$1.argument = expr;
        this.checkLVal(expr);
        this.next();
        expr = this.finishNode(node$1, "UpdateExpression");
      }
    }

    if (!sawUnary && this.eat(types.starstar))
      { return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false), "**", false) }
    else
      { return expr }
  };


  pp$3.parseExprSubscripts = function(refDestructuringErrors) {
    var startPos = this.start, startLoc = this.startLoc;
    var expr = this.parseExprAtom(refDestructuringErrors);
    if (expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")")
      { return expr }
    var result = this.parseSubscripts(expr, startPos, startLoc);
    if (refDestructuringErrors && result.type === "MemberExpression") {
      if (refDestructuringErrors.parenthesizedAssign >= result.start) { refDestructuringErrors.parenthesizedAssign = -1; }
      if (refDestructuringErrors.parenthesizedBind >= result.start) { refDestructuringErrors.parenthesizedBind = -1; }
    }
    return result
  };

  pp$3.parseSubscripts = function(base, startPos, startLoc, noCalls) {
    var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === "Identifier" && base.name === "async" &&
        this.lastTokEnd === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 &&
        this.potentialArrowAt === base.start;
    var optionalChained = false;

    while (true) {
      var element = this.parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained);

      if (element.optional) { optionalChained = true; }
      if (element === base || element.type === "ArrowFunctionExpression") {
        if (optionalChained) {
          var chainNode = this.startNodeAt(startPos, startLoc);
          chainNode.expression = element;
          element = this.finishNode(chainNode, "ChainExpression");
        }
        return element
      }

      base = element;
    }
  };

  pp$3.parseSubscript = function(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained) {
    var optionalSupported = this.options.ecmaVersion >= 11;
    var optional = optionalSupported && this.eat(types.questionDot);
    if (noCalls && optional) { this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions"); }

    var computed = this.eat(types.bracketL);
    if (computed || (optional && this.type !== types.parenL && this.type !== types.backQuote) || this.eat(types.dot)) {
      var node = this.startNodeAt(startPos, startLoc);
      node.object = base;
      node.property = computed ? this.parseExpression() : this.parseIdent(this.options.allowReserved !== "never");
      node.computed = !!computed;
      if (computed) { this.expect(types.bracketR); }
      if (optionalSupported) {
        node.optional = optional;
      }
      base = this.finishNode(node, "MemberExpression");
    } else if (!noCalls && this.eat(types.parenL)) {
      var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
      this.yieldPos = 0;
      this.awaitPos = 0;
      this.awaitIdentPos = 0;
      var exprList = this.parseExprList(types.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);
      if (maybeAsyncArrow && !optional && !this.canInsertSemicolon() && this.eat(types.arrow)) {
        this.checkPatternErrors(refDestructuringErrors, false);
        this.checkYieldAwaitInDefaultParams();
        if (this.awaitIdentPos > 0)
          { this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function"); }
        this.yieldPos = oldYieldPos;
        this.awaitPos = oldAwaitPos;
        this.awaitIdentPos = oldAwaitIdentPos;
        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true)
      }
      this.checkExpressionErrors(refDestructuringErrors, true);
      this.yieldPos = oldYieldPos || this.yieldPos;
      this.awaitPos = oldAwaitPos || this.awaitPos;
      this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;
      var node$1 = this.startNodeAt(startPos, startLoc);
      node$1.callee = base;
      node$1.arguments = exprList;
      if (optionalSupported) {
        node$1.optional = optional;
      }
      base = this.finishNode(node$1, "CallExpression");
    } else if (this.type === types.backQuote) {
      if (optional || optionalChained) {
        this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions");
      }
      var node$2 = this.startNodeAt(startPos, startLoc);
      node$2.tag = base;
      node$2.quasi = this.parseTemplate({isTagged: true});
      base = this.finishNode(node$2, "TaggedTemplateExpression");
    }
    return base
  };


  pp$3.parseExprAtom = function(refDestructuringErrors) {
    if (this.type === types.slash) { this.readRegexp(); }

    var node, canBeArrow = this.potentialArrowAt === this.start;
    switch (this.type) {
    case types._super:
      if (!this.allowSuper)
        { this.raise(this.start, "'super' keyword outside a method"); }
      node = this.startNode();
      this.next();
      if (this.type === types.parenL && !this.allowDirectSuper)
        { this.raise(node.start, "super() call outside constructor of a subclass"); }
      if (this.type !== types.dot && this.type !== types.bracketL && this.type !== types.parenL)
        { this.unexpected(); }
      return this.finishNode(node, "Super")

    case types._this:
      node = this.startNode();
      this.next();
      return this.finishNode(node, "ThisExpression")

    case types.name:
      var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;
      var id = this.parseIdent(false);
      if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === "async" && !this.canInsertSemicolon() && this.eat(types._function))
        { return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true) }
      if (canBeArrow && !this.canInsertSemicolon()) {
        if (this.eat(types.arrow))
          { return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false) }
        if (this.options.ecmaVersion >= 8 && id.name === "async" && this.type === types.name && !containsEsc) {
          id = this.parseIdent(false);
          if (this.canInsertSemicolon() || !this.eat(types.arrow))
            { this.unexpected(); }
          return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true)
        }
      }
      return id

    case types.regexp:
      var value = this.value;
      node = this.parseLiteral(value.value);
      node.regex = {pattern: value.pattern, flags: value.flags};
      return node

    case types.num: case types.string:
      return this.parseLiteral(this.value)

    case types._null: case types._true: case types._false:
      node = this.startNode();
      node.value = this.type === types._null ? null : this.type === types._true;
      node.raw = this.type.keyword;
      this.next();
      return this.finishNode(node, "Literal")

    case types.parenL:
      var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow);
      if (refDestructuringErrors) {
        if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr))
          { refDestructuringErrors.parenthesizedAssign = start; }
        if (refDestructuringErrors.parenthesizedBind < 0)
          { refDestructuringErrors.parenthesizedBind = start; }
      }
      return expr

    case types.bracketL:
      node = this.startNode();
      this.next();
      node.elements = this.parseExprList(types.bracketR, true, true, refDestructuringErrors);
      return this.finishNode(node, "ArrayExpression")

    case types.braceL:
      return this.parseObj(false, refDestructuringErrors)

    case types._function:
      node = this.startNode();
      this.next();
      return this.parseFunction(node, 0)

    case types._class:
      return this.parseClass(this.startNode(), false)

    case types._new:
      return this.parseNew()

    case types.backQuote:
      return this.parseTemplate()

    case types._import:
      if (this.options.ecmaVersion >= 11) {
        return this.parseExprImport()
      } else {
        return this.unexpected()
      }

    default:
      this.unexpected();
    }
  };

  pp$3.parseExprImport = function() {
    var node = this.startNode();

    if (this.containsEsc) { this.raiseRecoverable(this.start, "Escape sequence in keyword import"); }
    var meta = this.parseIdent(true);

    switch (this.type) {
    case types.parenL:
      return this.parseDynamicImport(node)
    case types.dot:
      node.meta = meta;
      return this.parseImportMeta(node)
    default:
      this.unexpected();
    }
  };

  pp$3.parseDynamicImport = function(node) {
    this.next(); 

    node.source = this.parseMaybeAssign();

    if (!this.eat(types.parenR)) {
      var errorPos = this.start;
      if (this.eat(types.comma) && this.eat(types.parenR)) {
        this.raiseRecoverable(errorPos, "Trailing comma is not allowed in import()");
      } else {
        this.unexpected(errorPos);
      }
    }

    return this.finishNode(node, "ImportExpression")
  };

  pp$3.parseImportMeta = function(node) {
    this.next(); 

    var containsEsc = this.containsEsc;
    node.property = this.parseIdent(true);

    if (node.property.name !== "meta")
      { this.raiseRecoverable(node.property.start, "The only valid meta property for import is 'import.meta'"); }
    if (containsEsc)
      { this.raiseRecoverable(node.start, "'import.meta' must not contain escaped characters"); }
    if (this.options.sourceType !== "module")
      { this.raiseRecoverable(node.start, "Cannot use 'import.meta' outside a module"); }

    return this.finishNode(node, "MetaProperty")
  };

  pp$3.parseLiteral = function(value) {
    var node = this.startNode();
    node.value = value;
    node.raw = this.input.slice(this.start, this.end);
    if (node.raw.charCodeAt(node.raw.length - 1) === 110) { node.bigint = node.raw.slice(0, -1).replace(/_/g, ""); }
    this.next();
    return this.finishNode(node, "Literal")
  };

  pp$3.parseParenExpression = function() {
    this.expect(types.parenL);
    var val = this.parseExpression();
    this.expect(types.parenR);
    return val
  };

  pp$3.parseParenAndDistinguishExpression = function(canBeArrow) {
    var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;
    if (this.options.ecmaVersion >= 6) {
      this.next();

      var innerStartPos = this.start, innerStartLoc = this.startLoc;
      var exprList = [], first = true, lastIsComma = false;
      var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;
      this.yieldPos = 0;
      this.awaitPos = 0;
      while (this.type !== types.parenR) {
        first ? first = false : this.expect(types.comma);
        if (allowTrailingComma && this.afterTrailingComma(types.parenR, true)) {
          lastIsComma = true;
          break
        } else if (this.type === types.ellipsis) {
          spreadStart = this.start;
          exprList.push(this.parseParenItem(this.parseRestBinding()));
          if (this.type === types.comma) { this.raise(this.start, "Comma is not permitted after the rest element"); }
          break
        } else {
          exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
        }
      }
      var innerEndPos = this.start, innerEndLoc = this.startLoc;
      this.expect(types.parenR);

      if (canBeArrow && !this.canInsertSemicolon() && this.eat(types.arrow)) {
        this.checkPatternErrors(refDestructuringErrors, false);
        this.checkYieldAwaitInDefaultParams();
        this.yieldPos = oldYieldPos;
        this.awaitPos = oldAwaitPos;
        return this.parseParenArrowList(startPos, startLoc, exprList)
      }

      if (!exprList.length || lastIsComma) { this.unexpected(this.lastTokStart); }
      if (spreadStart) { this.unexpected(spreadStart); }
      this.checkExpressionErrors(refDestructuringErrors, true);
      this.yieldPos = oldYieldPos || this.yieldPos;
      this.awaitPos = oldAwaitPos || this.awaitPos;

      if (exprList.length > 1) {
        val = this.startNodeAt(innerStartPos, innerStartLoc);
        val.expressions = exprList;
        this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
      } else {
        val = exprList[0];
      }
    } else {
      val = this.parseParenExpression();
    }

    if (this.options.preserveParens) {
      var par = this.startNodeAt(startPos, startLoc);
      par.expression = val;
      return this.finishNode(par, "ParenthesizedExpression")
    } else {
      return val
    }
  };

  pp$3.parseParenItem = function(item) {
    return item
  };

  pp$3.parseParenArrowList = function(startPos, startLoc, exprList) {
    return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList)
  };


  var empty$1 = [];

  pp$3.parseNew = function() {
    if (this.containsEsc) { this.raiseRecoverable(this.start, "Escape sequence in keyword new"); }
    var node = this.startNode();
    var meta = this.parseIdent(true);
    if (this.options.ecmaVersion >= 6 && this.eat(types.dot)) {
      node.meta = meta;
      var containsEsc = this.containsEsc;
      node.property = this.parseIdent(true);
      if (node.property.name !== "target")
        { this.raiseRecoverable(node.property.start, "The only valid meta property for new is 'new.target'"); }
      if (containsEsc)
        { this.raiseRecoverable(node.start, "'new.target' must not contain escaped characters"); }
      if (!this.inNonArrowFunction())
        { this.raiseRecoverable(node.start, "'new.target' can only be used in functions"); }
      return this.finishNode(node, "MetaProperty")
    }
    var startPos = this.start, startLoc = this.startLoc, isImport = this.type === types._import;
    node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);
    if (isImport && node.callee.type === "ImportExpression") {
      this.raise(startPos, "Cannot use new with import()");
    }
    if (this.eat(types.parenL)) { node.arguments = this.parseExprList(types.parenR, this.options.ecmaVersion >= 8, false); }
    else { node.arguments = empty$1; }
    return this.finishNode(node, "NewExpression")
  };


  pp$3.parseTemplateElement = function(ref) {
    var isTagged = ref.isTagged;

    var elem = this.startNode();
    if (this.type === types.invalidTemplate) {
      if (!isTagged) {
        this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal");
      }
      elem.value = {
        raw: this.value,
        cooked: null
      };
    } else {
      elem.value = {
        raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"),
        cooked: this.value
      };
    }
    this.next();
    elem.tail = this.type === types.backQuote;
    return this.finishNode(elem, "TemplateElement")
  };

  pp$3.parseTemplate = function(ref) {
    if ( ref === void 0 ) ref = {};
    var isTagged = ref.isTagged; if ( isTagged === void 0 ) isTagged = false;

    var node = this.startNode();
    this.next();
    node.expressions = [];
    var curElt = this.parseTemplateElement({isTagged: isTagged});
    node.quasis = [curElt];
    while (!curElt.tail) {
      if (this.type === types.eof) { this.raise(this.pos, "Unterminated template literal"); }
      this.expect(types.dollarBraceL);
      node.expressions.push(this.parseExpression());
      this.expect(types.braceR);
      node.quasis.push(curElt = this.parseTemplateElement({isTagged: isTagged}));
    }
    this.next();
    return this.finishNode(node, "TemplateLiteral")
  };

  pp$3.isAsyncProp = function(prop) {
    return !prop.computed && prop.key.type === "Identifier" && prop.key.name === "async" &&
      (this.type === types.name || this.type === types.num || this.type === types.string || this.type === types.bracketL || this.type.keyword || (this.options.ecmaVersion >= 9 && this.type === types.star)) &&
      !lineBreak.test(this.input.slice(this.lastTokEnd, this.start))
  };


  pp$3.parseObj = function(isPattern, refDestructuringErrors) {
    var node = this.startNode(), first = true, propHash = {};
    node.properties = [];
    this.next();
    while (!this.eat(types.braceR)) {
      if (!first) {
        this.expect(types.comma);
        if (this.options.ecmaVersion >= 5 && this.afterTrailingComma(types.braceR)) { break }
      } else { first = false; }

      var prop = this.parseProperty(isPattern, refDestructuringErrors);
      if (!isPattern) { this.checkPropClash(prop, propHash, refDestructuringErrors); }
      node.properties.push(prop);
    }
    return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression")
  };

  pp$3.parseProperty = function(isPattern, refDestructuringErrors) {
    var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;
    if (this.options.ecmaVersion >= 9 && this.eat(types.ellipsis)) {
      if (isPattern) {
        prop.argument = this.parseIdent(false);
        if (this.type === types.comma) {
          this.raise(this.start, "Comma is not permitted after the rest element");
        }
        return this.finishNode(prop, "RestElement")
      }
      if (this.type === types.parenL && refDestructuringErrors) {
        if (refDestructuringErrors.parenthesizedAssign < 0) {
          refDestructuringErrors.parenthesizedAssign = this.start;
        }
        if (refDestructuringErrors.parenthesizedBind < 0) {
          refDestructuringErrors.parenthesizedBind = this.start;
        }
      }
      prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);
      if (this.type === types.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {
        refDestructuringErrors.trailingComma = this.start;
      }
      return this.finishNode(prop, "SpreadElement")
    }
    if (this.options.ecmaVersion >= 6) {
      prop.method = false;
      prop.shorthand = false;
      if (isPattern || refDestructuringErrors) {
        startPos = this.start;
        startLoc = this.startLoc;
      }
      if (!isPattern)
        { isGenerator = this.eat(types.star); }
    }
    var containsEsc = this.containsEsc;
    this.parsePropertyName(prop);
    if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {
      isAsync = true;
      isGenerator = this.options.ecmaVersion >= 9 && this.eat(types.star);
      this.parsePropertyName(prop, refDestructuringErrors);
    } else {
      isAsync = false;
    }
    this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);
    return this.finishNode(prop, "Property")
  };

  pp$3.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {
    if ((isGenerator || isAsync) && this.type === types.colon)
      { this.unexpected(); }

    if (this.eat(types.colon)) {
      prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
      prop.kind = "init";
    } else if (this.options.ecmaVersion >= 6 && this.type === types.parenL) {
      if (isPattern) { this.unexpected(); }
      prop.kind = "init";
      prop.method = true;
      prop.value = this.parseMethod(isGenerator, isAsync);
    } else if (!isPattern && !containsEsc &&
               this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" &&
               (prop.key.name === "get" || prop.key.name === "set") &&
               (this.type !== types.comma && this.type !== types.braceR && this.type !== types.eq)) {
      if (isGenerator || isAsync) { this.unexpected(); }
      prop.kind = prop.key.name;
      this.parsePropertyName(prop);
      prop.value = this.parseMethod(false);
      var paramCount = prop.kind === "get" ? 0 : 1;
      if (prop.value.params.length !== paramCount) {
        var start = prop.value.start;
        if (prop.kind === "get")
          { this.raiseRecoverable(start, "getter should have no params"); }
        else
          { this.raiseRecoverable(start, "setter should have exactly one param"); }
      } else {
        if (prop.kind === "set" && prop.value.params[0].type === "RestElement")
          { this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params"); }
      }
    } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
      if (isGenerator || isAsync) { this.unexpected(); }
      this.checkUnreserved(prop.key);
      if (prop.key.name === "await" && !this.awaitIdentPos)
        { this.awaitIdentPos = startPos; }
      prop.kind = "init";
      if (isPattern) {
        prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);
      } else if (this.type === types.eq && refDestructuringErrors) {
        if (refDestructuringErrors.shorthandAssign < 0)
          { refDestructuringErrors.shorthandAssign = this.start; }
        prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);
      } else {
        prop.value = prop.key;
      }
      prop.shorthand = true;
    } else { this.unexpected(); }
  };

  pp$3.parsePropertyName = function(prop) {
    if (this.options.ecmaVersion >= 6) {
      if (this.eat(types.bracketL)) {
        prop.computed = true;
        prop.key = this.parseMaybeAssign();
        this.expect(types.bracketR);
        return prop.key
      } else {
        prop.computed = false;
      }
    }
    return prop.key = this.type === types.num || this.type === types.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never")
  };


  pp$3.initFunction = function(node) {
    node.id = null;
    if (this.options.ecmaVersion >= 6) { node.generator = node.expression = false; }
    if (this.options.ecmaVersion >= 8) { node.async = false; }
  };


  pp$3.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {
    var node = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;

    this.initFunction(node);
    if (this.options.ecmaVersion >= 6)
      { node.generator = isGenerator; }
    if (this.options.ecmaVersion >= 8)
      { node.async = !!isAsync; }

    this.yieldPos = 0;
    this.awaitPos = 0;
    this.awaitIdentPos = 0;
    this.enterScope(functionFlags(isAsync, node.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));

    this.expect(types.parenL);
    node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);
    this.checkYieldAwaitInDefaultParams();
    this.parseFunctionBody(node, false, true);

    this.yieldPos = oldYieldPos;
    this.awaitPos = oldAwaitPos;
    this.awaitIdentPos = oldAwaitIdentPos;
    return this.finishNode(node, "FunctionExpression")
  };


  pp$3.parseArrowExpression = function(node, params, isAsync) {
    var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;

    this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);
    this.initFunction(node);
    if (this.options.ecmaVersion >= 8) { node.async = !!isAsync; }

    this.yieldPos = 0;
    this.awaitPos = 0;
    this.awaitIdentPos = 0;

    node.params = this.toAssignableList(params, true);
    this.parseFunctionBody(node, true, false);

    this.yieldPos = oldYieldPos;
    this.awaitPos = oldAwaitPos;
    this.awaitIdentPos = oldAwaitIdentPos;
    return this.finishNode(node, "ArrowFunctionExpression")
  };


  pp$3.parseFunctionBody = function(node, isArrowFunction, isMethod) {
    var isExpression = isArrowFunction && this.type !== types.braceL;
    var oldStrict = this.strict, useStrict = false;

    if (isExpression) {
      node.body = this.parseMaybeAssign();
      node.expression = true;
      this.checkParams(node, false);
    } else {
      var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);
      if (!oldStrict || nonSimple) {
        useStrict = this.strictDirective(this.end);
        if (useStrict && nonSimple)
          { this.raiseRecoverable(node.start, "Illegal 'use strict' directive in function with non-simple parameter list"); }
      }
      var oldLabels = this.labels;
      this.labels = [];
      if (useStrict) { this.strict = true; }

      this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node.params));
      if (this.strict && node.id) { this.checkLVal(node.id, BIND_OUTSIDE); }
      node.body = this.parseBlock(false, undefined, useStrict && !oldStrict);
      node.expression = false;
      this.adaptDirectivePrologue(node.body.body);
      this.labels = oldLabels;
    }
    this.exitScope();
  };

  pp$3.isSimpleParamList = function(params) {
    for (var i = 0, list = params; i < list.length; i += 1)
      {
      var param = list[i];

      if (param.type !== "Identifier") { return false
    } }
    return true
  };


  pp$3.checkParams = function(node, allowDuplicates) {
    var nameHash = {};
    for (var i = 0, list = node.params; i < list.length; i += 1)
      {
      var param = list[i];

      this.checkLVal(param, BIND_VAR, allowDuplicates ? null : nameHash);
    }
  };


  pp$3.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
    var elts = [], first = true;
    while (!this.eat(close)) {
      if (!first) {
        this.expect(types.comma);
        if (allowTrailingComma && this.afterTrailingComma(close)) { break }
      } else { first = false; }

      var elt = (void 0);
      if (allowEmpty && this.type === types.comma)
        { elt = null; }
      else if (this.type === types.ellipsis) {
        elt = this.parseSpread(refDestructuringErrors);
        if (refDestructuringErrors && this.type === types.comma && refDestructuringErrors.trailingComma < 0)
          { refDestructuringErrors.trailingComma = this.start; }
      } else {
        elt = this.parseMaybeAssign(false, refDestructuringErrors);
      }
      elts.push(elt);
    }
    return elts
  };

  pp$3.checkUnreserved = function(ref) {
    var start = ref.start;
    var end = ref.end;
    var name = ref.name;

    if (this.inGenerator && name === "yield")
      { this.raiseRecoverable(start, "Cannot use 'yield' as identifier inside a generator"); }
    if (this.inAsync && name === "await")
      { this.raiseRecoverable(start, "Cannot use 'await' as identifier inside an async function"); }
    if (this.keywords.test(name))
      { this.raise(start, ("Unexpected keyword '" + name + "'")); }
    if (this.options.ecmaVersion < 6 &&
      this.input.slice(start, end).indexOf("\\") !== -1) { return }
    var re = this.strict ? this.reservedWordsStrict : this.reservedWords;
    if (re.test(name)) {
      if (!this.inAsync && name === "await")
        { this.raiseRecoverable(start, "Cannot use keyword 'await' outside an async function"); }
      this.raiseRecoverable(start, ("The keyword '" + name + "' is reserved"));
    }
  };


  pp$3.parseIdent = function(liberal, isBinding) {
    var node = this.startNode();
    if (this.type === types.name) {
      node.name = this.value;
    } else if (this.type.keyword) {
      node.name = this.type.keyword;

      if ((node.name === "class" || node.name === "function") &&
          (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {
        this.context.pop();
      }
    } else {
      this.unexpected();
    }
    this.next(!!liberal);
    this.finishNode(node, "Identifier");
    if (!liberal) {
      this.checkUnreserved(node);
      if (node.name === "await" && !this.awaitIdentPos)
        { this.awaitIdentPos = node.start; }
    }
    return node
  };


  pp$3.parseYield = function(noIn) {
    if (!this.yieldPos) { this.yieldPos = this.start; }

    var node = this.startNode();
    this.next();
    if (this.type === types.semi || this.canInsertSemicolon() || (this.type !== types.star && !this.type.startsExpr)) {
      node.delegate = false;
      node.argument = null;
    } else {
      node.delegate = this.eat(types.star);
      node.argument = this.parseMaybeAssign(noIn);
    }
    return this.finishNode(node, "YieldExpression")
  };

  pp$3.parseAwait = function() {
    if (!this.awaitPos) { this.awaitPos = this.start; }

    var node = this.startNode();
    this.next();
    node.argument = this.parseMaybeUnary(null, false);
    return this.finishNode(node, "AwaitExpression")
  };

  var pp$4 = Parser.prototype;


  pp$4.raise = function(pos, message) {
    var loc = getLineInfo(this.input, pos);
    message += " (" + loc.line + ":" + loc.column + ")";
    var err = new SyntaxError(message);
    err.pos = pos; err.loc = loc; err.raisedAt = this.pos;
    throw err
  };

  pp$4.raiseRecoverable = pp$4.raise;

  pp$4.curPosition = function() {
    if (this.options.locations) {
      return new Position(this.curLine, this.pos - this.lineStart)
    }
  };

  var pp$5 = Parser.prototype;

  var Scope = function Scope(flags) {
    this.flags = flags;
    this.var = [];
    this.lexical = [];
    this.functions = [];
  };


  pp$5.enterScope = function(flags) {
    this.scopeStack.push(new Scope(flags));
  };

  pp$5.exitScope = function() {
    this.scopeStack.pop();
  };

  pp$5.treatFunctionsAsVarInScope = function(scope) {
    return (scope.flags & SCOPE_FUNCTION) || !this.inModule && (scope.flags & SCOPE_TOP)
  };

  pp$5.declareName = function(name, bindingType, pos) {
    var redeclared = false;
    if (bindingType === BIND_LEXICAL) {
      var scope = this.currentScope();
      redeclared = scope.lexical.indexOf(name) > -1 || scope.functions.indexOf(name) > -1 || scope.var.indexOf(name) > -1;
      scope.lexical.push(name);
      if (this.inModule && (scope.flags & SCOPE_TOP))
        { delete this.undefinedExports[name]; }
    } else if (bindingType === BIND_SIMPLE_CATCH) {
      var scope$1 = this.currentScope();
      scope$1.lexical.push(name);
    } else if (bindingType === BIND_FUNCTION) {
      var scope$2 = this.currentScope();
      if (this.treatFunctionsAsVar)
        { redeclared = scope$2.lexical.indexOf(name) > -1; }
      else
        { redeclared = scope$2.lexical.indexOf(name) > -1 || scope$2.var.indexOf(name) > -1; }
      scope$2.functions.push(name);
    } else {
      for (var i = this.scopeStack.length - 1; i >= 0; --i) {
        var scope$3 = this.scopeStack[i];
        if (scope$3.lexical.indexOf(name) > -1 && !((scope$3.flags & SCOPE_SIMPLE_CATCH) && scope$3.lexical[0] === name) ||
            !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name) > -1) {
          redeclared = true;
          break
        }
        scope$3.var.push(name);
        if (this.inModule && (scope$3.flags & SCOPE_TOP))
          { delete this.undefinedExports[name]; }
        if (scope$3.flags & SCOPE_VAR) { break }
      }
    }
    if (redeclared) { this.raiseRecoverable(pos, ("Identifier '" + name + "' has already been declared")); }
  };

  pp$5.checkLocalExport = function(id) {
    if (this.scopeStack[0].lexical.indexOf(id.name) === -1 &&
        this.scopeStack[0].var.indexOf(id.name) === -1) {
      this.undefinedExports[id.name] = id;
    }
  };

  pp$5.currentScope = function() {
    return this.scopeStack[this.scopeStack.length - 1]
  };

  pp$5.currentVarScope = function() {
    for (var i = this.scopeStack.length - 1;; i--) {
      var scope = this.scopeStack[i];
      if (scope.flags & SCOPE_VAR) { return scope }
    }
  };

  pp$5.currentThisScope = function() {
    for (var i = this.scopeStack.length - 1;; i--) {
      var scope = this.scopeStack[i];
      if (scope.flags & SCOPE_VAR && !(scope.flags & SCOPE_ARROW)) { return scope }
    }
  };

  var Node = function Node(parser, pos, loc) {
    this.type = "";
    this.start = pos;
    this.end = 0;
    if (parser.options.locations)
      { this.loc = new SourceLocation(parser, loc); }
    if (parser.options.directSourceFile)
      { this.sourceFile = parser.options.directSourceFile; }
    if (parser.options.ranges)
      { this.range = [pos, 0]; }
  };


  var pp$6 = Parser.prototype;

  pp$6.startNode = function() {
    return new Node(this, this.start, this.startLoc)
  };

  pp$6.startNodeAt = function(pos, loc) {
    return new Node(this, pos, loc)
  };


  function finishNodeAt(node, type, pos, loc) {
    node.type = type;
    node.end = pos;
    if (this.options.locations)
      { node.loc.end = loc; }
    if (this.options.ranges)
      { node.range[1] = pos; }
    return node
  }

  pp$6.finishNode = function(node, type) {
    return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc)
  };


  pp$6.finishNodeAt = function(node, type, pos, loc) {
    return finishNodeAt.call(this, node, type, pos, loc)
  };


  var TokContext = function TokContext(token, isExpr, preserveSpace, override, generator) {
    this.token = token;
    this.isExpr = !!isExpr;
    this.preserveSpace = !!preserveSpace;
    this.override = override;
    this.generator = !!generator;
  };

  var types$1 = {
    b_stat: new TokContext("{", false),
    b_expr: new TokContext("{", true),
    b_tmpl: new TokContext("${", false),
    p_stat: new TokContext("(", false),
    p_expr: new TokContext("(", true),
    q_tmpl: new TokContext("`", true, true, function (p) { return p.tryReadTemplateToken(); }),
    f_stat: new TokContext("function", false),
    f_expr: new TokContext("function", true),
    f_expr_gen: new TokContext("function", true, false, null, true),
    f_gen: new TokContext("function", false, false, null, true)
  };

  var pp$7 = Parser.prototype;

  pp$7.initialContext = function() {
    return [types$1.b_stat]
  };

  pp$7.braceIsBlock = function(prevType) {
    var parent = this.curContext();
    if (parent === types$1.f_expr || parent === types$1.f_stat)
      { return true }
    if (prevType === types.colon && (parent === types$1.b_stat || parent === types$1.b_expr))
      { return !parent.isExpr }

    if (prevType === types._return || prevType === types.name && this.exprAllowed)
      { return lineBreak.test(this.input.slice(this.lastTokEnd, this.start)) }
    if (prevType === types._else || prevType === types.semi || prevType === types.eof || prevType === types.parenR || prevType === types.arrow)
      { return true }
    if (prevType === types.braceL)
      { return parent === types$1.b_stat }
    if (prevType === types._var || prevType === types._const || prevType === types.name)
      { return false }
    return !this.exprAllowed
  };

  pp$7.inGeneratorContext = function() {
    for (var i = this.context.length - 1; i >= 1; i--) {
      var context = this.context[i];
      if (context.token === "function")
        { return context.generator }
    }
    return false
  };

  pp$7.updateContext = function(prevType) {
    var update, type = this.type;
    if (type.keyword && prevType === types.dot)
      { this.exprAllowed = false; }
    else if (update = type.updateContext)
      { update.call(this, prevType); }
    else
      { this.exprAllowed = type.beforeExpr; }
  };


  types.parenR.updateContext = types.braceR.updateContext = function() {
    if (this.context.length === 1) {
      this.exprAllowed = true;
      return
    }
    var out = this.context.pop();
    if (out === types$1.b_stat && this.curContext().token === "function") {
      out = this.context.pop();
    }
    this.exprAllowed = !out.isExpr;
  };

  types.braceL.updateContext = function(prevType) {
    this.context.push(this.braceIsBlock(prevType) ? types$1.b_stat : types$1.b_expr);
    this.exprAllowed = true;
  };

  types.dollarBraceL.updateContext = function() {
    this.context.push(types$1.b_tmpl);
    this.exprAllowed = true;
  };

  types.parenL.updateContext = function(prevType) {
    var statementParens = prevType === types._if || prevType === types._for || prevType === types._with || prevType === types._while;
    this.context.push(statementParens ? types$1.p_stat : types$1.p_expr);
    this.exprAllowed = true;
  };

  types.incDec.updateContext = function() {
  };

  types._function.updateContext = types._class.updateContext = function(prevType) {
    if (prevType.beforeExpr && prevType !== types.semi && prevType !== types._else &&
        !(prevType === types._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) &&
        !((prevType === types.colon || prevType === types.braceL) && this.curContext() === types$1.b_stat))
      { this.context.push(types$1.f_expr); }
    else
      { this.context.push(types$1.f_stat); }
    this.exprAllowed = false;
  };

  types.backQuote.updateContext = function() {
    if (this.curContext() === types$1.q_tmpl)
      { this.context.pop(); }
    else
      { this.context.push(types$1.q_tmpl); }
    this.exprAllowed = false;
  };

  types.star.updateContext = function(prevType) {
    if (prevType === types._function) {
      var index = this.context.length - 1;
      if (this.context[index] === types$1.f_expr)
        { this.context[index] = types$1.f_expr_gen; }
      else
        { this.context[index] = types$1.f_gen; }
    }
    this.exprAllowed = true;
  };

  types.name.updateContext = function(prevType) {
    var allowed = false;
    if (this.options.ecmaVersion >= 6 && prevType !== types.dot) {
      if (this.value === "of" && !this.exprAllowed ||
          this.value === "yield" && this.inGeneratorContext())
        { allowed = true; }
    }
    this.exprAllowed = allowed;
  };


  var ecma9BinaryProperties = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS";
  var ecma10BinaryProperties = ecma9BinaryProperties + " Extended_Pictographic";
  var ecma11BinaryProperties = ecma10BinaryProperties;
  var unicodeBinaryProperties = {
    9: ecma9BinaryProperties,
    10: ecma10BinaryProperties,
    11: ecma11BinaryProperties
  };

  var unicodeGeneralCategoryValues = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu";

  var ecma9ScriptValues = "Adlam Adlm Ahom Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb";
  var ecma10ScriptValues = ecma9ScriptValues + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd";
  var ecma11ScriptValues = ecma10ScriptValues + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho";
  var unicodeScriptValues = {
    9: ecma9ScriptValues,
    10: ecma10ScriptValues,
    11: ecma11ScriptValues
  };

  var data = {};
  function buildUnicodeData(ecmaVersion) {
    var d = data[ecmaVersion] = {
      binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion] + " " + unicodeGeneralCategoryValues),
      nonBinary: {
        General_Category: wordsRegexp(unicodeGeneralCategoryValues),
        Script: wordsRegexp(unicodeScriptValues[ecmaVersion])
      }
    };
    d.nonBinary.Script_Extensions = d.nonBinary.Script;

    d.nonBinary.gc = d.nonBinary.General_Category;
    d.nonBinary.sc = d.nonBinary.Script;
    d.nonBinary.scx = d.nonBinary.Script_Extensions;
  }
  buildUnicodeData(9);
  buildUnicodeData(10);
  buildUnicodeData(11);

  var pp$8 = Parser.prototype;

  var RegExpValidationState = function RegExpValidationState(parser) {
    this.parser = parser;
    this.validFlags = "gim" + (parser.options.ecmaVersion >= 6 ? "uy" : "") + (parser.options.ecmaVersion >= 9 ? "s" : "");
    this.unicodeProperties = data[parser.options.ecmaVersion >= 11 ? 11 : parser.options.ecmaVersion];
    this.source = "";
    this.flags = "";
    this.start = 0;
    this.switchU = false;
    this.switchN = false;
    this.pos = 0;
    this.lastIntValue = 0;
    this.lastStringValue = "";
    this.lastAssertionIsQuantifiable = false;
    this.numCapturingParens = 0;
    this.maxBackReference = 0;
    this.groupNames = [];
    this.backReferenceNames = [];
  };

  RegExpValidationState.prototype.reset = function reset (start, pattern, flags) {
    var unicode = flags.indexOf("u") !== -1;
    this.start = start | 0;
    this.source = pattern + "";
    this.flags = flags;
    this.switchU = unicode && this.parser.options.ecmaVersion >= 6;
    this.switchN = unicode && this.parser.options.ecmaVersion >= 9;
  };

  RegExpValidationState.prototype.raise = function raise (message) {
    this.parser.raiseRecoverable(this.start, ("Invalid regular expression: /" + (this.source) + "/: " + message));
  };

  RegExpValidationState.prototype.at = function at (i, forceU) {
      if ( forceU === void 0 ) forceU = false;

    var s = this.source;
    var l = s.length;
    if (i >= l) {
      return -1
    }
    var c = s.charCodeAt(i);
    if (!(forceU || this.switchU) || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l) {
      return c
    }
    var next = s.charCodeAt(i + 1);
    return next >= 0xDC00 && next <= 0xDFFF ? (c << 10) + next - 0x35FDC00 : c
  };

  RegExpValidationState.prototype.nextIndex = function nextIndex (i, forceU) {
      if ( forceU === void 0 ) forceU = false;

    var s = this.source;
    var l = s.length;
    if (i >= l) {
      return l
    }
    var c = s.charCodeAt(i), next;
    if (!(forceU || this.switchU) || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l ||
        (next = s.charCodeAt(i + 1)) < 0xDC00 || next > 0xDFFF) {
      return i + 1
    }
    return i + 2
  };

  RegExpValidationState.prototype.current = function current (forceU) {
      if ( forceU === void 0 ) forceU = false;

    return this.at(this.pos, forceU)
  };

  RegExpValidationState.prototype.lookahead = function lookahead (forceU) {
      if ( forceU === void 0 ) forceU = false;

    return this.at(this.nextIndex(this.pos, forceU), forceU)
  };

  RegExpValidationState.prototype.advance = function advance (forceU) {
      if ( forceU === void 0 ) forceU = false;

    this.pos = this.nextIndex(this.pos, forceU);
  };

  RegExpValidationState.prototype.eat = function eat (ch, forceU) {
      if ( forceU === void 0 ) forceU = false;

    if (this.current(forceU) === ch) {
      this.advance(forceU);
      return true
    }
    return false
  };

  function codePointToString(ch) {
    if (ch <= 0xFFFF) { return String.fromCharCode(ch) }
    ch -= 0x10000;
    return String.fromCharCode((ch >> 10) + 0xD800, (ch & 0x03FF) + 0xDC00)
  }

  pp$8.validateRegExpFlags = function(state) {
    var validFlags = state.validFlags;
    var flags = state.flags;

    for (var i = 0; i < flags.length; i++) {
      var flag = flags.charAt(i);
      if (validFlags.indexOf(flag) === -1) {
        this.raise(state.start, "Invalid regular expression flag");
      }
      if (flags.indexOf(flag, i + 1) > -1) {
        this.raise(state.start, "Duplicate regular expression flag");
      }
    }
  };

  pp$8.validateRegExpPattern = function(state) {
    this.regexp_pattern(state);

    if (!state.switchN && this.options.ecmaVersion >= 9 && state.groupNames.length > 0) {
      state.switchN = true;
      this.regexp_pattern(state);
    }
  };

  pp$8.regexp_pattern = function(state) {
    state.pos = 0;
    state.lastIntValue = 0;
    state.lastStringValue = "";
    state.lastAssertionIsQuantifiable = false;
    state.numCapturingParens = 0;
    state.maxBackReference = 0;
    state.groupNames.length = 0;
    state.backReferenceNames.length = 0;

    this.regexp_disjunction(state);

    if (state.pos !== state.source.length) {
      if (state.eat(0x29 )) {
        state.raise("Unmatched ')'");
      }
      if (state.eat(0x5D ) || state.eat(0x7D )) {
        state.raise("Lone quantifier brackets");
      }
    }
    if (state.maxBackReference > state.numCapturingParens) {
      state.raise("Invalid escape");
    }
    for (var i = 0, list = state.backReferenceNames; i < list.length; i += 1) {
      var name = list[i];

      if (state.groupNames.indexOf(name) === -1) {
        state.raise("Invalid named capture referenced");
      }
    }
  };

  pp$8.regexp_disjunction = function(state) {
    this.regexp_alternative(state);
    while (state.eat(0x7C )) {
      this.regexp_alternative(state);
    }

    if (this.regexp_eatQuantifier(state, true)) {
      state.raise("Nothing to repeat");
    }
    if (state.eat(0x7B )) {
      state.raise("Lone quantifier brackets");
    }
  };

  pp$8.regexp_alternative = function(state) {
    while (state.pos < state.source.length && this.regexp_eatTerm(state))
      { }
  };

  pp$8.regexp_eatTerm = function(state) {
    if (this.regexp_eatAssertion(state)) {
      if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {
        if (state.switchU) {
          state.raise("Invalid quantifier");
        }
      }
      return true
    }

    if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {
      this.regexp_eatQuantifier(state);
      return true
    }

    return false
  };

  pp$8.regexp_eatAssertion = function(state) {
    var start = state.pos;
    state.lastAssertionIsQuantifiable = false;

    if (state.eat(0x5E ) || state.eat(0x24 )) {
      return true
    }

    if (state.eat(0x5C )) {
      if (state.eat(0x42 ) || state.eat(0x62 )) {
        return true
      }
      state.pos = start;
    }

    if (state.eat(0x28 ) && state.eat(0x3F )) {
      var lookbehind = false;
      if (this.options.ecmaVersion >= 9) {
        lookbehind = state.eat(0x3C );
      }
      if (state.eat(0x3D ) || state.eat(0x21 )) {
        this.regexp_disjunction(state);
        if (!state.eat(0x29 )) {
          state.raise("Unterminated group");
        }
        state.lastAssertionIsQuantifiable = !lookbehind;
        return true
      }
    }

    state.pos = start;
    return false
  };

  pp$8.regexp_eatQuantifier = function(state, noError) {
    if ( noError === void 0 ) noError = false;

    if (this.regexp_eatQuantifierPrefix(state, noError)) {
      state.eat(0x3F );
      return true
    }
    return false
  };

  pp$8.regexp_eatQuantifierPrefix = function(state, noError) {
    return (
      state.eat(0x2A ) ||
      state.eat(0x2B ) ||
      state.eat(0x3F ) ||
      this.regexp_eatBracedQuantifier(state, noError)
    )
  };
  pp$8.regexp_eatBracedQuantifier = function(state, noError) {
    var start = state.pos;
    if (state.eat(0x7B )) {
      var min = 0, max = -1;
      if (this.regexp_eatDecimalDigits(state)) {
        min = state.lastIntValue;
        if (state.eat(0x2C ) && this.regexp_eatDecimalDigits(state)) {
          max = state.lastIntValue;
        }
        if (state.eat(0x7D )) {
          if (max !== -1 && max < min && !noError) {
            state.raise("numbers out of order in {} quantifier");
          }
          return true
        }
      }
      if (state.switchU && !noError) {
        state.raise("Incomplete quantifier");
      }
      state.pos = start;
    }
    return false
  };

  pp$8.regexp_eatAtom = function(state) {
    return (
      this.regexp_eatPatternCharacters(state) ||
      state.eat(0x2E ) ||
      this.regexp_eatReverseSolidusAtomEscape(state) ||
      this.regexp_eatCharacterClass(state) ||
      this.regexp_eatUncapturingGroup(state) ||
      this.regexp_eatCapturingGroup(state)
    )
  };
  pp$8.regexp_eatReverseSolidusAtomEscape = function(state) {
    var start = state.pos;
    if (state.eat(0x5C )) {
      if (this.regexp_eatAtomEscape(state)) {
        return true
      }
      state.pos = start;
    }
    return false
  };
  pp$8.regexp_eatUncapturingGroup = function(state) {
    var start = state.pos;
    if (state.eat(0x28 )) {
      if (state.eat(0x3F ) && state.eat(0x3A )) {
        this.regexp_disjunction(state);
        if (state.eat(0x29 )) {
          return true
        }
        state.raise("Unterminated group");
      }
      state.pos = start;
    }
    return false
  };
  pp$8.regexp_eatCapturingGroup = function(state) {
    if (state.eat(0x28 )) {
      if (this.options.ecmaVersion >= 9) {
        this.regexp_groupSpecifier(state);
      } else if (state.current() === 0x3F ) {
        state.raise("Invalid group");
      }
      this.regexp_disjunction(state);
      if (state.eat(0x29 )) {
        state.numCapturingParens += 1;
        return true
      }
      state.raise("Unterminated group");
    }
    return false
  };

  pp$8.regexp_eatExtendedAtom = function(state) {
    return (
      state.eat(0x2E ) ||
      this.regexp_eatReverseSolidusAtomEscape(state) ||
      this.regexp_eatCharacterClass(state) ||
      this.regexp_eatUncapturingGroup(state) ||
      this.regexp_eatCapturingGroup(state) ||
      this.regexp_eatInvalidBracedQuantifier(state) ||
      this.regexp_eatExtendedPatternCharacter(state)
    )
  };

  pp$8.regexp_eatInvalidBracedQuantifier = function(state) {
    if (this.regexp_eatBracedQuantifier(state, true)) {
      state.raise("Nothing to repeat");
    }
    return false
  };

  pp$8.regexp_eatSyntaxCharacter = function(state) {
    var ch = state.current();
    if (isSyntaxCharacter(ch)) {
      state.lastIntValue = ch;
      state.advance();
      return true
    }
    return false
  };
  function isSyntaxCharacter(ch) {
    return (
      ch === 0x24  ||
      ch >= 0x28  && ch <= 0x2B  ||
      ch === 0x2E  ||
      ch === 0x3F  ||
      ch >= 0x5B  && ch <= 0x5E  ||
      ch >= 0x7B  && ch <= 0x7D 
    )
  }

  pp$8.regexp_eatPatternCharacters = function(state) {
    var start = state.pos;
    var ch = 0;
    while ((ch = state.current()) !== -1 && !isSyntaxCharacter(ch)) {
      state.advance();
    }
    return state.pos !== start
  };

  pp$8.regexp_eatExtendedPatternCharacter = function(state) {
    var ch = state.current();
    if (
      ch !== -1 &&
      ch !== 0x24  &&
      !(ch >= 0x28  && ch <= 0x2B ) &&
      ch !== 0x2E  &&
      ch !== 0x3F  &&
      ch !== 0x5B  &&
      ch !== 0x5E  &&
      ch !== 0x7C 
    ) {
      state.advance();
      return true
    }
    return false
  };

  pp$8.regexp_groupSpecifier = function(state) {
    if (state.eat(0x3F )) {
      if (this.regexp_eatGroupName(state)) {
        if (state.groupNames.indexOf(state.lastStringValue) !== -1) {
          state.raise("Duplicate capture group name");
        }
        state.groupNames.push(state.lastStringValue);
        return
      }
      state.raise("Invalid group");
    }
  };

  pp$8.regexp_eatGroupName = function(state) {
    state.lastStringValue = "";
    if (state.eat(0x3C )) {
      if (this.regexp_eatRegExpIdentifierName(state) && state.eat(0x3E )) {
        return true
      }
      state.raise("Invalid capture group name");
    }
    return false
  };

  pp$8.regexp_eatRegExpIdentifierName = function(state) {
    state.lastStringValue = "";
    if (this.regexp_eatRegExpIdentifierStart(state)) {
      state.lastStringValue += codePointToString(state.lastIntValue);
      while (this.regexp_eatRegExpIdentifierPart(state)) {
        state.lastStringValue += codePointToString(state.lastIntValue);
      }
      return true
    }
    return false
  };

  pp$8.regexp_eatRegExpIdentifierStart = function(state) {
    var start = state.pos;
    var forceU = this.options.ecmaVersion >= 11;
    var ch = state.current(forceU);
    state.advance(forceU);

    if (ch === 0x5C  && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
      ch = state.lastIntValue;
    }
    if (isRegExpIdentifierStart(ch)) {
      state.lastIntValue = ch;
      return true
    }

    state.pos = start;
    return false
  };
  function isRegExpIdentifierStart(ch) {
    return isIdentifierStart(ch, true) || ch === 0x24  || ch === 0x5F 
  }

  pp$8.regexp_eatRegExpIdentifierPart = function(state) {
    var start = state.pos;
    var forceU = this.options.ecmaVersion >= 11;
    var ch = state.current(forceU);
    state.advance(forceU);

    if (ch === 0x5C  && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
      ch = state.lastIntValue;
    }
    if (isRegExpIdentifierPart(ch)) {
      state.lastIntValue = ch;
      return true
    }

    state.pos = start;
    return false
  };
  function isRegExpIdentifierPart(ch) {
    return isIdentifierChar(ch, true) || ch === 0x24  || ch === 0x5F  || ch === 0x200C  || ch === 0x200D 
  }

  pp$8.regexp_eatAtomEscape = function(state) {
    if (
      this.regexp_eatBackReference(state) ||
      this.regexp_eatCharacterClassEscape(state) ||
      this.regexp_eatCharacterEscape(state) ||
      (state.switchN && this.regexp_eatKGroupName(state))
    ) {
      return true
    }
    if (state.switchU) {
      if (state.current() === 0x63 ) {
        state.raise("Invalid unicode escape");
      }
      state.raise("Invalid escape");
    }
    return false
  };
  pp$8.regexp_eatBackReference = function(state) {
    var start = state.pos;
    if (this.regexp_eatDecimalEscape(state)) {
      var n = state.lastIntValue;
      if (state.switchU) {
        if (n > state.maxBackReference) {
          state.maxBackReference = n;
        }
        return true
      }
      if (n <= state.numCapturingParens) {
        return true
      }
      state.pos = start;
    }
    return false
  };
  pp$8.regexp_eatKGroupName = function(state) {
    if (state.eat(0x6B )) {
      if (this.regexp_eatGroupName(state)) {
        state.backReferenceNames.push(state.lastStringValue);
        return true
      }
      state.raise("Invalid named reference");
    }
    return false
  };

  pp$8.regexp_eatCharacterEscape = function(state) {
    return (
      this.regexp_eatControlEscape(state) ||
      this.regexp_eatCControlLetter(state) ||
      this.regexp_eatZero(state) ||
      this.regexp_eatHexEscapeSequence(state) ||
      this.regexp_eatRegExpUnicodeEscapeSequence(state, false) ||
      (!state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state)) ||
      this.regexp_eatIdentityEscape(state)
    )
  };
  pp$8.regexp_eatCControlLetter = function(state) {
    var start = state.pos;
    if (state.eat(0x63 )) {
      if (this.regexp_eatControlLetter(state)) {
        return true
      }
      state.pos = start;
    }
    return false
  };
  pp$8.regexp_eatZero = function(state) {
    if (state.current() === 0x30  && !isDecimalDigit(state.lookahead())) {
      state.lastIntValue = 0;
      state.advance();
      return true
    }
    return false
  };

  pp$8.regexp_eatControlEscape = function(state) {
    var ch = state.current();
    if (ch === 0x74 ) {
      state.lastIntValue = 0x09; 
      state.advance();
      return true
    }
    if (ch === 0x6E ) {
      state.lastIntValue = 0x0A; 
      state.advance();
      return true
    }
    if (ch === 0x76 ) {
      state.lastIntValue = 0x0B; 
      state.advance();
      return true
    }
    if (ch === 0x66 ) {
      state.lastIntValue = 0x0C; 
      state.advance();
      return true
    }
    if (ch === 0x72 ) {
      state.lastIntValue = 0x0D; 
      state.advance();
      return true
    }
    return false
  };

  pp$8.regexp_eatControlLetter = function(state) {
    var ch = state.current();
    if (isControlLetter(ch)) {
      state.lastIntValue = ch % 0x20;
      state.advance();
      return true
    }
    return false
  };
  function isControlLetter(ch) {
    return (
      (ch >= 0x41  && ch <= 0x5A ) ||
      (ch >= 0x61  && ch <= 0x7A )
    )
  }

  pp$8.regexp_eatRegExpUnicodeEscapeSequence = function(state, forceU) {
    if ( forceU === void 0 ) forceU = false;

    var start = state.pos;
    var switchU = forceU || state.switchU;

    if (state.eat(0x75 )) {
      if (this.regexp_eatFixedHexDigits(state, 4)) {
        var lead = state.lastIntValue;
        if (switchU && lead >= 0xD800 && lead <= 0xDBFF) {
          var leadSurrogateEnd = state.pos;
          if (state.eat(0x5C ) && state.eat(0x75 ) && this.regexp_eatFixedHexDigits(state, 4)) {
            var trail = state.lastIntValue;
            if (trail >= 0xDC00 && trail <= 0xDFFF) {
              state.lastIntValue = (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;
              return true
            }
          }
          state.pos = leadSurrogateEnd;
          state.lastIntValue = lead;
        }
        return true
      }
      if (
        switchU &&
        state.eat(0x7B ) &&
        this.regexp_eatHexDigits(state) &&
        state.eat(0x7D ) &&
        isValidUnicode(state.lastIntValue)
      ) {
        return true
      }
      if (switchU) {
        state.raise("Invalid unicode escape");
      }
      state.pos = start;
    }

    return false
  };
  function isValidUnicode(ch) {
    return ch >= 0 && ch <= 0x10FFFF
  }

  pp$8.regexp_eatIdentityEscape = function(state) {
    if (state.switchU) {
      if (this.regexp_eatSyntaxCharacter(state)) {
        return true
      }
      if (state.eat(0x2F )) {
        state.lastIntValue = 0x2F; 
        return true
      }
      return false
    }

    var ch = state.current();
    if (ch !== 0x63  && (!state.switchN || ch !== 0x6B )) {
      state.lastIntValue = ch;
      state.advance();
      return true
    }

    return false
  };

  pp$8.regexp_eatDecimalEscape = function(state) {
    state.lastIntValue = 0;
    var ch = state.current();
    if (ch >= 0x31  && ch <= 0x39 ) {
      do {
        state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 );
        state.advance();
      } while ((ch = state.current()) >= 0x30  && ch <= 0x39 )
      return true
    }
    return false
  };

  pp$8.regexp_eatCharacterClassEscape = function(state) {
    var ch = state.current();

    if (isCharacterClassEscape(ch)) {
      state.lastIntValue = -1;
      state.advance();
      return true
    }

    if (
      state.switchU &&
      this.options.ecmaVersion >= 9 &&
      (ch === 0x50  || ch === 0x70 )
    ) {
      state.lastIntValue = -1;
      state.advance();
      if (
        state.eat(0x7B ) &&
        this.regexp_eatUnicodePropertyValueExpression(state) &&
        state.eat(0x7D )
      ) {
        return true
      }
      state.raise("Invalid property name");
    }

    return false
  };
  function isCharacterClassEscape(ch) {
    return (
      ch === 0x64  ||
      ch === 0x44  ||
      ch === 0x73  ||
      ch === 0x53  ||
      ch === 0x77  ||
      ch === 0x57 
    )
  }

  pp$8.regexp_eatUnicodePropertyValueExpression = function(state) {
    var start = state.pos;

    if (this.regexp_eatUnicodePropertyName(state) && state.eat(0x3D )) {
      var name = state.lastStringValue;
      if (this.regexp_eatUnicodePropertyValue(state)) {
        var value = state.lastStringValue;
        this.regexp_validateUnicodePropertyNameAndValue(state, name, value);
        return true
      }
    }
    state.pos = start;

    if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {
      var nameOrValue = state.lastStringValue;
      this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);
      return true
    }
    return false
  };
  pp$8.regexp_validateUnicodePropertyNameAndValue = function(state, name, value) {
    if (!has(state.unicodeProperties.nonBinary, name))
      { state.raise("Invalid property name"); }
    if (!state.unicodeProperties.nonBinary[name].test(value))
      { state.raise("Invalid property value"); }
  };
  pp$8.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {
    if (!state.unicodeProperties.binary.test(nameOrValue))
      { state.raise("Invalid property name"); }
  };

  pp$8.regexp_eatUnicodePropertyName = function(state) {
    var ch = 0;
    state.lastStringValue = "";
    while (isUnicodePropertyNameCharacter(ch = state.current())) {
      state.lastStringValue += codePointToString(ch);
      state.advance();
    }
    return state.lastStringValue !== ""
  };
  function isUnicodePropertyNameCharacter(ch) {
    return isControlLetter(ch) || ch === 0x5F 
  }

  pp$8.regexp_eatUnicodePropertyValue = function(state) {
    var ch = 0;
    state.lastStringValue = "";
    while (isUnicodePropertyValueCharacter(ch = state.current())) {
      state.lastStringValue += codePointToString(ch);
      state.advance();
    }
    return state.lastStringValue !== ""
  };
  function isUnicodePropertyValueCharacter(ch) {
    return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch)
  }

  pp$8.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {
    return this.regexp_eatUnicodePropertyValue(state)
  };

  pp$8.regexp_eatCharacterClass = function(state) {
    if (state.eat(0x5B )) {
      state.eat(0x5E );
      this.regexp_classRanges(state);
      if (state.eat(0x5D )) {
        return true
      }
      state.raise("Unterminated character class");
    }
    return false
  };

  pp$8.regexp_classRanges = function(state) {
    while (this.regexp_eatClassAtom(state)) {
      var left = state.lastIntValue;
      if (state.eat(0x2D ) && this.regexp_eatClassAtom(state)) {
        var right = state.lastIntValue;
        if (state.switchU && (left === -1 || right === -1)) {
          state.raise("Invalid character class");
        }
        if (left !== -1 && right !== -1 && left > right) {
          state.raise("Range out of order in character class");
        }
      }
    }
  };

  pp$8.regexp_eatClassAtom = function(state) {
    var start = state.pos;

    if (state.eat(0x5C )) {
      if (this.regexp_eatClassEscape(state)) {
        return true
      }
      if (state.switchU) {
        var ch$1 = state.current();
        if (ch$1 === 0x63  || isOctalDigit(ch$1)) {
          state.raise("Invalid class escape");
        }
        state.raise("Invalid escape");
      }
      state.pos = start;
    }

    var ch = state.current();
    if (ch !== 0x5D ) {
      state.lastIntValue = ch;
      state.advance();
      return true
    }

    return false
  };

  pp$8.regexp_eatClassEscape = function(state) {
    var start = state.pos;

    if (state.eat(0x62 )) {
      state.lastIntValue = 0x08; 
      return true
    }

    if (state.switchU && state.eat(0x2D )) {
      state.lastIntValue = 0x2D; 
      return true
    }

    if (!state.switchU && state.eat(0x63 )) {
      if (this.regexp_eatClassControlLetter(state)) {
        return true
      }
      state.pos = start;
    }

    return (
      this.regexp_eatCharacterClassEscape(state) ||
      this.regexp_eatCharacterEscape(state)
    )
  };

  pp$8.regexp_eatClassControlLetter = function(state) {
    var ch = state.current();
    if (isDecimalDigit(ch) || ch === 0x5F ) {
      state.lastIntValue = ch % 0x20;
      state.advance();
      return true
    }
    return false
  };

  pp$8.regexp_eatHexEscapeSequence = function(state) {
    var start = state.pos;
    if (state.eat(0x78 )) {
      if (this.regexp_eatFixedHexDigits(state, 2)) {
        return true
      }
      if (state.switchU) {
        state.raise("Invalid escape");
      }
      state.pos = start;
    }
    return false
  };

  pp$8.regexp_eatDecimalDigits = function(state) {
    var start = state.pos;
    var ch = 0;
    state.lastIntValue = 0;
    while (isDecimalDigit(ch = state.current())) {
      state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 );
      state.advance();
    }
    return state.pos !== start
  };
  function isDecimalDigit(ch) {
    return ch >= 0x30  && ch <= 0x39 
  }

  pp$8.regexp_eatHexDigits = function(state) {
    var start = state.pos;
    var ch = 0;
    state.lastIntValue = 0;
    while (isHexDigit(ch = state.current())) {
      state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
      state.advance();
    }
    return state.pos !== start
  };
  function isHexDigit(ch) {
    return (
      (ch >= 0x30  && ch <= 0x39 ) ||
      (ch >= 0x41  && ch <= 0x46 ) ||
      (ch >= 0x61  && ch <= 0x66 )
    )
  }
  function hexToInt(ch) {
    if (ch >= 0x41  && ch <= 0x46 ) {
      return 10 + (ch - 0x41 )
    }
    if (ch >= 0x61  && ch <= 0x66 ) {
      return 10 + (ch - 0x61 )
    }
    return ch - 0x30 
  }

  pp$8.regexp_eatLegacyOctalEscapeSequence = function(state) {
    if (this.regexp_eatOctalDigit(state)) {
      var n1 = state.lastIntValue;
      if (this.regexp_eatOctalDigit(state)) {
        var n2 = state.lastIntValue;
        if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {
          state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;
        } else {
          state.lastIntValue = n1 * 8 + n2;
        }
      } else {
        state.lastIntValue = n1;
      }
      return true
    }
    return false
  };

  pp$8.regexp_eatOctalDigit = function(state) {
    var ch = state.current();
    if (isOctalDigit(ch)) {
      state.lastIntValue = ch - 0x30; 
      state.advance();
      return true
    }
    state.lastIntValue = 0;
    return false
  };
  function isOctalDigit(ch) {
    return ch >= 0x30  && ch <= 0x37 
  }

  pp$8.regexp_eatFixedHexDigits = function(state, length) {
    var start = state.pos;
    state.lastIntValue = 0;
    for (var i = 0; i < length; ++i) {
      var ch = state.current();
      if (!isHexDigit(ch)) {
        state.pos = start;
        return false
      }
      state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
      state.advance();
    }
    return true
  };


  var Token = function Token(p) {
    this.type = p.type;
    this.value = p.value;
    this.start = p.start;
    this.end = p.end;
    if (p.options.locations)
      { this.loc = new SourceLocation(p, p.startLoc, p.endLoc); }
    if (p.options.ranges)
      { this.range = [p.start, p.end]; }
  };


  var pp$9 = Parser.prototype;


  pp$9.next = function(ignoreEscapeSequenceInKeyword) {
    if (!ignoreEscapeSequenceInKeyword && this.type.keyword && this.containsEsc)
      { this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword); }
    if (this.options.onToken)
      { this.options.onToken(new Token(this)); }

    this.lastTokEnd = this.end;
    this.lastTokStart = this.start;
    this.lastTokEndLoc = this.endLoc;
    this.lastTokStartLoc = this.startLoc;
    this.nextToken();
  };

  pp$9.getToken = function() {
    this.next();
    return new Token(this)
  };

  if (typeof Symbol !== "undefined")
    { pp$9[Symbol.iterator] = function() {
      var this$1 = this;

      return {
        next: function () {
          var token = this$1.getToken();
          return {
            done: token.type === types.eof,
            value: token
          }
        }
      }
    }; }


  pp$9.curContext = function() {
    return this.context[this.context.length - 1]
  };


  pp$9.nextToken = function() {
    var curContext = this.curContext();
    if (!curContext || !curContext.preserveSpace) { this.skipSpace(); }

    this.start = this.pos;
    if (this.options.locations) { this.startLoc = this.curPosition(); }
    if (this.pos >= this.input.length) { return this.finishToken(types.eof) }

    if (curContext.override) { return curContext.override(this) }
    else { this.readToken(this.fullCharCodeAtPos()); }
  };

  pp$9.readToken = function(code) {
    if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92 )
      { return this.readWord() }

    return this.getTokenFromCode(code)
  };

  pp$9.fullCharCodeAtPos = function() {
    var code = this.input.charCodeAt(this.pos);
    if (code <= 0xd7ff || code >= 0xe000) { return code }
    var next = this.input.charCodeAt(this.pos + 1);
    return (code << 10) + next - 0x35fdc00
  };

  pp$9.skipBlockComment = function() {
    var startLoc = this.options.onComment && this.curPosition();
    var start = this.pos, end = this.input.indexOf("*/", this.pos += 2);
    if (end === -1) { this.raise(this.pos - 2, "Unterminated comment"); }
    this.pos = end + 2;
    if (this.options.locations) {
      lineBreakG.lastIndex = start;
      var match;
      while ((match = lineBreakG.exec(this.input)) && match.index < this.pos) {
        ++this.curLine;
        this.lineStart = match.index + match[0].length;
      }
    }
    if (this.options.onComment)
      { this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos,
                             startLoc, this.curPosition()); }
  };

  pp$9.skipLineComment = function(startSkip) {
    var start = this.pos;
    var startLoc = this.options.onComment && this.curPosition();
    var ch = this.input.charCodeAt(this.pos += startSkip);
    while (this.pos < this.input.length && !isNewLine(ch)) {
      ch = this.input.charCodeAt(++this.pos);
    }
    if (this.options.onComment)
      { this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos,
                             startLoc, this.curPosition()); }
  };


  pp$9.skipSpace = function() {
    loop: while (this.pos < this.input.length) {
      var ch = this.input.charCodeAt(this.pos);
      switch (ch) {
      case 32: case 160: 
        ++this.pos;
        break
      case 13:
        if (this.input.charCodeAt(this.pos + 1) === 10) {
          ++this.pos;
        }
      case 10: case 8232: case 8233:
        ++this.pos;
        if (this.options.locations) {
          ++this.curLine;
          this.lineStart = this.pos;
        }
        break
      case 47: 
        switch (this.input.charCodeAt(this.pos + 1)) {
        case 42: 
          this.skipBlockComment();
          break
        case 47:
          this.skipLineComment(2);
          break
        default:
          break loop
        }
        break
      default:
        if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {
          ++this.pos;
        } else {
          break loop
        }
      }
    }
  };


  pp$9.finishToken = function(type, val) {
    this.end = this.pos;
    if (this.options.locations) { this.endLoc = this.curPosition(); }
    var prevType = this.type;
    this.type = type;
    this.value = val;

    this.updateContext(prevType);
  };


  pp$9.readToken_dot = function() {
    var next = this.input.charCodeAt(this.pos + 1);
    if (next >= 48 && next <= 57) { return this.readNumber(true) }
    var next2 = this.input.charCodeAt(this.pos + 2);
    if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) { 
      this.pos += 3;
      return this.finishToken(types.ellipsis)
    } else {
      ++this.pos;
      return this.finishToken(types.dot)
    }
  };

  pp$9.readToken_slash = function() { 
    var next = this.input.charCodeAt(this.pos + 1);
    if (this.exprAllowed) { ++this.pos; return this.readRegexp() }
    if (next === 61) { return this.finishOp(types.assign, 2) }
    return this.finishOp(types.slash, 1)
  };

  pp$9.readToken_mult_modulo_exp = function(code) { 
    var next = this.input.charCodeAt(this.pos + 1);
    var size = 1;
    var tokentype = code === 42 ? types.star : types.modulo;

    if (this.options.ecmaVersion >= 7 && code === 42 && next === 42) {
      ++size;
      tokentype = types.starstar;
      next = this.input.charCodeAt(this.pos + 2);
    }

    if (next === 61) { return this.finishOp(types.assign, size + 1) }
    return this.finishOp(tokentype, size)
  };

  pp$9.readToken_pipe_amp = function(code) { 
    var next = this.input.charCodeAt(this.pos + 1);
    if (next === code) {
      if (this.options.ecmaVersion >= 12) {
        var next2 = this.input.charCodeAt(this.pos + 2);
        if (next2 === 61) { return this.finishOp(types.assign, 3) }
      }
      return this.finishOp(code === 124 ? types.logicalOR : types.logicalAND, 2)
    }
    if (next === 61) { return this.finishOp(types.assign, 2) }
    return this.finishOp(code === 124 ? types.bitwiseOR : types.bitwiseAND, 1)
  };

  pp$9.readToken_caret = function() { 
    var next = this.input.charCodeAt(this.pos + 1);
    if (next === 61) { return this.finishOp(types.assign, 2) }
    return this.finishOp(types.bitwiseXOR, 1)
  };

  pp$9.readToken_plus_min = function(code) { 
    var next = this.input.charCodeAt(this.pos + 1);
    if (next === code) {
      if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 &&
          (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {
        this.skipLineComment(3);
        this.skipSpace();
        return this.nextToken()
      }
      return this.finishOp(types.incDec, 2)
    }
    if (next === 61) { return this.finishOp(types.assign, 2) }
    return this.finishOp(types.plusMin, 1)
  };

  pp$9.readToken_lt_gt = function(code) { 
    var next = this.input.charCodeAt(this.pos + 1);
    var size = 1;
    if (next === code) {
      size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
      if (this.input.charCodeAt(this.pos + size) === 61) { return this.finishOp(types.assign, size + 1) }
      return this.finishOp(types.bitShift, size)
    }
    if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 &&
        this.input.charCodeAt(this.pos + 3) === 45) {
      this.skipLineComment(4);
      this.skipSpace();
      return this.nextToken()
    }
    if (next === 61) { size = 2; }
    return this.finishOp(types.relational, size)
  };

  pp$9.readToken_eq_excl = function(code) { 
    var next = this.input.charCodeAt(this.pos + 1);
    if (next === 61) { return this.finishOp(types.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2) }
    if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) { 
      this.pos += 2;
      return this.finishToken(types.arrow)
    }
    return this.finishOp(code === 61 ? types.eq : types.prefix, 1)
  };

  pp$9.readToken_question = function() { 
    var ecmaVersion = this.options.ecmaVersion;
    if (ecmaVersion >= 11) {
      var next = this.input.charCodeAt(this.pos + 1);
      if (next === 46) {
        var next2 = this.input.charCodeAt(this.pos + 2);
        if (next2 < 48 || next2 > 57) { return this.finishOp(types.questionDot, 2) }
      }
      if (next === 63) {
        if (ecmaVersion >= 12) {
          var next2$1 = this.input.charCodeAt(this.pos + 2);
          if (next2$1 === 61) { return this.finishOp(types.assign, 3) }
        }
        return this.finishOp(types.coalesce, 2)
      }
    }
    return this.finishOp(types.question, 1)
  };

  pp$9.getTokenFromCode = function(code) {
    switch (code) {
    case 46: 
      return this.readToken_dot()

    case 40: ++this.pos; return this.finishToken(types.parenL)
    case 41: ++this.pos; return this.finishToken(types.parenR)
    case 59: ++this.pos; return this.finishToken(types.semi)
    case 44: ++this.pos; return this.finishToken(types.comma)
    case 91: ++this.pos; return this.finishToken(types.bracketL)
    case 93: ++this.pos; return this.finishToken(types.bracketR)
    case 123: ++this.pos; return this.finishToken(types.braceL)
    case 125: ++this.pos; return this.finishToken(types.braceR)
    case 58: ++this.pos; return this.finishToken(types.colon)

    case 96: 
      if (this.options.ecmaVersion < 6) { break }
      ++this.pos;
      return this.finishToken(types.backQuote)

    case 48: 
      var next = this.input.charCodeAt(this.pos + 1);
      if (next === 120 || next === 88) { return this.readRadixNumber(16) } 
      if (this.options.ecmaVersion >= 6) {
        if (next === 111 || next === 79) { return this.readRadixNumber(8) } 
        if (next === 98 || next === 66) { return this.readRadixNumber(2) } 
      }

    case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: 
      return this.readNumber(false)

    case 34: case 39: 
      return this.readString(code)


    case 47: 
      return this.readToken_slash()

    case 37: case 42: 
      return this.readToken_mult_modulo_exp(code)

    case 124: case 38: 
      return this.readToken_pipe_amp(code)

    case 94: 
      return this.readToken_caret()

    case 43: case 45: 
      return this.readToken_plus_min(code)

    case 60: case 62: 
      return this.readToken_lt_gt(code)

    case 61: case 33: 
      return this.readToken_eq_excl(code)

    case 63: 
      return this.readToken_question()

    case 126: 
      return this.finishOp(types.prefix, 1)
    }

    this.raise(this.pos, "Unexpected character '" + codePointToString$1(code) + "'");
  };

  pp$9.finishOp = function(type, size) {
    var str = this.input.slice(this.pos, this.pos + size);
    this.pos += size;
    return this.finishToken(type, str)
  };

  pp$9.readRegexp = function() {
    var escaped, inClass, start = this.pos;
    for (;;) {
      if (this.pos >= this.input.length) { this.raise(start, "Unterminated regular expression"); }
      var ch = this.input.charAt(this.pos);
      if (lineBreak.test(ch)) { this.raise(start, "Unterminated regular expression"); }
      if (!escaped) {
        if (ch === "[") { inClass = true; }
        else if (ch === "]" && inClass) { inClass = false; }
        else if (ch === "/" && !inClass) { break }
        escaped = ch === "\\";
      } else { escaped = false; }
      ++this.pos;
    }
    var pattern = this.input.slice(start, this.pos);
    ++this.pos;
    var flagsStart = this.pos;
    var flags = this.readWord1();
    if (this.containsEsc) { this.unexpected(flagsStart); }

    var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));
    state.reset(start, pattern, flags);
    this.validateRegExpFlags(state);
    this.validateRegExpPattern(state);

    var value = null;
    try {
      value = new RegExp(pattern, flags);
    } catch (e) {
    }

    return this.finishToken(types.regexp, {pattern: pattern, flags: flags, value: value})
  };


  pp$9.readInt = function(radix, len, maybeLegacyOctalNumericLiteral) {
    var allowSeparators = this.options.ecmaVersion >= 12 && len === undefined;

    var isLegacyOctalNumericLiteral = maybeLegacyOctalNumericLiteral && this.input.charCodeAt(this.pos) === 48;

    var start = this.pos, total = 0, lastCode = 0;
    for (var i = 0, e = len == null ? Infinity : len; i < e; ++i, ++this.pos) {
      var code = this.input.charCodeAt(this.pos), val = (void 0);

      if (allowSeparators && code === 95) {
        if (isLegacyOctalNumericLiteral) { this.raiseRecoverable(this.pos, "Numeric separator is not allowed in legacy octal numeric literals"); }
        if (lastCode === 95) { this.raiseRecoverable(this.pos, "Numeric separator must be exactly one underscore"); }
        if (i === 0) { this.raiseRecoverable(this.pos, "Numeric separator is not allowed at the first of digits"); }
        lastCode = code;
        continue
      }

      if (code >= 97) { val = code - 97 + 10; } 
      else if (code >= 65) { val = code - 65 + 10; } 
      else if (code >= 48 && code <= 57) { val = code - 48; } 
      else { val = Infinity; }
      if (val >= radix) { break }
      lastCode = code;
      total = total * radix + val;
    }

    if (allowSeparators && lastCode === 95) { this.raiseRecoverable(this.pos - 1, "Numeric separator is not allowed at the last of digits"); }
    if (this.pos === start || len != null && this.pos - start !== len) { return null }

    return total
  };

  function stringToNumber(str, isLegacyOctalNumericLiteral) {
    if (isLegacyOctalNumericLiteral) {
      return parseInt(str, 8)
    }

    return parseFloat(str.replace(/_/g, ""))
  }

  function stringToBigInt(str) {
    if (typeof BigInt !== "function") {
      return null
    }

    return BigInt(str.replace(/_/g, ""))
  }

  pp$9.readRadixNumber = function(radix) {
    var start = this.pos;
    this.pos += 2; 
    var val = this.readInt(radix);
    if (val == null) { this.raise(this.start + 2, "Expected number in radix " + radix); }
    if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {
      val = stringToBigInt(this.input.slice(start, this.pos));
      ++this.pos;
    } else if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, "Identifier directly after number"); }
    return this.finishToken(types.num, val)
  };


  pp$9.readNumber = function(startsWithDot) {
    var start = this.pos;
    if (!startsWithDot && this.readInt(10, undefined, true) === null) { this.raise(start, "Invalid number"); }
    var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;
    if (octal && this.strict) { this.raise(start, "Invalid number"); }
    var next = this.input.charCodeAt(this.pos);
    if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next === 110) {
      var val$1 = stringToBigInt(this.input.slice(start, this.pos));
      ++this.pos;
      if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, "Identifier directly after number"); }
      return this.finishToken(types.num, val$1)
    }
    if (octal && /[89]/.test(this.input.slice(start, this.pos))) { octal = false; }
    if (next === 46 && !octal) { 
      ++this.pos;
      this.readInt(10);
      next = this.input.charCodeAt(this.pos);
    }
    if ((next === 69 || next === 101) && !octal) { 
      next = this.input.charCodeAt(++this.pos);
      if (next === 43 || next === 45) { ++this.pos; } 
      if (this.readInt(10) === null) { this.raise(start, "Invalid number"); }
    }
    if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, "Identifier directly after number"); }

    var val = stringToNumber(this.input.slice(start, this.pos), octal);
    return this.finishToken(types.num, val)
  };


  pp$9.readCodePoint = function() {
    var ch = this.input.charCodeAt(this.pos), code;

    if (ch === 123) { 
      if (this.options.ecmaVersion < 6) { this.unexpected(); }
      var codePos = ++this.pos;
      code = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos);
      ++this.pos;
      if (code > 0x10FFFF) { this.invalidStringToken(codePos, "Code point out of bounds"); }
    } else {
      code = this.readHexChar(4);
    }
    return code
  };

  function codePointToString$1(code) {
    if (code <= 0xFFFF) { return String.fromCharCode(code) }
    code -= 0x10000;
    return String.fromCharCode((code >> 10) + 0xD800, (code & 1023) + 0xDC00)
  }

  pp$9.readString = function(quote) {
    var out = "", chunkStart = ++this.pos;
    for (;;) {
      if (this.pos >= this.input.length) { this.raise(this.start, "Unterminated string constant"); }
      var ch = this.input.charCodeAt(this.pos);
      if (ch === quote) { break }
      if (ch === 92) { 
        out += this.input.slice(chunkStart, this.pos);
        out += this.readEscapedChar(false);
        chunkStart = this.pos;
      } else {
        if (isNewLine(ch, this.options.ecmaVersion >= 10)) { this.raise(this.start, "Unterminated string constant"); }
        ++this.pos;
      }
    }
    out += this.input.slice(chunkStart, this.pos++);
    return this.finishToken(types.string, out)
  };


  var INVALID_TEMPLATE_ESCAPE_ERROR = {};

  pp$9.tryReadTemplateToken = function() {
    this.inTemplateElement = true;
    try {
      this.readTmplToken();
    } catch (err) {
      if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {
        this.readInvalidTemplateToken();
      } else {
        throw err
      }
    }

    this.inTemplateElement = false;
  };

  pp$9.invalidStringToken = function(position, message) {
    if (this.inTemplateElement && this.options.ecmaVersion >= 9) {
      throw INVALID_TEMPLATE_ESCAPE_ERROR
    } else {
      this.raise(position, message);
    }
  };

  pp$9.readTmplToken = function() {
    var out = "", chunkStart = this.pos;
    for (;;) {
      if (this.pos >= this.input.length) { this.raise(this.start, "Unterminated template"); }
      var ch = this.input.charCodeAt(this.pos);
      if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) { 
        if (this.pos === this.start && (this.type === types.template || this.type === types.invalidTemplate)) {
          if (ch === 36) {
            this.pos += 2;
            return this.finishToken(types.dollarBraceL)
          } else {
            ++this.pos;
            return this.finishToken(types.backQuote)
          }
        }
        out += this.input.slice(chunkStart, this.pos);
        return this.finishToken(types.template, out)
      }
      if (ch === 92) { 
        out += this.input.slice(chunkStart, this.pos);
        out += this.readEscapedChar(true);
        chunkStart = this.pos;
      } else if (isNewLine(ch)) {
        out += this.input.slice(chunkStart, this.pos);
        ++this.pos;
        switch (ch) {
        case 13:
          if (this.input.charCodeAt(this.pos) === 10) { ++this.pos; }
        case 10:
          out += "\n";
          break
        default:
          out += String.fromCharCode(ch);
          break
        }
        if (this.options.locations) {
          ++this.curLine;
          this.lineStart = this.pos;
        }
        chunkStart = this.pos;
      } else {
        ++this.pos;
      }
    }
  };

  pp$9.readInvalidTemplateToken = function() {
    for (; this.pos < this.input.length; this.pos++) {
      switch (this.input[this.pos]) {
      case "\\":
        ++this.pos;
        break

      case "$":
        if (this.input[this.pos + 1] !== "{") {
          break
        }

      case "`":
        return this.finishToken(types.invalidTemplate, this.input.slice(this.start, this.pos))

      }
    }
    this.raise(this.start, "Unterminated template");
  };


  pp$9.readEscapedChar = function(inTemplate) {
    var ch = this.input.charCodeAt(++this.pos);
    ++this.pos;
    switch (ch) {
    case 110: return "\n" 
    case 114: return "\r" 
    case 120: return String.fromCharCode(this.readHexChar(2)) 
    case 117: return codePointToString$1(this.readCodePoint()) 
    case 116: return "\t" 
    case 98: return "\b" 
    case 118: return "\u000b" 
    case 102: return "\f" 
    case 13: if (this.input.charCodeAt(this.pos) === 10) { ++this.pos; } 
    case 10: 
      if (this.options.locations) { this.lineStart = this.pos; ++this.curLine; }
      return ""
    case 56:
    case 57:
      if (inTemplate) {
        var codePos = this.pos - 1;

        this.invalidStringToken(
          codePos,
          "Invalid escape sequence in template string"
        );

        return null
      }
    default:
      if (ch >= 48 && ch <= 55) {
        var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
        var octal = parseInt(octalStr, 8);
        if (octal > 255) {
          octalStr = octalStr.slice(0, -1);
          octal = parseInt(octalStr, 8);
        }
        this.pos += octalStr.length - 1;
        ch = this.input.charCodeAt(this.pos);
        if ((octalStr !== "0" || ch === 56 || ch === 57) && (this.strict || inTemplate)) {
          this.invalidStringToken(
            this.pos - 1 - octalStr.length,
            inTemplate
              ? "Octal literal in template string"
              : "Octal literal in strict mode"
          );
        }
        return String.fromCharCode(octal)
      }
      if (isNewLine(ch)) {
        return ""
      }
      return String.fromCharCode(ch)
    }
  };


  pp$9.readHexChar = function(len) {
    var codePos = this.pos;
    var n = this.readInt(16, len);
    if (n === null) { this.invalidStringToken(codePos, "Bad character escape sequence"); }
    return n
  };


  pp$9.readWord1 = function() {
    this.containsEsc = false;
    var word = "", first = true, chunkStart = this.pos;
    var astral = this.options.ecmaVersion >= 6;
    while (this.pos < this.input.length) {
      var ch = this.fullCharCodeAtPos();
      if (isIdentifierChar(ch, astral)) {
        this.pos += ch <= 0xffff ? 1 : 2;
      } else if (ch === 92) { 
        this.containsEsc = true;
        word += this.input.slice(chunkStart, this.pos);
        var escStart = this.pos;
        if (this.input.charCodeAt(++this.pos) !== 117) 
          { this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX"); }
        ++this.pos;
        var esc = this.readCodePoint();
        if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral))
          { this.invalidStringToken(escStart, "Invalid Unicode escape"); }
        word += codePointToString$1(esc);
        chunkStart = this.pos;
      } else {
        break
      }
      first = false;
    }
    return word + this.input.slice(chunkStart, this.pos)
  };


  pp$9.readWord = function() {
    var word = this.readWord1();
    var type = types.name;
    if (this.keywords.test(word)) {
      type = keywords$1[word];
    }
    return this.finishToken(type, word)
  };


  var version = "7.4.0";

  Parser.acorn = {
    Parser: Parser,
    version: version,
    defaultOptions: defaultOptions,
    Position: Position,
    SourceLocation: SourceLocation,
    getLineInfo: getLineInfo,
    Node: Node,
    TokenType: TokenType,
    tokTypes: types,
    keywordTypes: keywords$1,
    TokContext: TokContext,
    tokContexts: types$1,
    isIdentifierChar: isIdentifierChar,
    isIdentifierStart: isIdentifierStart,
    Token: Token,
    isNewLine: isNewLine,
    lineBreak: lineBreak,
    lineBreakG: lineBreakG,
    nonASCIIwhitespace: nonASCIIwhitespace
  };


  function parse(input, options) {
    return Parser.parse(input, options)
  }


  function parseExpressionAt(input, pos, options) {
    return Parser.parseExpressionAt(input, pos, options)
  }


  function tokenizer(input, options) {
    return Parser.tokenizer(input, options)
  }

  exports.Node = Node;
  exports.Parser = Parser;
  exports.Position = Position;
  exports.SourceLocation = SourceLocation;
  exports.TokContext = TokContext;
  exports.Token = Token;
  exports.TokenType = TokenType;
  exports.defaultOptions = defaultOptions;
  exports.getLineInfo = getLineInfo;
  exports.isIdentifierChar = isIdentifierChar;
  exports.isIdentifierStart = isIdentifierStart;
  exports.isNewLine = isNewLine;
  exports.keywordTypes = keywords$1;
  exports.lineBreak = lineBreak;
  exports.lineBreakG = lineBreakG;
  exports.nonASCIIwhitespace = nonASCIIwhitespace;
  exports.parse = parse;
  exports.parseExpressionAt = parseExpressionAt;
  exports.tokContexts = types$1;
  exports.tokTypes = types;
  exports.tokenizer = tokenizer;
  exports.version = version;

  Object.defineProperty(exports, '__esModule', { value: true });

})));

},{}],2:[function(require,module,exports){

},{}],3:[function(require,module,exports){
function glWiretap(gl, options = {}) {
  const {
    contextName = 'gl',
    throwGetError,
    useTrackablePrimitives,
    readPixelsFile,
    recording = [],
    variables = {},
    onReadPixels,
    onUnrecognizedArgumentLookup,
  } = options;
  const proxy = new Proxy(gl, { get: listen });
  const contextVariables = [];
  const entityNames = {};
  let imageCount = 0;
  let indent = '';
  let readPixelsVariableName;
  return proxy;
  function listen(obj, property) {
    switch (property) {
      case 'addComment': return addComment;
      case 'checkThrowError': return checkThrowError;
      case 'getReadPixelsVariableName': return readPixelsVariableName;
      case 'insertVariable': return insertVariable;
      case 'reset': return reset;
      case 'setIndent': return setIndent;
      case 'toString': return toString;
      case 'getContextVariableName': return getContextVariableName;
    }
    if (typeof gl[property] === 'function') {
      return function() { 
        switch (property) {
          case 'getError':
            if (throwGetError) {
              recording.push(`${indent}if (${contextName}.getError() !== ${contextName}.NONE) throw new Error('error');`);
            } else {
              recording.push(`${indent}${contextName}.getError();`); 
            }
            return gl.getError();
          case 'getExtension': {
            const variableName = `${contextName}Variables${contextVariables.length}`;
            recording.push(`${indent}const ${variableName} = ${contextName}.getExtension('${arguments[0]}');`);
            const extension = gl.getExtension(arguments[0]);
            if (extension && typeof extension === 'object') {
              const tappedExtension = glExtensionWiretap(extension, {
                getEntity,
                useTrackablePrimitives,
                recording,
                contextName: variableName,
                contextVariables,
                variables,
                indent,
                onUnrecognizedArgumentLookup,
              });
              contextVariables.push(tappedExtension);
              return tappedExtension;
            } else {
              contextVariables.push(null);
            }
            return extension;
          }
          case 'readPixels':
            const i = contextVariables.indexOf(arguments[6]);
            let targetVariableName;
            if (i === -1) {
              const variableName = getVariableName(arguments[6]);
              if (variableName) {
                targetVariableName = variableName;
                recording.push(`${indent}${variableName}`);
              } else {
                targetVariableName = `${contextName}Variable${contextVariables.length}`;
                contextVariables.push(arguments[6]);
                recording.push(`${indent}const ${targetVariableName} = new ${arguments[6].constructor.name}(${arguments[6].length});`);
              }
            } else {
              targetVariableName = `${contextName}Variable${i}`;
            }
            readPixelsVariableName = targetVariableName;
            const argumentAsStrings = [
              arguments[0],
              arguments[1],
              arguments[2],
              arguments[3],
              getEntity(arguments[4]),
              getEntity(arguments[5]),
              targetVariableName
            ];
            recording.push(`${indent}${contextName}.readPixels(${argumentAsStrings.join(', ')});`);
            if (readPixelsFile) {
              writePPM(arguments[2], arguments[3]);
            }
            if (onReadPixels) {
              onReadPixels(targetVariableName, argumentAsStrings);
            }
            return gl.readPixels.apply(gl, arguments);
          case 'drawBuffers':
            recording.push(`${indent}${contextName}.drawBuffers([${argumentsToString(arguments[0], { contextName, contextVariables, getEntity, addVariable, variables, onUnrecognizedArgumentLookup } )}]);`);
            return gl.drawBuffers(arguments[0]);
        }
        let result = gl[property].apply(gl, arguments);
        switch (typeof result) {
          case 'undefined':
            recording.push(`${indent}${methodCallToString(property, arguments)};`);
            return;
          case 'number':
          case 'boolean':
            if (useTrackablePrimitives && contextVariables.indexOf(trackablePrimitive(result)) === -1) {
              recording.push(`${indent}const ${contextName}Variable${contextVariables.length} = ${methodCallToString(property, arguments)};`);
              contextVariables.push(result = trackablePrimitive(result));
              break;
            }
          default:
            if (result === null) {
              recording.push(`${methodCallToString(property, arguments)};`);
            } else {
              recording.push(`${indent}const ${contextName}Variable${contextVariables.length} = ${methodCallToString(property, arguments)};`);
            }

            contextVariables.push(result);
        }
        return result;
      }
    }
    entityNames[gl[property]] = property;
    return gl[property];
  }
  function toString() {
    return recording.join('\n');
  }
  function reset() {
    while (recording.length > 0) {
      recording.pop();
    }
  }
  function insertVariable(name, value) {
    variables[name] = value;
  }
  function getEntity(value) {
    const name = entityNames[value];
    if (name) {
      return contextName + '.' + name;
    }
    return value;
  }
  function setIndent(spaces) {
    indent = ' '.repeat(spaces);
  }
  function addVariable(value, source) {
    const variableName = `${contextName}Variable${contextVariables.length}`;
    recording.push(`${indent}const ${variableName} = ${source};`);
    contextVariables.push(value);
    return variableName;
  }
  function writePPM(width, height) {
    const sourceVariable = `${contextName}Variable${contextVariables.length}`;
    const imageVariable = `imageDatum${imageCount}`;
    recording.push(`${indent}let ${imageVariable} = ["P3\\n# ${readPixelsFile}.ppm\\n", ${width}, ' ', ${height}, "\\n255\\n"].join("");`);
    recording.push(`${indent}for (let i = 0; i < ${imageVariable}.length; i += 4) {`);
    recording.push(`${indent}  ${imageVariable} += ${sourceVariable}[i] + ' ' + ${sourceVariable}[i + 1] + ' ' + ${sourceVariable}[i + 2] + ' ';`);
    recording.push(`${indent}}`);
    recording.push(`${indent}if (typeof require !== "undefined") {`);
    recording.push(`${indent}  require('fs').writeFileSync('./${readPixelsFile}.ppm', ${imageVariable});`);
    recording.push(`${indent}}`);
    imageCount++;
  }
  function addComment(value) {
    recording.push(`${indent}// ${value}`);
  }
  function checkThrowError() {
    recording.push(`${indent}(() => {
${indent}const error = ${contextName}.getError();
${indent}if (error !== ${contextName}.NONE) {
${indent}  const names = Object.getOwnPropertyNames(gl);
${indent}  for (let i = 0; i < names.length; i++) {
${indent}    const name = names[i];
${indent}    if (${contextName}[name] === error) {
${indent}      throw new Error('${contextName} threw ' + name);
${indent}    }
${indent}  }
${indent}}
${indent}})();`);
  }
  function methodCallToString(method, args) {
    return `${contextName}.${method}(${argumentsToString(args, { contextName, contextVariables, getEntity, addVariable, variables, onUnrecognizedArgumentLookup })})`;
  }

  function getVariableName(value) {
    if (variables) {
      for (const name in variables) {
        if (variables[name] === value) {
          return name;
        }
      }
    }
    return null;
  }

  function getContextVariableName(value) {
    const i = contextVariables.indexOf(value);
    if (i !== -1) {
      return `${contextName}Variable${i}`;
    }
    return null;
  }
}

function glExtensionWiretap(extension, options) {
  const proxy = new Proxy(extension, { get: listen });
  const extensionEntityNames = {};
  const {
    contextName,
    contextVariables,
    getEntity,
    useTrackablePrimitives,
    recording,
    variables,
    indent,
    onUnrecognizedArgumentLookup,
  } = options;
  return proxy;
  function listen(obj, property) {
    if (typeof obj[property] === 'function') {
      return function() {
        switch (property) {
          case 'drawBuffersWEBGL':
            recording.push(`${indent}${contextName}.drawBuffersWEBGL([${argumentsToString(arguments[0], { contextName, contextVariables, getEntity: getExtensionEntity, addVariable, variables, onUnrecognizedArgumentLookup })}]);`);
            return extension.drawBuffersWEBGL(arguments[0]);
        }
        let result = extension[property].apply(extension, arguments);
        switch (typeof result) {
          case 'undefined':
            recording.push(`${indent}${methodCallToString(property, arguments)};`);
            return;
          case 'number':
          case 'boolean':
            if (useTrackablePrimitives && contextVariables.indexOf(trackablePrimitive(result)) === -1) {
              recording.push(`${indent}const ${contextName}Variable${contextVariables.length} = ${methodCallToString(property, arguments)};`);
              contextVariables.push(result = trackablePrimitive(result));
            } else {
              recording.push(`${indent}const ${contextName}Variable${contextVariables.length} = ${methodCallToString(property, arguments)};`);
              contextVariables.push(result);
            }
            break;
          default:
            if (result === null) {
              recording.push(`${methodCallToString(property, arguments)};`);
            } else {
              recording.push(`${indent}const ${contextName}Variable${contextVariables.length} = ${methodCallToString(property, arguments)};`);
            }
            contextVariables.push(result);
        }
        return result;
      };
    }
    extensionEntityNames[extension[property]] = property;
    return extension[property];
  }

  function getExtensionEntity(value) {
    if (extensionEntityNames.hasOwnProperty(value)) {
      return `${contextName}.${extensionEntityNames[value]}`;
    }
    return getEntity(value);
  }

  function methodCallToString(method, args) {
    return `${contextName}.${method}(${argumentsToString(args, { contextName, contextVariables, getEntity: getExtensionEntity, addVariable, variables, onUnrecognizedArgumentLookup })})`;
  }

  function addVariable(value, source) {
    const variableName = `${contextName}Variable${contextVariables.length}`;
    contextVariables.push(value);
    recording.push(`${indent}const ${variableName} = ${source};`);
    return variableName;
  }
}

function argumentsToString(args, options) {
  const { variables, onUnrecognizedArgumentLookup } = options;
  return (Array.from(args).map((arg) => {
    const variableName = getVariableName(arg);
    if (variableName) {
      return variableName;
    }
    return argumentToString(arg, options);
  }).join(', '));

  function getVariableName(value) {
    if (variables) {
      for (const name in variables) {
        if (!variables.hasOwnProperty(name)) continue;
        if (variables[name] === value) {
          return name;
        }
      }
    }
    if (onUnrecognizedArgumentLookup) {
      return onUnrecognizedArgumentLookup(value);
    }
    return null;
  }
}

function argumentToString(arg, options) {
  const { contextName, contextVariables, getEntity, addVariable, onUnrecognizedArgumentLookup } = options;
  if (typeof arg === 'undefined') {
    return 'undefined';
  }
  if (arg === null) {
    return 'null';
  }
  const i = contextVariables.indexOf(arg);
  if (i > -1) {
    return `${contextName}Variable${i}`;
  }
  switch (arg.constructor.name) {
    case 'String':
      const hasLines = /\n/.test(arg);
      const hasSingleQuotes = /'/.test(arg);
      const hasDoubleQuotes = /"/.test(arg);
      if (hasLines) {
        return '`' + arg + '`';
      } else if (hasSingleQuotes && !hasDoubleQuotes) {
        return '"' + arg + '"';
      } else if (!hasSingleQuotes && hasDoubleQuotes) {
        return "'" + arg + "'";
      } else {
        return '\'' + arg + '\'';
      }
    case 'Number': return getEntity(arg);
    case 'Boolean': return getEntity(arg);
    case 'Array':
      return addVariable(arg, `new ${arg.constructor.name}([${Array.from(arg).join(',')}])`);
    case 'Float32Array':
    case 'Uint8Array':
    case 'Uint16Array':
    case 'Int32Array':
      return addVariable(arg, `new ${arg.constructor.name}(${JSON.stringify(Array.from(arg))})`);
    default:
      if (onUnrecognizedArgumentLookup) {
        const instantiationString = onUnrecognizedArgumentLookup(arg);
        if (instantiationString) {
          return instantiationString;
        }
      }
      throw new Error(`unrecognized argument type ${arg.constructor.name}`);
  }
}

function trackablePrimitive(value) {
  return new value.constructor(value);
}

if (typeof module !== 'undefined') {
  module.exports = { glWiretap, glExtensionWiretap };
}

if (typeof window !== 'undefined') {
  glWiretap.glExtensionWiretap = glExtensionWiretap;
  window.glWiretap = glWiretap;
}

},{}],4:[function(require,module,exports){
function setupArguments(args) {
  const newArguments = new Array(args.length);
  for (let i = 0; i < args.length; i++) {
    const arg = args[i];
    if (arg.toArray) {
      newArguments[i] = arg.toArray();
    } else {
      newArguments[i] = arg;
    }
  }
  return newArguments;
}

function mock1D() {
  const args = setupArguments(arguments);
  const row = new Float32Array(this.output.x);
  for (let x = 0; x < this.output.x; x++) {
    this.thread.x = x;
    this.thread.y = 0;
    this.thread.z = 0;
    row[x] = this._fn.apply(this, args);
  }
  return row;
}

function mock2D() {
  const args = setupArguments(arguments);
  const matrix = new Array(this.output.y);
  for (let y = 0; y < this.output.y; y++) {
    const row = new Float32Array(this.output.x);
    for (let x = 0; x < this.output.x; x++) {
      this.thread.x = x;
      this.thread.y = y;
      this.thread.z = 0;
      row[x] = this._fn.apply(this, args);
    }
    matrix[y] = row;
  }
  return matrix;
}

function mock2DGraphical() {
  const args = setupArguments(arguments);
  for (let y = 0; y < this.output.y; y++) {
    for (let x = 0; x < this.output.x; x++) {
      this.thread.x = x;
      this.thread.y = y;
      this.thread.z = 0;
      this._fn.apply(this, args);
    }
  }
}

function mock3D() {
  const args = setupArguments(arguments);
  const cube = new Array(this.output.z);
  for (let z = 0; z < this.output.z; z++) {
    const matrix = new Array(this.output.y);
    for (let y = 0; y < this.output.y; y++) {
      const row = new Float32Array(this.output.x);
      for (let x = 0; x < this.output.x; x++) {
        this.thread.x = x;
        this.thread.y = y;
        this.thread.z = z;
        row[x] = this._fn.apply(this, args);
      }
      matrix[y] = row;
    }
    cube[z] = matrix;
  }
  return cube;
}

function apiDecorate(kernel) {
  kernel.setOutput = (output) => {
    kernel.output = setupOutput(output);
    if (kernel.graphical) {
      setupGraphical(kernel);
    }
  };
  kernel.toJSON = () => {
    throw new Error('Not usable with gpuMock');
  };
  kernel.setConstants = (flag) => {
    kernel.constants = flag;
    return kernel;
  };
  kernel.setGraphical = (flag) => {
    kernel.graphical = flag;
    return kernel;
  };
  kernel.setCanvas = (flag) => {
    kernel.canvas = flag;
    return kernel;
  };
  kernel.setContext = (flag) => {
    kernel.context = flag;
    return kernel;
  };
  kernel.destroy = () => {};
  kernel.validateSettings = () => {};
  if (kernel.graphical && kernel.output) {
    setupGraphical(kernel);
  }
  kernel.exec = function() {
    return new Promise((resolve, reject) => {
      try {
        resolve(kernel.apply(kernel, arguments));
      } catch(e) {
        reject(e);
      }
    });
  };
  kernel.getPixels = (flip) => {
    const {x, y} = kernel.output;
    return flip ? flipPixels(kernel._imageData.data, x, y) : kernel._imageData.data.slice(0);
  };
  kernel.color = function(r, g, b, a) {
    if (typeof a === 'undefined') {
      a = 1;
    }

    r = Math.floor(r * 255);
    g = Math.floor(g * 255);
    b = Math.floor(b * 255);
    a = Math.floor(a * 255);

    const width = kernel.output.x;
    const height = kernel.output.y;

    const x = kernel.thread.x;
    const y = height - kernel.thread.y - 1;

    const index = x + y * width;

    kernel._colorData[index * 4 + 0] = r;
    kernel._colorData[index * 4 + 1] = g;
    kernel._colorData[index * 4 + 2] = b;
    kernel._colorData[index * 4 + 3] = a;
  };

  const mockMethod = () => kernel;
  const methods = [
    'setWarnVarUsage',
    'setArgumentTypes',
    'setTactic',
    'setOptimizeFloatMemory',
    'setDebug',
    'setLoopMaxIterations',
    'setConstantTypes',
    'setFunctions',
    'setNativeFunctions',
    'setInjectedNative',
    'setPipeline',
    'setPrecision',
    'setOutputToTexture',
    'setImmutable',
    'setStrictIntegers',
    'setDynamicOutput',
    'setHardcodeConstants',
    'setDynamicArguments',
    'setUseLegacyEncoder',
    'setWarnVarUsage',
    'addSubKernel',
  ];
  for (let i = 0; i < methods.length; i++) {
    kernel[methods[i]] = mockMethod;
  }
  return kernel;
}

function setupGraphical(kernel) {
  const {x, y} = kernel.output;
  if (kernel.context && kernel.context.createImageData) {
    const data = new Uint8ClampedArray(x * y * 4);
    kernel._imageData = kernel.context.createImageData(x, y);
    kernel._colorData = data;
  } else {
    const data = new Uint8ClampedArray(x * y * 4);
    kernel._imageData = { data };
    kernel._colorData = data;
  }
}

function setupOutput(output) {
  let result = null;
  if (output.length) {
    if (output.length === 3) {
      const [x,y,z] = output;
      result = { x, y, z };
    } else if (output.length === 2) {
      const [x,y] = output;
      result = { x, y };
    } else {
      const [x] = output;
      result = { x };
    }
  } else {
    result = output;
  }
  return result;
}

function gpuMock(fn, settings = {}) {
  const output = settings.output ? setupOutput(settings.output) : null;
  function kernel() {
    if (kernel.output.z) {
      return mock3D.apply(kernel, arguments);
    } else if (kernel.output.y) {
      if (kernel.graphical) {
        return mock2DGraphical.apply(kernel, arguments);
      }
      return mock2D.apply(kernel, arguments);
    } else {
      return mock1D.apply(kernel, arguments);
    }
  }
  kernel._fn = fn;
  kernel.constants = settings.constants || null;
  kernel.context = settings.context || null;
  kernel.canvas = settings.canvas || null;
  kernel.graphical = settings.graphical || false;
  kernel._imageData = null;
  kernel._colorData = null;
  kernel.output = output;
  kernel.thread = {
    x: 0,
    y: 0,
    z: 0
  };
  return apiDecorate(kernel);
}

function flipPixels(pixels, width, height) {
  const halfHeight = height / 2 | 0; 
  const bytesPerRow = width * 4;
  const temp = new Uint8ClampedArray(width * 4);
  const result = pixels.slice(0);
  for (let y = 0; y < halfHeight; ++y) {
    const topOffset = y * bytesPerRow;
    const bottomOffset = (height - y - 1) * bytesPerRow;

    temp.set(result.subarray(topOffset, topOffset + bytesPerRow));

    result.copyWithin(topOffset, bottomOffset, bottomOffset + bytesPerRow);

    result.set(temp, bottomOffset);
  }
  return result;
}

module.exports = {
  gpuMock
};

},{}],5:[function(require,module,exports){
const { utils } = require('./utils');

function alias(name, source) {
  const fnString = source.toString();
  return new Function(`return function ${ name } (${ utils.getArgumentNamesFromString(fnString).join(', ') }) {
  ${ utils.getFunctionBodyFromString(fnString) }
}`)();
}

module.exports = {
  alias
};
},{"./utils":114}],6:[function(require,module,exports){
const { FunctionNode } = require('../function-node');

class CPUFunctionNode extends FunctionNode {
  astFunction(ast, retArr) {

    if (!this.isRootKernel) {
      retArr.push('function');
      retArr.push(' ');
      retArr.push(this.name);
      retArr.push('(');

      for (let i = 0; i < this.argumentNames.length; ++i) {
        const argumentName = this.argumentNames[i];

        if (i > 0) {
          retArr.push(', ');
        }
        retArr.push('user_');
        retArr.push(argumentName);
      }

      retArr.push(') {\n');
    }

    for (let i = 0; i < ast.body.body.length; ++i) {
      this.astGeneric(ast.body.body[i], retArr);
      retArr.push('\n');
    }

    if (!this.isRootKernel) {
      retArr.push('}\n');
    }
    return retArr;
  }

  astReturnStatement(ast, retArr) {
    const type = this.returnType || this.getType(ast.argument);

    if (!this.returnType) {
      this.returnType = type;
    }

    if (this.isRootKernel) {
      retArr.push(this.leadingReturnStatement);
      this.astGeneric(ast.argument, retArr);
      retArr.push(';\n');
      retArr.push(this.followingReturnStatement);
      retArr.push('continue;\n');
    } else if (this.isSubKernel) {
      retArr.push(`subKernelResult_${ this.name } = `);
      this.astGeneric(ast.argument, retArr);
      retArr.push(';');
      retArr.push(`return subKernelResult_${ this.name };`);
    } else {
      retArr.push('return ');
      this.astGeneric(ast.argument, retArr);
      retArr.push(';');
    }
    return retArr;
  }

  astLiteral(ast, retArr) {

    if (isNaN(ast.value)) {
      throw this.astErrorOutput(
        'Non-numeric literal not supported : ' + ast.value,
        ast
      );
    }

    retArr.push(ast.value);

    return retArr;
  }

  astBinaryExpression(ast, retArr) {
    retArr.push('(');
    this.astGeneric(ast.left, retArr);
    retArr.push(ast.operator);
    this.astGeneric(ast.right, retArr);
    retArr.push(')');
    return retArr;
  }

  astIdentifierExpression(idtNode, retArr) {
    if (idtNode.type !== 'Identifier') {
      throw this.astErrorOutput(
        'IdentifierExpression - not an Identifier',
        idtNode
      );
    }

    switch (idtNode.name) {
      case 'Infinity':
        retArr.push('Infinity');
        break;
      default:
        if (this.constants && this.constants.hasOwnProperty(idtNode.name)) {
          retArr.push('constants_' + idtNode.name);
        } else {
          retArr.push('user_' + idtNode.name);
        }
    }

    return retArr;
  }

  astForStatement(forNode, retArr) {
    if (forNode.type !== 'ForStatement') {
      throw this.astErrorOutput('Invalid for statement', forNode);
    }

    const initArr = [];
    const testArr = [];
    const updateArr = [];
    const bodyArr = [];
    let isSafe = null;

    if (forNode.init) {
      this.pushState('in-for-loop-init');
      this.astGeneric(forNode.init, initArr);
      for (let i = 0; i < initArr.length; i++) {
        if (initArr[i].includes && initArr[i].includes(',')) {
          isSafe = false;
        }
      }
      this.popState('in-for-loop-init');
    } else {
      isSafe = false;
    }

    if (forNode.test) {
      this.astGeneric(forNode.test, testArr);
    } else {
      isSafe = false;
    }

    if (forNode.update) {
      this.astGeneric(forNode.update, updateArr);
    } else {
      isSafe = false;
    }

    if (forNode.body) {
      this.pushState('loop-body');
      this.astGeneric(forNode.body, bodyArr);
      this.popState('loop-body');
    }

    if (isSafe === null) {
      isSafe = this.isSafe(forNode.init) && this.isSafe(forNode.test);
    }

    if (isSafe) {
      retArr.push(`for (${initArr.join('')};${testArr.join('')};${updateArr.join('')}){\n`);
      retArr.push(bodyArr.join(''));
      retArr.push('}\n');
    } else {
      const iVariableName = this.getInternalVariableName('safeI');
      if (initArr.length > 0) {
        retArr.push(initArr.join(''), ';\n');
      }
      retArr.push(`for (let ${iVariableName}=0;${iVariableName}<LOOP_MAX;${iVariableName}++){\n`);
      if (testArr.length > 0) {
        retArr.push(`if (!${testArr.join('')}) break;\n`);
      }
      retArr.push(bodyArr.join(''));
      retArr.push(`\n${updateArr.join('')};`);
      retArr.push('}\n');
    }
    return retArr;
  }

  astWhileStatement(whileNode, retArr) {
    if (whileNode.type !== 'WhileStatement') {
      throw this.astErrorOutput(
        'Invalid while statement',
        whileNode
      );
    }

    retArr.push('for (let i = 0; i < LOOP_MAX; i++) {');
    retArr.push('if (');
    this.astGeneric(whileNode.test, retArr);
    retArr.push(') {\n');
    this.astGeneric(whileNode.body, retArr);
    retArr.push('} else {\n');
    retArr.push('break;\n');
    retArr.push('}\n');
    retArr.push('}\n');

    return retArr;
  }

  astDoWhileStatement(doWhileNode, retArr) {
    if (doWhileNode.type !== 'DoWhileStatement') {
      throw this.astErrorOutput(
        'Invalid while statement',
        doWhileNode
      );
    }

    retArr.push('for (let i = 0; i < LOOP_MAX; i++) {');
    this.astGeneric(doWhileNode.body, retArr);
    retArr.push('if (!');
    this.astGeneric(doWhileNode.test, retArr);
    retArr.push(') {\n');
    retArr.push('break;\n');
    retArr.push('}\n');
    retArr.push('}\n');

    return retArr;

  }

  astAssignmentExpression(assNode, retArr) {
    const declaration = this.getDeclaration(assNode.left);
    if (declaration && !declaration.assignable) {
      throw this.astErrorOutput(`Variable ${assNode.left.name} is not assignable here`, assNode);
    }
    this.astGeneric(assNode.left, retArr);
    retArr.push(assNode.operator);
    this.astGeneric(assNode.right, retArr);
    return retArr;
  }

  astBlockStatement(bNode, retArr) {
    if (this.isState('loop-body')) {
      this.pushState('block-body'); 
      for (let i = 0; i < bNode.body.length; i++) {
        this.astGeneric(bNode.body[i], retArr);
      }
      this.popState('block-body');
    } else {
      retArr.push('{\n');
      for (let i = 0; i < bNode.body.length; i++) {
        this.astGeneric(bNode.body[i], retArr);
      }
      retArr.push('}\n');
    }
    return retArr;
  }

  astVariableDeclaration(varDecNode, retArr) {
    retArr.push(`${varDecNode.kind} `);
    const { declarations } = varDecNode;
    for (let i = 0; i < declarations.length; i++) {
      if (i > 0) {
        retArr.push(',');
      }
      const declaration = declarations[i];
      const info = this.getDeclaration(declaration.id);
      if (!info.valueType) {
        info.valueType = this.getType(declaration.init);
      }
      this.astGeneric(declaration, retArr);
    }
    if (!this.isState('in-for-loop-init')) {
      retArr.push(';');
    }
    return retArr;
  }

  astIfStatement(ifNode, retArr) {
    retArr.push('if (');
    this.astGeneric(ifNode.test, retArr);
    retArr.push(')');
    if (ifNode.consequent.type === 'BlockStatement') {
      this.astGeneric(ifNode.consequent, retArr);
    } else {
      retArr.push(' {\n');
      this.astGeneric(ifNode.consequent, retArr);
      retArr.push('\n}\n');
    }

    if (ifNode.alternate) {
      retArr.push('else ');
      if (ifNode.alternate.type === 'BlockStatement' || ifNode.alternate.type === 'IfStatement') {
        this.astGeneric(ifNode.alternate, retArr);
      } else {
        retArr.push(' {\n');
        this.astGeneric(ifNode.alternate, retArr);
        retArr.push('\n}\n');
      }
    }
    return retArr;

  }

  astSwitchStatement(ast, retArr) {
    const { discriminant, cases } = ast;
    retArr.push('switch (');
    this.astGeneric(discriminant, retArr);
    retArr.push(') {\n');
    for (let i = 0; i < cases.length; i++) {
      if (cases[i].test === null) {
        retArr.push('default:\n');
        this.astGeneric(cases[i].consequent, retArr);
        if (cases[i].consequent && cases[i].consequent.length > 0) {
          retArr.push('break;\n');
        }
        continue;
      }
      retArr.push('case ');
      this.astGeneric(cases[i].test, retArr);
      retArr.push(':\n');
      if (cases[i].consequent && cases[i].consequent.length > 0) {
        this.astGeneric(cases[i].consequent, retArr);
        retArr.push('break;\n');
      }
    }
    retArr.push('\n}');
  }

  astThisExpression(tNode, retArr) {
    retArr.push('_this');
    return retArr;
  }

  astMemberExpression(mNode, retArr) {
    const {
      signature,
      type,
      property,
      xProperty,
      yProperty,
      zProperty,
      name,
      origin
    } = this.getMemberExpressionDetails(mNode);
    switch (signature) {
      case 'this.thread.value':
        retArr.push(`_this.thread.${ name }`);
        return retArr;
      case 'this.output.value':
        switch (name) {
          case 'x':
            retArr.push('outputX');
            break;
          case 'y':
            retArr.push('outputY');
            break;
          case 'z':
            retArr.push('outputZ');
            break;
          default:
            throw this.astErrorOutput('Unexpected expression', mNode);
        }
        return retArr;
      case 'value':
        throw this.astErrorOutput('Unexpected expression', mNode);
      case 'value[]':
      case 'value[][]':
      case 'value[][][]':
      case 'value.value':
        if (origin === 'Math') {
          retArr.push(Math[name]);
          return retArr;
        }
        switch (property) {
          case 'r':
            retArr.push(`user_${ name }[0]`);
            return retArr;
          case 'g':
            retArr.push(`user_${ name }[1]`);
            return retArr;
          case 'b':
            retArr.push(`user_${ name }[2]`);
            return retArr;
          case 'a':
            retArr.push(`user_${ name }[3]`);
            return retArr;
        }
        break;
      case 'this.constants.value':
      case 'this.constants.value[]':
      case 'this.constants.value[][]':
      case 'this.constants.value[][][]':
        break;
      case 'fn()[]':
        this.astGeneric(mNode.object, retArr);
        retArr.push('[');
        this.astGeneric(mNode.property, retArr);
        retArr.push(']');
        return retArr;
      case 'fn()[][]':
        this.astGeneric(mNode.object.object, retArr);
        retArr.push('[');
        this.astGeneric(mNode.object.property, retArr);
        retArr.push(']');
        retArr.push('[');
        this.astGeneric(mNode.property, retArr);
        retArr.push(']');
        return retArr;
      default:
        throw this.astErrorOutput('Unexpected expression', mNode);
    }

    if (!mNode.computed) {
      switch (type) {
        case 'Number':
        case 'Integer':
        case 'Float':
        case 'Boolean':
          retArr.push(`${origin}_${name}`);
          return retArr;
      }
    }

    const markupName = `${origin}_${name}`;

    switch (type) {
      case 'Array(2)':
      case 'Array(3)':
      case 'Array(4)':
      case 'Matrix(2)':
      case 'Matrix(3)':
      case 'Matrix(4)':
      case 'HTMLImageArray':
      case 'ArrayTexture(1)':
      case 'ArrayTexture(2)':
      case 'ArrayTexture(3)':
      case 'ArrayTexture(4)':
      case 'HTMLImage':
      default:
        let size;
        let isInput;
        if (origin === 'constants') {
          const constant = this.constants[name];
          isInput = this.constantTypes[name] === 'Input';
          size = isInput ? constant.size : null;
        } else {
          isInput = this.isInput(name);
          size = isInput ? this.argumentSizes[this.argumentNames.indexOf(name)] : null;
        }
        retArr.push(`${ markupName }`);
        if (zProperty && yProperty) {
          if (isInput) {
            retArr.push('[(');
            this.astGeneric(zProperty, retArr);
            retArr.push(`*${ this.dynamicArguments ? '(outputY * outputX)' : size[1] * size[0] })+(`);
            this.astGeneric(yProperty, retArr);
            retArr.push(`*${ this.dynamicArguments ? 'outputX' : size[0] })+`);
            this.astGeneric(xProperty, retArr);
            retArr.push(']');
          } else {
            retArr.push('[');
            this.astGeneric(zProperty, retArr);
            retArr.push(']');
            retArr.push('[');
            this.astGeneric(yProperty, retArr);
            retArr.push(']');
            retArr.push('[');
            this.astGeneric(xProperty, retArr);
            retArr.push(']');
          }
        } else if (yProperty) {
          if (isInput) {
            retArr.push('[(');
            this.astGeneric(yProperty, retArr);
            retArr.push(`*${ this.dynamicArguments ? 'outputX' : size[0] })+`);
            this.astGeneric(xProperty, retArr);
            retArr.push(']');
          } else {
            retArr.push('[');
            this.astGeneric(yProperty, retArr);
            retArr.push(']');
            retArr.push('[');
            this.astGeneric(xProperty, retArr);
            retArr.push(']');
          }
        } else if (typeof xProperty !== 'undefined') {
          retArr.push('[');
          this.astGeneric(xProperty, retArr);
          retArr.push(']');
        }
    }
    return retArr;
  }

  astCallExpression(ast, retArr) {
    if (ast.type !== 'CallExpression') {
      throw this.astErrorOutput('Unknown CallExpression', ast);
    }
    let functionName = this.astMemberExpressionUnroll(ast.callee);

    if (this.calledFunctions.indexOf(functionName) < 0) {
      this.calledFunctions.push(functionName);
    }

    const isMathFunction = this.isAstMathFunction(ast);

    if (this.onFunctionCall) {
      this.onFunctionCall(this.name, functionName, ast.arguments);
    }

    retArr.push(functionName);

    retArr.push('(');
    const targetTypes = this.lookupFunctionArgumentTypes(functionName) || [];
    for (let i = 0; i < ast.arguments.length; ++i) {
      const argument = ast.arguments[i];

      let argumentType = this.getType(argument);
      if (!targetTypes[i]) {
        this.triggerImplyArgumentType(functionName, i, argumentType, this);
      }

      if (i > 0) {
        retArr.push(', ');
      }
      this.astGeneric(argument, retArr);
    }
    retArr.push(')');

    return retArr;
  }

  astArrayExpression(arrNode, retArr) {
    const returnType = this.getType(arrNode);
    const arrLen = arrNode.elements.length;
    const elements = [];
    for (let i = 0; i < arrLen; ++i) {
      const element = [];
      this.astGeneric(arrNode.elements[i], element);
      elements.push(element.join(''));
    }
    switch (returnType) {
      case 'Matrix(2)':
      case 'Matrix(3)':
      case 'Matrix(4)':
        retArr.push(`[${elements.join(', ')}]`);
        break;
      default:
        retArr.push(`new Float32Array([${elements.join(', ')}])`);
    }
    return retArr;
  }

  astDebuggerStatement(arrNode, retArr) {
    retArr.push('debugger;');
    return retArr;
  }
}

module.exports = {
  CPUFunctionNode
};
},{"../function-node":10}],7:[function(require,module,exports){
const { utils } = require('../../utils');

function constantsToString(constants, types) {
  const results = [];
  for (const name in types) {
    if (!types.hasOwnProperty(name)) continue;
    const type = types[name];
    const constant = constants[name];
    switch (type) {
      case 'Number':
      case 'Integer':
      case 'Float':
      case 'Boolean':
        results.push(`${name}:${constant}`);
        break;
      case 'Array(2)':
      case 'Array(3)':
      case 'Array(4)':
      case 'Matrix(2)':
      case 'Matrix(3)':
      case 'Matrix(4)':
        results.push(`${name}:new ${constant.constructor.name}(${JSON.stringify(Array.from(constant))})`);
        break;
    }
  }
  return `{ ${ results.join() } }`;
}

function cpuKernelString(cpuKernel, name) {
  const header = [];
  const thisProperties = [];
  const beforeReturn = [];

  const useFunctionKeyword = !/^function/.test(cpuKernel.color.toString());

  header.push(
    '  const { context, canvas, constants: incomingConstants } = settings;',
    `  const output = new Int32Array(${JSON.stringify(Array.from(cpuKernel.output))});`,
    `  const _constantTypes = ${JSON.stringify(cpuKernel.constantTypes)};`,
    `  const _constants = ${constantsToString(cpuKernel.constants, cpuKernel.constantTypes)};`
  );

  thisProperties.push(
    '    constants: _constants,',
    '    context,',
    '    output,',
    '    thread: {x: 0, y: 0, z: 0},'
  );

  if (cpuKernel.graphical) {
    header.push(`  const _imageData = context.createImageData(${cpuKernel.output[0]}, ${cpuKernel.output[1]});`);
    header.push(`  const _colorData = new Uint8ClampedArray(${cpuKernel.output[0]} * ${cpuKernel.output[1]} * 4);`);

    const colorFn = utils.flattenFunctionToString((useFunctionKeyword ? 'function ' : '') + cpuKernel.color.toString(), {
      thisLookup: (propertyName) => {
        switch (propertyName) {
          case '_colorData':
            return '_colorData';
          case '_imageData':
            return '_imageData';
          case 'output':
            return 'output';
          case 'thread':
            return 'this.thread';
        }
        return JSON.stringify(cpuKernel[propertyName]);
      },
      findDependency: (object, name) => {
        return null;
      }
    });

    const getPixelsFn = utils.flattenFunctionToString((useFunctionKeyword ? 'function ' : '') + cpuKernel.getPixels.toString(), {
      thisLookup: (propertyName) => {
        switch (propertyName) {
          case '_colorData':
            return '_colorData';
          case '_imageData':
            return '_imageData';
          case 'output':
            return 'output';
          case 'thread':
            return 'this.thread';
        }
        return JSON.stringify(cpuKernel[propertyName]);
      },
      findDependency: () => {
        return null;
      }
    });

    thisProperties.push(
      '    _imageData,',
      '    _colorData,',
      `    color: ${colorFn},`
    );

    beforeReturn.push(
      `  kernel.getPixels = ${getPixelsFn};`
    );
  }

  const constantTypes = [];
  const constantKeys = Object.keys(cpuKernel.constantTypes);
  for (let i = 0; i < constantKeys.length; i++) {
    constantTypes.push(cpuKernel.constantTypes[constantKeys]);
  }
  if (cpuKernel.argumentTypes.indexOf('HTMLImageArray') !== -1 || constantTypes.indexOf('HTMLImageArray') !== -1) {
    const flattenedImageTo3DArray = utils.flattenFunctionToString((useFunctionKeyword ? 'function ' : '') + cpuKernel._imageTo3DArray.toString(), {
      doNotDefine: ['canvas'],
      findDependency: (object, name) => {
        if (object === 'this') {
          return (useFunctionKeyword ? 'function ' : '') + cpuKernel[name].toString();
        }
        return null;
      },
      thisLookup: (propertyName) => {
        switch (propertyName) {
          case 'canvas':
            return;
          case 'context':
            return 'context';
        }
      }
    });
    beforeReturn.push(flattenedImageTo3DArray);
    thisProperties.push(`    _mediaTo2DArray,`);
    thisProperties.push(`    _imageTo3DArray,`);
  } else if (cpuKernel.argumentTypes.indexOf('HTMLImage') !== -1 || constantTypes.indexOf('HTMLImage') !== -1) {
    const flattenedImageTo2DArray = utils.flattenFunctionToString((useFunctionKeyword ? 'function ' : '') + cpuKernel._mediaTo2DArray.toString(), {
      findDependency: (object, name) => {
        return null;
      },
      thisLookup: (propertyName) => {
        switch (propertyName) {
          case 'canvas':
            return 'settings.canvas';
          case 'context':
            return 'settings.context';
        }
        throw new Error('unhandled thisLookup');
      }
    });
    beforeReturn.push(flattenedImageTo2DArray);
    thisProperties.push(`    _mediaTo2DArray,`);
  }

  return `function(settings) {
${ header.join('\n') }
  for (const p in _constantTypes) {
    if (!_constantTypes.hasOwnProperty(p)) continue;
    const type = _constantTypes[p];
    switch (type) {
      case 'Number':
      case 'Integer':
      case 'Float':
      case 'Boolean':
      case 'Array(2)':
      case 'Array(3)':
      case 'Array(4)':
      case 'Matrix(2)':
      case 'Matrix(3)':
      case 'Matrix(4)':
        if (incomingConstants.hasOwnProperty(p)) {
          console.warn('constant ' + p + ' of type ' + type + ' cannot be resigned');
        }
        continue;
    }
    if (!incomingConstants.hasOwnProperty(p)) {
      throw new Error('constant ' + p + ' not found');
    }
    _constants[p] = incomingConstants[p];
  }
  const kernel = (function() {
${cpuKernel._kernelString}
  })
    .apply({ ${thisProperties.join('\n')} });
  ${ beforeReturn.join('\n') }
  return kernel;
}`;
}

module.exports = {
  cpuKernelString
};
},{"../../utils":114}],8:[function(require,module,exports){
const { Kernel } = require('../kernel');
const { FunctionBuilder } = require('../function-builder');
const { CPUFunctionNode } = require('./function-node');
const { utils } = require('../../utils');
const { cpuKernelString } = require('./kernel-string');

class CPUKernel extends Kernel {
  static getFeatures() {
    return this.features;
  }
  static get features() {
    return Object.freeze({
      kernelMap: true,
      isIntegerDivisionAccurate: true
    });
  }
  static get isSupported() {
    return true;
  }
  static isContextMatch(context) {
    return false;
  }
  static get mode() {
    return 'cpu';
  }

  static nativeFunctionArguments() {
    return null;
  }

  static nativeFunctionReturnType() {
    throw new Error(`Looking up native function return type not supported on ${this.name}`);
  }

  static combineKernels(combinedKernel) {
    return combinedKernel;
  }

  static getSignature(kernel, argumentTypes) {
    return 'cpu' + (argumentTypes.length > 0 ? ':' + argumentTypes.join(',') : '');
  }

  constructor(source, settings) {
    super(source, settings);
    this.mergeSettings(source.settings || settings);

    this._imageData = null;
    this._colorData = null;
    this._kernelString = null;
    this._prependedString = [];
    this.thread = {
      x: 0,
      y: 0,
      z: 0
    };
    this.translatedSources = null;
  }

  initCanvas() {
    if (typeof document !== 'undefined') {
      return document.createElement('canvas');
    } else if (typeof OffscreenCanvas !== 'undefined') {
      return new OffscreenCanvas(0, 0);
    }
  }

  initContext() {
    if (!this.canvas) return null;
    return this.canvas.getContext('2d');
  }

  initPlugins(settings) {
    return [];
  }

  validateSettings(args) {
    if (!this.output || this.output.length === 0) {
      if (args.length !== 1) {
        throw new Error('Auto output only supported for kernels with only one input');
      }

      const argType = utils.getVariableType(args[0], this.strictIntegers);
      if (argType === 'Array') {
        this.output = utils.getDimensions(argType);
      } else if (argType === 'NumberTexture' || argType === 'ArrayTexture(4)') {
        this.output = args[0].output;
      } else {
        throw new Error('Auto output not supported for input type: ' + argType);
      }
    }

    if (this.graphical) {
      if (this.output.length !== 2) {
        throw new Error('Output must have 2 dimensions on graphical mode');
      }
    }

    this.checkOutput();
  }

  translateSource() {
    this.leadingReturnStatement = this.output.length > 1 ? 'resultX[x] = ' : 'result[x] = ';
    if (this.subKernels) {
      const followingReturnStatement = [];
      for (let i = 0; i < this.subKernels.length; i++) {
        const {
          name
        } = this.subKernels[i];
        followingReturnStatement.push(this.output.length > 1 ? `resultX_${ name }[x] = subKernelResult_${ name };\n` : `result_${ name }[x] = subKernelResult_${ name };\n`);
      }
      this.followingReturnStatement = followingReturnStatement.join('');
    }
    const functionBuilder = FunctionBuilder.fromKernel(this, CPUFunctionNode);
    this.translatedSources = functionBuilder.getPrototypes('kernel');
    if (!this.graphical && !this.returnType) {
      this.returnType = functionBuilder.getKernelResultType();
    }
  }

  build() {
    if (this.built) return;
    this.setupConstants();
    this.setupArguments(arguments);
    this.validateSettings(arguments);
    this.translateSource();

    if (this.graphical) {
      const {
        canvas,
        output
      } = this;
      if (!canvas) {
        throw new Error('no canvas available for using graphical output');
      }
      const width = output[0];
      const height = output[1] || 1;
      canvas.width = width;
      canvas.height = height;
      this._imageData = this.context.createImageData(width, height);
      this._colorData = new Uint8ClampedArray(width * height * 4);
    }

    const kernelString = this.getKernelString();
    this.kernelString = kernelString;

    if (this.debug) {
      console.log('Function output:');
      console.log(kernelString);
    }

    try {
      this.run = new Function([], kernelString).bind(this)();
    } catch (e) {
      console.error('An error occurred compiling the javascript: ', e);
    }
    this.buildSignature(arguments);
    this.built = true;
  }

  color(r, g, b, a) {
    if (typeof a === 'undefined') {
      a = 1;
    }

    r = Math.floor(r * 255);
    g = Math.floor(g * 255);
    b = Math.floor(b * 255);
    a = Math.floor(a * 255);

    const width = this.output[0];
    const height = this.output[1];

    const x = this.thread.x;
    const y = height - this.thread.y - 1;

    const index = x + y * width;

    this._colorData[index * 4 + 0] = r;
    this._colorData[index * 4 + 1] = g;
    this._colorData[index * 4 + 2] = b;
    this._colorData[index * 4 + 3] = a;
  }

  getKernelString() {
    if (this._kernelString !== null) return this._kernelString;

    let kernelThreadString = null;
    let {
      translatedSources
    } = this;
    if (translatedSources.length > 1) {
      translatedSources = translatedSources.filter(fn => {
        if (/^function/.test(fn)) return fn;
        kernelThreadString = fn;
        return false;
      });
    } else {
      kernelThreadString = translatedSources.shift();
    }
    return this._kernelString = `  const LOOP_MAX = ${ this._getLoopMaxString() };
  ${ this.injectedNative || '' }
  const _this = this;
  ${ this._resultKernelHeader() }
  ${ this._processConstants() }
  return (${ this.argumentNames.map(argumentName => 'user_' + argumentName).join(', ') }) => {
    ${ this._prependedString.join('') }
    ${ this._earlyThrows() }
    ${ this._processArguments() }
    ${ this.graphical ? this._graphicalKernelBody(kernelThreadString) : this._resultKernelBody(kernelThreadString) }
    ${ translatedSources.length > 0 ? translatedSources.join('\n') : '' }
  };`;
  }

  toString() {
    return cpuKernelString(this);
  }

  _getLoopMaxString() {
    return (
      this.loopMaxIterations ?
      ` ${ parseInt(this.loopMaxIterations) };` :
      ' 1000;'
    );
  }

  _processConstants() {
    if (!this.constants) return '';

    const result = [];
    for (let p in this.constants) {
      const type = this.constantTypes[p];
      switch (type) {
        case 'HTMLCanvas':
        case 'OffscreenCanvas':
        case 'HTMLImage':
        case 'ImageBitmap':
        case 'ImageData':
        case 'HTMLVideo':
          result.push(`    const constants_${p} = this._mediaTo2DArray(this.constants.${p});\n`);
          break;
        case 'HTMLImageArray':
          result.push(`    const constants_${p} = this._imageTo3DArray(this.constants.${p});\n`);
          break;
        case 'Input':
          result.push(`    const constants_${p} = this.constants.${p}.value;\n`);
          break;
        default:
          result.push(`    const constants_${p} = this.constants.${p};\n`);
      }
    }
    return result.join('');
  }

  _earlyThrows() {
    if (this.graphical) return '';
    if (this.immutable) return '';
    if (!this.pipeline) return '';
    const arrayArguments = [];
    for (let i = 0; i < this.argumentTypes.length; i++) {
      if (this.argumentTypes[i] === 'Array') {
        arrayArguments.push(this.argumentNames[i]);
      }
    }
    if (arrayArguments.length === 0) return '';
    const checks = [];
    for (let i = 0; i < arrayArguments.length; i++) {
      const argumentName = arrayArguments[i];
      const checkSubKernels = this._mapSubKernels(subKernel => `user_${argumentName} === result_${subKernel.name}`).join(' || ');
      checks.push(`user_${argumentName} === result${checkSubKernels ? ` || ${checkSubKernels}` : ''}`);
    }
    return `if (${checks.join(' || ')}) throw new Error('Source and destination arrays are the same.  Use immutable = true');`;
  }

  _processArguments() {
    const result = [];
    for (let i = 0; i < this.argumentTypes.length; i++) {
      const variableName = `user_${this.argumentNames[i]}`;
      switch (this.argumentTypes[i]) {
        case 'HTMLCanvas':
        case 'OffscreenCanvas':
        case 'HTMLImage':
        case 'ImageBitmap':
        case 'ImageData':
        case 'HTMLVideo':
          result.push(`    ${variableName} = this._mediaTo2DArray(${variableName});\n`);
          break;
        case 'HTMLImageArray':
          result.push(`    ${variableName} = this._imageTo3DArray(${variableName});\n`);
          break;
        case 'Input':
          result.push(`    ${variableName} = ${variableName}.value;\n`);
          break;
        case 'ArrayTexture(1)':
        case 'ArrayTexture(2)':
        case 'ArrayTexture(3)':
        case 'ArrayTexture(4)':
        case 'NumberTexture':
        case 'MemoryOptimizedNumberTexture':
          result.push(`
    if (${variableName}.toArray) {
      if (!_this.textureCache) {
        _this.textureCache = [];
        _this.arrayCache = [];
      }
      const textureIndex = _this.textureCache.indexOf(${variableName});
      if (textureIndex !== -1) {
        ${variableName} = _this.arrayCache[textureIndex];
      } else {
        _this.textureCache.push(${variableName});
        ${variableName} = ${variableName}.toArray();
        _this.arrayCache.push(${variableName});
      }
    }`);
          break;
      }
    }
    return result.join('');
  }

  _mediaTo2DArray(media) {
    const canvas = this.canvas;
    const width = media.width > 0 ? media.width : media.videoWidth;
    const height = media.height > 0 ? media.height : media.videoHeight;
    if (canvas.width < width) {
      canvas.width = width;
    }
    if (canvas.height < height) {
      canvas.height = height;
    }
    const ctx = this.context;
    let pixelsData;
    if (media.constructor === ImageData) {
      pixelsData = media.data;
    } else {
      ctx.drawImage(media, 0, 0, width, height);
      pixelsData = ctx.getImageData(0, 0, width, height).data;
    }
    const imageArray = new Array(height);
    let index = 0;
    for (let y = height - 1; y >= 0; y--) {
      const row = imageArray[y] = new Array(width);
      for (let x = 0; x < width; x++) {
        const pixel = new Float32Array(4);
        pixel[0] = pixelsData[index++] / 255; 
        pixel[1] = pixelsData[index++] / 255; 
        pixel[2] = pixelsData[index++] / 255; 
        pixel[3] = pixelsData[index++] / 255; 
        row[x] = pixel;
      }
    }
    return imageArray;
  }

  getPixels(flip) {
    const [width, height] = this.output;
    return flip ? utils.flipPixels(this._imageData.data, width, height) : this._imageData.data.slice(0);
  }

  _imageTo3DArray(images) {
    const imagesArray = new Array(images.length);
    for (let i = 0; i < images.length; i++) {
      imagesArray[i] = this._mediaTo2DArray(images[i]);
    }
    return imagesArray;
  }

  _resultKernelHeader() {
    if (this.graphical) return '';
    if (this.immutable) return '';
    if (!this.pipeline) return '';
    switch (this.output.length) {
      case 1:
        return this._mutableKernel1DResults();
      case 2:
        return this._mutableKernel2DResults();
      case 3:
        return this._mutableKernel3DResults();
    }
  }

  _resultKernelBody(kernelString) {
    switch (this.output.length) {
      case 1:
        return (!this.immutable && this.pipeline ? this._resultMutableKernel1DLoop(kernelString) : this._resultImmutableKernel1DLoop(kernelString)) + this._kernelOutput();
      case 2:
        return (!this.immutable && this.pipeline ? this._resultMutableKernel2DLoop(kernelString) : this._resultImmutableKernel2DLoop(kernelString)) + this._kernelOutput();
      case 3:
        return (!this.immutable && this.pipeline ? this._resultMutableKernel3DLoop(kernelString) : this._resultImmutableKernel3DLoop(kernelString)) + this._kernelOutput();
      default:
        throw new Error('unsupported size kernel');
    }
  }

  _graphicalKernelBody(kernelThreadString) {
    switch (this.output.length) {
      case 2:
        return this._graphicalKernel2DLoop(kernelThreadString) + this._graphicalOutput();
      default:
        throw new Error('unsupported size kernel');
    }
  }

  _graphicalOutput() {
    return `
    this._imageData.data.set(this._colorData);
    this.context.putImageData(this._imageData, 0, 0);
    return;`
  }

  _getKernelResultTypeConstructorString() {
    switch (this.returnType) {
      case 'LiteralInteger':
      case 'Number':
      case 'Integer':
      case 'Float':
        return 'Float32Array';
      case 'Array(2)':
      case 'Array(3)':
      case 'Array(4)':
        return 'Array';
      default:
        if (this.graphical) {
          return 'Float32Array';
        }
        throw new Error(`unhandled returnType ${ this.returnType }`);
    }
  }

  _resultImmutableKernel1DLoop(kernelString) {
    const constructorString = this._getKernelResultTypeConstructorString();
    return `  const outputX = _this.output[0];
    const result = new ${constructorString}(outputX);
    ${ this._mapSubKernels(subKernel => `const result_${ subKernel.name } = new ${constructorString}(outputX);\n`).join('    ') }
    ${ this._mapSubKernels(subKernel => `let subKernelResult_${ subKernel.name };\n`).join('    ') }
    for (let x = 0; x < outputX; x++) {
      this.thread.x = x;
      this.thread.y = 0;
      this.thread.z = 0;
      ${ kernelString }
    }`;
  }

  _mutableKernel1DResults() {
    const constructorString = this._getKernelResultTypeConstructorString();
    return `  const outputX = _this.output[0];
    const result = new ${constructorString}(outputX);
    ${ this._mapSubKernels(subKernel => `const result_${ subKernel.name } = new ${constructorString}(outputX);\n`).join('    ') }
    ${ this._mapSubKernels(subKernel => `let subKernelResult_${ subKernel.name };\n`).join('    ') }`;
  }

  _resultMutableKernel1DLoop(kernelString) {
    return `  const outputX = _this.output[0];
    for (let x = 0; x < outputX; x++) {
      this.thread.x = x;
      this.thread.y = 0;
      this.thread.z = 0;
      ${ kernelString }
    }`;
  }

  _resultImmutableKernel2DLoop(kernelString) {
    const constructorString = this._getKernelResultTypeConstructorString();
    return `  const outputX = _this.output[0];
    const outputY = _this.output[1];
    const result = new Array(outputY);
    ${ this._mapSubKernels(subKernel => `const result_${ subKernel.name } = new Array(outputY);\n`).join('    ') }
    ${ this._mapSubKernels(subKernel => `let subKernelResult_${ subKernel.name };\n`).join('    ') }
    for (let y = 0; y < outputY; y++) {
      this.thread.z = 0;
      this.thread.y = y;
      const resultX = result[y] = new ${constructorString}(outputX);
      ${ this._mapSubKernels(subKernel => `const resultX_${ subKernel.name } = result_${subKernel.name}[y] = new ${constructorString}(outputX);\n`).join('') }
      for (let x = 0; x < outputX; x++) {
        this.thread.x = x;
        ${ kernelString }
      }
    }`;
  }

  _mutableKernel2DResults() {
    const constructorString = this._getKernelResultTypeConstructorString();
    return `  const outputX = _this.output[0];
    const outputY = _this.output[1];
    const result = new Array(outputY);
    ${ this._mapSubKernels(subKernel => `const result_${ subKernel.name } = new Array(outputY);\n`).join('    ') }
    ${ this._mapSubKernels(subKernel => `let subKernelResult_${ subKernel.name };\n`).join('    ') }
    for (let y = 0; y < outputY; y++) {
      const resultX = result[y] = new ${constructorString}(outputX);
      ${ this._mapSubKernels(subKernel => `const resultX_${ subKernel.name } = result_${subKernel.name}[y] = new ${constructorString}(outputX);\n`).join('') }
    }`;
  }

  _resultMutableKernel2DLoop(kernelString) {
    const constructorString = this._getKernelResultTypeConstructorString();
    return `  const outputX = _this.output[0];
    const outputY = _this.output[1];
    for (let y = 0; y < outputY; y++) {
      this.thread.z = 0;
      this.thread.y = y;
      const resultX = result[y];
      ${ this._mapSubKernels(subKernel => `const resultX_${ subKernel.name } = result_${subKernel.name}[y] = new ${constructorString}(outputX);\n`).join('') }
      for (let x = 0; x < outputX; x++) {
        this.thread.x = x;
        ${ kernelString }
      }
    }`;
  }

  _graphicalKernel2DLoop(kernelString) {
    return `  const outputX = _this.output[0];
    const outputY = _this.output[1];
    for (let y = 0; y < outputY; y++) {
      this.thread.z = 0;
      this.thread.y = y;
      for (let x = 0; x < outputX; x++) {
        this.thread.x = x;
        ${ kernelString }
      }
    }`;
  }

  _resultImmutableKernel3DLoop(kernelString) {
    const constructorString = this._getKernelResultTypeConstructorString();
    return `  const outputX = _this.output[0];
    const outputY = _this.output[1];
    const outputZ = _this.output[2];
    const result = new Array(outputZ);
    ${ this._mapSubKernels(subKernel => `const result_${ subKernel.name } = new Array(outputZ);\n`).join('    ') }
    ${ this._mapSubKernels(subKernel => `let subKernelResult_${ subKernel.name };\n`).join('    ') }
    for (let z = 0; z < outputZ; z++) {
      this.thread.z = z;
      const resultY = result[z] = new Array(outputY);
      ${ this._mapSubKernels(subKernel => `const resultY_${ subKernel.name } = result_${subKernel.name}[z] = new Array(outputY);\n`).join('      ') }
      for (let y = 0; y < outputY; y++) {
        this.thread.y = y;
        const resultX = resultY[y] = new ${constructorString}(outputX);
        ${ this._mapSubKernels(subKernel => `const resultX_${ subKernel.name } = resultY_${subKernel.name}[y] = new ${constructorString}(outputX);\n`).join('        ') }
        for (let x = 0; x < outputX; x++) {
          this.thread.x = x;
          ${ kernelString }
        }
      }
    }`;
  }

  _mutableKernel3DResults() {
    const constructorString = this._getKernelResultTypeConstructorString();
    return `  const outputX = _this.output[0];
    const outputY = _this.output[1];
    const outputZ = _this.output[2];
    const result = new Array(outputZ);
    ${ this._mapSubKernels(subKernel => `const result_${ subKernel.name } = new Array(outputZ);\n`).join('    ') }
    ${ this._mapSubKernels(subKernel => `let subKernelResult_${ subKernel.name };\n`).join('    ') }
    for (let z = 0; z < outputZ; z++) {
      const resultY = result[z] = new Array(outputY);
      ${ this._mapSubKernels(subKernel => `const resultY_${ subKernel.name } = result_${subKernel.name}[z] = new Array(outputY);\n`).join('      ') }
      for (let y = 0; y < outputY; y++) {
        const resultX = resultY[y] = new ${constructorString}(outputX);
        ${ this._mapSubKernels(subKernel => `const resultX_${ subKernel.name } = resultY_${subKernel.name}[y] = new ${constructorString}(outputX);\n`).join('        ') }
      }
    }`;
  }

  _resultMutableKernel3DLoop(kernelString) {
    return `  const outputX = _this.output[0];
    const outputY = _this.output[1];
    const outputZ = _this.output[2];
    for (let z = 0; z < outputZ; z++) {
      this.thread.z = z;
      const resultY = result[z];
      for (let y = 0; y < outputY; y++) {
        this.thread.y = y;
        const resultX = resultY[y];
        for (let x = 0; x < outputX; x++) {
          this.thread.x = x;
          ${ kernelString }
        }
      }
    }`;
  }

  _kernelOutput() {
    if (!this.subKernels) {
      return '\n    return result;';
    }
    return `\n    return {
      result: result,
      ${ this.subKernels.map(subKernel => `${ subKernel.property }: result_${ subKernel.name }`).join(',\n      ') }
    };`;
  }

  _mapSubKernels(fn) {
    return this.subKernels === null ? [''] :
      this.subKernels.map(fn);
  }

  destroy(removeCanvasReference) {
    if (removeCanvasReference) {
      delete this.canvas;
    }
  }

  static destroyContext(context) {}

  toJSON() {
    const json = super.toJSON();
    json.functionNodes = FunctionBuilder.fromKernel(this, CPUFunctionNode).toJSON();
    return json;
  }

  setOutput(output) {
    super.setOutput(output);
    const [width, height] = this.output;
    if (this.graphical) {
      this._imageData = this.context.createImageData(width, height);
      this._colorData = new Uint8ClampedArray(width * height * 4);
    }
  }

  prependString(value) {
    if (this._kernelString) throw new Error('Kernel already built');
    this._prependedString.push(value);
  }

  hasPrependString(value) {
    return this._prependedString.indexOf(value) > -1;
  }
}

module.exports = {
  CPUKernel
};
},{"../../utils":114,"../function-builder":9,"../kernel":36,"./function-node":6,"./kernel-string":7}],9:[function(require,module,exports){
class FunctionBuilder {
  static fromKernel(kernel, FunctionNode, extraNodeOptions) {
    const {
      kernelArguments,
      kernelConstants,
      argumentNames,
      argumentSizes,
      argumentBitRatios,
      constants,
      constantBitRatios,
      debug,
      loopMaxIterations,
      nativeFunctions,
      output,
      optimizeFloatMemory,
      precision,
      plugins,
      source,
      subKernels,
      functions,
      leadingReturnStatement,
      followingReturnStatement,
      dynamicArguments,
      dynamicOutput,
    } = kernel;

    const argumentTypes = new Array(kernelArguments.length);
    const constantTypes = {};

    for (let i = 0; i < kernelArguments.length; i++) {
      argumentTypes[i] = kernelArguments[i].type;
    }

    for (let i = 0; i < kernelConstants.length; i++) {
      const kernelConstant = kernelConstants[i];
      constantTypes[kernelConstant.name] = kernelConstant.type;
    }

    const needsArgumentType = (functionName, index) => {
      return functionBuilder.needsArgumentType(functionName, index);
    };

    const assignArgumentType = (functionName, index, type) => {
      functionBuilder.assignArgumentType(functionName, index, type);
    };

    const lookupReturnType = (functionName, ast, requestingNode) => {
      return functionBuilder.lookupReturnType(functionName, ast, requestingNode);
    };

    const lookupFunctionArgumentTypes = (functionName) => {
      return functionBuilder.lookupFunctionArgumentTypes(functionName);
    };

    const lookupFunctionArgumentName = (functionName, argumentIndex) => {
      return functionBuilder.lookupFunctionArgumentName(functionName, argumentIndex);
    };

    const lookupFunctionArgumentBitRatio = (functionName, argumentName) => {
      return functionBuilder.lookupFunctionArgumentBitRatio(functionName, argumentName);
    };

    const triggerImplyArgumentType = (functionName, i, argumentType, requestingNode) => {
      functionBuilder.assignArgumentType(functionName, i, argumentType, requestingNode);
    };

    const triggerImplyArgumentBitRatio = (functionName, argumentName, calleeFunctionName, argumentIndex) => {
      functionBuilder.assignArgumentBitRatio(functionName, argumentName, calleeFunctionName, argumentIndex);
    };

    const onFunctionCall = (functionName, calleeFunctionName, args) => {
      functionBuilder.trackFunctionCall(functionName, calleeFunctionName, args);
    };

    const onNestedFunction = (ast, source) => {
      const argumentNames = [];
      for (let i = 0; i < ast.params.length; i++) {
        argumentNames.push(ast.params[i].name);
      }
      const nestedFunction = new FunctionNode(source, Object.assign({}, nodeOptions, {
        returnType: null,
        ast,
        name: ast.id.name,
        argumentNames,
        lookupReturnType,
        lookupFunctionArgumentTypes,
        lookupFunctionArgumentName,
        lookupFunctionArgumentBitRatio,
        needsArgumentType,
        assignArgumentType,
        triggerImplyArgumentType,
        triggerImplyArgumentBitRatio,
        onFunctionCall,
      }));
      nestedFunction.traceFunctionAST(ast);
      functionBuilder.addFunctionNode(nestedFunction);
    };

    const nodeOptions = Object.assign({
      isRootKernel: false,
      onNestedFunction,
      lookupReturnType,
      lookupFunctionArgumentTypes,
      lookupFunctionArgumentName,
      lookupFunctionArgumentBitRatio,
      needsArgumentType,
      assignArgumentType,
      triggerImplyArgumentType,
      triggerImplyArgumentBitRatio,
      onFunctionCall,
      optimizeFloatMemory,
      precision,
      constants,
      constantTypes,
      constantBitRatios,
      debug,
      loopMaxIterations,
      output,
      plugins,
      dynamicArguments,
      dynamicOutput,
    }, extraNodeOptions || {});

    const rootNodeOptions = Object.assign({}, nodeOptions, {
      isRootKernel: true,
      name: 'kernel',
      argumentNames,
      argumentTypes,
      argumentSizes,
      argumentBitRatios,
      leadingReturnStatement,
      followingReturnStatement,
    });

    if (typeof source === 'object' && source.functionNodes) {
      return new FunctionBuilder().fromJSON(source.functionNodes, FunctionNode);
    }

    const rootNode = new FunctionNode(source, rootNodeOptions);

    let functionNodes = null;
    if (functions) {
      functionNodes = functions.map((fn) => new FunctionNode(fn.source, {
        returnType: fn.returnType,
        argumentTypes: fn.argumentTypes,
        output,
        plugins,
        constants,
        constantTypes,
        constantBitRatios,
        optimizeFloatMemory,
        precision,
        lookupReturnType,
        lookupFunctionArgumentTypes,
        lookupFunctionArgumentName,
        lookupFunctionArgumentBitRatio,
        needsArgumentType,
        assignArgumentType,
        triggerImplyArgumentType,
        triggerImplyArgumentBitRatio,
        onFunctionCall,
        onNestedFunction,
      }));
    }

    let subKernelNodes = null;
    if (subKernels) {
      subKernelNodes = subKernels.map((subKernel) => {
        const { name, source } = subKernel;
        return new FunctionNode(source, Object.assign({}, nodeOptions, {
          name,
          isSubKernel: true,
          isRootKernel: false,
        }));
      });
    }

    const functionBuilder = new FunctionBuilder({
      kernel,
      rootNode,
      functionNodes,
      nativeFunctions,
      subKernelNodes
    });

    return functionBuilder;
  }

  constructor(settings) {
    settings = settings || {};
    this.kernel = settings.kernel;
    this.rootNode = settings.rootNode;
    this.functionNodes = settings.functionNodes || [];
    this.subKernelNodes = settings.subKernelNodes || [];
    this.nativeFunctions = settings.nativeFunctions || [];
    this.functionMap = {};
    this.nativeFunctionNames = [];
    this.lookupChain = [];
    this.functionNodeDependencies = {};
    this.functionCalls = {};

    if (this.rootNode) {
      this.functionMap['kernel'] = this.rootNode;
    }

    if (this.functionNodes) {
      for (let i = 0; i < this.functionNodes.length; i++) {
        this.functionMap[this.functionNodes[i].name] = this.functionNodes[i];
      }
    }

    if (this.subKernelNodes) {
      for (let i = 0; i < this.subKernelNodes.length; i++) {
        this.functionMap[this.subKernelNodes[i].name] = this.subKernelNodes[i];
      }
    }

    if (this.nativeFunctions) {
      for (let i = 0; i < this.nativeFunctions.length; i++) {
        const nativeFunction = this.nativeFunctions[i];
        this.nativeFunctionNames.push(nativeFunction.name);
      }
    }
  }

  addFunctionNode(functionNode) {
    if (!functionNode.name) throw new Error('functionNode.name needs set');
    this.functionMap[functionNode.name] = functionNode;
    if (functionNode.isRootKernel) {
      this.rootNode = functionNode;
    }
  }

  traceFunctionCalls(functionName, retList) {
    functionName = functionName || 'kernel';
    retList = retList || [];

    if (this.nativeFunctionNames.indexOf(functionName) > -1) {
      const nativeFunctionIndex = retList.indexOf(functionName);
      if (nativeFunctionIndex === -1) {
        retList.push(functionName);
      } else {
        const dependantNativeFunctionName = retList.splice(nativeFunctionIndex, 1)[0];
        retList.push(dependantNativeFunctionName);
      }
      return retList;
    }

    const functionNode = this.functionMap[functionName];
    if (functionNode) {
      const functionIndex = retList.indexOf(functionName);
      if (functionIndex === -1) {
        retList.push(functionName);
        functionNode.toString(); 
        for (let i = 0; i < functionNode.calledFunctions.length; ++i) {
          this.traceFunctionCalls(functionNode.calledFunctions[i], retList);
        }
      } else {
        const dependantFunctionName = retList.splice(functionIndex, 1)[0];
        retList.push(dependantFunctionName);
      }
    }

    return retList;
  }

  getPrototypeString(functionName) {
    return this.getPrototypes(functionName).join('\n');
  }

  getPrototypes(functionName) {
    if (this.rootNode) {
      this.rootNode.toString();
    }
    if (functionName) {
      return this.getPrototypesFromFunctionNames(this.traceFunctionCalls(functionName, []).reverse());
    }
    return this.getPrototypesFromFunctionNames(Object.keys(this.functionMap));
  }

  getStringFromFunctionNames(functionList) {
    const ret = [];
    for (let i = 0; i < functionList.length; ++i) {
      const node = this.functionMap[functionList[i]];
      if (node) {
        ret.push(this.functionMap[functionList[i]].toString());
      }
    }
    return ret.join('\n');
  }

  getPrototypesFromFunctionNames(functionList) {
    const ret = [];
    for (let i = 0; i < functionList.length; ++i) {
      const functionName = functionList[i];
      const functionIndex = this.nativeFunctionNames.indexOf(functionName);
      if (functionIndex > -1) {
        ret.push(this.nativeFunctions[functionIndex].source);
        continue;
      }
      const node = this.functionMap[functionName];
      if (node) {
        ret.push(node.toString());
      }
    }
    return ret;
  }

  toJSON() {
    return this.traceFunctionCalls(this.rootNode.name).reverse().map(name => {
      const nativeIndex = this.nativeFunctions.indexOf(name);
      if (nativeIndex > -1) {
        return {
          name,
          source: this.nativeFunctions[nativeIndex].source
        };
      } else if (this.functionMap[name]) {
        return this.functionMap[name].toJSON();
      } else {
        throw new Error(`function ${ name } not found`);
      }
    });
  }

  fromJSON(jsonFunctionNodes, FunctionNode) {
    this.functionMap = {};
    for (let i = 0; i < jsonFunctionNodes.length; i++) {
      const jsonFunctionNode = jsonFunctionNodes[i];
      this.functionMap[jsonFunctionNode.settings.name] = new FunctionNode(jsonFunctionNode.ast, jsonFunctionNode.settings);
    }
    return this;
  }

  getString(functionName) {
    if (functionName) {
      return this.getStringFromFunctionNames(this.traceFunctionCalls(functionName).reverse());
    }
    return this.getStringFromFunctionNames(Object.keys(this.functionMap));
  }

  lookupReturnType(functionName, ast, requestingNode) {
    if (ast.type !== 'CallExpression') {
      throw new Error(`expected ast type of "CallExpression", but is ${ ast.type }`);
    }
    if (this._isNativeFunction(functionName)) {
      return this._lookupNativeFunctionReturnType(functionName);
    } else if (this._isFunction(functionName)) {
      const node = this._getFunction(functionName);
      if (node.returnType) {
        return node.returnType;
      } else {
        for (let i = 0; i < this.lookupChain.length; i++) {
          if (this.lookupChain[i].ast === ast) {
            if (node.argumentTypes.length === 0 && ast.arguments.length > 0) {
              const args = ast.arguments;
              for (let j = 0; j < args.length; j++) {
                this.lookupChain.push({
                  name: requestingNode.name,
                  ast: args[i],
                  requestingNode
                });
                node.argumentTypes[j] = requestingNode.getType(args[j]);
                this.lookupChain.pop();
              }
              return node.returnType = node.getType(node.getJsAST());
            }

            throw new Error('circlical logic detected!');
          }
        }
        this.lookupChain.push({
          name: requestingNode.name,
          ast,
          requestingNode
        });
        const type = node.getType(node.getJsAST());
        this.lookupChain.pop();
        return node.returnType = type;
      }
    }

    return null;
  }

  _getFunction(functionName) {
    if (!this._isFunction(functionName)) {
      new Error(`Function ${functionName} not found`);
    }
    return this.functionMap[functionName];
  }

  _isFunction(functionName) {
    return Boolean(this.functionMap[functionName]);
  }

  _getNativeFunction(functionName) {
    for (let i = 0; i < this.nativeFunctions.length; i++) {
      if (this.nativeFunctions[i].name === functionName) return this.nativeFunctions[i];
    }
    return null;
  }

  _isNativeFunction(functionName) {
    return Boolean(this._getNativeFunction(functionName));
  }

  _lookupNativeFunctionReturnType(functionName) {
    let nativeFunction = this._getNativeFunction(functionName);
    if (nativeFunction) {
      return nativeFunction.returnType;
    }
    throw new Error(`Native function ${ functionName } not found`);
  }

  lookupFunctionArgumentTypes(functionName) {
    if (this._isNativeFunction(functionName)) {
      return this._getNativeFunction(functionName).argumentTypes;
    } else if (this._isFunction(functionName)) {
      return this._getFunction(functionName).argumentTypes;
    }
    return null;
  }

  lookupFunctionArgumentName(functionName, argumentIndex) {
    return this._getFunction(functionName).argumentNames[argumentIndex];
  }

  lookupFunctionArgumentBitRatio(functionName, argumentName) {
    if (!this._isFunction(functionName)) {
      throw new Error('function not found');
    }
    if (this.rootNode.name === functionName) {
      const i = this.rootNode.argumentNames.indexOf(argumentName);
      if (i !== -1) {
        return this.rootNode.argumentBitRatios[i];
      }
    }
    const node = this._getFunction(functionName);
    const i = node.argumentNames.indexOf(argumentName);
    if (i === -1) {
      throw new Error('argument not found');
    }
    const bitRatio = node.argumentBitRatios[i];
    if (typeof bitRatio !== 'number') {
      throw new Error('argument bit ratio not found');
    }
    return bitRatio;
  }

  needsArgumentType(functionName, i) {
    if (!this._isFunction(functionName)) return false;
    const fnNode = this._getFunction(functionName);
    return !fnNode.argumentTypes[i];
  }

  assignArgumentType(functionName, i, argumentType, requestingNode) {
    if (!this._isFunction(functionName)) return;
    const fnNode = this._getFunction(functionName);
    if (!fnNode.argumentTypes[i]) {
      fnNode.argumentTypes[i] = argumentType;
    }
  }

  assignArgumentBitRatio(functionName, argumentName, calleeFunctionName, argumentIndex) {
    const node = this._getFunction(functionName);
    if (this._isNativeFunction(calleeFunctionName)) return null;
    const calleeNode = this._getFunction(calleeFunctionName);
    const i = node.argumentNames.indexOf(argumentName);
    if (i === -1) {
      throw new Error(`Argument ${argumentName} not found in arguments from function ${functionName}`);
    }
    const bitRatio = node.argumentBitRatios[i];
    if (typeof bitRatio !== 'number') {
      throw new Error(`Bit ratio for argument ${argumentName} not found in function ${functionName}`);
    }
    if (!calleeNode.argumentBitRatios) {
      calleeNode.argumentBitRatios = new Array(calleeNode.argumentNames.length);
    }
    const calleeBitRatio = calleeNode.argumentBitRatios[i];
    if (typeof calleeBitRatio === 'number') {
      if (calleeBitRatio !== bitRatio) {
        throw new Error(`Incompatible bit ratio found at function ${functionName} at argument ${argumentName}`);
      }
      return calleeBitRatio;
    }
    calleeNode.argumentBitRatios[i] = bitRatio;
    return bitRatio;
  }

  trackFunctionCall(functionName, calleeFunctionName, args) {
    if (!this.functionNodeDependencies[functionName]) {
      this.functionNodeDependencies[functionName] = new Set();
      this.functionCalls[functionName] = [];
    }
    this.functionNodeDependencies[functionName].add(calleeFunctionName);
    this.functionCalls[functionName].push(args);
  }

  getKernelResultType() {
    return this.rootNode.returnType || this.rootNode.getType(this.rootNode.ast);
  }

  getSubKernelResultType(index) {
    const subKernelNode = this.subKernelNodes[index];
    let called = false;
    for (let functionCallIndex = 0; functionCallIndex < this.rootNode.functionCalls.length; functionCallIndex++) {
      const functionCall = this.rootNode.functionCalls[functionCallIndex];
      if (functionCall.ast.callee.name === subKernelNode.name) {
        called = true;
      }
    }
    if (!called) {
      throw new Error(`SubKernel ${ subKernelNode.name } never called by kernel`);
    }
    return subKernelNode.returnType || subKernelNode.getType(subKernelNode.getJsAST());
  }

  getReturnTypes() {
    const result = {
      [this.rootNode.name]: this.rootNode.getType(this.rootNode.ast),
    };
    const list = this.traceFunctionCalls(this.rootNode.name);
    for (let i = 0; i < list.length; i++) {
      const functionName = list[i];
      const functionNode = this.functionMap[functionName];
      result[functionName] = functionNode.getType(functionNode.ast);
    }
    return result;
  }
}

module.exports = {
  FunctionBuilder
};
},{}],10:[function(require,module,exports){
const acorn = require('acorn');
const { utils } = require('../utils');
const { FunctionTracer } = require('./function-tracer');

class FunctionNode {
  constructor(source, settings) {
    if (!source && !settings.ast) {
      throw new Error('source parameter is missing');
    }
    settings = settings || {};
    this.source = source;
    this.ast = null;
    this.name = typeof source === 'string' ? settings.isRootKernel ?
      'kernel' :
      (settings.name || utils.getFunctionNameFromString(source)) : null;
    this.calledFunctions = [];
    this.constants = {};
    this.constantTypes = {};
    this.constantBitRatios = {};
    this.isRootKernel = false;
    this.isSubKernel = false;
    this.debug = null;
    this.functions = null;
    this.identifiers = null;
    this.contexts = null;
    this.functionCalls = null;
    this.states = [];
    this.needsArgumentType = null;
    this.assignArgumentType = null;
    this.lookupReturnType = null;
    this.lookupFunctionArgumentTypes = null;
    this.lookupFunctionArgumentBitRatio = null;
    this.triggerImplyArgumentType = null;
    this.triggerImplyArgumentBitRatio = null;
    this.onNestedFunction = null;
    this.onFunctionCall = null;
    this.optimizeFloatMemory = null;
    this.precision = null;
    this.loopMaxIterations = null;
    this.argumentNames = (typeof this.source === 'string' ? utils.getArgumentNamesFromString(this.source) : null);
    this.argumentTypes = [];
    this.argumentSizes = [];
    this.argumentBitRatios = null;
    this.returnType = null;
    this.output = [];
    this.plugins = null;
    this.leadingReturnStatement = null;
    this.followingReturnStatement = null;
    this.dynamicOutput = null;
    this.dynamicArguments = null;
    this.strictTypingChecking = false;
    this.fixIntegerDivisionAccuracy = null;

    if (settings) {
      for (const p in settings) {
        if (!settings.hasOwnProperty(p)) continue;
        if (!this.hasOwnProperty(p)) continue;
        this[p] = settings[p];
      }
    }

    this.literalTypes = {};

    this.validate();
    this._string = null;
    this._internalVariableNames = {};
  }

  validate() {
    if (typeof this.source !== 'string' && !this.ast) {
      throw new Error('this.source not a string');
    }

    if (!this.ast && !utils.isFunctionString(this.source)) {
      throw new Error('this.source not a function string');
    }

    if (!this.name) {
      throw new Error('this.name could not be set');
    }

    if (this.argumentTypes.length > 0 && this.argumentTypes.length !== this.argumentNames.length) {
      throw new Error(`argumentTypes count of ${ this.argumentTypes.length } exceeds ${ this.argumentNames.length }`);
    }

    if (this.output.length < 1) {
      throw new Error('this.output is not big enough');
    }
  }

  isIdentifierConstant(name) {
    if (!this.constants) return false;
    return this.constants.hasOwnProperty(name);
  }

  isInput(argumentName) {
    return this.argumentTypes[this.argumentNames.indexOf(argumentName)] === 'Input';
  }

  pushState(state) {
    this.states.push(state);
  }

  popState(state) {
    if (this.state !== state) {
      throw new Error(`Cannot popState ${ state } when in ${ this.state }`);
    }
    this.states.pop();
  }

  isState(state) {
    return this.state === state;
  }

  get state() {
    return this.states[this.states.length - 1];
  }

  astMemberExpressionUnroll(ast) {
    if (ast.type === 'Identifier') {
      return ast.name;
    } else if (ast.type === 'ThisExpression') {
      return 'this';
    }

    if (ast.type === 'MemberExpression') {
      if (ast.object && ast.property) {
        if (ast.object.hasOwnProperty('name') && ast.object.name !== 'Math') {
          return this.astMemberExpressionUnroll(ast.property);
        }

        return (
          this.astMemberExpressionUnroll(ast.object) +
          '.' +
          this.astMemberExpressionUnroll(ast.property)
        );
      }
    }

    if (ast.hasOwnProperty('expressions')) {
      const firstExpression = ast.expressions[0];
      if (firstExpression.type === 'Literal' && firstExpression.value === 0 && ast.expressions.length === 2) {
        return this.astMemberExpressionUnroll(ast.expressions[1]);
      }
    }

    throw this.astErrorOutput('Unknown astMemberExpressionUnroll', ast);
  }

  getJsAST(inParser) {
    if (this.ast) {
      return this.ast;
    }
    if (typeof this.source === 'object') {
      this.traceFunctionAST(this.source);
      return this.ast = this.source;
    }

    inParser = inParser || acorn;
    if (inParser === null) {
      throw new Error('Missing JS to AST parser');
    }

    const ast = Object.freeze(inParser.parse(`const parser_${ this.name } = ${ this.source };`, {
      locations: true
    }));
    const functionAST = ast.body[0].declarations[0].init;
    this.traceFunctionAST(functionAST);

    if (!ast) {
      throw new Error('Failed to parse JS code');
    }

    return this.ast = functionAST;
  }

  traceFunctionAST(ast) {
    const { contexts, declarations, functions, identifiers, functionCalls } = new FunctionTracer(ast);
    this.contexts = contexts;
    this.identifiers = identifiers;
    this.functionCalls = functionCalls;
    this.functions = functions;
    for (let i = 0; i < declarations.length; i++) {
      const declaration = declarations[i];
      const { ast, inForLoopInit, inForLoopTest } = declaration;
      const { init } = ast;
      const dependencies = this.getDependencies(init);
      let valueType = null;

      if (inForLoopInit && inForLoopTest) {
        valueType = 'Integer';
      } else {
        if (init) {
          const realType = this.getType(init);
          switch (realType) {
            case 'Integer':
            case 'Float':
            case 'Number':
              if (init.type === 'MemberExpression') {
                valueType = realType;
              } else {
                valueType = 'Number';
              }
              break;
            case 'LiteralInteger':
              valueType = 'Number';
              break;
            default:
              valueType = realType;
          }
        }
      }
      declaration.valueType = valueType;
      declaration.dependencies = dependencies;
      declaration.isSafe = this.isSafeDependencies(dependencies);
    }

    for (let i = 0; i < functions.length; i++) {
      this.onNestedFunction(functions[i], this.source);
    }
  }

  getDeclaration(ast) {
    for (let i = 0; i < this.identifiers.length; i++) {
      const identifier = this.identifiers[i];
      if (ast === identifier.ast) {
        return identifier.declaration;
      }
    }
    return null;
  }

  getVariableType(ast) {
    if (ast.type !== 'Identifier') {
      throw new Error(`ast of ${ast.type} not "Identifier"`);
    }
    let type = null;
    const argumentIndex = this.argumentNames.indexOf(ast.name);
    if (argumentIndex === -1) {
      const declaration = this.getDeclaration(ast);
      if (declaration) {
        return declaration.valueType;
      }
    } else {
      const argumentType = this.argumentTypes[argumentIndex];
      if (argumentType) {
        type = argumentType;
      }
    }
    if (!type && this.strictTypingChecking) {
      throw new Error(`Declaration of ${name} not found`);
    }
    return type;
  }

  getLookupType(type) {
    if (!typeLookupMap.hasOwnProperty(type)) {
      throw new Error(`unknown typeLookupMap ${ type }`);
    }
    return typeLookupMap[type];
  }

  getConstantType(constantName) {
    if (this.constantTypes[constantName]) {
      const type = this.constantTypes[constantName];
      if (type === 'Float') {
        return 'Number';
      } else {
        return type;
      }
    }
    throw new Error(`Type for constant "${ constantName }" not declared`);
  }

  toString() {
    if (this._string) return this._string;
    return this._string = this.astGeneric(this.getJsAST(), []).join('').trim();
  }

  toJSON() {
    const settings = {
      source: this.source,
      name: this.name,
      constants: this.constants,
      constantTypes: this.constantTypes,
      isRootKernel: this.isRootKernel,
      isSubKernel: this.isSubKernel,
      debug: this.debug,
      output: this.output,
      loopMaxIterations: this.loopMaxIterations,
      argumentNames: this.argumentNames,
      argumentTypes: this.argumentTypes,
      argumentSizes: this.argumentSizes,
      returnType: this.returnType,
      leadingReturnStatement: this.leadingReturnStatement,
      followingReturnStatement: this.followingReturnStatement,
    };

    return {
      ast: this.ast,
      settings
    };
  }

  getType(ast) {
    if (Array.isArray(ast)) {
      return this.getType(ast[ast.length - 1]);
    }
    switch (ast.type) {
      case 'BlockStatement':
        return this.getType(ast.body);
      case 'ArrayExpression':
        const childType = this.getType(ast.elements[0]);
        switch (childType) {
          case 'Array(2)':
          case 'Array(3)':
          case 'Array(4)':
            return `Matrix(${ast.elements.length})`;
        }
        return `Array(${ ast.elements.length })`;
      case 'Literal':
        const literalKey = this.astKey(ast);
        if (this.literalTypes[literalKey]) {
          return this.literalTypes[literalKey];
        }
        if (Number.isInteger(ast.value)) {
          return 'LiteralInteger';
        } else if (ast.value === true || ast.value === false) {
          return 'Boolean';
        } else {
          return 'Number';
        }
        case 'AssignmentExpression':
          return this.getType(ast.left);
        case 'CallExpression':
          if (this.isAstMathFunction(ast)) {
            return 'Number';
          }
          if (!ast.callee || !ast.callee.name) {
            if (ast.callee.type === 'SequenceExpression' && ast.callee.expressions[ast.callee.expressions.length - 1].property.name) {
              const functionName = ast.callee.expressions[ast.callee.expressions.length - 1].property.name;
              this.inferArgumentTypesIfNeeded(functionName, ast.arguments);
              return this.lookupReturnType(functionName, ast, this);
            }
            if (this.getVariableSignature(ast.callee, true) === 'this.color') {
              return null;
            }
            if (ast.callee.type === 'MemberExpression' && ast.callee.object && ast.callee.property && ast.callee.property.name && ast.arguments) {
              const functionName = ast.callee.property.name;
              this.inferArgumentTypesIfNeeded(functionName, ast.arguments);
              return this.lookupReturnType(functionName, ast, this);
            }
            throw this.astErrorOutput('Unknown call expression', ast);
          }
          if (ast.callee && ast.callee.name) {
            const functionName = ast.callee.name;
            this.inferArgumentTypesIfNeeded(functionName, ast.arguments);
            return this.lookupReturnType(functionName, ast, this);
          }
          throw this.astErrorOutput(`Unhandled getType Type "${ ast.type }"`, ast);
        case 'LogicalExpression':
          return 'Boolean';
        case 'BinaryExpression':
          switch (ast.operator) {
            case '%':
            case '/':
              if (this.fixIntegerDivisionAccuracy) {
                return 'Number';
              } else {
                break;
              }
              case '>':
              case '<':
                return 'Boolean';
              case '&':
              case '|':
              case '^':
              case '<<':
              case '>>':
              case '>>>':
                return 'Integer';
          }
          const type = this.getType(ast.left);
          if (this.isState('skip-literal-correction')) return type;
          if (type === 'LiteralInteger') {
            const rightType = this.getType(ast.right);
            if (rightType === 'LiteralInteger') {
              if (ast.left.value % 1 === 0) {
                return 'Integer';
              } else {
                return 'Float';
              }
            }
            return rightType;
          }
          return typeLookupMap[type] || type;
        case 'UpdateExpression':
          return this.getType(ast.argument);
        case 'UnaryExpression':
          if (ast.operator === '~') {
            return 'Integer';
          }
          return this.getType(ast.argument);
        case 'VariableDeclaration': {
          const declarations = ast.declarations;
          let lastType;
          for (let i = 0; i < declarations.length; i++) {
            const declaration = declarations[i];
            lastType = this.getType(declaration);
          }
          if (!lastType) {
            throw this.astErrorOutput(`Unable to find type for declaration`, ast);
          }
          return lastType;
        }
        case 'VariableDeclarator':
          const declaration = this.getDeclaration(ast.id);
          if (!declaration) {
            throw this.astErrorOutput(`Unable to find declarator`, ast);
          }

          if (!declaration.valueType) {
            throw this.astErrorOutput(`Unable to find declarator valueType`, ast);
          }

          return declaration.valueType;
        case 'Identifier':
          if (ast.name === 'Infinity') {
            return 'Number';
          }
          if (this.isAstVariable(ast)) {
            const signature = this.getVariableSignature(ast);
            if (signature === 'value') {
              return this.getCheckVariableType(ast);
            }
          }
          const origin = this.findIdentifierOrigin(ast);
          if (origin && origin.init) {
            return this.getType(origin.init);
          }
          return null;
        case 'ReturnStatement':
          return this.getType(ast.argument);
        case 'MemberExpression':
          if (this.isAstMathFunction(ast)) {
            switch (ast.property.name) {
              case 'ceil':
                return 'Integer';
              case 'floor':
                return 'Integer';
              case 'round':
                return 'Integer';
            }
            return 'Number';
          }
          if (this.isAstVariable(ast)) {
            const variableSignature = this.getVariableSignature(ast);
            switch (variableSignature) {
              case 'value[]':
                return this.getLookupType(this.getCheckVariableType(ast.object));
              case 'value[][]':
                return this.getLookupType(this.getCheckVariableType(ast.object.object));
              case 'value[][][]':
                return this.getLookupType(this.getCheckVariableType(ast.object.object.object));
              case 'value[][][][]':
                return this.getLookupType(this.getCheckVariableType(ast.object.object.object.object));
              case 'value.thread.value':
              case 'this.thread.value':
                return 'Integer';
              case 'this.output.value':
                return this.dynamicOutput ? 'Integer' : 'LiteralInteger';
              case 'this.constants.value':
                return this.getConstantType(ast.property.name);
              case 'this.constants.value[]':
                return this.getLookupType(this.getConstantType(ast.object.property.name));
              case 'this.constants.value[][]':
                return this.getLookupType(this.getConstantType(ast.object.object.property.name));
              case 'this.constants.value[][][]':
                return this.getLookupType(this.getConstantType(ast.object.object.object.property.name));
              case 'this.constants.value[][][][]':
                return this.getLookupType(this.getConstantType(ast.object.object.object.object.property.name));
              case 'fn()[]':
              case 'fn()[][]':
              case 'fn()[][][]':
                return this.getLookupType(this.getType(ast.object));
              case 'value.value':
                if (this.isAstMathVariable(ast)) {
                  return 'Number';
                }
                switch (ast.property.name) {
                  case 'r':
                  case 'g':
                  case 'b':
                  case 'a':
                    return this.getLookupType(this.getCheckVariableType(ast.object));
                }
                case '[][]':
                  return 'Number';
            }
            throw this.astErrorOutput('Unhandled getType MemberExpression', ast);
          }
          throw this.astErrorOutput('Unhandled getType MemberExpression', ast);
        case 'ConditionalExpression':
          return this.getType(ast.consequent);
        case 'FunctionDeclaration':
        case 'FunctionExpression':
          const lastReturn = this.findLastReturn(ast.body);
          if (lastReturn) {
            return this.getType(lastReturn);
          }
          return null;
        case 'IfStatement':
          return this.getType(ast.consequent);
        case 'SequenceExpression':
          return this.getType(ast.expressions[ast.expressions.length - 1]);
        default:
          throw this.astErrorOutput(`Unhandled getType Type "${ ast.type }"`, ast);
    }
  }

  getCheckVariableType(ast) {
    const type = this.getVariableType(ast);
    if (!type) {
      throw this.astErrorOutput(`${ast.type} is not defined`, ast);
    }
    return type;
  }

  inferArgumentTypesIfNeeded(functionName, args) {
    for (let i = 0; i < args.length; i++) {
      if (!this.needsArgumentType(functionName, i)) continue;
      const type = this.getType(args[i]);
      if (!type) {
        throw this.astErrorOutput(`Unable to infer argument ${i}`, args[i]);
      }
      this.assignArgumentType(functionName, i, type);
    }
  }

  isAstMathVariable(ast) {
    const mathProperties = [
      'E',
      'PI',
      'SQRT2',
      'SQRT1_2',
      'LN2',
      'LN10',
      'LOG2E',
      'LOG10E',
    ];
    return ast.type === 'MemberExpression' &&
      ast.object && ast.object.type === 'Identifier' &&
      ast.object.name === 'Math' &&
      ast.property &&
      ast.property.type === 'Identifier' &&
      mathProperties.indexOf(ast.property.name) > -1;
  }

  isAstMathFunction(ast) {
    const mathFunctions = [
      'abs',
      'acos',
      'acosh',
      'asin',
      'asinh',
      'atan',
      'atan2',
      'atanh',
      'cbrt',
      'ceil',
      'clz32',
      'cos',
      'cosh',
      'expm1',
      'exp',
      'floor',
      'fround',
      'imul',
      'log',
      'log2',
      'log10',
      'log1p',
      'max',
      'min',
      'pow',
      'random',
      'round',
      'sign',
      'sin',
      'sinh',
      'sqrt',
      'tan',
      'tanh',
      'trunc',
    ];
    return ast.type === 'CallExpression' &&
      ast.callee &&
      ast.callee.type === 'MemberExpression' &&
      ast.callee.object &&
      ast.callee.object.type === 'Identifier' &&
      ast.callee.object.name === 'Math' &&
      ast.callee.property &&
      ast.callee.property.type === 'Identifier' &&
      mathFunctions.indexOf(ast.callee.property.name) > -1;
  }

  isAstVariable(ast) {
    return ast.type === 'Identifier' || ast.type === 'MemberExpression';
  }

  isSafe(ast) {
    return this.isSafeDependencies(this.getDependencies(ast));
  }

  isSafeDependencies(dependencies) {
    return dependencies && dependencies.every ? dependencies.every(dependency => dependency.isSafe) : true;
  }

  getDependencies(ast, dependencies, isNotSafe) {
    if (!dependencies) {
      dependencies = [];
    }
    if (!ast) return null;
    if (Array.isArray(ast)) {
      for (let i = 0; i < ast.length; i++) {
        this.getDependencies(ast[i], dependencies, isNotSafe);
      }
      return dependencies;
    }
    switch (ast.type) {
      case 'AssignmentExpression':
        this.getDependencies(ast.left, dependencies, isNotSafe);
        this.getDependencies(ast.right, dependencies, isNotSafe);
        return dependencies;
      case 'ConditionalExpression':
        this.getDependencies(ast.test, dependencies, isNotSafe);
        this.getDependencies(ast.alternate, dependencies, isNotSafe);
        this.getDependencies(ast.consequent, dependencies, isNotSafe);
        return dependencies;
      case 'Literal':
        dependencies.push({
          origin: 'literal',
          value: ast.value,
          isSafe: isNotSafe === true ? false : ast.value > -Infinity && ast.value < Infinity && !isNaN(ast.value)
        });
        break;
      case 'VariableDeclarator':
        return this.getDependencies(ast.init, dependencies, isNotSafe);
      case 'Identifier':
        const declaration = this.getDeclaration(ast);
        if (declaration) {
          dependencies.push({
            name: ast.name,
            origin: 'declaration',
            isSafe: isNotSafe ? false : this.isSafeDependencies(declaration.dependencies),
          });
        } else if (this.argumentNames.indexOf(ast.name) > -1) {
          dependencies.push({
            name: ast.name,
            origin: 'argument',
            isSafe: false,
          });
        } else if (this.strictTypingChecking) {
          throw new Error(`Cannot find identifier origin "${ast.name}"`);
        }
        break;
      case 'FunctionDeclaration':
        return this.getDependencies(ast.body.body[ast.body.body.length - 1], dependencies, isNotSafe);
      case 'ReturnStatement':
        return this.getDependencies(ast.argument, dependencies);
      case 'BinaryExpression':
      case 'LogicalExpression':
        isNotSafe = (ast.operator === '/' || ast.operator === '*');
        this.getDependencies(ast.left, dependencies, isNotSafe);
        this.getDependencies(ast.right, dependencies, isNotSafe);
        return dependencies;
      case 'UnaryExpression':
      case 'UpdateExpression':
        return this.getDependencies(ast.argument, dependencies, isNotSafe);
      case 'VariableDeclaration':
        return this.getDependencies(ast.declarations, dependencies, isNotSafe);
      case 'ArrayExpression':
        dependencies.push({
          origin: 'declaration',
          isSafe: true,
        });
        return dependencies;
      case 'CallExpression':
        dependencies.push({
          origin: 'function',
          isSafe: true,
        });
        return dependencies;
      case 'MemberExpression':
        const details = this.getMemberExpressionDetails(ast);
        switch (details.signature) {
          case 'value[]':
            this.getDependencies(ast.object, dependencies, isNotSafe);
            break;
          case 'value[][]':
            this.getDependencies(ast.object.object, dependencies, isNotSafe);
            break;
          case 'value[][][]':
            this.getDependencies(ast.object.object.object, dependencies, isNotSafe);
            break;
          case 'this.output.value':
            if (this.dynamicOutput) {
              dependencies.push({
                name: details.name,
                origin: 'output',
                isSafe: false,
              });
            }
            break;
        }
        if (details) {
          if (details.property) {
            this.getDependencies(details.property, dependencies, isNotSafe);
          }
          if (details.xProperty) {
            this.getDependencies(details.xProperty, dependencies, isNotSafe);
          }
          if (details.yProperty) {
            this.getDependencies(details.yProperty, dependencies, isNotSafe);
          }
          if (details.zProperty) {
            this.getDependencies(details.zProperty, dependencies, isNotSafe);
          }
          return dependencies;
        }
        case 'SequenceExpression':
          return this.getDependencies(ast.expressions, dependencies, isNotSafe);
        default:
          throw this.astErrorOutput(`Unhandled type ${ ast.type } in getDependencies`, ast);
    }
    return dependencies;
  }

  getVariableSignature(ast, returnRawValue) {
    if (!this.isAstVariable(ast)) {
      throw new Error(`ast of type "${ ast.type }" is not a variable signature`);
    }
    if (ast.type === 'Identifier') {
      return 'value';
    }
    const signature = [];
    while (true) {
      if (!ast) break;
      if (ast.computed) {
        signature.push('[]');
      } else if (ast.type === 'ThisExpression') {
        signature.unshift('this');
      } else if (ast.property && ast.property.name) {
        if (
          ast.property.name === 'x' ||
          ast.property.name === 'y' ||
          ast.property.name === 'z'
        ) {
          signature.unshift(returnRawValue ? '.' + ast.property.name : '.value');
        } else if (
          ast.property.name === 'constants' ||
          ast.property.name === 'thread' ||
          ast.property.name === 'output'
        ) {
          signature.unshift('.' + ast.property.name);
        } else {
          signature.unshift(returnRawValue ? '.' + ast.property.name : '.value');
        }
      } else if (ast.name) {
        signature.unshift(returnRawValue ? ast.name : 'value');
      } else if (ast.callee && ast.callee.name) {
        signature.unshift(returnRawValue ? ast.callee.name + '()' : 'fn()');
      } else if (ast.elements) {
        signature.unshift('[]');
      } else {
        signature.unshift('unknown');
      }
      ast = ast.object;
    }

    const signatureString = signature.join('');
    if (returnRawValue) {
      return signatureString;
    }

    const allowedExpressions = [
      'value',
      'value[]',
      'value[][]',
      'value[][][]',
      'value[][][][]',
      'value.value',
      'value.thread.value',
      'this.thread.value',
      'this.output.value',
      'this.constants.value',
      'this.constants.value[]',
      'this.constants.value[][]',
      'this.constants.value[][][]',
      'this.constants.value[][][][]',
      'fn()[]',
      'fn()[][]',
      'fn()[][][]',
      '[][]',
    ];
    if (allowedExpressions.indexOf(signatureString) > -1) {
      return signatureString;
    }
    return null;
  }

  build() {
    return this.toString().length > 0;
  }

  astGeneric(ast, retArr) {
    if (ast === null) {
      throw this.astErrorOutput('NULL ast', ast);
    } else {
      if (Array.isArray(ast)) {
        for (let i = 0; i < ast.length; i++) {
          this.astGeneric(ast[i], retArr);
        }
        return retArr;
      }

      switch (ast.type) {
        case 'FunctionDeclaration':
          return this.astFunctionDeclaration(ast, retArr);
        case 'FunctionExpression':
          return this.astFunctionExpression(ast, retArr);
        case 'ReturnStatement':
          return this.astReturnStatement(ast, retArr);
        case 'Literal':
          return this.astLiteral(ast, retArr);
        case 'BinaryExpression':
          return this.astBinaryExpression(ast, retArr);
        case 'Identifier':
          return this.astIdentifierExpression(ast, retArr);
        case 'AssignmentExpression':
          return this.astAssignmentExpression(ast, retArr);
        case 'ExpressionStatement':
          return this.astExpressionStatement(ast, retArr);
        case 'EmptyStatement':
          return this.astEmptyStatement(ast, retArr);
        case 'BlockStatement':
          return this.astBlockStatement(ast, retArr);
        case 'IfStatement':
          return this.astIfStatement(ast, retArr);
        case 'SwitchStatement':
          return this.astSwitchStatement(ast, retArr);
        case 'BreakStatement':
          return this.astBreakStatement(ast, retArr);
        case 'ContinueStatement':
          return this.astContinueStatement(ast, retArr);
        case 'ForStatement':
          return this.astForStatement(ast, retArr);
        case 'WhileStatement':
          return this.astWhileStatement(ast, retArr);
        case 'DoWhileStatement':
          return this.astDoWhileStatement(ast, retArr);
        case 'VariableDeclaration':
          return this.astVariableDeclaration(ast, retArr);
        case 'VariableDeclarator':
          return this.astVariableDeclarator(ast, retArr);
        case 'ThisExpression':
          return this.astThisExpression(ast, retArr);
        case 'SequenceExpression':
          return this.astSequenceExpression(ast, retArr);
        case 'UnaryExpression':
          return this.astUnaryExpression(ast, retArr);
        case 'UpdateExpression':
          return this.astUpdateExpression(ast, retArr);
        case 'LogicalExpression':
          return this.astLogicalExpression(ast, retArr);
        case 'MemberExpression':
          return this.astMemberExpression(ast, retArr);
        case 'CallExpression':
          return this.astCallExpression(ast, retArr);
        case 'ArrayExpression':
          return this.astArrayExpression(ast, retArr);
        case 'DebuggerStatement':
          return this.astDebuggerStatement(ast, retArr);
        case 'ConditionalExpression':
          return this.astConditionalExpression(ast, retArr);
      }

      throw this.astErrorOutput('Unknown ast type : ' + ast.type, ast);
    }
  }
  astErrorOutput(error, ast) {
    if (typeof this.source !== 'string') {
      return new Error(error);
    }

    const debugString = utils.getAstString(this.source, ast);
    const leadingSource = this.source.substr(ast.start);
    const splitLines = leadingSource.split(/\n/);
    const lineBefore = splitLines.length > 0 ? splitLines[splitLines.length - 1] : 0;
    return new Error(`${error} on line ${ splitLines.length }, position ${ lineBefore.length }:\n ${ debugString }`);
  }

  astDebuggerStatement(arrNode, retArr) {
    return retArr;
  }

  astConditionalExpression(ast, retArr) {
    if (ast.type !== 'ConditionalExpression') {
      throw this.astErrorOutput('Not a conditional expression', ast);
    }
    retArr.push('(');
    this.astGeneric(ast.test, retArr);
    retArr.push('?');
    this.astGeneric(ast.consequent, retArr);
    retArr.push(':');
    this.astGeneric(ast.alternate, retArr);
    retArr.push(')');
    return retArr;
  }

  astFunction(ast, retArr) {
    throw new Error(`"astFunction" not defined on ${ this.constructor.name }`);
  }

  astFunctionDeclaration(ast, retArr) {
    if (this.isChildFunction(ast)) {
      return retArr;
    }
    return this.astFunction(ast, retArr);
  }
  astFunctionExpression(ast, retArr) {
    if (this.isChildFunction(ast)) {
      return retArr;
    }
    return this.astFunction(ast, retArr);
  }
  isChildFunction(ast) {
    for (let i = 0; i < this.functions.length; i++) {
      if (this.functions[i] === ast) {
        return true;
      }
    }
    return false;
  }
  astReturnStatement(ast, retArr) {
    return retArr;
  }
  astLiteral(ast, retArr) {
    this.literalTypes[this.astKey(ast)] = 'Number';
    return retArr;
  }
  astBinaryExpression(ast, retArr) {
    return retArr;
  }
  astIdentifierExpression(ast, retArr) {
    return retArr;
  }
  astAssignmentExpression(ast, retArr) {
    return retArr;
  }
  astExpressionStatement(esNode, retArr) {
    this.astGeneric(esNode.expression, retArr);
    retArr.push(';');
    return retArr;
  }
  astEmptyStatement(eNode, retArr) {
    return retArr;
  }
  astBlockStatement(ast, retArr) {
    return retArr;
  }
  astIfStatement(ast, retArr) {
    return retArr;
  }
  astSwitchStatement(ast, retArr) {
    return retArr;
  }
  astBreakStatement(brNode, retArr) {
    retArr.push('break;');
    return retArr;
  }
  astContinueStatement(crNode, retArr) {
    retArr.push('continue;\n');
    return retArr;
  }
  astForStatement(ast, retArr) {
    return retArr;
  }
  astWhileStatement(ast, retArr) {
    return retArr;
  }
  astDoWhileStatement(ast, retArr) {
    return retArr;
  }
  astVariableDeclarator(iVarDecNode, retArr) {
    this.astGeneric(iVarDecNode.id, retArr);
    if (iVarDecNode.init !== null) {
      retArr.push('=');
      this.astGeneric(iVarDecNode.init, retArr);
    }
    return retArr;
  }
  astThisExpression(ast, retArr) {
    return retArr;
  }
  astSequenceExpression(sNode, retArr) {
    const { expressions } = sNode;
    const sequenceResult = [];
    for (let i = 0; i < expressions.length; i++) {
      const expression = expressions[i];
      const expressionResult = [];
      this.astGeneric(expression, expressionResult);
      sequenceResult.push(expressionResult.join(''));
    }
    if (sequenceResult.length > 1) {
      retArr.push('(', sequenceResult.join(','), ')');
    } else {
      retArr.push(sequenceResult[0]);
    }
    return retArr;
  }
  astUnaryExpression(uNode, retArr) {
    const unaryResult = this.checkAndUpconvertBitwiseUnary(uNode, retArr);
    if (unaryResult) {
      return retArr;
    }

    if (uNode.prefix) {
      retArr.push(uNode.operator);
      this.astGeneric(uNode.argument, retArr);
    } else {
      this.astGeneric(uNode.argument, retArr);
      retArr.push(uNode.operator);
    }

    return retArr;
  }

  checkAndUpconvertBitwiseUnary(uNode, retArr) {}

  astUpdateExpression(uNode, retArr) {
    if (uNode.prefix) {
      retArr.push(uNode.operator);
      this.astGeneric(uNode.argument, retArr);
    } else {
      this.astGeneric(uNode.argument, retArr);
      retArr.push(uNode.operator);
    }

    return retArr;
  }
  astLogicalExpression(logNode, retArr) {
    retArr.push('(');
    this.astGeneric(logNode.left, retArr);
    retArr.push(logNode.operator);
    this.astGeneric(logNode.right, retArr);
    retArr.push(')');
    return retArr;
  }
  astMemberExpression(ast, retArr) {
    return retArr;
  }
  astCallExpression(ast, retArr) {
    return retArr;
  }
  astArrayExpression(ast, retArr) {
    return retArr;
  }

  getMemberExpressionDetails(ast) {
    if (ast.type !== 'MemberExpression') {
      throw this.astErrorOutput(`Expression ${ ast.type } not a MemberExpression`, ast);
    }
    let name = null;
    let type = null;
    const variableSignature = this.getVariableSignature(ast);
    switch (variableSignature) {
      case 'value':
        return null;
      case 'value.thread.value':
      case 'this.thread.value':
      case 'this.output.value':
        return {
          signature: variableSignature,
            type: 'Integer',
            name: ast.property.name
        };
      case 'value[]':
        if (typeof ast.object.name !== 'string') {
          throw this.astErrorOutput('Unexpected expression', ast);
        }
        name = ast.object.name;
        return {
          name,
          origin: 'user',
            signature: variableSignature,
            type: this.getVariableType(ast.object),
            xProperty: ast.property
        };
      case 'value[][]':
        if (typeof ast.object.object.name !== 'string') {
          throw this.astErrorOutput('Unexpected expression', ast);
        }
        name = ast.object.object.name;
        return {
          name,
          origin: 'user',
            signature: variableSignature,
            type: this.getVariableType(ast.object.object),
            yProperty: ast.object.property,
            xProperty: ast.property,
        };
      case 'value[][][]':
        if (typeof ast.object.object.object.name !== 'string') {
          throw this.astErrorOutput('Unexpected expression', ast);
        }
        name = ast.object.object.object.name;
        return {
          name,
          origin: 'user',
            signature: variableSignature,
            type: this.getVariableType(ast.object.object.object),
            zProperty: ast.object.object.property,
            yProperty: ast.object.property,
            xProperty: ast.property,
        };
      case 'value[][][][]':
        if (typeof ast.object.object.object.object.name !== 'string') {
          throw this.astErrorOutput('Unexpected expression', ast);
        }
        name = ast.object.object.object.object.name;
        return {
          name,
          origin: 'user',
            signature: variableSignature,
            type: this.getVariableType(ast.object.object.object.object),
            zProperty: ast.object.object.property,
            yProperty: ast.object.property,
            xProperty: ast.property,
        };
      case 'value.value':
        if (typeof ast.property.name !== 'string') {
          throw this.astErrorOutput('Unexpected expression', ast);
        }
        if (this.isAstMathVariable(ast)) {
          name = ast.property.name;
          return {
            name,
            origin: 'Math',
            type: 'Number',
            signature: variableSignature,
          };
        }
        switch (ast.property.name) {
          case 'r':
          case 'g':
          case 'b':
          case 'a':
            name = ast.object.name;
            return {
              name,
              property: ast.property.name,
                origin: 'user',
                signature: variableSignature,
                type: 'Number'
            };
          default:
            throw this.astErrorOutput('Unexpected expression', ast);
        }
        case 'this.constants.value':
          if (typeof ast.property.name !== 'string') {
            throw this.astErrorOutput('Unexpected expression', ast);
          }
          name = ast.property.name;
          type = this.getConstantType(name);
          if (!type) {
            throw this.astErrorOutput('Constant has no type', ast);
          }
          return {
            name,
            type,
            origin: 'constants',
              signature: variableSignature,
          };
        case 'this.constants.value[]':
          if (typeof ast.object.property.name !== 'string') {
            throw this.astErrorOutput('Unexpected expression', ast);
          }
          name = ast.object.property.name;
          type = this.getConstantType(name);
          if (!type) {
            throw this.astErrorOutput('Constant has no type', ast);
          }
          return {
            name,
            type,
            origin: 'constants',
              signature: variableSignature,
              xProperty: ast.property,
          };
        case 'this.constants.value[][]': {
          if (typeof ast.object.object.property.name !== 'string') {
            throw this.astErrorOutput('Unexpected expression', ast);
          }
          name = ast.object.object.property.name;
          type = this.getConstantType(name);
          if (!type) {
            throw this.astErrorOutput('Constant has no type', ast);
          }
          return {
            name,
            type,
            origin: 'constants',
            signature: variableSignature,
            yProperty: ast.object.property,
            xProperty: ast.property,
          };
        }
        case 'this.constants.value[][][]': {
          if (typeof ast.object.object.object.property.name !== 'string') {
            throw this.astErrorOutput('Unexpected expression', ast);
          }
          name = ast.object.object.object.property.name;
          type = this.getConstantType(name);
          if (!type) {
            throw this.astErrorOutput('Constant has no type', ast);
          }
          return {
            name,
            type,
            origin: 'constants',
            signature: variableSignature,
            zProperty: ast.object.object.property,
            yProperty: ast.object.property,
            xProperty: ast.property,
          };
        }
        case 'fn()[]':
        case 'fn()[][]':
        case '[][]':
          return {
            signature: variableSignature,
              property: ast.property,
          };
        default:
          throw this.astErrorOutput('Unexpected expression', ast);
    }
  }

  findIdentifierOrigin(astToFind) {
    const stack = [this.ast];

    while (stack.length > 0) {
      const atNode = stack[0];
      if (atNode.type === 'VariableDeclarator' && atNode.id && atNode.id.name && atNode.id.name === astToFind.name) {
        return atNode;
      }
      stack.shift();
      if (atNode.argument) {
        stack.push(atNode.argument);
      } else if (atNode.body) {
        stack.push(atNode.body);
      } else if (atNode.declarations) {
        stack.push(atNode.declarations);
      } else if (Array.isArray(atNode)) {
        for (let i = 0; i < atNode.length; i++) {
          stack.push(atNode[i]);
        }
      }
    }
    return null;
  }

  findLastReturn(ast) {
    const stack = [ast || this.ast];

    while (stack.length > 0) {
      const atNode = stack.pop();
      if (atNode.type === 'ReturnStatement') {
        return atNode;
      }
      if (atNode.type === 'FunctionDeclaration') {
        continue;
      }
      if (atNode.argument) {
        stack.push(atNode.argument);
      } else if (atNode.body) {
        stack.push(atNode.body);
      } else if (atNode.declarations) {
        stack.push(atNode.declarations);
      } else if (Array.isArray(atNode)) {
        for (let i = 0; i < atNode.length; i++) {
          stack.push(atNode[i]);
        }
      } else if (atNode.consequent) {
        stack.push(atNode.consequent);
      } else if (atNode.cases) {
        stack.push(atNode.cases);
      }
    }
    return null;
  }

  getInternalVariableName(name) {
    if (!this._internalVariableNames.hasOwnProperty(name)) {
      this._internalVariableNames[name] = 0;
    }
    this._internalVariableNames[name]++;
    if (this._internalVariableNames[name] === 1) {
      return name;
    }
    return name + this._internalVariableNames[name];
  }

  astKey(ast, separator = ',') {
    if (!ast.start || !ast.end) throw new Error('AST start and end needed');
    return `${ast.start}${separator}${ast.end}`;
  }
}

const typeLookupMap = {
  'Number': 'Number',
  'Float': 'Float',
  'Integer': 'Integer',
  'Array': 'Number',
  'Array(2)': 'Number',
  'Array(3)': 'Number',
  'Array(4)': 'Number',
  'Matrix(2)': 'Number',
  'Matrix(3)': 'Number',
  'Matrix(4)': 'Number',
  'Array2D': 'Number',
  'Array3D': 'Number',
  'Input': 'Number',
  'HTMLCanvas': 'Array(4)',
  'OffscreenCanvas': 'Array(4)',
  'HTMLImage': 'Array(4)',
  'ImageBitmap': 'Array(4)',
  'ImageData': 'Array(4)',
  'HTMLVideo': 'Array(4)',
  'HTMLImageArray': 'Array(4)',
  'NumberTexture': 'Number',
  'MemoryOptimizedNumberTexture': 'Number',
  'Array1D(2)': 'Array(2)',
  'Array1D(3)': 'Array(3)',
  'Array1D(4)': 'Array(4)',
  'Array2D(2)': 'Array(2)',
  'Array2D(3)': 'Array(3)',
  'Array2D(4)': 'Array(4)',
  'Array3D(2)': 'Array(2)',
  'Array3D(3)': 'Array(3)',
  'Array3D(4)': 'Array(4)',
  'ArrayTexture(1)': 'Number',
  'ArrayTexture(2)': 'Array(2)',
  'ArrayTexture(3)': 'Array(3)',
  'ArrayTexture(4)': 'Array(4)',
};

module.exports = {
  FunctionNode
};
},{"../utils":114,"./function-tracer":11,"acorn":1}],11:[function(require,module,exports){
const { utils } = require('../utils');

function last(array) {
  return array.length > 0 ? array[array.length - 1] : null;
}

const states = {
  trackIdentifiers: 'trackIdentifiers',
  memberExpression: 'memberExpression',
  inForLoopInit: 'inForLoopInit'
};

class FunctionTracer {
  constructor(ast) {
    this.runningContexts = [];
    this.functionContexts = [];
    this.contexts = [];
    this.functionCalls = [];
    this.declarations = [];
    this.identifiers = [];
    this.functions = [];
    this.returnStatements = [];
    this.trackedIdentifiers = null;
    this.states = [];
    this.newFunctionContext();
    this.scan(ast);
  }

  isState(state) {
    return this.states[this.states.length - 1] === state;
  }

  hasState(state) {
    return this.states.indexOf(state) > -1;
  }

  pushState(state) {
    this.states.push(state);
  }

  popState(state) {
    if (this.isState(state)) {
      this.states.pop();
    } else {
      throw new Error(`Cannot pop the non-active state "${state}"`);
    }
  }

  get currentFunctionContext() {
    return last(this.functionContexts);
  }

  get currentContext() {
    return last(this.runningContexts);
  }

  newFunctionContext() {
    const newContext = { '@contextType': 'function' };
    this.contexts.push(newContext);
    this.functionContexts.push(newContext);
  }

  newContext(run) {
    const newContext = Object.assign({ '@contextType': 'const/let' }, this.currentContext);
    this.contexts.push(newContext);
    this.runningContexts.push(newContext);
    run();
    const { currentFunctionContext } = this;
    for (const p in currentFunctionContext) {
      if (!currentFunctionContext.hasOwnProperty(p) || newContext.hasOwnProperty(p)) continue;
      newContext[p] = currentFunctionContext[p];
    }
    this.runningContexts.pop();
    return newContext;
  }

  useFunctionContext(run) {
    const functionContext = last(this.functionContexts);
    this.runningContexts.push(functionContext);
    run();
    this.runningContexts.pop();
  }

  getIdentifiers(run) {
    const trackedIdentifiers = this.trackedIdentifiers = [];
    this.pushState(states.trackIdentifiers);
    run();
    this.trackedIdentifiers = null;
    this.popState(states.trackIdentifiers);
    return trackedIdentifiers;
  }

  getDeclaration(name) {
    const { currentContext, currentFunctionContext, runningContexts } = this;
    const declaration = currentContext[name] || currentFunctionContext[name] || null;

    if (
      !declaration &&
      currentContext === currentFunctionContext &&
      runningContexts.length > 0
    ) {
      const previousRunningContext = runningContexts[runningContexts.length - 2];
      if (previousRunningContext[name]) {
        return previousRunningContext[name];
      }
    }

    return declaration;
  }

  scan(ast) {
    if (!ast) return;
    if (Array.isArray(ast)) {
      for (let i = 0; i < ast.length; i++) {
        this.scan(ast[i]);
      }
      return;
    }
    switch (ast.type) {
      case 'Program':
        this.useFunctionContext(() => {
          this.scan(ast.body);
        });
        break;
      case 'BlockStatement':
        this.newContext(() => {
          this.scan(ast.body);
        });
        break;
      case 'AssignmentExpression':
      case 'LogicalExpression':
        this.scan(ast.left);
        this.scan(ast.right);
        break;
      case 'BinaryExpression':
        this.scan(ast.left);
        this.scan(ast.right);
        break;
      case 'UpdateExpression':
        if (ast.operator === '++') {
          const declaration = this.getDeclaration(ast.argument.name);
          if (declaration) {
            declaration.suggestedType = 'Integer';
          }
        }
        this.scan(ast.argument);
        break;
      case 'UnaryExpression':
        this.scan(ast.argument);
        break;
      case 'VariableDeclaration':
        if (ast.kind === 'var') {
          this.useFunctionContext(() => {
            ast.declarations = utils.normalizeDeclarations(ast);
            this.scan(ast.declarations);
          });
        } else {
          ast.declarations = utils.normalizeDeclarations(ast);
          this.scan(ast.declarations);
        }
        break;
      case 'VariableDeclarator': {
        const { currentContext } = this;
        const inForLoopInit = this.hasState(states.inForLoopInit);
        const declaration = {
          ast: ast,
          context: currentContext,
          name: ast.id.name,
          origin: 'declaration',
          inForLoopInit,
          inForLoopTest: null,
          assignable: currentContext === this.currentFunctionContext || (!inForLoopInit && !currentContext.hasOwnProperty(ast.id.name)),
          suggestedType: null,
          valueType: null,
          dependencies: null,
          isSafe: null,
        };
        if (!currentContext[ast.id.name]) {
          currentContext[ast.id.name] = declaration;
        }
        this.declarations.push(declaration);
        this.scan(ast.id);
        this.scan(ast.init);
        break;
      }
      case 'FunctionExpression':
      case 'FunctionDeclaration':
        if (this.runningContexts.length === 0) {
          this.scan(ast.body);
        } else {
          this.functions.push(ast);
        }
        break;
      case 'IfStatement':
        this.scan(ast.test);
        this.scan(ast.consequent);
        if (ast.alternate) this.scan(ast.alternate);
        break;
      case 'ForStatement': {
        let testIdentifiers;
        const context = this.newContext(() => {
          this.pushState(states.inForLoopInit);
          this.scan(ast.init);
          this.popState(states.inForLoopInit);

          testIdentifiers = this.getIdentifiers(() => {
            this.scan(ast.test);
          });

          this.scan(ast.update);
          this.newContext(() => {
            this.scan(ast.body);
          });
        });

        if (testIdentifiers) {
          for (const p in context) {
            if (p === '@contextType') continue;
            if (testIdentifiers.indexOf(p) > -1) {
              context[p].inForLoopTest = true;
            }
          }
        }
        break;
      }
      case 'DoWhileStatement':
      case 'WhileStatement':
        this.newContext(() => {
          this.scan(ast.body);
          this.scan(ast.test);
        });
        break;
      case 'Identifier': {
        if (this.isState(states.trackIdentifiers)) {
          this.trackedIdentifiers.push(ast.name);
        }
        this.identifiers.push({
          context: this.currentContext,
          declaration: this.getDeclaration(ast.name),
          ast,
        });
        break;
      }
      case 'ReturnStatement':
        this.returnStatements.push(ast);
        this.scan(ast.argument);
        break;
      case 'MemberExpression':
        this.pushState(states.memberExpression);
        this.scan(ast.object);
        this.scan(ast.property);
        this.popState(states.memberExpression);
        break;
      case 'ExpressionStatement':
        this.scan(ast.expression);
        break;
      case 'SequenceExpression':
        this.scan(ast.expressions);
        break;
      case 'CallExpression':
        this.functionCalls.push({
          context: this.currentContext,
          ast,
        });
        this.scan(ast.arguments);
        break;
      case 'ArrayExpression':
        this.scan(ast.elements);
        break;
      case 'ConditionalExpression':
        this.scan(ast.test);
        this.scan(ast.alternate);
        this.scan(ast.consequent);
        break;
      case 'SwitchStatement':
        this.scan(ast.discriminant);
        this.scan(ast.cases);
        break;
      case 'SwitchCase':
        this.scan(ast.test);
        this.scan(ast.consequent);
        break;

      case 'ThisExpression':
      case 'Literal':
      case 'DebuggerStatement':
      case 'EmptyStatement':
      case 'BreakStatement':
      case 'ContinueStatement':
        break;
      default:
        throw new Error(`unhandled type "${ast.type}"`);
    }
  }
}

module.exports = {
  FunctionTracer,
};
},{"../utils":114}],12:[function(require,module,exports){
const { glWiretap } = require('gl-wiretap');
const { utils } = require('../../utils');

function toStringWithoutUtils(fn) {
  return fn.toString()
    .replace('=>', '')
    .replace(/^function /, '')
    .replace(/utils[.]/g, '/*utils.*/');
}

function glKernelString(Kernel, args, originKernel, setupContextString, destroyContextString) {
  if (!originKernel.built) {
    originKernel.build.apply(originKernel, args);
  }
  args = args ? Array.from(args).map(arg => {
    switch (typeof arg) {
      case 'boolean':
        return new Boolean(arg);
      case 'number':
        return new Number(arg);
      default:
        return arg;
    }
  }) : null;
  const uploadedValues = [];
  const postResult = [];
  const context = glWiretap(originKernel.context, {
    useTrackablePrimitives: true,
    onReadPixels: (targetName) => {
      if (kernel.subKernels) {
        if (!subKernelsResultVariableSetup) {
          postResult.push(`    const result = { result: ${getRenderString(targetName, kernel)} };`);
          subKernelsResultVariableSetup = true;
        } else {
          const property = kernel.subKernels[subKernelsResultIndex++].property;
          postResult.push(`    result${isNaN(property) ? '.' + property : `[${property}]`} = ${getRenderString(targetName, kernel)};`);
        }
        if (subKernelsResultIndex === kernel.subKernels.length) {
          postResult.push('    return result;');
        }
        return;
      }
      if (targetName) {
        postResult.push(`    return ${getRenderString(targetName, kernel)};`);
      } else {
        postResult.push(`    return null;`);
      }
    },
    onUnrecognizedArgumentLookup: (argument) => {
      const argumentName = findKernelValue(argument, kernel.kernelArguments, [], context, uploadedValues);
      if (argumentName) {
        return argumentName;
      }
      const constantName = findKernelValue(argument, kernel.kernelConstants, constants ? Object.keys(constants).map(key => constants[key]) : [], context, uploadedValues);
      if (constantName) {
        return constantName;
      }
      return null;
    }
  });
  let subKernelsResultVariableSetup = false;
  let subKernelsResultIndex = 0;
  const {
    source,
    canvas,
    output,
    pipeline,
    graphical,
    loopMaxIterations,
    constants,
    optimizeFloatMemory,
    precision,
    fixIntegerDivisionAccuracy,
    functions,
    nativeFunctions,
    subKernels,
    immutable,
    argumentTypes,
    constantTypes,
    kernelArguments,
    kernelConstants,
    tactic,
  } = originKernel;
  const kernel = new Kernel(source, {
    canvas,
    context,
    checkContext: false,
    output,
    pipeline,
    graphical,
    loopMaxIterations,
    constants,
    optimizeFloatMemory,
    precision,
    fixIntegerDivisionAccuracy,
    functions,
    nativeFunctions,
    subKernels,
    immutable,
    argumentTypes,
    constantTypes,
    tactic,
  });
  let result = [];
  context.setIndent(2);
  kernel.build.apply(kernel, args);
  result.push(context.toString());
  context.reset();

  kernel.kernelArguments.forEach((kernelArgument, i) => {
    switch (kernelArgument.type) {
      case 'Integer':
      case 'Boolean':
      case 'Number':
      case 'Float':
      case 'Array':
      case 'Array(2)':
      case 'Array(3)':
      case 'Array(4)':
      case 'HTMLCanvas':
      case 'HTMLImage':
      case 'HTMLVideo':
        context.insertVariable(`uploadValue_${kernelArgument.name}`, kernelArgument.uploadValue);
        break;
      case 'HTMLImageArray':
        for (let imageIndex = 0; imageIndex < args[i].length; imageIndex++) {
          const arg = args[i];
          context.insertVariable(`uploadValue_${kernelArgument.name}[${imageIndex}]`, arg[imageIndex]);
        }
        break;
      case 'Input':
        context.insertVariable(`uploadValue_${kernelArgument.name}`, kernelArgument.uploadValue);
        break;
      case 'MemoryOptimizedNumberTexture':
      case 'NumberTexture':
      case 'Array1D(2)':
      case 'Array1D(3)':
      case 'Array1D(4)':
      case 'Array2D(2)':
      case 'Array2D(3)':
      case 'Array2D(4)':
      case 'Array3D(2)':
      case 'Array3D(3)':
      case 'Array3D(4)':
      case 'ArrayTexture(1)':
      case 'ArrayTexture(2)':
      case 'ArrayTexture(3)':
      case 'ArrayTexture(4)':
        context.insertVariable(`uploadValue_${kernelArgument.name}`, args[i].texture);
        break;
      default:
        throw new Error(`unhandled kernelArgumentType insertion for glWiretap of type ${kernelArgument.type}`);
    }
  });
  result.push('/** start of injected functions **/');
  result.push(`function ${toStringWithoutUtils(utils.flattenTo)}`);
  result.push(`function ${toStringWithoutUtils(utils.flatten2dArrayTo)}`);
  result.push(`function ${toStringWithoutUtils(utils.flatten3dArrayTo)}`);
  result.push(`function ${toStringWithoutUtils(utils.flatten4dArrayTo)}`);
  result.push(`function ${toStringWithoutUtils(utils.isArray)}`);
  if (kernel.renderOutput !== kernel.renderTexture && kernel.formatValues) {
    result.push(
      `  const renderOutput = function ${toStringWithoutUtils(kernel.formatValues)};`
    );
  }
  result.push('/** end of injected functions **/');
  result.push(`  const innerKernel = function (${kernel.kernelArguments.map(kernelArgument => kernelArgument.varName).join(', ')}) {`);
  context.setIndent(4);
  kernel.run.apply(kernel, args);
  if (kernel.renderKernels) {
    kernel.renderKernels();
  } else if (kernel.renderOutput) {
    kernel.renderOutput();
  }
  result.push('    /** start setup uploads for kernel values **/');
  kernel.kernelArguments.forEach(kernelArgument => {
    result.push('    ' + kernelArgument.getStringValueHandler().split('\n').join('\n    '));
  });
  result.push('    /** end setup uploads for kernel values **/');
  result.push(context.toString());
  if (kernel.renderOutput === kernel.renderTexture) {
    context.reset();
    const framebufferName = context.getContextVariableName(kernel.framebuffer);
    if (kernel.renderKernels) {
      const results = kernel.renderKernels();
      const textureName = context.getContextVariableName(kernel.texture.texture);
      result.push(`    return {
      result: {
        texture: ${ textureName },
        type: '${ results.result.type }',
        toArray: ${ getToArrayString(results.result, textureName, framebufferName) }
      },`);
      const { subKernels, mappedTextures } = kernel;
      for (let i = 0; i < subKernels.length; i++) {
        const texture = mappedTextures[i];
        const subKernel = subKernels[i];
        const subKernelResult = results[subKernel.property];
        const subKernelTextureName = context.getContextVariableName(texture.texture);
        result.push(`
      ${subKernel.property}: {
        texture: ${ subKernelTextureName },
        type: '${ subKernelResult.type }',
        toArray: ${ getToArrayString(subKernelResult, subKernelTextureName, framebufferName) }
      },`);
      }
      result.push(`    };`);
    } else {
      const rendered = kernel.renderOutput();
      const textureName = context.getContextVariableName(kernel.texture.texture);
      result.push(`    return {
        texture: ${ textureName },
        type: '${ rendered.type }',
        toArray: ${ getToArrayString(rendered, textureName, framebufferName) }
      };`);
    }
  }
  result.push(`    ${destroyContextString ? '\n' + destroyContextString + '    ': ''}`);
  result.push(postResult.join('\n'));
  result.push('  };');
  if (kernel.graphical) {
    result.push(getGetPixelsString(kernel));
    result.push(`  innerKernel.getPixels = getPixels;`);
  }
  result.push('  return innerKernel;');

  let constantsUpload = [];
  kernelConstants.forEach((kernelConstant) => {
    constantsUpload.push(`${kernelConstant.getStringValueHandler()}`);
  });
  return `function kernel(settings) {
  const { context, constants } = settings;
  ${constantsUpload.join('')}
  ${setupContextString ? setupContextString : ''}
${result.join('\n')}
}`;
}

function getRenderString(targetName, kernel) {
  const readBackValue = kernel.precision === 'single' ? targetName : `new Float32Array(${targetName}.buffer)`;
  if (kernel.output[2]) {
    return `renderOutput(${readBackValue}, ${kernel.output[0]}, ${kernel.output[1]}, ${kernel.output[2]})`;
  }
  if (kernel.output[1]) {
    return `renderOutput(${readBackValue}, ${kernel.output[0]}, ${kernel.output[1]})`;
  }

  return `renderOutput(${readBackValue}, ${kernel.output[0]})`;
}

function getGetPixelsString(kernel) {
  const getPixels = kernel.getPixels.toString();
  const useFunctionKeyword = !/^function/.test(getPixels);
  return utils.flattenFunctionToString(`${useFunctionKeyword ? 'function ' : ''}${ getPixels }`, {
    findDependency: (object, name) => {
      if (object === 'utils') {
        return `const ${name} = ${utils[name].toString()};`;
      }
      return null;
    },
    thisLookup: (property) => {
      if (property === 'context') {
        return null;
      }
      if (kernel.hasOwnProperty(property)) {
        return JSON.stringify(kernel[property]);
      }
      throw new Error(`unhandled thisLookup ${ property }`);
    }
  });
}

function getToArrayString(kernelResult, textureName, framebufferName) {
  const toArray = kernelResult.toArray.toString();
  const useFunctionKeyword = !/^function/.test(toArray);
  const flattenedFunctions = utils.flattenFunctionToString(`${useFunctionKeyword ? 'function ' : ''}${ toArray }`, {
    findDependency: (object, name) => {
      if (object === 'utils') {
        return `const ${name} = ${utils[name].toString()};`;
      } else if (object === 'this') {
        if (name === 'framebuffer') {
          return '';
        }
        return `${useFunctionKeyword ? 'function ' : ''}${kernelResult[name].toString()}`;
      } else {
        throw new Error('unhandled fromObject');
      }
    },
    thisLookup: (property, isDeclaration) => {
      if (property === 'texture') {
        return textureName;
      }
      if (property === 'context') {
        if (isDeclaration) return null;
        return 'gl';
      }
      if (kernelResult.hasOwnProperty(property)) {
        return JSON.stringify(kernelResult[property]);
      }
      throw new Error(`unhandled thisLookup ${ property }`);
    }
  });
  return `() => {
  function framebuffer() { return ${framebufferName}; };
  ${flattenedFunctions}
  return toArray();
  }`;
}

function findKernelValue(argument, kernelValues, values, context, uploadedValues) {
  if (argument === null) return null;
  if (kernelValues === null) return null;
  switch (typeof argument) {
    case 'boolean':
    case 'number':
      return null;
  }
  if (
    typeof HTMLImageElement !== 'undefined' &&
    argument instanceof HTMLImageElement
  ) {
    for (let i = 0; i < kernelValues.length; i++) {
      const kernelValue = kernelValues[i];
      if (kernelValue.type !== 'HTMLImageArray' && kernelValue) continue;
      if (kernelValue.uploadValue !== argument) continue;
      const variableIndex = values[i].indexOf(argument);
      if (variableIndex === -1) continue;
      const variableName = `uploadValue_${kernelValue.name}[${variableIndex}]`;
      context.insertVariable(variableName, argument);
      return variableName;
    }
  }

  for (let i = 0; i < kernelValues.length; i++) {
    const kernelValue = kernelValues[i];
    if (argument !== kernelValue.uploadValue) continue;
    const variable = `uploadValue_${kernelValue.name}`;
    context.insertVariable(variable, kernelValue);
    return variable;
  }
  return null;
}

module.exports = {
  glKernelString
};
},{"../../utils":114,"gl-wiretap":3}],13:[function(require,module,exports){
const { Kernel } = require('../kernel');
const { utils } = require('../../utils');
const { GLTextureArray2Float } = require('./texture/array-2-float');
const { GLTextureArray2Float2D } = require('./texture/array-2-float-2d');
const { GLTextureArray2Float3D } = require('./texture/array-2-float-3d');
const { GLTextureArray3Float } = require('./texture/array-3-float');
const { GLTextureArray3Float2D } = require('./texture/array-3-float-2d');
const { GLTextureArray3Float3D } = require('./texture/array-3-float-3d');
const { GLTextureArray4Float } = require('./texture/array-4-float');
const { GLTextureArray4Float2D } = require('./texture/array-4-float-2d');
const { GLTextureArray4Float3D } = require('./texture/array-4-float-3d');
const { GLTextureFloat } = require('./texture/float');
const { GLTextureFloat2D } = require('./texture/float-2d');
const { GLTextureFloat3D } = require('./texture/float-3d');
const { GLTextureMemoryOptimized } = require('./texture/memory-optimized');
const { GLTextureMemoryOptimized2D } = require('./texture/memory-optimized-2d');
const { GLTextureMemoryOptimized3D } = require('./texture/memory-optimized-3d');
const { GLTextureUnsigned } = require('./texture/unsigned');
const { GLTextureUnsigned2D } = require('./texture/unsigned-2d');
const { GLTextureUnsigned3D } = require('./texture/unsigned-3d');
const { GLTextureGraphical } = require('./texture/graphical');

class GLKernel extends Kernel {
  static get mode() {
    return 'gpu';
  }

  static getIsFloatRead() {
    const kernelString = `function kernelFunction() {
      return 1;
    }`;
    const kernel = new this(kernelString, {
      context: this.testContext,
      canvas: this.testCanvas,
      validate: false,
      output: [1],
      precision: 'single',
      returnType: 'Number',
      tactic: 'speed',
    });
    kernel.build();
    kernel.run();
    const result = kernel.renderOutput();
    kernel.destroy(true);
    return result[0] === 1;
  }

  static getIsIntegerDivisionAccurate() {
    function kernelFunction(v1, v2) {
      return v1[this.thread.x] / v2[this.thread.x];
    }
    const kernel = new this(kernelFunction.toString(), {
      context: this.testContext,
      canvas: this.testCanvas,
      validate: false,
      output: [2],
      returnType: 'Number',
      precision: 'unsigned',
      tactic: 'speed',
    });
    const args = [
      [6, 6030401],
      [3, 3991]
    ];
    kernel.build.apply(kernel, args);
    kernel.run.apply(kernel, args);
    const result = kernel.renderOutput();
    kernel.destroy(true);
    return result[0] === 2 && result[1] === 1511;
  }

  static getIsSpeedTacticSupported() {
    function kernelFunction(value) {
      return value[this.thread.x];
    }
    const kernel = new this(kernelFunction.toString(), {
      context: this.testContext,
      canvas: this.testCanvas,
      validate: false,
      output: [4],
      returnType: 'Number',
      precision: 'unsigned',
      tactic: 'speed',
    });
    const args = [
      [0, 1, 2, 3]
    ];
    kernel.build.apply(kernel, args);
    kernel.run.apply(kernel, args);
    const result = kernel.renderOutput();
    kernel.destroy(true);
    return Math.round(result[0]) === 0 && Math.round(result[1]) === 1 && Math.round(result[2]) === 2 && Math.round(result[3]) === 3;
  }

  static get testCanvas() {
    throw new Error(`"testCanvas" not defined on ${ this.name }`);
  }

  static get testContext() {
    throw new Error(`"testContext" not defined on ${ this.name }`);
  }

  static getFeatures() {
    const gl = this.testContext;
    const isDrawBuffers = this.getIsDrawBuffers();
    return Object.freeze({
      isFloatRead: this.getIsFloatRead(),
      isIntegerDivisionAccurate: this.getIsIntegerDivisionAccurate(),
      isSpeedTacticSupported: this.getIsSpeedTacticSupported(),
      isTextureFloat: this.getIsTextureFloat(),
      isDrawBuffers,
      kernelMap: isDrawBuffers,
      channelCount: this.getChannelCount(),
      maxTextureSize: this.getMaxTextureSize(),
      lowIntPrecision: gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.LOW_INT),
      lowFloatPrecision: gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.LOW_FLOAT),
      mediumIntPrecision: gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_INT),
      mediumFloatPrecision: gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT),
      highIntPrecision: gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_INT),
      highFloatPrecision: gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT),
    });
  }

  static setupFeatureChecks() {
    throw new Error(`"setupFeatureChecks" not defined on ${ this.name }`);
  }

  static getSignature(kernel, argumentTypes) {
    return kernel.getVariablePrecisionString() + (argumentTypes.length > 0 ? ':' + argumentTypes.join(',') : '');
  }

  setFixIntegerDivisionAccuracy(fix) {
    this.fixIntegerDivisionAccuracy = fix;
    return this;
  }

  setPrecision(flag) {
    this.precision = flag;
    return this;
  }

  setFloatTextures(flag) {
    utils.warnDeprecated('method', 'setFloatTextures', 'setOptimizeFloatMemory');
    this.floatTextures = flag;
    return this;
  }

  static nativeFunctionArguments(source) {
    const argumentTypes = [];
    const argumentNames = [];
    const states = [];
    const isStartingVariableName = /^[a-zA-Z_]/;
    const isVariableChar = /[a-zA-Z_0-9]/;
    let i = 0;
    let argumentName = null;
    let argumentType = null;
    while (i < source.length) {
      const char = source[i];
      const nextChar = source[i + 1];
      const state = states.length > 0 ? states[states.length - 1] : null;

      if (state === 'FUNCTION_ARGUMENTS' && char === '/' && nextChar === '*') {
        states.push('MULTI_LINE_COMMENT');
        i += 2;
        continue;
      } else if (state === 'MULTI_LINE_COMMENT' && char === '*' && nextChar === '/') {
        states.pop();
        i += 2;
        continue;
      }

      else if (state === 'FUNCTION_ARGUMENTS' && char === '/' && nextChar === '/') {
        states.push('COMMENT');
        i += 2;
        continue;
      } else if (state === 'COMMENT' && char === '\n') {
        states.pop();
        i++;
        continue;
      }

      else if (state === null && char === '(') {
        states.push('FUNCTION_ARGUMENTS');
        i++;
        continue;
      } else if (state === 'FUNCTION_ARGUMENTS') {
        if (char === ')') {
          states.pop();
          break;
        }
        if (char === 'f' && nextChar === 'l' && source[i + 2] === 'o' && source[i + 3] === 'a' && source[i + 4] === 't' && source[i + 5] === ' ') {
          states.push('DECLARE_VARIABLE');
          argumentType = 'float';
          argumentName = '';
          i += 6;
          continue;
        } else if (char === 'i' && nextChar === 'n' && source[i + 2] === 't' && source[i + 3] === ' ') {
          states.push('DECLARE_VARIABLE');
          argumentType = 'int';
          argumentName = '';
          i += 4;
          continue;
        } else if (char === 'v' && nextChar === 'e' && source[i + 2] === 'c' && source[i + 3] === '2' && source[i + 4] === ' ') {
          states.push('DECLARE_VARIABLE');
          argumentType = 'vec2';
          argumentName = '';
          i += 5;
          continue;
        } else if (char === 'v' && nextChar === 'e' && source[i + 2] === 'c' && source[i + 3] === '3' && source[i + 4] === ' ') {
          states.push('DECLARE_VARIABLE');
          argumentType = 'vec3';
          argumentName = '';
          i += 5;
          continue;
        } else if (char === 'v' && nextChar === 'e' && source[i + 2] === 'c' && source[i + 3] === '4' && source[i + 4] === ' ') {
          states.push('DECLARE_VARIABLE');
          argumentType = 'vec4';
          argumentName = '';
          i += 5;
          continue;
        }
      }

      else if (state === 'DECLARE_VARIABLE') {
        if (argumentName === '') {
          if (char === ' ') {
            i++;
            continue;
          }
          if (!isStartingVariableName.test(char)) {
            throw new Error('variable name is not expected string');
          }
        }
        argumentName += char;
        if (!isVariableChar.test(nextChar)) {
          states.pop();
          argumentNames.push(argumentName);
          argumentTypes.push(typeMap[argumentType]);
        }
      }

      i++;
    }
    if (states.length > 0) {
      throw new Error('GLSL function was not parsable');
    }
    return {
      argumentNames,
      argumentTypes,
    };
  }

  static nativeFunctionReturnType(source) {
    return typeMap[source.match(/int|float|vec[2-4]/)[0]];
  }

  static combineKernels(combinedKernel, lastKernel) {
    combinedKernel.apply(null, arguments);
    const {
      texSize,
      context,
      threadDim
    } = lastKernel.texSize;
    let result;
    if (lastKernel.precision === 'single') {
      const w = texSize[0];
      const h = Math.ceil(texSize[1] / 4);
      result = new Float32Array(w * h * 4 * 4);
      context.readPixels(0, 0, w, h * 4, context.RGBA, context.FLOAT, result);
    } else {
      const bytes = new Uint8Array(texSize[0] * texSize[1] * 4);
      context.readPixels(0, 0, texSize[0], texSize[1], context.RGBA, context.UNSIGNED_BYTE, bytes);
      result = new Float32Array(bytes.buffer);
    }

    result = result.subarray(0, threadDim[0] * threadDim[1] * threadDim[2]);

    if (lastKernel.output.length === 1) {
      return result;
    } else if (lastKernel.output.length === 2) {
      return utils.splitArray(result, lastKernel.output[0]);
    } else if (lastKernel.output.length === 3) {
      const cube = utils.splitArray(result, lastKernel.output[0] * lastKernel.output[1]);
      return cube.map(function(x) {
        return utils.splitArray(x, lastKernel.output[0]);
      });
    }
  }

  constructor(source, settings) {
    super(source, settings);
    this.transferValues = null;
    this.formatValues = null;
    this.TextureConstructor = null;
    this.renderOutput = null;
    this.renderRawOutput = null;
    this.texSize = null;
    this.translatedSource = null;
    this.compiledFragmentShader = null;
    this.compiledVertexShader = null;
    this.switchingKernels = null;
    this._textureSwitched = null;
    this._mappedTextureSwitched = null;
  }

  checkTextureSize() {
    const { features } = this.constructor;
    if (this.texSize[0] > features.maxTextureSize || this.texSize[1] > features.maxTextureSize) {
      throw new Error(`Texture size [${this.texSize[0]},${this.texSize[1]}] generated by kernel is larger than supported size [${features.maxTextureSize},${features.maxTextureSize}]`);
    }
  }

  translateSource() {
    throw new Error(`"translateSource" not defined on ${this.constructor.name}`);
  }

  pickRenderStrategy(args) {
    if (this.graphical) {
      this.renderRawOutput = this.readPackedPixelsToUint8Array;
      this.transferValues = (pixels) => pixels;
      this.TextureConstructor = GLTextureGraphical;
      return null;
    }
    if (this.precision === 'unsigned') {
      this.renderRawOutput = this.readPackedPixelsToUint8Array;
      this.transferValues = this.readPackedPixelsToFloat32Array;
      if (this.pipeline) {
        this.renderOutput = this.renderTexture;
        if (this.subKernels !== null) {
          this.renderKernels = this.renderKernelsToTextures;
        }
        switch (this.returnType) {
          case 'LiteralInteger':
          case 'Float':
          case 'Number':
          case 'Integer':
            if (this.output[2] > 0) {
              this.TextureConstructor = GLTextureUnsigned3D;
              return null;
            } else if (this.output[1] > 0) {
              this.TextureConstructor = GLTextureUnsigned2D;
              return null;
            } else {
              this.TextureConstructor = GLTextureUnsigned;
              return null;
            }
            case 'Array(2)':
            case 'Array(3)':
            case 'Array(4)':
              return this.requestFallback(args);
        }
      } else {
        if (this.subKernels !== null) {
          this.renderKernels = this.renderKernelsToArrays;
        }
        switch (this.returnType) {
          case 'LiteralInteger':
          case 'Float':
          case 'Number':
          case 'Integer':
            this.renderOutput = this.renderValues;
            if (this.output[2] > 0) {
              this.TextureConstructor = GLTextureUnsigned3D;
              this.formatValues = utils.erect3DPackedFloat;
              return null;
            } else if (this.output[1] > 0) {
              this.TextureConstructor = GLTextureUnsigned2D;
              this.formatValues = utils.erect2DPackedFloat;
              return null;
            } else {
              this.TextureConstructor = GLTextureUnsigned;
              this.formatValues = utils.erectPackedFloat;
              return null;
            }
            case 'Array(2)':
            case 'Array(3)':
            case 'Array(4)':
              return this.requestFallback(args);
        }
      }
    } else if (this.precision === 'single') {
      this.renderRawOutput = this.readFloatPixelsToFloat32Array;
      this.transferValues = this.readFloatPixelsToFloat32Array;
      if (this.pipeline) {
        this.renderOutput = this.renderTexture;
        if (this.subKernels !== null) {
          this.renderKernels = this.renderKernelsToTextures;
        }
        switch (this.returnType) {
          case 'LiteralInteger':
          case 'Float':
          case 'Number':
          case 'Integer': {
            if (this.optimizeFloatMemory) {
              if (this.output[2] > 0) {
                this.TextureConstructor = GLTextureMemoryOptimized3D;
                return null;
              } else if (this.output[1] > 0) {
                this.TextureConstructor = GLTextureMemoryOptimized2D;
                return null;
              } else {
                this.TextureConstructor = GLTextureMemoryOptimized;
                return null;
              }
            } else {
              if (this.output[2] > 0) {
                this.TextureConstructor = GLTextureFloat3D;
                return null;
              } else if (this.output[1] > 0) {
                this.TextureConstructor = GLTextureFloat2D;
                return null;
              } else {
                this.TextureConstructor = GLTextureFloat;
                return null;
              }
            }
          }
          case 'Array(2)': {
            if (this.output[2] > 0) {
              this.TextureConstructor = GLTextureArray2Float3D;
              return null;
            } else if (this.output[1] > 0) {
              this.TextureConstructor = GLTextureArray2Float2D;
              return null;
            } else {
              this.TextureConstructor = GLTextureArray2Float;
              return null;
            }
          }
          case 'Array(3)': {
            if (this.output[2] > 0) {
              this.TextureConstructor = GLTextureArray3Float3D;
              return null;
            } else if (this.output[1] > 0) {
              this.TextureConstructor = GLTextureArray3Float2D;
              return null;
            } else {
              this.TextureConstructor = GLTextureArray3Float;
              return null;
            }
          }
          case 'Array(4)': {
            if (this.output[2] > 0) {
              this.TextureConstructor = GLTextureArray4Float3D;
              return null;
            } else if (this.output[1] > 0) {
              this.TextureConstructor = GLTextureArray4Float2D;
              return null;
            } else {
              this.TextureConstructor = GLTextureArray4Float;
              return null;
            }
          }
        }
      }
      this.renderOutput = this.renderValues;
      if (this.subKernels !== null) {
        this.renderKernels = this.renderKernelsToArrays;
      }
      if (this.optimizeFloatMemory) {
        switch (this.returnType) {
          case 'LiteralInteger':
          case 'Float':
          case 'Number':
          case 'Integer': {
            if (this.output[2] > 0) {
              this.TextureConstructor = GLTextureMemoryOptimized3D;
              this.formatValues = utils.erectMemoryOptimized3DFloat;
              return null;
            } else if (this.output[1] > 0) {
              this.TextureConstructor = GLTextureMemoryOptimized2D;
              this.formatValues = utils.erectMemoryOptimized2DFloat;
              return null;
            } else {
              this.TextureConstructor = GLTextureMemoryOptimized;
              this.formatValues = utils.erectMemoryOptimizedFloat;
              return null;
            }
          }
          case 'Array(2)': {
            if (this.output[2] > 0) {
              this.TextureConstructor = GLTextureArray2Float3D;
              this.formatValues = utils.erect3DArray2;
              return null;
            } else if (this.output[1] > 0) {
              this.TextureConstructor = GLTextureArray2Float2D;
              this.formatValues = utils.erect2DArray2;
              return null;
            } else {
              this.TextureConstructor = GLTextureArray2Float;
              this.formatValues = utils.erectArray2;
              return null;
            }
          }
          case 'Array(3)': {
            if (this.output[2] > 0) {
              this.TextureConstructor = GLTextureArray3Float3D;
              this.formatValues = utils.erect3DArray3;
              return null;
            } else if (this.output[1] > 0) {
              this.TextureConstructor = GLTextureArray3Float2D;
              this.formatValues = utils.erect2DArray3;
              return null;
            } else {
              this.TextureConstructor = GLTextureArray3Float;
              this.formatValues = utils.erectArray3;
              return null;
            }
          }
          case 'Array(4)': {
            if (this.output[2] > 0) {
              this.TextureConstructor = GLTextureArray4Float3D;
              this.formatValues = utils.erect3DArray4;
              return null;
            } else if (this.output[1] > 0) {
              this.TextureConstructor = GLTextureArray4Float2D;
              this.formatValues = utils.erect2DArray4;
              return null;
            } else {
              this.TextureConstructor = GLTextureArray4Float;
              this.formatValues = utils.erectArray4;
              return null;
            }
          }
        }
      } else {
        switch (this.returnType) {
          case 'LiteralInteger':
          case 'Float':
          case 'Number':
          case 'Integer': {
            if (this.output[2] > 0) {
              this.TextureConstructor = GLTextureFloat3D;
              this.formatValues = utils.erect3DFloat;
              return null;
            } else if (this.output[1] > 0) {
              this.TextureConstructor = GLTextureFloat2D;
              this.formatValues = utils.erect2DFloat;
              return null;
            } else {
              this.TextureConstructor = GLTextureFloat;
              this.formatValues = utils.erectFloat;
              return null;
            }
          }
          case 'Array(2)': {
            if (this.output[2] > 0) {
              this.TextureConstructor = GLTextureArray2Float3D;
              this.formatValues = utils.erect3DArray2;
              return null;
            } else if (this.output[1] > 0) {
              this.TextureConstructor = GLTextureArray2Float2D;
              this.formatValues = utils.erect2DArray2;
              return null;
            } else {
              this.TextureConstructor = GLTextureArray2Float;
              this.formatValues = utils.erectArray2;
              return null;
            }
          }
          case 'Array(3)': {
            if (this.output[2] > 0) {
              this.TextureConstructor = GLTextureArray3Float3D;
              this.formatValues = utils.erect3DArray3;
              return null;
            } else if (this.output[1] > 0) {
              this.TextureConstructor = GLTextureArray3Float2D;
              this.formatValues = utils.erect2DArray3;
              return null;
            } else {
              this.TextureConstructor = GLTextureArray3Float;
              this.formatValues = utils.erectArray3;
              return null;
            }
          }
          case 'Array(4)': {
            if (this.output[2] > 0) {
              this.TextureConstructor = GLTextureArray4Float3D;
              this.formatValues = utils.erect3DArray4;
              return null;
            } else if (this.output[1] > 0) {
              this.TextureConstructor = GLTextureArray4Float2D;
              this.formatValues = utils.erect2DArray4;
              return null;
            } else {
              this.TextureConstructor = GLTextureArray4Float;
              this.formatValues = utils.erectArray4;
              return null;
            }
          }
        }
      }
    } else {
      throw new Error(`unhandled precision of "${this.precision}"`);
    }

    throw new Error(`unhandled return type "${this.returnType}"`);
  }

  getKernelString() {
    throw new Error(`abstract method call`);
  }

  getMainResultTexture() {
    switch (this.returnType) {
      case 'LiteralInteger':
      case 'Float':
      case 'Integer':
      case 'Number':
        return this.getMainResultNumberTexture();
      case 'Array(2)':
        return this.getMainResultArray2Texture();
      case 'Array(3)':
        return this.getMainResultArray3Texture();
      case 'Array(4)':
        return this.getMainResultArray4Texture();
      default:
        throw new Error(`unhandled returnType type ${ this.returnType }`);
    }
  }

  getMainResultKernelNumberTexture() {
    throw new Error(`abstract method call`);
  }
  getMainResultSubKernelNumberTexture() {
    throw new Error(`abstract method call`);
  }
  getMainResultKernelArray2Texture() {
    throw new Error(`abstract method call`);
  }
  getMainResultSubKernelArray2Texture() {
    throw new Error(`abstract method call`);
  }
  getMainResultKernelArray3Texture() {
    throw new Error(`abstract method call`);
  }
  getMainResultSubKernelArray3Texture() {
    throw new Error(`abstract method call`);
  }
  getMainResultKernelArray4Texture() {
    throw new Error(`abstract method call`);
  }
  getMainResultSubKernelArray4Texture() {
    throw new Error(`abstract method call`);
  }
  getMainResultGraphical() {
    throw new Error(`abstract method call`);
  }
  getMainResultMemoryOptimizedFloats() {
    throw new Error(`abstract method call`);
  }
  getMainResultPackedPixels() {
    throw new Error(`abstract method call`);
  }

  getMainResultString() {
    if (this.graphical) {
      return this.getMainResultGraphical();
    } else if (this.precision === 'single') {
      if (this.optimizeFloatMemory) {
        return this.getMainResultMemoryOptimizedFloats();
      }
      return this.getMainResultTexture();
    } else {
      return this.getMainResultPackedPixels();
    }
  }

  getMainResultNumberTexture() {
    return utils.linesToString(this.getMainResultKernelNumberTexture()) +
      utils.linesToString(this.getMainResultSubKernelNumberTexture());
  }

  getMainResultArray2Texture() {
    return utils.linesToString(this.getMainResultKernelArray2Texture()) +
      utils.linesToString(this.getMainResultSubKernelArray2Texture());
  }

  getMainResultArray3Texture() {
    return utils.linesToString(this.getMainResultKernelArray3Texture()) +
      utils.linesToString(this.getMainResultSubKernelArray3Texture());
  }

  getMainResultArray4Texture() {
    return utils.linesToString(this.getMainResultKernelArray4Texture()) +
      utils.linesToString(this.getMainResultSubKernelArray4Texture());
  }

  getFloatTacticDeclaration() {
    const variablePrecision = this.getVariablePrecisionString(this.texSize, this.tactic);
    return `precision ${variablePrecision} float;\n`;
  }

  getIntTacticDeclaration() {
    return `precision ${this.getVariablePrecisionString(this.texSize, this.tactic, true)} int;\n`;
  }

  getSampler2DTacticDeclaration() {
    return `precision ${this.getVariablePrecisionString(this.texSize, this.tactic)} sampler2D;\n`;
  }

  getSampler2DArrayTacticDeclaration() {
    return `precision ${this.getVariablePrecisionString(this.texSize, this.tactic)} sampler2DArray;\n`;
  }

  renderTexture() {
    return this.immutable ? this.texture.clone() : this.texture;
  }
  readPackedPixelsToUint8Array() {
    if (this.precision !== 'unsigned') throw new Error('Requires this.precision to be "unsigned"');
    const {
      texSize,
      context: gl
    } = this;
    const result = new Uint8Array(texSize[0] * texSize[1] * 4);
    gl.readPixels(0, 0, texSize[0], texSize[1], gl.RGBA, gl.UNSIGNED_BYTE, result);
    return result;
  }

  readPackedPixelsToFloat32Array() {
    return new Float32Array(this.readPackedPixelsToUint8Array().buffer);
  }

  readFloatPixelsToFloat32Array() {
    if (this.precision !== 'single') throw new Error('Requires this.precision to be "single"');
    const {
      texSize,
      context: gl
    } = this;
    const w = texSize[0];
    const h = texSize[1];
    const result = new Float32Array(w * h * 4);
    gl.readPixels(0, 0, w, h, gl.RGBA, gl.FLOAT, result);
    return result;
  }

  getPixels(flip) {
    const {
      context: gl,
      output
    } = this;
    const [width, height] = output;
    const pixels = new Uint8Array(width * height * 4);
    gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
    return new Uint8ClampedArray((flip ? pixels : utils.flipPixels(pixels, width, height)).buffer);
  }

  renderKernelsToArrays() {
    const result = {
      result: this.renderOutput(),
    };
    for (let i = 0; i < this.subKernels.length; i++) {
      result[this.subKernels[i].property] = this.mappedTextures[i].toArray();
    }
    return result;
  }

  renderKernelsToTextures() {
    const result = {
      result: this.renderOutput(),
    };
    if (this.immutable) {
      for (let i = 0; i < this.subKernels.length; i++) {
        result[this.subKernels[i].property] = this.mappedTextures[i].clone();
      }
    } else {
      for (let i = 0; i < this.subKernels.length; i++) {
        result[this.subKernels[i].property] = this.mappedTextures[i];
      }
    }
    return result;
  }

  resetSwitchingKernels() {
    const existingValue = this.switchingKernels;
    this.switchingKernels = null;
    return existingValue;
  }

  setOutput(output) {
    const newOutput = this.toKernelOutput(output);
    if (this.program) {
      if (!this.dynamicOutput) {
        throw new Error('Resizing a kernel with dynamicOutput: false is not possible');
      }
      const newThreadDim = [newOutput[0], newOutput[1] || 1, newOutput[2] || 1];
      const newTexSize = utils.getKernelTextureSize({
        optimizeFloatMemory: this.optimizeFloatMemory,
        precision: this.precision,
      }, newThreadDim);
      const oldTexSize = this.texSize;
      if (oldTexSize) {
        const oldPrecision = this.getVariablePrecisionString(oldTexSize, this.tactic);
        const newPrecision = this.getVariablePrecisionString(newTexSize, this.tactic);
        if (oldPrecision !== newPrecision) {
          if (this.debug) {
            console.warn('Precision requirement changed, asking GPU instance to recompile');
          }
          this.switchKernels({
            type: 'outputPrecisionMismatch',
            precision: newPrecision,
            needed: output
          });
          return;
        }
      }
      this.output = newOutput;
      this.threadDim = newThreadDim;
      this.texSize = newTexSize;
      const { context: gl } = this;
      gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);
      this.updateMaxTexSize();
      this.framebuffer.width = this.texSize[0];
      this.framebuffer.height = this.texSize[1];
      gl.viewport(0, 0, this.maxTexSize[0], this.maxTexSize[1]);
      this.canvas.width = this.maxTexSize[0];
      this.canvas.height = this.maxTexSize[1];
      if (this.texture) {
        this.texture.delete();
      }
      this.texture = null;
      this._setupOutputTexture();
      if (this.mappedTextures && this.mappedTextures.length > 0) {
        for (let i = 0; i < this.mappedTextures.length; i++) {
          this.mappedTextures[i].delete();
        }
        this.mappedTextures = null;
        this._setupSubOutputTextures();
      }
    } else {
      this.output = newOutput;
    }
    return this;
  }
  renderValues() {
    return this.formatValues(
      this.transferValues(),
      this.output[0],
      this.output[1],
      this.output[2]
    );
  }
  switchKernels(reason) {
    if (this.switchingKernels) {
      this.switchingKernels.push(reason);
    } else {
      this.switchingKernels = [reason];
    }
  }
  getVariablePrecisionString(textureSize = this.texSize, tactic = this.tactic, isInt = false) {
    if (!tactic) {
      if (!this.constructor.features.isSpeedTacticSupported) return 'highp';
      const low = this.constructor.features[isInt ? 'lowIntPrecision' : 'lowFloatPrecision'];
      const medium = this.constructor.features[isInt ? 'mediumIntPrecision' : 'mediumFloatPrecision'];
      const high = this.constructor.features[isInt ? 'highIntPrecision' : 'highFloatPrecision'];
      const requiredSize = Math.log2(textureSize[0] * textureSize[1]);
      if (requiredSize <= low.rangeMax) {
        return 'lowp';
      } else if (requiredSize <= medium.rangeMax) {
        return 'mediump';
      } else if (requiredSize <= high.rangeMax) {
        return 'highp';
      } else {
        throw new Error(`The required size exceeds that of the ability of your system`);
      }
    }
    switch (tactic) {
      case 'speed':
        return 'lowp';
      case 'balanced':
        return 'mediump';
      case 'precision':
        return 'highp';
      default:
        throw new Error(`Unknown tactic "${tactic}" use "speed", "balanced", "precision", or empty for auto`);
    }
  }

  updateTextureArgumentRefs(kernelValue, arg) {
    if (!this.immutable) return;
    if (this.texture.texture === arg.texture) {
      const { prevArg } = kernelValue;
      if (prevArg) {
        if (prevArg.texture._refs === 1) {
          this.texture.delete();
          this.texture = prevArg.clone();
          this._textureSwitched = true;
        }
        prevArg.delete();
      }
      kernelValue.prevArg = arg.clone();
    } else if (this.mappedTextures && this.mappedTextures.length > 0) {
      const { mappedTextures } = this;
      for (let i = 0; i < mappedTextures.length; i++) {
        const mappedTexture = mappedTextures[i];
        if (mappedTexture.texture === arg.texture) {
          const { prevArg } = kernelValue;
          if (prevArg) {
            if (prevArg.texture._refs === 1) {
              mappedTexture.delete();
              mappedTextures[i] = prevArg.clone();
              this._mappedTextureSwitched[i] = true;
            }
            prevArg.delete();
          }
          kernelValue.prevArg = arg.clone();
          return;
        }
      }
    }
  }

  onActivate(previousKernel) {
    this._textureSwitched = true;
    this.texture = previousKernel.texture;
    if (this.mappedTextures) {
      for (let i = 0; i < this.mappedTextures.length; i++) {
        this._mappedTextureSwitched[i] = true;
      }
      this.mappedTextures = previousKernel.mappedTextures;
    }
  }

  initCanvas() {}
}

const typeMap = {
  int: 'Integer',
  float: 'Number',
  vec2: 'Array(2)',
  vec3: 'Array(3)',
  vec4: 'Array(4)',
};

module.exports = {
  GLKernel
};
},{"../../utils":114,"../kernel":36,"./texture/array-2-float":16,"./texture/array-2-float-2d":14,"./texture/array-2-float-3d":15,"./texture/array-3-float":19,"./texture/array-3-float-2d":17,"./texture/array-3-float-3d":18,"./texture/array-4-float":22,"./texture/array-4-float-2d":20,"./texture/array-4-float-3d":21,"./texture/float":25,"./texture/float-2d":23,"./texture/float-3d":24,"./texture/graphical":26,"./texture/memory-optimized":30,"./texture/memory-optimized-2d":28,"./texture/memory-optimized-3d":29,"./texture/unsigned":33,"./texture/unsigned-2d":31,"./texture/unsigned-3d":32}],14:[function(require,module,exports){
const { utils } = require('../../../utils');
const { GLTextureFloat } = require('./float');

class GLTextureArray2Float2D extends GLTextureFloat {
  constructor(settings) {
    super(settings);
    this.type = 'ArrayTexture(2)';
  }
  toArray() {
    return utils.erect2DArray2(this.renderValues(), this.output[0], this.output[1]);
  }
}

module.exports = {
  GLTextureArray2Float2D
};
},{"../../../utils":114,"./float":25}],15:[function(require,module,exports){
const { utils } = require('../../../utils');
const { GLTextureFloat } = require('./float');

class GLTextureArray2Float3D extends GLTextureFloat {
  constructor(settings) {
    super(settings);
    this.type = 'ArrayTexture(2)';
  }
  toArray() {
    return utils.erect3DArray2(this.renderValues(), this.output[0], this.output[1], this.output[2]);
  }
}

module.exports = {
  GLTextureArray2Float3D
};
},{"../../../utils":114,"./float":25}],16:[function(require,module,exports){
const { utils } = require('../../../utils');
const { GLTextureFloat } = require('./float');

class GLTextureArray2Float extends GLTextureFloat {
  constructor(settings) {
    super(settings);
    this.type = 'ArrayTexture(2)';
  }
  toArray() {
    return utils.erectArray2(this.renderValues(), this.output[0], this.output[1]);
  }
}

module.exports = {
  GLTextureArray2Float
};
},{"../../../utils":114,"./float":25}],17:[function(require,module,exports){
const { utils } = require('../../../utils');
const { GLTextureFloat } = require('./float');

class GLTextureArray3Float2D extends GLTextureFloat {
  constructor(settings) {
    super(settings);
    this.type = 'ArrayTexture(3)';
  }
  toArray() {
    return utils.erect2DArray3(this.renderValues(), this.output[0], this.output[1]);
  }
}

module.exports = {
  GLTextureArray3Float2D
};
},{"../../../utils":114,"./float":25}],18:[function(require,module,exports){
const { utils } = require('../../../utils');
const { GLTextureFloat } = require('./float');

class GLTextureArray3Float3D extends GLTextureFloat {
  constructor(settings) {
    super(settings);
    this.type = 'ArrayTexture(3)';
  }
  toArray() {
    return utils.erect3DArray3(this.renderValues(), this.output[0], this.output[1], this.output[2]);
  }
}

module.exports = {
  GLTextureArray3Float3D
};
},{"../../../utils":114,"./float":25}],19:[function(require,module,exports){
const { utils } = require('../../../utils');
const { GLTextureFloat } = require('./float');

class GLTextureArray3Float extends GLTextureFloat {
  constructor(settings) {
    super(settings);
    this.type = 'ArrayTexture(3)';
  }
  toArray() {
    return utils.erectArray3(this.renderValues(), this.output[0]);
  }
}

module.exports = {
  GLTextureArray3Float
};
},{"../../../utils":114,"./float":25}],20:[function(require,module,exports){
const { utils } = require('../../../utils');
const { GLTextureFloat } = require('./float');

class GLTextureArray4Float2D extends GLTextureFloat {
  constructor(settings) {
    super(settings);
    this.type = 'ArrayTexture(4)';
  }
  toArray() {
    return utils.erect2DArray4(this.renderValues(), this.output[0], this.output[1]);
  }
}

module.exports = {
  GLTextureArray4Float2D
};
},{"../../../utils":114,"./float":25}],21:[function(require,module,exports){
const { utils } = require('../../../utils');
const { GLTextureFloat } = require('./float');

class GLTextureArray4Float3D extends GLTextureFloat {
  constructor(settings) {
    super(settings);
    this.type = 'ArrayTexture(4)';
  }
  toArray() {
    return utils.erect3DArray4(this.renderValues(), this.output[0], this.output[1], this.output[2]);
  }
}

module.exports = {
  GLTextureArray4Float3D
};
},{"../../../utils":114,"./float":25}],22:[function(require,module,exports){
const { utils } = require('../../../utils');
const { GLTextureFloat } = require('./float');

class GLTextureArray4Float extends GLTextureFloat {
  constructor(settings) {
    super(settings);
    this.type = 'ArrayTexture(4)';
  }
  toArray() {
    return utils.erectArray4(this.renderValues(), this.output[0]);
  }
}

module.exports = {
  GLTextureArray4Float
};
},{"../../../utils":114,"./float":25}],23:[function(require,module,exports){
const { utils } = require('../../../utils');
const { GLTextureFloat } = require('./float');

class GLTextureFloat2D extends GLTextureFloat {
  constructor(settings) {
    super(settings);
    this.type = 'ArrayTexture(1)';
  }
  toArray() {
    return utils.erect2DFloat(this.renderValues(), this.output[0], this.output[1]);
  }
}

module.exports = {
  GLTextureFloat2D
};
},{"../../../utils":114,"./float":25}],24:[function(require,module,exports){
const { utils } = require('../../../utils');
const { GLTextureFloat } = require('./float');

class GLTextureFloat3D extends GLTextureFloat {
  constructor(settings) {
    super(settings);
    this.type = 'ArrayTexture(1)';
  }
  toArray() {
    return utils.erect3DFloat(this.renderValues(), this.output[0], this.output[1], this.output[2]);
  }
}

module.exports = {
  GLTextureFloat3D
};
},{"../../../utils":114,"./float":25}],25:[function(require,module,exports){
const { utils } = require('../../../utils');
const { GLTexture } = require('./index');

class GLTextureFloat extends GLTexture {
  get textureType() {
    return this.context.FLOAT;
  }
  constructor(settings) {
    super(settings);
    this.type = 'ArrayTexture(1)';
  }
  renderRawOutput() {
    const gl = this.context;
    const size = this.size;
    gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer());
    gl.framebufferTexture2D(
      gl.FRAMEBUFFER,
      gl.COLOR_ATTACHMENT0,
      gl.TEXTURE_2D,
      this.texture,
      0
    );
    const result = new Float32Array(size[0] * size[1] * 4);
    gl.readPixels(0, 0, size[0], size[1], gl.RGBA, gl.FLOAT, result);
    return result;
  }
  renderValues() {
    if (this._deleted) return null;
    return this.renderRawOutput();
  }
  toArray() {
    return utils.erectFloat(this.renderValues(), this.output[0]);
  }
}

module.exports = {
  GLTextureFloat
};
},{"../../../utils":114,"./index":27}],26:[function(require,module,exports){
const { GLTextureUnsigned } = require('./unsigned');

class GLTextureGraphical extends GLTextureUnsigned {
  constructor(settings) {
    super(settings);
    this.type = 'ArrayTexture(4)';
  }
  toArray() {
    return this.renderValues();
  }
}

module.exports = {
  GLTextureGraphical
};
},{"./unsigned":33}],27:[function(require,module,exports){
const { Texture } = require('../../../texture');

class GLTexture extends Texture {
  get textureType() {
    throw new Error(`"textureType" not implemented on ${ this.name }`);
  }

  clone() {
    return new this.constructor(this);
  }

  beforeMutate() {
    if (this.texture._refs > 1) {
      this.newTexture();
      return true;
    }
    return false;
  }

  cloneTexture() {
    this.texture._refs--;
    const { context: gl, size, texture, kernel } = this;
    if (kernel.debug) {
      console.warn('cloning internal texture');
    }
    gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer());
    selectTexture(gl, texture);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
    const target = gl.createTexture();
    selectTexture(gl, target);
    gl.texImage2D(gl.TEXTURE_2D, 0, this.internalFormat, size[0], size[1], 0, this.textureFormat, this.textureType, null);
    gl.copyTexSubImage2D(gl.TEXTURE_2D, 0, 0, 0, 0, 0, size[0], size[1]);
    target._refs = 1;
    this.texture = target;
  }

  newTexture() {
    this.texture._refs--;
    const gl = this.context;
    const size = this.size;
    const kernel = this.kernel;
    if (kernel.debug) {
      console.warn('new internal texture');
    }
    const target = gl.createTexture();
    selectTexture(gl, target);
    gl.texImage2D(gl.TEXTURE_2D, 0, this.internalFormat, size[0], size[1], 0, this.textureFormat, this.textureType, null);
    target._refs = 1;
    this.texture = target;
  }

  clear() {
    if (this.texture._refs) {
      this.texture._refs--;
      const gl = this.context;
      const target = this.texture = gl.createTexture();
      selectTexture(gl, target);
      const size = this.size;
      target._refs = 1;
      gl.texImage2D(gl.TEXTURE_2D, 0, this.internalFormat, size[0], size[1], 0, this.textureFormat, this.textureType, null);
    }
    const { context: gl, texture } = this;
    gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer());
    gl.bindTexture(gl.TEXTURE_2D, texture);
    selectTexture(gl, texture);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
    gl.clearColor(0, 0, 0, 0);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
  }

  delete() {
    if (this._deleted) return;
    this._deleted = true;
    if (this.texture._refs) {
      this.texture._refs--;
      if (this.texture._refs) return;
    }
    this.context.deleteTexture(this.texture);
  }

  framebuffer() {
    if (!this._framebuffer) {
      this._framebuffer = this.kernel.getRawValueFramebuffer(this.size[0], this.size[1]);
    }
    return this._framebuffer;
  }
}

function selectTexture(gl, texture) {
  gl.activeTexture(gl.TEXTURE15);
  gl.bindTexture(gl.TEXTURE_2D, texture);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
}

module.exports = { GLTexture };
},{"../../../texture":113}],28:[function(require,module,exports){
const { utils } = require('../../../utils');
const { GLTextureFloat } = require('./float');

class GLTextureMemoryOptimized2D extends GLTextureFloat {
  constructor(settings) {
    super(settings);
    this.type = 'MemoryOptimizedNumberTexture';
  }
  toArray() {
    return utils.erectMemoryOptimized2DFloat(this.renderValues(), this.output[0], this.output[1]);
  }
}

module.exports = {
  GLTextureMemoryOptimized2D
};
},{"../../../utils":114,"./float":25}],29:[function(require,module,exports){
const { utils } = require('../../../utils');
const { GLTextureFloat } = require('./float');

class GLTextureMemoryOptimized3D extends GLTextureFloat {
  constructor(settings) {
    super(settings);
    this.type = 'MemoryOptimizedNumberTexture';
  }
  toArray() {
    return utils.erectMemoryOptimized3DFloat(this.renderValues(), this.output[0], this.output[1], this.output[2]);
  }
}

module.exports = {
  GLTextureMemoryOptimized3D
};
},{"../../../utils":114,"./float":25}],30:[function(require,module,exports){
const { utils } = require('../../../utils');
const { GLTextureFloat } = require('./float');

class GLTextureMemoryOptimized extends GLTextureFloat {
  constructor(settings) {
    super(settings);
    this.type = 'MemoryOptimizedNumberTexture';
  }
  toArray() {
    return utils.erectMemoryOptimizedFloat(this.renderValues(), this.output[0]);
  }
}

module.exports = {
  GLTextureMemoryOptimized
};
},{"../../../utils":114,"./float":25}],31:[function(require,module,exports){
const { utils } = require('../../../utils');
const { GLTextureUnsigned } = require('./unsigned');

class GLTextureUnsigned2D extends GLTextureUnsigned {
  constructor(settings) {
    super(settings);
    this.type = 'NumberTexture';
  }
  toArray() {
    return utils.erect2DPackedFloat(this.renderValues(), this.output[0], this.output[1]);
  }
}

module.exports = {
  GLTextureUnsigned2D
};
},{"../../../utils":114,"./unsigned":33}],32:[function(require,module,exports){
const { utils } = require('../../../utils');
const { GLTextureUnsigned } = require('./unsigned');

class GLTextureUnsigned3D extends GLTextureUnsigned {
  constructor(settings) {
    super(settings);
    this.type = 'NumberTexture';
  }
  toArray() {
    return utils.erect3DPackedFloat(this.renderValues(), this.output[0], this.output[1], this.output[2]);
  }
}

module.exports = {
  GLTextureUnsigned3D
};
},{"../../../utils":114,"./unsigned":33}],33:[function(require,module,exports){
const { utils } = require('../../../utils');
const { GLTexture } = require('./index');

class GLTextureUnsigned extends GLTexture {
  get textureType() {
    return this.context.UNSIGNED_BYTE;
  }
  constructor(settings) {
    super(settings);
    this.type = 'NumberTexture';
  }
  renderRawOutput() {
    const { context: gl } = this;
    gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer());
    gl.framebufferTexture2D(
      gl.FRAMEBUFFER,
      gl.COLOR_ATTACHMENT0,
      gl.TEXTURE_2D,
      this.texture,
      0
    );
    const result = new Uint8Array(this.size[0] * this.size[1] * 4);
    gl.readPixels(0, 0, this.size[0], this.size[1], gl.RGBA, gl.UNSIGNED_BYTE, result);
    return result;
  }
  renderValues() {
    if (this._deleted) return null;
    return new Float32Array(this.renderRawOutput().buffer);
  }
  toArray() {
    return utils.erectPackedFloat(this.renderValues(), this.output[0]);
  }
}

module.exports = {
  GLTextureUnsigned
};
},{"../../../utils":114,"./index":27}],34:[function(require,module,exports){
const getContext = require('gl');
const { WebGLKernel } = require('../web-gl/kernel');
const { glKernelString } = require('../gl/kernel-string');

let isSupported = null;
let testCanvas = null;
let testContext = null;
let testExtensions = null;
let features = null;

class HeadlessGLKernel extends WebGLKernel {
  static get isSupported() {
    if (isSupported !== null) return isSupported;
    this.setupFeatureChecks();
    isSupported = testContext !== null;
    return isSupported;
  }

  static setupFeatureChecks() {
    testCanvas = null;
    testExtensions = null;
    if (typeof getContext !== 'function') return;
    try { 
      testContext = getContext(2, 2, {
        preserveDrawingBuffer: true
      });
      if (!testContext || !testContext.getExtension) return;
      testExtensions = {
        STACKGL_resize_drawingbuffer: testContext.getExtension('STACKGL_resize_drawingbuffer'),
        STACKGL_destroy_context: testContext.getExtension('STACKGL_destroy_context'),
        OES_texture_float: testContext.getExtension('OES_texture_float'),
        OES_texture_float_linear: testContext.getExtension('OES_texture_float_linear'),
        OES_element_index_uint: testContext.getExtension('OES_element_index_uint'),
        WEBGL_draw_buffers: testContext.getExtension('WEBGL_draw_buffers'),
        WEBGL_color_buffer_float: testContext.getExtension('WEBGL_color_buffer_float'),
      };
      features = this.getFeatures();
    } catch (e) {
      console.warn(e);
    }
  }

  static isContextMatch(context) {
    try {
      return context.getParameter(context.RENDERER) === 'ANGLE';
    } catch (e) {
      return false;
    }
  }

  static getIsTextureFloat() {
    return Boolean(testExtensions.OES_texture_float);
  }

  static getIsDrawBuffers() {
    return Boolean(testExtensions.WEBGL_draw_buffers);
  }

  static getChannelCount() {
    return testExtensions.WEBGL_draw_buffers ?
      testContext.getParameter(testExtensions.WEBGL_draw_buffers.MAX_DRAW_BUFFERS_WEBGL) :
      1;
  }

  static getMaxTextureSize() {
    return testContext.getParameter(testContext.MAX_TEXTURE_SIZE);
  }

  static get testCanvas() {
    return testCanvas;
  }

  static get testContext() {
    return testContext;
  }

  static get features() {
    return features;
  }

  initCanvas() {
    return {};
  }

  initContext() {
    return getContext(2, 2, {
      preserveDrawingBuffer: true
    });
  }

  initExtensions() {
    this.extensions = {
      STACKGL_resize_drawingbuffer: this.context.getExtension('STACKGL_resize_drawingbuffer'),
      STACKGL_destroy_context: this.context.getExtension('STACKGL_destroy_context'),
      OES_texture_float: this.context.getExtension('OES_texture_float'),
      OES_texture_float_linear: this.context.getExtension('OES_texture_float_linear'),
      OES_element_index_uint: this.context.getExtension('OES_element_index_uint'),
      WEBGL_draw_buffers: this.context.getExtension('WEBGL_draw_buffers'),
    };
  }

  build() {
    super.build.apply(this, arguments);
    if (!this.fallbackRequested) {
      this.extensions.STACKGL_resize_drawingbuffer.resize(this.maxTexSize[0], this.maxTexSize[1]);
    }
  }

  destroyExtensions() {
    this.extensions.STACKGL_resize_drawingbuffer = null;
    this.extensions.STACKGL_destroy_context = null;
    this.extensions.OES_texture_float = null;
    this.extensions.OES_texture_float_linear = null;
    this.extensions.OES_element_index_uint = null;
    this.extensions.WEBGL_draw_buffers = null;
  }

  static destroyContext(context) {
    const extension = context.getExtension('STACKGL_destroy_context');
    if (extension && extension.destroy) {
      extension.destroy();
    }
  }

  toString() {
    const setupContextString = `const gl = context || require('gl')(1, 1);\n`;
    const destroyContextString = `    if (!context) { gl.getExtension('STACKGL_destroy_context').destroy(); }\n`;
    return glKernelString(this.constructor, arguments, this, setupContextString, destroyContextString);
  }

  setOutput(output) {
    super.setOutput(output);
    if (this.graphical && this.extensions.STACKGL_resize_drawingbuffer) {
      this.extensions.STACKGL_resize_drawingbuffer.resize(this.maxTexSize[0], this.maxTexSize[1]);
    }
    return this;
  }
}

module.exports = {
  HeadlessGLKernel
};
},{"../gl/kernel-string":12,"../web-gl/kernel":70,"gl":2}],35:[function(require,module,exports){
class KernelValue {
  constructor(value, settings) {
    const {
      name,
      kernel,
      context,
      checkContext,
      onRequestContextHandle,
      onUpdateValueMismatch,
      origin,
      strictIntegers,
      type,
      tactic,
    } = settings;
    if (!name) {
      throw new Error('name not set');
    }
    if (!type) {
      throw new Error('type not set');
    }
    if (!origin) {
      throw new Error('origin not set');
    }
    if (origin !== 'user' && origin !== 'constants') {
      throw new Error(`origin must be "user" or "constants" value is "${ origin }"`);
    }
    if (!onRequestContextHandle) {
      throw new Error('onRequestContextHandle is not set');
    }
    this.name = name;
    this.origin = origin;
    this.tactic = tactic;
    this.varName = origin === 'constants' ? `constants.${name}` : name;
    this.kernel = kernel;
    this.strictIntegers = strictIntegers;
    this.type = value.type || type;
    this.size = value.size || null;
    this.index = null;
    this.context = context;
    this.checkContext = checkContext !== null && checkContext !== undefined ? checkContext : true;
    this.contextHandle = null;
    this.onRequestContextHandle = onRequestContextHandle;
    this.onUpdateValueMismatch = onUpdateValueMismatch;
    this.forceUploadEachRun = null;
  }

  get id() {
    return `${this.origin}_${name}`;
  }

  getSource() {
    throw new Error(`"getSource" not defined on ${ this.constructor.name }`);
  }

  updateValue(value) {
    throw new Error(`"updateValue" not defined on ${ this.constructor.name }`);
  }
}

module.exports = {
  KernelValue
};
},{}],36:[function(require,module,exports){
const { utils } = require('../utils');
const { Input } = require('../input');

class Kernel {
  static get isSupported() {
    throw new Error(`"isSupported" not implemented on ${ this.name }`);
  }

  static isContextMatch(context) {
    throw new Error(`"isContextMatch" not implemented on ${ this.name }`);
  }

  static getFeatures() {
    throw new Error(`"getFeatures" not implemented on ${ this.name }`);
  }

  static destroyContext(context) {
    throw new Error(`"destroyContext" called on ${ this.name }`);
  }

  static nativeFunctionArguments() {
    throw new Error(`"nativeFunctionArguments" called on ${ this.name }`);
  }

  static nativeFunctionReturnType() {
    throw new Error(`"nativeFunctionReturnType" called on ${ this.name }`);
  }

  static combineKernels() {
    throw new Error(`"combineKernels" called on ${ this.name }`);
  }

  constructor(source, settings) {
    if (typeof source !== 'object') {
      if (typeof source !== 'string') {
        throw new Error('source not a string');
      }
      if (!utils.isFunctionString(source)) {
        throw new Error('source not a function string');
      }
    }
    this.useLegacyEncoder = false;
    this.fallbackRequested = false;
    this.onRequestFallback = null;

    this.argumentNames = typeof source === 'string' ? utils.getArgumentNamesFromString(source) : null;
    this.argumentTypes = null;
    this.argumentSizes = null;
    this.argumentBitRatios = null;
    this.kernelArguments = null;
    this.kernelConstants = null;
    this.forceUploadKernelConstants = null;


    this.source = source;

    this.output = null;

    this.debug = false;

    this.graphical = false;

    this.loopMaxIterations = 0;

    this.constants = null;

    this.constantTypes = null;

    this.constantBitRatios = null;

    this.dynamicArguments = false;

    this.dynamicOutput = false;

    this.canvas = null;

    this.context = null;

    this.checkContext = null;

    this.gpu = null;

    this.functions = null;

    this.nativeFunctions = null;

    this.injectedNative = null;

    this.subKernels = null;

    this.validate = true;

    this.immutable = false;

    this.pipeline = false;

    this.precision = null;

    this.tactic = null;

    this.plugins = null;

    this.returnType = null;
    this.leadingReturnStatement = null;
    this.followingReturnStatement = null;
    this.optimizeFloatMemory = null;
    this.strictIntegers = false;
    this.fixIntegerDivisionAccuracy = null;
    this.built = false;
    this.signature = null;
  }

  mergeSettings(settings) {
    for (let p in settings) {
      if (!settings.hasOwnProperty(p) || !this.hasOwnProperty(p)) continue;
      switch (p) {
        case 'output':
          if (!Array.isArray(settings.output)) {
            this.setOutput(settings.output); 
            continue;
          }
          break;
        case 'functions':
          this.functions = [];
          for (let i = 0; i < settings.functions.length; i++) {
            this.addFunction(settings.functions[i]);
          }
          continue;
        case 'graphical':
          if (settings[p] && !settings.hasOwnProperty('precision')) {
            this.precision = 'unsigned';
          }
          this[p] = settings[p];
          continue;
        case 'nativeFunctions':
          if (!settings.nativeFunctions) continue;
          this.nativeFunctions = [];
          for (let i = 0; i < settings.nativeFunctions.length; i++) {
            const s = settings.nativeFunctions[i];
            const { name, source } = s;
            this.addNativeFunction(name, source, s);
          }
          continue;
      }
      this[p] = settings[p];
    }

    if (!this.canvas) this.canvas = this.initCanvas();
    if (!this.context) this.context = this.initContext();
    if (!this.plugins) this.plugins = this.initPlugins(settings);
  }
  build() {
    throw new Error(`"build" not defined on ${ this.constructor.name }`);
  }

  run() {
    throw new Error(`"run" not defined on ${ this.constructor.name }`)
  }

  initCanvas() {
    throw new Error(`"initCanvas" not defined on ${ this.constructor.name }`);
  }

  initContext() {
    throw new Error(`"initContext" not defined on ${ this.constructor.name }`);
  }

  initPlugins(settings) {
    throw new Error(`"initPlugins" not defined on ${ this.constructor.name }`);
  }

  addFunction(source, settings = {}) {
    if (source.name && source.source && source.argumentTypes && 'returnType' in source) {
      this.functions.push(source);
    } else if ('settings' in source && 'source' in source) {
      this.functions.push(this.functionToIGPUFunction(source.source, source.settings));
    } else if (typeof source === 'string' || typeof source === 'function') {
      this.functions.push(this.functionToIGPUFunction(source, settings));
    } else {
      throw new Error(`function not properly defined`);
    }
    return this;
  }

  addNativeFunction(name, source, settings = {}) {
    const { argumentTypes, argumentNames } = settings.argumentTypes ?
      splitArgumentTypes(settings.argumentTypes) :
      this.constructor.nativeFunctionArguments(source) || {};
    this.nativeFunctions.push({
      name,
      source,
      settings,
      argumentTypes,
      argumentNames,
      returnType: settings.returnType || this.constructor.nativeFunctionReturnType(source)
    });
    return this;
  }

  setupArguments(args) {
    this.kernelArguments = [];
    if (!this.argumentTypes) {
      if (!this.argumentTypes) {
        this.argumentTypes = [];
        for (let i = 0; i < args.length; i++) {
          const argType = utils.getVariableType(args[i], this.strictIntegers);
          const type = argType === 'Integer' ? 'Number' : argType;
          this.argumentTypes.push(type);
          this.kernelArguments.push({
            type
          });
        }
      }
    } else {
      for (let i = 0; i < this.argumentTypes.length; i++) {
        this.kernelArguments.push({
          type: this.argumentTypes[i]
        });
      }
    }

    this.argumentSizes = new Array(args.length);
    this.argumentBitRatios = new Int32Array(args.length);

    for (let i = 0; i < args.length; i++) {
      const arg = args[i];
      this.argumentSizes[i] = arg.constructor === Input ? arg.size : null;
      this.argumentBitRatios[i] = this.getBitRatio(arg);
    }

    if (this.argumentNames.length !== args.length) {
      throw new Error(`arguments are miss-aligned`);
    }
  }

  setupConstants() {
    this.kernelConstants = [];
    let needsConstantTypes = this.constantTypes === null;
    if (needsConstantTypes) {
      this.constantTypes = {};
    }
    this.constantBitRatios = {};
    if (this.constants) {
      for (let name in this.constants) {
        if (needsConstantTypes) {
          const type = utils.getVariableType(this.constants[name], this.strictIntegers);
          this.constantTypes[name] = type;
          this.kernelConstants.push({
            name,
            type
          });
        } else {
          this.kernelConstants.push({
            name,
            type: this.constantTypes[name]
          });
        }
        this.constantBitRatios[name] = this.getBitRatio(this.constants[name]);
      }
    }
  }

  setOptimizeFloatMemory(flag) {
    this.optimizeFloatMemory = flag;
    return this;
  }

  toKernelOutput(output) {
    if (output.hasOwnProperty('x')) {
      if (output.hasOwnProperty('y')) {
        if (output.hasOwnProperty('z')) {
          return [output.x, output.y, output.z];
        } else {
          return [output.x, output.y];
        }
      } else {
        return [output.x];
      }
    } else {
      return output;
    }
  }

  setOutput(output) {
    this.output = this.toKernelOutput(output);
    return this;
  }

  setDebug(flag) {
    this.debug = flag;
    return this;
  }

  setGraphical(flag) {
    this.graphical = flag;
    this.precision = 'unsigned';
    return this;
  }

  setLoopMaxIterations(max) {
    this.loopMaxIterations = max;
    return this;
  }

  setConstants(constants) {
    this.constants = constants;
    return this;
  }

  setConstantTypes(constantTypes) {
    this.constantTypes = constantTypes;
    return this;
  }

  setFunctions(functions) {
    for (let i = 0; i < functions.length; i++) {
      this.addFunction(functions[i]);
    }
    return this;
  }

  setNativeFunctions(nativeFunctions) {
    for (let i = 0; i < nativeFunctions.length; i++) {
      const settings = nativeFunctions[i];
      const { name, source } = settings;
      this.addNativeFunction(name, source, settings);
    }
    return this;
  }

  setInjectedNative(injectedNative) {
    this.injectedNative = injectedNative;
    return this;
  }

  setPipeline(flag) {
    this.pipeline = flag;
    return this;
  }

  setPrecision(flag) {
    this.precision = flag;
    return this;
  }

  setDimensions(flag) {
    utils.warnDeprecated('method', 'setDimensions', 'setOutput');
    this.output = flag;
    return this;
  }

  setOutputToTexture(flag) {
    utils.warnDeprecated('method', 'setOutputToTexture', 'setPipeline');
    this.pipeline = flag;
    return this;
  }

  setImmutable(flag) {
    this.immutable = flag;
    return this;
  }

  setCanvas(canvas) {
    this.canvas = canvas;
    return this;
  }

  setStrictIntegers(flag) {
    this.strictIntegers = flag;
    return this;
  }

  setDynamicOutput(flag) {
    this.dynamicOutput = flag;
    return this;
  }

  setHardcodeConstants(flag) {
    utils.warnDeprecated('method', 'setHardcodeConstants');
    this.setDynamicOutput(flag);
    this.setDynamicArguments(flag);
    return this;
  }

  setDynamicArguments(flag) {
    this.dynamicArguments = flag;
    return this;
  }

  setUseLegacyEncoder(flag) {
    this.useLegacyEncoder = flag;
    return this;
  }

  setWarnVarUsage(flag) {
    utils.warnDeprecated('method', 'setWarnVarUsage');
    return this;
  }

  getCanvas() {
    utils.warnDeprecated('method', 'getCanvas');
    return this.canvas;
  }

  getWebGl() {
    utils.warnDeprecated('method', 'getWebGl');
    return this.context;
  }

  setContext(context) {
    this.context = context;
    return this;
  }

  setArgumentTypes(argumentTypes) {
    if (Array.isArray(argumentTypes)) {
      this.argumentTypes = argumentTypes;
    } else {
      this.argumentTypes = [];
      for (const p in argumentTypes) {
        if (!argumentTypes.hasOwnProperty(p)) continue;
        const argumentIndex = this.argumentNames.indexOf(p);
        if (argumentIndex === -1) throw new Error(`unable to find argument ${ p }`);
        this.argumentTypes[argumentIndex] = argumentTypes[p];
      }
    }
    return this;
  }

  setTactic(tactic) {
    this.tactic = tactic;
    return this;
  }

  requestFallback(args) {
    if (!this.onRequestFallback) {
      throw new Error(`"onRequestFallback" not defined on ${ this.constructor.name }`);
    }
    this.fallbackRequested = true;
    return this.onRequestFallback(args);
  }

  validateSettings() {
    throw new Error(`"validateSettings" not defined on ${ this.constructor.name }`);
  }

  addSubKernel(subKernel) {
    if (this.subKernels === null) {
      this.subKernels = [];
    }
    if (!subKernel.source) throw new Error('subKernel missing "source" property');
    if (!subKernel.property && isNaN(subKernel.property)) throw new Error('subKernel missing "property" property');
    if (!subKernel.name) throw new Error('subKernel missing "name" property');
    this.subKernels.push(subKernel);
    return this;
  }

  destroy(removeCanvasReferences) {
    throw new Error(`"destroy" called on ${ this.constructor.name }`);
  }

  getBitRatio(value) {
    if (this.precision === 'single') {
      return 4;
    } else if (Array.isArray(value[0])) {
      return this.getBitRatio(value[0]);
    } else if (value.constructor === Input) {
      return this.getBitRatio(value.value);
    }
    switch (value.constructor) {
      case Uint8ClampedArray:
      case Uint8Array:
      case Int8Array:
        return 1;
      case Uint16Array:
      case Int16Array:
        return 2;
      case Float32Array:
      case Int32Array:
      default:
        return 4;
    }
  }

  getPixels(flip) {
    throw new Error(`"getPixels" called on ${ this.constructor.name }`);
  }

  checkOutput() {
    if (!this.output || !utils.isArray(this.output)) throw new Error('kernel.output not an array');
    if (this.output.length < 1) throw new Error('kernel.output is empty, needs at least 1 value');
    for (let i = 0; i < this.output.length; i++) {
      if (isNaN(this.output[i]) || this.output[i] < 1) {
        throw new Error(`${ this.constructor.name }.output[${ i }] incorrectly defined as \`${ this.output[i] }\`, needs to be numeric, and greater than 0`);
      }
    }
  }

  prependString(value) {
    throw new Error(`"prependString" called on ${ this.constructor.name }`);
  }

  hasPrependString(value) {
    throw new Error(`"hasPrependString" called on ${ this.constructor.name }`);
  }

  toJSON() {
    return {
      settings: {
        output: this.output,
        pipeline: this.pipeline,
        argumentNames: this.argumentNames,
        argumentsTypes: this.argumentTypes,
        constants: this.constants,
        pluginNames: this.plugins ? this.plugins.map(plugin => plugin.name) : null,
        returnType: this.returnType,
      }
    };
  }

  buildSignature(args) {
    const Constructor = this.constructor;
    this.signature = Constructor.getSignature(this, Constructor.getArgumentTypes(this, args));
  }

  static getArgumentTypes(kernel, args) {
    const argumentTypes = new Array(args.length);
    for (let i = 0; i < args.length; i++) {
      const arg = args[i];
      const type = kernel.argumentTypes[i];
      if (arg.type) {
        argumentTypes[i] = arg.type;
      } else {
        switch (type) {
          case 'Number':
          case 'Integer':
          case 'Float':
          case 'ArrayTexture(1)':
            argumentTypes[i] = utils.getVariableType(arg);
            break;
          default:
            argumentTypes[i] = type;
        }
      }
    }
    return argumentTypes;
  }

  static getSignature(kernel, argumentTypes) {
    throw new Error(`"getSignature" not implemented on ${ this.name }`);
  }

  functionToIGPUFunction(source, settings = {}) {
    if (typeof source !== 'string' && typeof source !== 'function') throw new Error('source not a string or function');
    const sourceString = typeof source === 'string' ? source : source.toString();
    let argumentTypes = [];

    if (Array.isArray(settings.argumentTypes)) {
      argumentTypes = settings.argumentTypes;
    } else if (typeof settings.argumentTypes === 'object') {
      argumentTypes = utils.getArgumentNamesFromString(sourceString)
        .map(name => settings.argumentTypes[name]) || [];
    } else {
      argumentTypes = settings.argumentTypes || [];
    }

    return {
      name: utils.getFunctionNameFromString(sourceString) || null,
      source: sourceString,
      argumentTypes,
      returnType: settings.returnType || null,
    };
  }

  onActivate(previousKernel) {}
}

function splitArgumentTypes(argumentTypesObject) {
  const argumentNames = Object.keys(argumentTypesObject);
  const argumentTypes = [];
  for (let i = 0; i < argumentNames.length; i++) {
    const argumentName = argumentNames[i];
    argumentTypes.push(argumentTypesObject[argumentName]);
  }
  return { argumentTypes, argumentNames };
}

module.exports = {
  Kernel
};
},{"../input":110,"../utils":114}],37:[function(require,module,exports){
const fragmentShader = `__HEADER__;
__FLOAT_TACTIC_DECLARATION__;
__INT_TACTIC_DECLARATION__;
__SAMPLER_2D_TACTIC_DECLARATION__;

const int LOOP_MAX = __LOOP_MAX__;

__PLUGINS__;
__CONSTANTS__;

varying vec2 vTexCoord;

float acosh(float x) {
  return log(x + sqrt(x * x - 1.0));
}

float sinh(float x) {
  return (pow(${Math.E}, x) - pow(${Math.E}, -x)) / 2.0;
}

float asinh(float x) {
  return log(x + sqrt(x * x + 1.0));
}

float atan2(float v1, float v2) {
  if (v1 == 0.0 || v2 == 0.0) return 0.0;
  return atan(v1 / v2);
}

float atanh(float x) {
  x = (x + 1.0) / (x - 1.0);
  if (x < 0.0) {
    return 0.5 * log(-x);
  }
  return 0.5 * log(x);
}

float cbrt(float x) {
  if (x >= 0.0) {
    return pow(x, 1.0 / 3.0);
  } else {
    return -pow(x, 1.0 / 3.0);
  }
}

float cosh(float x) {
  return (pow(${Math.E}, x) + pow(${Math.E}, -x)) / 2.0; 
}

float expm1(float x) {
  return pow(${Math.E}, x) - 1.0; 
}

float fround(highp float x) {
  return x;
}

float imul(float v1, float v2) {
  return float(int(v1) * int(v2));
}

float log10(float x) {
  return log2(x) * (1.0 / log2(10.0));
}

float log1p(float x) {
  return log(1.0 + x);
}

float _pow(float v1, float v2) {
  if (v2 == 0.0) return 1.0;
  return pow(v1, v2);
}

float tanh(float x) {
  float e = exp(2.0 * x);
  return (e - 1.0) / (e + 1.0);
}

float trunc(float x) {
  if (x >= 0.0) {
    return floor(x); 
  } else {
    return ceil(x);
  }
}

vec4 _round(vec4 x) {
  return floor(x + 0.5);
}

float _round(float x) {
  return floor(x + 0.5);
}

const int BIT_COUNT = 32;
int modi(int x, int y) {
  return x - y * (x / y);
}

int bitwiseOr(int a, int b) {
  int result = 0;
  int n = 1;
  
  for (int i = 0; i < BIT_COUNT; i++) {
    if ((modi(a, 2) == 1) || (modi(b, 2) == 1)) {
      result += n;
    }
    a = a / 2;
    b = b / 2;
    n = n * 2;
    if(!(a > 0 || b > 0)) {
      break;
    }
  }
  return result;
}
int bitwiseXOR(int a, int b) {
  int result = 0;
  int n = 1;
  
  for (int i = 0; i < BIT_COUNT; i++) {
    if ((modi(a, 2) == 1) != (modi(b, 2) == 1)) {
      result += n;
    }
    a = a / 2;
    b = b / 2;
    n = n * 2;
    if(!(a > 0 || b > 0)) {
      break;
    }
  }
  return result;
}
int bitwiseAnd(int a, int b) {
  int result = 0;
  int n = 1;
  for (int i = 0; i < BIT_COUNT; i++) {
    if ((modi(a, 2) == 1) && (modi(b, 2) == 1)) {
      result += n;
    }
    a = a / 2;
    b = b / 2;
    n = n * 2;
    if(!(a > 0 && b > 0)) {
      break;
    }
  }
  return result;
}
int bitwiseNot(int a) {
  int result = 0;
  int n = 1;
  
  for (int i = 0; i < BIT_COUNT; i++) {
    if (modi(a, 2) == 0) {
      result += n;    
    }
    a = a / 2;
    n = n * 2;
  }
  return result;
}
int bitwiseZeroFillLeftShift(int n, int shift) {
  int maxBytes = BIT_COUNT;
  for (int i = 0; i < BIT_COUNT; i++) {
    if (maxBytes >= n) {
      break;
    }
    maxBytes *= 2;
  }
  for (int i = 0; i < BIT_COUNT; i++) {
    if (i >= shift) {
      break;
    }
    n *= 2;
  }

  int result = 0;
  int byteVal = 1;
  for (int i = 0; i < BIT_COUNT; i++) {
    if (i >= maxBytes) break;
    if (modi(n, 2) > 0) { result += byteVal; }
    n = int(n / 2);
    byteVal *= 2;
  }
  return result;
}

int bitwiseSignedRightShift(int num, int shifts) {
  return int(floor(float(num) / pow(2.0, float(shifts))));
}

int bitwiseZeroFillRightShift(int n, int shift) {
  int maxBytes = BIT_COUNT;
  for (int i = 0; i < BIT_COUNT; i++) {
    if (maxBytes >= n) {
      break;
    }
    maxBytes *= 2;
  }
  for (int i = 0; i < BIT_COUNT; i++) {
    if (i >= shift) {
      break;
    }
    n /= 2;
  }
  int result = 0;
  int byteVal = 1;
  for (int i = 0; i < BIT_COUNT; i++) {
    if (i >= maxBytes) break;
    if (modi(n, 2) > 0) { result += byteVal; }
    n = int(n / 2);
    byteVal *= 2;
  }
  return result;
}

vec2 integerMod(vec2 x, float y) {
  vec2 res = floor(mod(x, y));
  return res * step(1.0 - floor(y), -res);
}

vec3 integerMod(vec3 x, float y) {
  vec3 res = floor(mod(x, y));
  return res * step(1.0 - floor(y), -res);
}

vec4 integerMod(vec4 x, vec4 y) {
  vec4 res = floor(mod(x, y));
  return res * step(1.0 - floor(y), -res);
}

float integerMod(float x, float y) {
  float res = floor(mod(x, y));
  return res * (res > floor(y) - 1.0 ? 0.0 : 1.0);
}

int integerMod(int x, int y) {
  return x - (y * int(x / y));
}

__DIVIDE_WITH_INTEGER_CHECK__;

// Here be dragons!
// DO NOT OPTIMIZE THIS CODE
// YOU WILL BREAK SOMETHING ON SOMEBODY\'S MACHINE
// LEAVE IT AS IT IS, LEST YOU WASTE YOUR OWN TIME
const vec2 MAGIC_VEC = vec2(1.0, -256.0);
const vec4 SCALE_FACTOR = vec4(1.0, 256.0, 65536.0, 0.0);
const vec4 SCALE_FACTOR_INV = vec4(1.0, 0.00390625, 0.0000152587890625, 0.0); // 1, 1/256, 1/65536
float decode32(vec4 texel) {
  __DECODE32_ENDIANNESS__;
  texel *= 255.0;
  vec2 gte128;
  gte128.x = texel.b >= 128.0 ? 1.0 : 0.0;
  gte128.y = texel.a >= 128.0 ? 1.0 : 0.0;
  float exponent = 2.0 * texel.a - 127.0 + dot(gte128, MAGIC_VEC);
  float res = exp2(_round(exponent));
  texel.b = texel.b - 128.0 * gte128.x;
  res = dot(texel, SCALE_FACTOR) * exp2(_round(exponent-23.0)) + res;
  res *= gte128.y * -2.0 + 1.0;
  return res;
}

float decode16(vec4 texel, int index) {
  int channel = integerMod(index, 2);
  if (channel == 0) return texel.r * 255.0 + texel.g * 65280.0;
  if (channel == 1) return texel.b * 255.0 + texel.a * 65280.0;
  return 0.0;
}

float decode8(vec4 texel, int index) {
  int channel = integerMod(index, 4);
  if (channel == 0) return texel.r * 255.0;
  if (channel == 1) return texel.g * 255.0;
  if (channel == 2) return texel.b * 255.0;
  if (channel == 3) return texel.a * 255.0;
  return 0.0;
}

vec4 legacyEncode32(float f) {
  float F = abs(f);
  float sign = f < 0.0 ? 1.0 : 0.0;
  float exponent = floor(log2(F));
  float mantissa = (exp2(-exponent) * F);
  // exponent += floor(log2(mantissa));
  vec4 texel = vec4(F * exp2(23.0-exponent)) * SCALE_FACTOR_INV;
  texel.rg = integerMod(texel.rg, 256.0);
  texel.b = integerMod(texel.b, 128.0);
  texel.a = exponent*0.5 + 63.5;
  texel.ba += vec2(integerMod(exponent+127.0, 2.0), sign) * 128.0;
  texel = floor(texel);
  texel *= 0.003921569; // 1/255
  __ENCODE32_ENDIANNESS__;
  return texel;
}

// https://github.com/gpujs/gpu.js/wiki/Encoder-details
vec4 encode32(float value) {
  if (value == 0.0) return vec4(0, 0, 0, 0);

  float exponent;
  float mantissa;
  vec4  result;
  float sgn;

  sgn = step(0.0, -value);
  value = abs(value);

  exponent = floor(log2(value));

  mantissa = value*pow(2.0, -exponent)-1.0;
  exponent = exponent+127.0;
  result   = vec4(0,0,0,0);

  result.a = floor(exponent/2.0);
  exponent = exponent - result.a*2.0;
  result.a = result.a + 128.0*sgn;

  result.b = floor(mantissa * 128.0);
  mantissa = mantissa - result.b / 128.0;
  result.b = result.b + exponent*128.0;

  result.g = floor(mantissa*32768.0);
  mantissa = mantissa - result.g/32768.0;

  result.r = floor(mantissa*8388608.0);
  return result/255.0;
}
// Dragons end here

int index;
ivec3 threadId;

ivec3 indexTo3D(int idx, ivec3 texDim) {
  int z = int(idx / (texDim.x * texDim.y));
  idx -= z * int(texDim.x * texDim.y);
  int y = int(idx / texDim.x);
  int x = int(integerMod(idx, texDim.x));
  return ivec3(x, y, z);
}

float get32(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + texDim.x * (y + texDim.y * z);
  int w = texSize.x;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  vec4 texel = texture2D(tex, st / vec2(texSize));
  return decode32(texel);
}

float get16(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + texDim.x * (y + texDim.y * z);
  int w = texSize.x * 2;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  vec4 texel = texture2D(tex, st / vec2(texSize.x * 2, texSize.y));
  return decode16(texel, index);
}

float get8(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + texDim.x * (y + texDim.y * z);
  int w = texSize.x * 4;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  vec4 texel = texture2D(tex, st / vec2(texSize.x * 4, texSize.y));
  return decode8(texel, index);
}

float getMemoryOptimized32(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + texDim.x * (y + texDim.y * z);
  int channel = integerMod(index, 4);
  index = index / 4;
  int w = texSize.x;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  vec4 texel = texture2D(tex, st / vec2(texSize));
  if (channel == 0) return texel.r;
  if (channel == 1) return texel.g;
  if (channel == 2) return texel.b;
  if (channel == 3) return texel.a;
  return 0.0;
}

vec4 getImage2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + texDim.x * (y + texDim.y * z);
  int w = texSize.x;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  return texture2D(tex, st / vec2(texSize));
}

float getFloatFromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  vec4 result = getImage2D(tex, texSize, texDim, z, y, x);
  return result[0];
}

vec2 getVec2FromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  vec4 result = getImage2D(tex, texSize, texDim, z, y, x);
  return vec2(result[0], result[1]);
}

vec2 getMemoryOptimizedVec2(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + (texDim.x * (y + (texDim.y * z)));
  int channel = integerMod(index, 2);
  index = index / 2;
  int w = texSize.x;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  vec4 texel = texture2D(tex, st / vec2(texSize));
  if (channel == 0) return vec2(texel.r, texel.g);
  if (channel == 1) return vec2(texel.b, texel.a);
  return vec2(0.0, 0.0);
}

vec3 getVec3FromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  vec4 result = getImage2D(tex, texSize, texDim, z, y, x);
  return vec3(result[0], result[1], result[2]);
}

vec3 getMemoryOptimizedVec3(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int fieldIndex = 3 * (x + texDim.x * (y + texDim.y * z));
  int vectorIndex = fieldIndex / 4;
  int vectorOffset = fieldIndex - vectorIndex * 4;
  int readY = vectorIndex / texSize.x;
  int readX = vectorIndex - readY * texSize.x;
  vec4 tex1 = texture2D(tex, (vec2(readX, readY) + 0.5) / vec2(texSize));
  
  if (vectorOffset == 0) {
    return tex1.xyz;
  } else if (vectorOffset == 1) {
    return tex1.yzw;
  } else {
    readX++;
    if (readX >= texSize.x) {
      readX = 0;
      readY++;
    }
    vec4 tex2 = texture2D(tex, vec2(readX, readY) / vec2(texSize));
    if (vectorOffset == 2) {
      return vec3(tex1.z, tex1.w, tex2.x);
    } else {
      return vec3(tex1.w, tex2.x, tex2.y);
    }
  }
}

vec4 getVec4FromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  return getImage2D(tex, texSize, texDim, z, y, x);
}

vec4 getMemoryOptimizedVec4(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + texDim.x * (y + texDim.y * z);
  int channel = integerMod(index, 2);
  int w = texSize.x;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  vec4 texel = texture2D(tex, st / vec2(texSize));
  return vec4(texel.r, texel.g, texel.b, texel.a);
}

vec4 actualColor;
void color(float r, float g, float b, float a) {
  actualColor = vec4(r,g,b,a);
}

void color(float r, float g, float b) {
  color(r,g,b,1.0);
}

void color(sampler2D image) {
  actualColor = texture2D(image, vTexCoord);
}

float modulo(float number, float divisor) {
  if (number < 0.0) {
    number = abs(number);
    if (divisor < 0.0) {
      divisor = abs(divisor);
    }
    return -mod(number, divisor);
  }
  if (divisor < 0.0) {
    divisor = abs(divisor);
  }
  return mod(number, divisor);
}

__INJECTED_NATIVE__;
__MAIN_CONSTANTS__;
__MAIN_ARGUMENTS__;
__KERNEL__;

void main(void) {
  index = int(vTexCoord.s * float(uTexSize.x)) + int(vTexCoord.t * float(uTexSize.y)) * uTexSize.x;
  __MAIN_RESULT__;
}`;

module.exports = {
  fragmentShader
};
},{}],38:[function(require,module,exports){
const { utils } = require('../../utils');
const { FunctionNode } = require('../function-node');

class WebGLFunctionNode extends FunctionNode {
  constructor(source, settings) {
    super(source, settings);
    if (settings && settings.hasOwnProperty('fixIntegerDivisionAccuracy')) {
      this.fixIntegerDivisionAccuracy = settings.fixIntegerDivisionAccuracy;
    }
  }

  astConditionalExpression(ast, retArr) {
    if (ast.type !== 'ConditionalExpression') {
      throw this.astErrorOutput('Not a conditional expression', ast);
    }
    const consequentType = this.getType(ast.consequent);
    const alternateType = this.getType(ast.alternate);
    if (consequentType === null && alternateType === null) {
      retArr.push('if (');
      this.astGeneric(ast.test, retArr);
      retArr.push(') {');
      this.astGeneric(ast.consequent, retArr);
      retArr.push(';');
      retArr.push('} else {');
      this.astGeneric(ast.alternate, retArr);
      retArr.push(';');
      retArr.push('}');
      return retArr;
    }
    retArr.push('(');
    this.astGeneric(ast.test, retArr);
    retArr.push('?');
    this.astGeneric(ast.consequent, retArr);
    retArr.push(':');
    this.astGeneric(ast.alternate, retArr);
    retArr.push(')');
    return retArr;
  }

  astFunction(ast, retArr) {
    if (this.isRootKernel) {
      retArr.push('void');
    } else {
      if (!this.returnType) {
        const lastReturn = this.findLastReturn();
        if (lastReturn) {
          this.returnType = this.getType(ast.body);
          if (this.returnType === 'LiteralInteger') {
            this.returnType = 'Number';
          }
        }
      }

      const { returnType } = this;
      if (!returnType) {
        retArr.push('void');
      } else {
        const type = typeMap[returnType];
        if (!type) {
          throw new Error(`unknown type ${returnType}`);
        }
        retArr.push(type);
      }
    }
    retArr.push(' ');
    retArr.push(this.name);
    retArr.push('(');

    if (!this.isRootKernel) {
      for (let i = 0; i < this.argumentNames.length; ++i) {
        const argumentName = this.argumentNames[i];

        if (i > 0) {
          retArr.push(', ');
        }
        let argumentType = this.argumentTypes[this.argumentNames.indexOf(argumentName)];
        if (!argumentType) {
          throw this.astErrorOutput(`Unknown argument ${argumentName} type`, ast);
        }
        if (argumentType === 'LiteralInteger') {
          this.argumentTypes[i] = argumentType = 'Number';
        }
        const type = typeMap[argumentType];
        if (!type) {
          throw this.astErrorOutput('Unexpected expression', ast);
        }
        const name = utils.sanitizeName(argumentName);
        if (type === 'sampler2D' || type === 'sampler2DArray') {
          retArr.push(`${type} user_${name},ivec2 user_${name}Size,ivec3 user_${name}Dim`);
        } else {
          retArr.push(`${type} user_${name}`);
        }
      }
    }

    retArr.push(') {\n');

    for (let i = 0; i < ast.body.body.length; ++i) {
      this.astGeneric(ast.body.body[i], retArr);
      retArr.push('\n');
    }

    retArr.push('}\n');
    return retArr;
  }

  astReturnStatement(ast, retArr) {
    if (!ast.argument) throw this.astErrorOutput('Unexpected return statement', ast);
    this.pushState('skip-literal-correction');
    const type = this.getType(ast.argument);
    this.popState('skip-literal-correction');

    const result = [];

    if (!this.returnType) {
      if (type === 'LiteralInteger' || type === 'Integer') {
        this.returnType = 'Number';
      } else {
        this.returnType = type;
      }
    }

    switch (this.returnType) {
      case 'LiteralInteger':
      case 'Number':
      case 'Float':
        switch (type) {
          case 'Integer':
            result.push('float(');
            this.astGeneric(ast.argument, result);
            result.push(')');
            break;
          case 'LiteralInteger':
            this.castLiteralToFloat(ast.argument, result);

            if (this.getType(ast) === 'Integer') {
              result.unshift('float(');
              result.push(')');
            }
            break;
          default:
            this.astGeneric(ast.argument, result);
        }
        break;
      case 'Integer':
        switch (type) {
          case 'Float':
          case 'Number':
            this.castValueToInteger(ast.argument, result);
            break;
          case 'LiteralInteger':
            this.castLiteralToInteger(ast.argument, result);
            break;
          default:
            this.astGeneric(ast.argument, result);
        }
        break;
      case 'Array(4)':
      case 'Array(3)':
      case 'Array(2)':
      case 'Matrix(2)':
      case 'Matrix(3)':
      case 'Matrix(4)':
      case 'Input':
        this.astGeneric(ast.argument, result);
        break;
      default:
        throw this.astErrorOutput(`unhandled return type ${this.returnType}`, ast);
    }

    if (this.isRootKernel) {
      retArr.push(`kernelResult = ${ result.join('') };`);
      retArr.push('return;');
    } else if (this.isSubKernel) {
      retArr.push(`subKernelResult_${ this.name } = ${ result.join('') };`);
      retArr.push(`return subKernelResult_${ this.name };`);
    } else {
      retArr.push(`return ${ result.join('') };`);
    }
    return retArr;
  }

  astLiteral(ast, retArr) {
    if (isNaN(ast.value)) {
      throw this.astErrorOutput(
        'Non-numeric literal not supported : ' + ast.value,
        ast
      );
    }

    const key = this.astKey(ast);
    if (Number.isInteger(ast.value)) {
      if (this.isState('casting-to-integer') || this.isState('building-integer')) {
        this.literalTypes[key] = 'Integer';
        retArr.push(`${ast.value}`);
      } else if (this.isState('casting-to-float') || this.isState('building-float')) {
        this.literalTypes[key] = 'Number';
        retArr.push(`${ast.value}.0`);
      } else {
        this.literalTypes[key] = 'Number';
        retArr.push(`${ast.value}.0`);
      }
    } else if (this.isState('casting-to-integer') || this.isState('building-integer')) {
      this.literalTypes[key] = 'Integer';
      retArr.push(Math.round(ast.value));
    } else {
      this.literalTypes[key] = 'Number';
      retArr.push(`${ast.value}`);
    }
    return retArr;
  }

  astBinaryExpression(ast, retArr) {
    if (this.checkAndUpconvertOperator(ast, retArr)) {
      return retArr;
    }

    if (this.fixIntegerDivisionAccuracy && ast.operator === '/') {
      retArr.push('divWithIntCheck(');
      this.pushState('building-float');
      switch (this.getType(ast.left)) {
        case 'Integer':
          this.castValueToFloat(ast.left, retArr);
          break;
        case 'LiteralInteger':
          this.castLiteralToFloat(ast.left, retArr);
          break;
        default:
          this.astGeneric(ast.left, retArr);
      }
      retArr.push(', ');
      switch (this.getType(ast.right)) {
        case 'Integer':
          this.castValueToFloat(ast.right, retArr);
          break;
        case 'LiteralInteger':
          this.castLiteralToFloat(ast.right, retArr);
          break;
        default:
          this.astGeneric(ast.right, retArr);
      }
      this.popState('building-float');
      retArr.push(')');
      return retArr;
    }

    retArr.push('(');
    const leftType = this.getType(ast.left) || 'Number';
    const rightType = this.getType(ast.right) || 'Number';
    if (!leftType || !rightType) {
      throw this.astErrorOutput(`Unhandled binary expression`, ast);
    }
    const key = leftType + ' & ' + rightType;
    switch (key) {
      case 'Integer & Integer':
        this.pushState('building-integer');
        this.astGeneric(ast.left, retArr);
        retArr.push(operatorMap[ast.operator] || ast.operator);
        this.astGeneric(ast.right, retArr);
        this.popState('building-integer');
        break;
      case 'Number & Float':
      case 'Float & Number':
      case 'Float & Float':
      case 'Number & Number':
        this.pushState('building-float');
        this.astGeneric(ast.left, retArr);
        retArr.push(operatorMap[ast.operator] || ast.operator);
        this.astGeneric(ast.right, retArr);
        this.popState('building-float');
        break;
      case 'LiteralInteger & LiteralInteger':
        if (this.isState('casting-to-integer') || this.isState('building-integer')) {
          this.pushState('building-integer');
          this.astGeneric(ast.left, retArr);
          retArr.push(operatorMap[ast.operator] || ast.operator);
          this.astGeneric(ast.right, retArr);
          this.popState('building-integer');
        } else {
          this.pushState('building-float');
          this.castLiteralToFloat(ast.left, retArr);
          retArr.push(operatorMap[ast.operator] || ast.operator);
          this.castLiteralToFloat(ast.right, retArr);
          this.popState('building-float');
        }
        break;

      case 'Integer & Float':
      case 'Integer & Number':
        if (ast.operator === '>' || ast.operator === '<' && ast.right.type === 'Literal') {
          if (!Number.isInteger(ast.right.value)) {
            this.pushState('building-float');
            this.castValueToFloat(ast.left, retArr);
            retArr.push(operatorMap[ast.operator] || ast.operator);
            this.astGeneric(ast.right, retArr);
            this.popState('building-float');
            break;
          }
        }
        this.pushState('building-integer');
        this.astGeneric(ast.left, retArr);
        retArr.push(operatorMap[ast.operator] || ast.operator);
        this.pushState('casting-to-integer');
        if (ast.right.type === 'Literal') {
          const literalResult = [];
          this.astGeneric(ast.right, literalResult);
          const literalType = this.getType(ast.right);
          if (literalType === 'Integer') {
            retArr.push(literalResult.join(''));
          } else {
            throw this.astErrorOutput(`Unhandled binary expression with literal`, ast);
          }
        } else {
          retArr.push('int(');
          this.astGeneric(ast.right, retArr);
          retArr.push(')');
        }
        this.popState('casting-to-integer');
        this.popState('building-integer');
        break;
      case 'Integer & LiteralInteger':
        this.pushState('building-integer');
        this.astGeneric(ast.left, retArr);
        retArr.push(operatorMap[ast.operator] || ast.operator);
        this.castLiteralToInteger(ast.right, retArr);
        this.popState('building-integer');
        break;

      case 'Number & Integer':
        this.pushState('building-float');
        this.astGeneric(ast.left, retArr);
        retArr.push(operatorMap[ast.operator] || ast.operator);
        this.castValueToFloat(ast.right, retArr);
        this.popState('building-float');
        break;
      case 'Float & LiteralInteger':
      case 'Number & LiteralInteger':
        this.pushState('building-float');
        this.astGeneric(ast.left, retArr);
        retArr.push(operatorMap[ast.operator] || ast.operator);
        this.castLiteralToFloat(ast.right, retArr);
        this.popState('building-float');
        break;
      case 'LiteralInteger & Float':
      case 'LiteralInteger & Number':
        if (this.isState('casting-to-integer')) {
          this.pushState('building-integer');
          this.castLiteralToInteger(ast.left, retArr);
          retArr.push(operatorMap[ast.operator] || ast.operator);
          this.castValueToInteger(ast.right, retArr);
          this.popState('building-integer');
        } else {
          this.pushState('building-float');
          this.astGeneric(ast.left, retArr);
          retArr.push(operatorMap[ast.operator] || ast.operator);
          this.pushState('casting-to-float');
          this.astGeneric(ast.right, retArr);
          this.popState('casting-to-float');
          this.popState('building-float');
        }
        break;
      case 'LiteralInteger & Integer':
        this.pushState('building-integer');
        this.castLiteralToInteger(ast.left, retArr);
        retArr.push(operatorMap[ast.operator] || ast.operator);
        this.astGeneric(ast.right, retArr);
        this.popState('building-integer');
        break;

      case 'Boolean & Boolean':
        this.pushState('building-boolean');
        this.astGeneric(ast.left, retArr);
        retArr.push(operatorMap[ast.operator] || ast.operator);
        this.astGeneric(ast.right, retArr);
        this.popState('building-boolean');
        break;

      case 'Float & Integer':
        this.pushState('building-float');
        this.astGeneric(ast.left, retArr);
        retArr.push(operatorMap[ast.operator] || ast.operator);
        this.castValueToFloat(ast.right, retArr);
        this.popState('building-float');
        break;

      default:
        throw this.astErrorOutput(`Unhandled binary expression between ${key}`, ast);
    }
    retArr.push(')');

    return retArr;
  }

  checkAndUpconvertOperator(ast, retArr) {
    const bitwiseResult = this.checkAndUpconvertBitwiseOperators(ast, retArr);
    if (bitwiseResult) {
      return bitwiseResult;
    }
    const upconvertableOperators = {
      '%': this.fixIntegerDivisionAccuracy ? 'integerCorrectionModulo' : 'modulo',
      '**': 'pow',
    };
    const foundOperator = upconvertableOperators[ast.operator];
    if (!foundOperator) return null;
    retArr.push(foundOperator);
    retArr.push('(');
    switch (this.getType(ast.left)) {
      case 'Integer':
        this.castValueToFloat(ast.left, retArr);
        break;
      case 'LiteralInteger':
        this.castLiteralToFloat(ast.left, retArr);
        break;
      default:
        this.astGeneric(ast.left, retArr);
    }
    retArr.push(',');
    switch (this.getType(ast.right)) {
      case 'Integer':
        this.castValueToFloat(ast.right, retArr);
        break;
      case 'LiteralInteger':
        this.castLiteralToFloat(ast.right, retArr);
        break;
      default:
        this.astGeneric(ast.right, retArr);
    }
    retArr.push(')');
    return retArr;
  }

  checkAndUpconvertBitwiseOperators(ast, retArr) {
    const upconvertableOperators = {
      '&': 'bitwiseAnd',
      '|': 'bitwiseOr',
      '^': 'bitwiseXOR',
      '<<': 'bitwiseZeroFillLeftShift',
      '>>': 'bitwiseSignedRightShift',
      '>>>': 'bitwiseZeroFillRightShift',
    };
    const foundOperator = upconvertableOperators[ast.operator];
    if (!foundOperator) return null;
    retArr.push(foundOperator);
    retArr.push('(');
    const leftType = this.getType(ast.left);
    switch (leftType) {
      case 'Number':
      case 'Float':
        this.castValueToInteger(ast.left, retArr);
        break;
      case 'LiteralInteger':
        this.castLiteralToInteger(ast.left, retArr);
        break;
      default:
        this.astGeneric(ast.left, retArr);
    }
    retArr.push(',');
    const rightType = this.getType(ast.right);
    switch (rightType) {
      case 'Number':
      case 'Float':
        this.castValueToInteger(ast.right, retArr);
        break;
      case 'LiteralInteger':
        this.castLiteralToInteger(ast.right, retArr);
        break;
      default:
        this.astGeneric(ast.right, retArr);
    }
    retArr.push(')');
    return retArr;
  }

  checkAndUpconvertBitwiseUnary(ast, retArr) {
    const upconvertableOperators = {
      '~': 'bitwiseNot',
    };
    const foundOperator = upconvertableOperators[ast.operator];
    if (!foundOperator) return null;
    retArr.push(foundOperator);
    retArr.push('(');
    switch (this.getType(ast.argument)) {
      case 'Number':
      case 'Float':
        this.castValueToInteger(ast.argument, retArr);
        break;
      case 'LiteralInteger':
        this.castLiteralToInteger(ast.argument, retArr);
        break;
      default:
        this.astGeneric(ast.argument, retArr);
    }
    retArr.push(')');
    return retArr;
  }

  castLiteralToInteger(ast, retArr) {
    this.pushState('casting-to-integer');
    this.astGeneric(ast, retArr);
    this.popState('casting-to-integer');
    return retArr;
  }

  castLiteralToFloat(ast, retArr) {
    this.pushState('casting-to-float');
    this.astGeneric(ast, retArr);
    this.popState('casting-to-float');
    return retArr;
  }

  castValueToInteger(ast, retArr) {
    this.pushState('casting-to-integer');
    retArr.push('int(');
    this.astGeneric(ast, retArr);
    retArr.push(')');
    this.popState('casting-to-integer');
    return retArr;
  }

  castValueToFloat(ast, retArr) {
    this.pushState('casting-to-float');
    retArr.push('float(');
    this.astGeneric(ast, retArr);
    retArr.push(')');
    this.popState('casting-to-float');
    return retArr;
  }

  astIdentifierExpression(idtNode, retArr) {
    if (idtNode.type !== 'Identifier') {
      throw this.astErrorOutput('IdentifierExpression - not an Identifier', idtNode);
    }

    const type = this.getType(idtNode);

    const name = utils.sanitizeName(idtNode.name);
    if (idtNode.name === 'Infinity') {
      retArr.push('3.402823466e+38');
    } else if (type === 'Boolean') {
      if (this.argumentNames.indexOf(name) > -1) {
        retArr.push(`bool(user_${name})`);
      } else {
        retArr.push(`user_${name}`);
      }
    } else {
      retArr.push(`user_${name}`);
    }

    return retArr;
  }

  astForStatement(forNode, retArr) {
    if (forNode.type !== 'ForStatement') {
      throw this.astErrorOutput('Invalid for statement', forNode);
    }

    const initArr = [];
    const testArr = [];
    const updateArr = [];
    const bodyArr = [];
    let isSafe = null;

    if (forNode.init) {
      const { declarations } = forNode.init;
      if (declarations.length > 1) {
        isSafe = false;
      }
      this.astGeneric(forNode.init, initArr);
      for (let i = 0; i < declarations.length; i++) {
        if (declarations[i].init && declarations[i].init.type !== 'Literal') {
          isSafe = false;
        }
      }
    } else {
      isSafe = false;
    }

    if (forNode.test) {
      this.astGeneric(forNode.test, testArr);
    } else {
      isSafe = false;
    }

    if (forNode.update) {
      this.astGeneric(forNode.update, updateArr);
    } else {
      isSafe = false;
    }

    if (forNode.body) {
      this.pushState('loop-body');
      this.astGeneric(forNode.body, bodyArr);
      this.popState('loop-body');
    }

    if (isSafe === null) {
      isSafe = this.isSafe(forNode.init) && this.isSafe(forNode.test);
    }

    if (isSafe) {
      const initString = initArr.join('');
      const initNeedsSemiColon = initString[initString.length - 1] !== ';';
      retArr.push(`for (${initString}${initNeedsSemiColon ? ';' : ''}${testArr.join('')};${updateArr.join('')}){\n`);
      retArr.push(bodyArr.join(''));
      retArr.push('}\n');
    } else {
      const iVariableName = this.getInternalVariableName('safeI');
      if (initArr.length > 0) {
        retArr.push(initArr.join(''), '\n');
      }
      retArr.push(`for (int ${iVariableName}=0;${iVariableName}<LOOP_MAX;${iVariableName}++){\n`);
      if (testArr.length > 0) {
        retArr.push(`if (!${testArr.join('')}) break;\n`);
      }
      retArr.push(bodyArr.join(''));
      retArr.push(`\n${updateArr.join('')};`);
      retArr.push('}\n');
    }
    return retArr;
  }

  astWhileStatement(whileNode, retArr) {
    if (whileNode.type !== 'WhileStatement') {
      throw this.astErrorOutput('Invalid while statement', whileNode);
    }

    const iVariableName = this.getInternalVariableName('safeI');
    retArr.push(`for (int ${iVariableName}=0;${iVariableName}<LOOP_MAX;${iVariableName}++){\n`);
    retArr.push('if (!');
    this.astGeneric(whileNode.test, retArr);
    retArr.push(') break;\n');
    this.astGeneric(whileNode.body, retArr);
    retArr.push('}\n');

    return retArr;
  }

  astDoWhileStatement(doWhileNode, retArr) {
    if (doWhileNode.type !== 'DoWhileStatement') {
      throw this.astErrorOutput('Invalid while statement', doWhileNode);
    }

    const iVariableName = this.getInternalVariableName('safeI');
    retArr.push(`for (int ${iVariableName}=0;${iVariableName}<LOOP_MAX;${iVariableName}++){\n`);
    this.astGeneric(doWhileNode.body, retArr);
    retArr.push('if (!');
    this.astGeneric(doWhileNode.test, retArr);
    retArr.push(') break;\n');
    retArr.push('}\n');

    return retArr;
  }


  astAssignmentExpression(assNode, retArr) {
    if (assNode.operator === '%=') {
      this.astGeneric(assNode.left, retArr);
      retArr.push('=');
      retArr.push('mod(');
      this.astGeneric(assNode.left, retArr);
      retArr.push(',');
      this.astGeneric(assNode.right, retArr);
      retArr.push(')');
    } else if (assNode.operator === '**=') {
      this.astGeneric(assNode.left, retArr);
      retArr.push('=');
      retArr.push('pow(');
      this.astGeneric(assNode.left, retArr);
      retArr.push(',');
      this.astGeneric(assNode.right, retArr);
      retArr.push(')');
    } else {
      const leftType = this.getType(assNode.left);
      const rightType = this.getType(assNode.right);
      this.astGeneric(assNode.left, retArr);
      retArr.push(assNode.operator);
      if (leftType !== 'Integer' && rightType === 'Integer') {
        retArr.push('float(');
        this.astGeneric(assNode.right, retArr);
        retArr.push(')');
      } else {
        this.astGeneric(assNode.right, retArr);
      }
      return retArr;
    }
  }

  astBlockStatement(bNode, retArr) {
    if (this.isState('loop-body')) {
      this.pushState('block-body'); 
      for (let i = 0; i < bNode.body.length; i++) {
        this.astGeneric(bNode.body[i], retArr);
      }
      this.popState('block-body');
    } else {
      retArr.push('{\n');
      for (let i = 0; i < bNode.body.length; i++) {
        this.astGeneric(bNode.body[i], retArr);
      }
      retArr.push('}\n');
    }
    return retArr;
  }

  astVariableDeclaration(varDecNode, retArr) {
    const declarations = varDecNode.declarations;
    if (!declarations || !declarations[0] || !declarations[0].init) {
      throw this.astErrorOutput('Unexpected expression', varDecNode);
    }
    const result = [];
    let lastType = null;
    const declarationSets = [];
    let declarationSet = [];
    for (let i = 0; i < declarations.length; i++) {
      const declaration = declarations[i];
      const init = declaration.init;
      const info = this.getDeclaration(declaration.id);
      const actualType = this.getType(declaration.init);
      let type = actualType;
      if (type === 'LiteralInteger') {
        if (info.suggestedType === 'Integer') {
          type = 'Integer';
        } else {
          type = 'Number';
        }
      }
      const markupType = typeMap[type];
      if (!markupType) {
        throw this.astErrorOutput(`Markup type ${ type } not handled`, varDecNode);
      }
      const declarationResult = [];
      if (actualType === 'Integer' && type === 'Integer') {
        info.valueType = 'Number';
        if (i === 0 || lastType === null) {
          declarationResult.push('float ');
        } else if (type !== lastType) {
          throw new Error('Unhandled declaration');
        }
        lastType = type;
        declarationResult.push(`user_${utils.sanitizeName(declaration.id.name)}=`);
        declarationResult.push('float(');
        this.astGeneric(init, declarationResult);
        declarationResult.push(')');
      } else {
        info.valueType = type;
        if (i === 0 || lastType === null) {
          declarationResult.push(`${markupType} `);
        } else if (type !== lastType) {
          declarationSets.push(declarationSet.join(','));
          declarationSet = [];
          declarationResult.push(`${markupType} `);
        }
        lastType = type;
        declarationResult.push(`user_${utils.sanitizeName(declaration.id.name)}=`);
        if (actualType === 'Number' && type === 'Integer') {
          if (init.left && init.left.type === 'Literal') {
            this.astGeneric(init, declarationResult);
          } else {
            declarationResult.push('int(');
            this.astGeneric(init, declarationResult);
            declarationResult.push(')');
          }
        } else if (actualType === 'LiteralInteger' && type === 'Integer') {
          this.castLiteralToInteger(init, declarationResult);
        } else {
          this.astGeneric(init, declarationResult);
        }
      }
      declarationSet.push(declarationResult.join(''));
    }

    if (declarationSet.length > 0) {
      declarationSets.push(declarationSet.join(','));
    }

    result.push(declarationSets.join(';'));

    retArr.push(result.join(''));
    retArr.push(';');
    return retArr;
  }

  astIfStatement(ifNode, retArr) {
    retArr.push('if (');
    this.astGeneric(ifNode.test, retArr);
    retArr.push(')');
    if (ifNode.consequent.type === 'BlockStatement') {
      this.astGeneric(ifNode.consequent, retArr);
    } else {
      retArr.push(' {\n');
      this.astGeneric(ifNode.consequent, retArr);
      retArr.push('\n}\n');
    }

    if (ifNode.alternate) {
      retArr.push('else ');
      if (ifNode.alternate.type === 'BlockStatement' || ifNode.alternate.type === 'IfStatement') {
        this.astGeneric(ifNode.alternate, retArr);
      } else {
        retArr.push(' {\n');
        this.astGeneric(ifNode.alternate, retArr);
        retArr.push('\n}\n');
      }
    }
    return retArr;
  }

  astSwitchStatement(ast, retArr) {
    if (ast.type !== 'SwitchStatement') {
      throw this.astErrorOutput('Invalid switch statement', ast);
    }
    const { discriminant, cases } = ast;
    const type = this.getType(discriminant);
    const varName = `switchDiscriminant${this.astKey(ast, '_')}`;
    switch (type) {
      case 'Float':
      case 'Number':
        retArr.push(`float ${varName} = `);
        this.astGeneric(discriminant, retArr);
        retArr.push(';\n');
        break;
      case 'Integer':
        retArr.push(`int ${varName} = `);
        this.astGeneric(discriminant, retArr);
        retArr.push(';\n');
        break;
    }
    if (cases.length === 1 && !cases[0].test) {
      this.astGeneric(cases[0].consequent, retArr);
      return retArr;
    }

    let fallingThrough = false;
    let defaultResult = [];
    let movingDefaultToEnd = false;
    let pastFirstIf = false;
    for (let i = 0; i < cases.length; i++) {
      if (!cases[i].test) {
        if (cases.length > i + 1) {
          movingDefaultToEnd = true;
          this.astGeneric(cases[i].consequent, defaultResult);
          continue;
        } else {
          retArr.push(' else {\n');
        }
      } else {
        if (i === 0 || !pastFirstIf) {
          pastFirstIf = true;
          retArr.push(`if (${varName} == `);
        } else {
          if (fallingThrough) {
            retArr.push(`${varName} == `);
            fallingThrough = false;
          } else {
            retArr.push(` else if (${varName} == `);
          }
        }
        if (type === 'Integer') {
          const testType = this.getType(cases[i].test);
          switch (testType) {
            case 'Number':
            case 'Float':
              this.castValueToInteger(cases[i].test, retArr);
              break;
            case 'LiteralInteger':
              this.castLiteralToInteger(cases[i].test, retArr);
              break;
          }
        } else if (type === 'Float') {
          const testType = this.getType(cases[i].test);
          switch (testType) {
            case 'LiteralInteger':
              this.castLiteralToFloat(cases[i].test, retArr);
              break;
            case 'Integer':
              this.castValueToFloat(cases[i].test, retArr);
              break;
          }
        } else {
          throw new Error('unhanlded');
        }
        if (!cases[i].consequent || cases[i].consequent.length === 0) {
          fallingThrough = true;
          retArr.push(' || ');
          continue;
        }
        retArr.push(`) {\n`);
      }
      this.astGeneric(cases[i].consequent, retArr);
      retArr.push('\n}');
    }
    if (movingDefaultToEnd) {
      retArr.push(' else {');
      retArr.push(defaultResult.join(''));
      retArr.push('}');
    }
    return retArr;
  }

  astThisExpression(tNode, retArr) {
    retArr.push('this');
    return retArr;
  }

  astMemberExpression(mNode, retArr) {
    const {
      property,
      name,
      signature,
      origin,
      type,
      xProperty,
      yProperty,
      zProperty
    } = this.getMemberExpressionDetails(mNode);
    switch (signature) {
      case 'value.thread.value':
      case 'this.thread.value':
        if (name !== 'x' && name !== 'y' && name !== 'z') {
          throw this.astErrorOutput('Unexpected expression, expected `this.thread.x`, `this.thread.y`, or `this.thread.z`', mNode);
        }
        retArr.push(`threadId.${name}`);
        return retArr;
      case 'this.output.value':
        if (this.dynamicOutput) {
          switch (name) {
            case 'x':
              if (this.isState('casting-to-float')) {
                retArr.push('float(uOutputDim.x)');
              } else {
                retArr.push('uOutputDim.x');
              }
              break;
            case 'y':
              if (this.isState('casting-to-float')) {
                retArr.push('float(uOutputDim.y)');
              } else {
                retArr.push('uOutputDim.y');
              }
              break;
            case 'z':
              if (this.isState('casting-to-float')) {
                retArr.push('float(uOutputDim.z)');
              } else {
                retArr.push('uOutputDim.z');
              }
              break;
            default:
              throw this.astErrorOutput('Unexpected expression', mNode);
          }
        } else {
          switch (name) {
            case 'x':
              if (this.isState('casting-to-integer')) {
                retArr.push(this.output[0]);
              } else {
                retArr.push(this.output[0], '.0');
              }
              break;
            case 'y':
              if (this.isState('casting-to-integer')) {
                retArr.push(this.output[1]);
              } else {
                retArr.push(this.output[1], '.0');
              }
              break;
            case 'z':
              if (this.isState('casting-to-integer')) {
                retArr.push(this.output[2]);
              } else {
                retArr.push(this.output[2], '.0');
              }
              break;
            default:
              throw this.astErrorOutput('Unexpected expression', mNode);
          }
        }
        return retArr;
      case 'value':
        throw this.astErrorOutput('Unexpected expression', mNode);
      case 'value[]':
      case 'value[][]':
      case 'value[][][]':
      case 'value[][][][]':
      case 'value.value':
        if (origin === 'Math') {
          retArr.push(Math[name]);
          return retArr;
        }
        const cleanName = utils.sanitizeName(name);
        switch (property) {
          case 'r':
            retArr.push(`user_${ cleanName }.r`);
            return retArr;
          case 'g':
            retArr.push(`user_${ cleanName }.g`);
            return retArr;
          case 'b':
            retArr.push(`user_${ cleanName }.b`);
            return retArr;
          case 'a':
            retArr.push(`user_${ cleanName }.a`);
            return retArr;
        }
        break;
      case 'this.constants.value':
        if (typeof xProperty === 'undefined') {
          switch (type) {
            case 'Array(2)':
            case 'Array(3)':
            case 'Array(4)':
              retArr.push(`constants_${ utils.sanitizeName(name) }`);
              return retArr;
          }
        }
        case 'this.constants.value[]':
        case 'this.constants.value[][]':
        case 'this.constants.value[][][]':
        case 'this.constants.value[][][][]':
          break;
        case 'fn()[]':
          this.astCallExpression(mNode.object, retArr);
          retArr.push('[');
          retArr.push(this.memberExpressionPropertyMarkup(property));
          retArr.push(']');
          return retArr;
        case 'fn()[][]':
          this.astCallExpression(mNode.object.object, retArr);
          retArr.push('[');
          retArr.push(this.memberExpressionPropertyMarkup(mNode.object.property));
          retArr.push(']');
          retArr.push('[');
          retArr.push(this.memberExpressionPropertyMarkup(mNode.property));
          retArr.push(']');
          return retArr;
        case '[][]':
          this.astArrayExpression(mNode.object, retArr);
          retArr.push('[');
          retArr.push(this.memberExpressionPropertyMarkup(property));
          retArr.push(']');
          return retArr;
        default:
          throw this.astErrorOutput('Unexpected expression', mNode);
    }

    if (mNode.computed === false) {
      switch (type) {
        case 'Number':
        case 'Integer':
        case 'Float':
        case 'Boolean':
          retArr.push(`${origin}_${utils.sanitizeName(name)}`);
          return retArr;
      }
    }

    const markupName = `${origin}_${utils.sanitizeName(name)}`;

    switch (type) {
      case 'Array(2)':
      case 'Array(3)':
      case 'Array(4)':
        this.astGeneric(mNode.object, retArr);
        retArr.push('[');
        retArr.push(this.memberExpressionPropertyMarkup(xProperty));
        retArr.push(']');
        break;
      case 'HTMLImageArray':
        retArr.push(`getImage3D(${ markupName }, ${ markupName }Size, ${ markupName }Dim, `);
        this.memberExpressionXYZ(xProperty, yProperty, zProperty, retArr);
        retArr.push(')');
        break;
      case 'ArrayTexture(1)':
        retArr.push(`getFloatFromSampler2D(${ markupName }, ${ markupName }Size, ${ markupName }Dim, `);
        this.memberExpressionXYZ(xProperty, yProperty, zProperty, retArr);
        retArr.push(')');
        break;
      case 'Array1D(2)':
      case 'Array2D(2)':
      case 'Array3D(2)':
        retArr.push(`getMemoryOptimizedVec2(${ markupName }, ${ markupName }Size, ${ markupName }Dim, `);
        this.memberExpressionXYZ(xProperty, yProperty, zProperty, retArr);
        retArr.push(')');
        break;
      case 'ArrayTexture(2)':
        retArr.push(`getVec2FromSampler2D(${ markupName }, ${ markupName }Size, ${ markupName }Dim, `);
        this.memberExpressionXYZ(xProperty, yProperty, zProperty, retArr);
        retArr.push(')');
        break;
      case 'Array1D(3)':
      case 'Array2D(3)':
      case 'Array3D(3)':
        retArr.push(`getMemoryOptimizedVec3(${ markupName }, ${ markupName }Size, ${ markupName }Dim, `);
        this.memberExpressionXYZ(xProperty, yProperty, zProperty, retArr);
        retArr.push(')');
        break;
      case 'ArrayTexture(3)':
        retArr.push(`getVec3FromSampler2D(${ markupName }, ${ markupName }Size, ${ markupName }Dim, `);
        this.memberExpressionXYZ(xProperty, yProperty, zProperty, retArr);
        retArr.push(')');
        break;
      case 'Array1D(4)':
      case 'Array2D(4)':
      case 'Array3D(4)':
        retArr.push(`getMemoryOptimizedVec4(${ markupName }, ${ markupName }Size, ${ markupName }Dim, `);
        this.memberExpressionXYZ(xProperty, yProperty, zProperty, retArr);
        retArr.push(')');
        break;
      case 'ArrayTexture(4)':
      case 'HTMLCanvas':
      case 'OffscreenCanvas':
      case 'HTMLImage':
      case 'ImageBitmap':
      case 'ImageData':
      case 'HTMLVideo':
        retArr.push(`getVec4FromSampler2D(${ markupName }, ${ markupName }Size, ${ markupName }Dim, `);
        this.memberExpressionXYZ(xProperty, yProperty, zProperty, retArr);
        retArr.push(')');
        break;
      case 'NumberTexture':
      case 'Array':
      case 'Array2D':
      case 'Array3D':
      case 'Array4D':
      case 'Input':
      case 'Number':
      case 'Float':
      case 'Integer':
        if (this.precision === 'single') {
          retArr.push(`getMemoryOptimized32(${markupName}, ${markupName}Size, ${markupName}Dim, `);
          this.memberExpressionXYZ(xProperty, yProperty, zProperty, retArr);
          retArr.push(')');
        } else {
          const bitRatio = (origin === 'user' ?
            this.lookupFunctionArgumentBitRatio(this.name, name) :
            this.constantBitRatios[name]
          );
          switch (bitRatio) {
            case 1:
              retArr.push(`get8(${markupName}, ${markupName}Size, ${markupName}Dim, `);
              break;
            case 2:
              retArr.push(`get16(${markupName}, ${markupName}Size, ${markupName}Dim, `);
              break;
            case 4:
            case 0:
              retArr.push(`get32(${markupName}, ${markupName}Size, ${markupName}Dim, `);
              break;
            default:
              throw new Error(`unhandled bit ratio of ${bitRatio}`);
          }
          this.memberExpressionXYZ(xProperty, yProperty, zProperty, retArr);
          retArr.push(')');
        }
        break;
      case 'MemoryOptimizedNumberTexture':
        retArr.push(`getMemoryOptimized32(${ markupName }, ${ markupName }Size, ${ markupName }Dim, `);
        this.memberExpressionXYZ(xProperty, yProperty, zProperty, retArr);
        retArr.push(')');
        break;
      case 'Matrix(2)':
      case 'Matrix(3)':
      case 'Matrix(4)':
        retArr.push(`${markupName}[${this.memberExpressionPropertyMarkup(yProperty)}]`);
        if (yProperty) {
          retArr.push(`[${this.memberExpressionPropertyMarkup(xProperty)}]`);
        }
        break;
      default:
        throw new Error(`unhandled member expression "${ type }"`);
    }
    return retArr;
  }

  astCallExpression(ast, retArr) {
    if (!ast.callee) {
      throw this.astErrorOutput('Unknown CallExpression', ast);
    }

    let functionName = null;
    const isMathFunction = this.isAstMathFunction(ast);

    if (isMathFunction || (ast.callee.object && ast.callee.object.type === 'ThisExpression')) {
      functionName = ast.callee.property.name;
    }
    else if (ast.callee.type === 'SequenceExpression' && ast.callee.expressions[0].type === 'Literal' && !isNaN(ast.callee.expressions[0].raw)) {
      functionName = ast.callee.expressions[1].property.name;
    } else {
      functionName = ast.callee.name;
    }

    if (!functionName) {
      throw this.astErrorOutput(`Unhandled function, couldn't find name`, ast);
    }

    switch (functionName) {
      case 'pow':
        functionName = '_pow';
        break;
      case 'round':
        functionName = '_round';
        break;
    }

    if (this.calledFunctions.indexOf(functionName) < 0) {
      this.calledFunctions.push(functionName);
    }

    if (functionName === 'random' && this.plugins && this.plugins.length > 0) {
      for (let i = 0; i < this.plugins.length; i++) {
        const plugin = this.plugins[i];
        if (plugin.functionMatch === 'Math.random()' && plugin.functionReplace) {
          retArr.push(plugin.functionReplace);
          return retArr;
        }
      }
    }

    if (this.onFunctionCall) {
      this.onFunctionCall(this.name, functionName, ast.arguments);
    }

    retArr.push(functionName);

    retArr.push('(');

    if (isMathFunction) {
      for (let i = 0; i < ast.arguments.length; ++i) {
        const argument = ast.arguments[i];
        const argumentType = this.getType(argument);
        if (i > 0) {
          retArr.push(', ');
        }

        switch (argumentType) {
          case 'Integer':
            this.castValueToFloat(argument, retArr);
            break;
          default:
            this.astGeneric(argument, retArr);
            break;
        }
      }
    } else {
      const targetTypes = this.lookupFunctionArgumentTypes(functionName) || [];
      for (let i = 0; i < ast.arguments.length; ++i) {
        const argument = ast.arguments[i];
        let targetType = targetTypes[i];
        if (i > 0) {
          retArr.push(', ');
        }
        const argumentType = this.getType(argument);
        if (!targetType) {
          this.triggerImplyArgumentType(functionName, i, argumentType, this);
          targetType = argumentType;
        }
        switch (argumentType) {
          case 'Boolean':
            this.astGeneric(argument, retArr);
            continue;
          case 'Number':
          case 'Float':
            if (targetType === 'Integer') {
              retArr.push('int(');
              this.astGeneric(argument, retArr);
              retArr.push(')');
              continue;
            } else if (targetType === 'Number' || targetType === 'Float') {
              this.astGeneric(argument, retArr);
              continue;
            } else if (targetType === 'LiteralInteger') {
              this.castLiteralToFloat(argument, retArr);
              continue;
            }
            break;
          case 'Integer':
            if (targetType === 'Number' || targetType === 'Float') {
              retArr.push('float(');
              this.astGeneric(argument, retArr);
              retArr.push(')');
              continue;
            } else if (targetType === 'Integer') {
              this.astGeneric(argument, retArr);
              continue;
            }
            break;
          case 'LiteralInteger':
            if (targetType === 'Integer') {
              this.castLiteralToInteger(argument, retArr);
              continue;
            } else if (targetType === 'Number' || targetType === 'Float') {
              this.castLiteralToFloat(argument, retArr);
              continue;
            } else if (targetType === 'LiteralInteger') {
              this.astGeneric(argument, retArr);
              continue;
            }
            break;
          case 'Array(2)':
          case 'Array(3)':
          case 'Array(4)':
            if (targetType === argumentType) {
              if (argument.type === 'Identifier') {
                retArr.push(`user_${utils.sanitizeName(argument.name)}`);
              } else if (argument.type === 'ArrayExpression' || argument.type === 'MemberExpression' || argument.type === 'CallExpression') {
                this.astGeneric(argument, retArr);
              } else {
                throw this.astErrorOutput(`Unhandled argument type ${ argument.type }`, ast);
              }
              continue;
            }
            break;
          case 'HTMLCanvas':
          case 'OffscreenCanvas':
          case 'HTMLImage':
          case 'ImageBitmap':
          case 'ImageData':
          case 'HTMLImageArray':
          case 'HTMLVideo':
          case 'ArrayTexture(1)':
          case 'ArrayTexture(2)':
          case 'ArrayTexture(3)':
          case 'ArrayTexture(4)':
          case 'Array':
          case 'Input':
            if (targetType === argumentType) {
              if (argument.type !== 'Identifier') throw this.astErrorOutput(`Unhandled argument type ${ argument.type }`, ast);
              this.triggerImplyArgumentBitRatio(this.name, argument.name, functionName, i);
              const name = utils.sanitizeName(argument.name);
              retArr.push(`user_${name},user_${name}Size,user_${name}Dim`);
              continue;
            }
            break;
        }
        throw this.astErrorOutput(`Unhandled argument combination of ${ argumentType } and ${ targetType } for argument named "${ argument.name }"`, ast);
      }
    }
    retArr.push(')');

    return retArr;
  }

  astArrayExpression(arrNode, retArr) {
    const returnType = this.getType(arrNode);

    const arrLen = arrNode.elements.length;

    switch (returnType) {
      case 'Matrix(2)':
      case 'Matrix(3)':
      case 'Matrix(4)':
        retArr.push(`mat${arrLen}(`);
        break;
      default:
        retArr.push(`vec${arrLen}(`);
    }
    for (let i = 0; i < arrLen; ++i) {
      if (i > 0) {
        retArr.push(', ');
      }
      const subNode = arrNode.elements[i];
      this.astGeneric(subNode, retArr)
    }
    retArr.push(')');

    return retArr;
  }

  memberExpressionXYZ(x, y, z, retArr) {
    if (z) {
      retArr.push(this.memberExpressionPropertyMarkup(z), ', ');
    } else {
      retArr.push('0, ');
    }
    if (y) {
      retArr.push(this.memberExpressionPropertyMarkup(y), ', ');
    } else {
      retArr.push('0, ');
    }
    retArr.push(this.memberExpressionPropertyMarkup(x));
    return retArr;
  }

  memberExpressionPropertyMarkup(property) {
    if (!property) {
      throw new Error('Property not set');
    }
    const type = this.getType(property);
    const result = [];
    switch (type) {
      case 'Number':
      case 'Float':
        this.castValueToInteger(property, result);
        break;
      case 'LiteralInteger':
        this.castLiteralToInteger(property, result);
        break;
      default:
        this.astGeneric(property, result);
    }
    return result.join('');
  }
}

const typeMap = {
  'Array': 'sampler2D',
  'Array(2)': 'vec2',
  'Array(3)': 'vec3',
  'Array(4)': 'vec4',
  'Matrix(2)': 'mat2',
  'Matrix(3)': 'mat3',
  'Matrix(4)': 'mat4',
  'Array2D': 'sampler2D',
  'Array3D': 'sampler2D',
  'Boolean': 'bool',
  'Float': 'float',
  'Input': 'sampler2D',
  'Integer': 'int',
  'Number': 'float',
  'LiteralInteger': 'float',
  'NumberTexture': 'sampler2D',
  'MemoryOptimizedNumberTexture': 'sampler2D',
  'ArrayTexture(1)': 'sampler2D',
  'ArrayTexture(2)': 'sampler2D',
  'ArrayTexture(3)': 'sampler2D',
  'ArrayTexture(4)': 'sampler2D',
  'HTMLVideo': 'sampler2D',
  'HTMLCanvas': 'sampler2D',
  'OffscreenCanvas': 'sampler2D',
  'HTMLImage': 'sampler2D',
  'ImageBitmap': 'sampler2D',
  'ImageData': 'sampler2D',
  'HTMLImageArray': 'sampler2DArray',
};

const operatorMap = {
  '===': '==',
  '!==': '!='
};

module.exports = {
  WebGLFunctionNode
};
},{"../../utils":114,"../function-node":10}],39:[function(require,module,exports){
const { WebGLKernelValueBoolean } = require('./kernel-value/boolean');
const { WebGLKernelValueFloat } = require('./kernel-value/float');
const { WebGLKernelValueInteger } = require('./kernel-value/integer');

const { WebGLKernelValueHTMLImage } = require('./kernel-value/html-image');
const { WebGLKernelValueDynamicHTMLImage } = require('./kernel-value/dynamic-html-image');

const { WebGLKernelValueHTMLVideo } = require('./kernel-value/html-video');
const { WebGLKernelValueDynamicHTMLVideo } = require('./kernel-value/dynamic-html-video');

const { WebGLKernelValueSingleInput } = require('./kernel-value/single-input');
const { WebGLKernelValueDynamicSingleInput } = require('./kernel-value/dynamic-single-input');

const { WebGLKernelValueUnsignedInput } = require('./kernel-value/unsigned-input');
const { WebGLKernelValueDynamicUnsignedInput } = require('./kernel-value/dynamic-unsigned-input');

const { WebGLKernelValueMemoryOptimizedNumberTexture } = require('./kernel-value/memory-optimized-number-texture');
const { WebGLKernelValueDynamicMemoryOptimizedNumberTexture } = require('./kernel-value/dynamic-memory-optimized-number-texture');

const { WebGLKernelValueNumberTexture } = require('./kernel-value/number-texture');
const { WebGLKernelValueDynamicNumberTexture } = require('./kernel-value/dynamic-number-texture');

const { WebGLKernelValueSingleArray } = require('./kernel-value/single-array');
const { WebGLKernelValueDynamicSingleArray } = require('./kernel-value/dynamic-single-array');

const { WebGLKernelValueSingleArray1DI } = require('./kernel-value/single-array1d-i');
const { WebGLKernelValueDynamicSingleArray1DI } = require('./kernel-value/dynamic-single-array1d-i');

const { WebGLKernelValueSingleArray2DI } = require('./kernel-value/single-array2d-i');
const { WebGLKernelValueDynamicSingleArray2DI } = require('./kernel-value/dynamic-single-array2d-i');

const { WebGLKernelValueSingleArray3DI } = require('./kernel-value/single-array3d-i');
const { WebGLKernelValueDynamicSingleArray3DI } = require('./kernel-value/dynamic-single-array3d-i');

const { WebGLKernelValueArray2 } = require('./kernel-value/array2');
const { WebGLKernelValueArray3 } = require('./kernel-value/array3');
const { WebGLKernelValueArray4 } = require('./kernel-value/array4');

const { WebGLKernelValueUnsignedArray } = require('./kernel-value/unsigned-array');
const { WebGLKernelValueDynamicUnsignedArray } = require('./kernel-value/dynamic-unsigned-array');

const kernelValueMaps = {
  unsigned: {
    dynamic: {
      'Boolean': WebGLKernelValueBoolean,
      'Integer': WebGLKernelValueInteger,
      'Float': WebGLKernelValueFloat,
      'Array': WebGLKernelValueDynamicUnsignedArray,
      'Array(2)': WebGLKernelValueArray2,
      'Array(3)': WebGLKernelValueArray3,
      'Array(4)': WebGLKernelValueArray4,
      'Array1D(2)': false,
      'Array1D(3)': false,
      'Array1D(4)': false,
      'Array2D(2)': false,
      'Array2D(3)': false,
      'Array2D(4)': false,
      'Array3D(2)': false,
      'Array3D(3)': false,
      'Array3D(4)': false,
      'Input': WebGLKernelValueDynamicUnsignedInput,
      'NumberTexture': WebGLKernelValueDynamicNumberTexture,
      'ArrayTexture(1)': WebGLKernelValueDynamicNumberTexture,
      'ArrayTexture(2)': WebGLKernelValueDynamicNumberTexture,
      'ArrayTexture(3)': WebGLKernelValueDynamicNumberTexture,
      'ArrayTexture(4)': WebGLKernelValueDynamicNumberTexture,
      'MemoryOptimizedNumberTexture': WebGLKernelValueDynamicMemoryOptimizedNumberTexture,
      'HTMLCanvas': WebGLKernelValueDynamicHTMLImage,
      'OffscreenCanvas': WebGLKernelValueDynamicHTMLImage,
      'HTMLImage': WebGLKernelValueDynamicHTMLImage,
      'ImageBitmap': WebGLKernelValueDynamicHTMLImage,
      'ImageData': WebGLKernelValueDynamicHTMLImage,
      'HTMLImageArray': false,
      'HTMLVideo': WebGLKernelValueDynamicHTMLVideo,
    },
    static: {
      'Boolean': WebGLKernelValueBoolean,
      'Float': WebGLKernelValueFloat,
      'Integer': WebGLKernelValueInteger,
      'Array': WebGLKernelValueUnsignedArray,
      'Array(2)': WebGLKernelValueArray2,
      'Array(3)': WebGLKernelValueArray3,
      'Array(4)': WebGLKernelValueArray4,
      'Array1D(2)': false,
      'Array1D(3)': false,
      'Array1D(4)': false,
      'Array2D(2)': false,
      'Array2D(3)': false,
      'Array2D(4)': false,
      'Array3D(2)': false,
      'Array3D(3)': false,
      'Array3D(4)': false,
      'Input': WebGLKernelValueUnsignedInput,
      'NumberTexture': WebGLKernelValueNumberTexture,
      'ArrayTexture(1)': WebGLKernelValueNumberTexture,
      'ArrayTexture(2)': WebGLKernelValueNumberTexture,
      'ArrayTexture(3)': WebGLKernelValueNumberTexture,
      'ArrayTexture(4)': WebGLKernelValueNumberTexture,
      'MemoryOptimizedNumberTexture': WebGLKernelValueMemoryOptimizedNumberTexture,
      'HTMLCanvas': WebGLKernelValueHTMLImage,
      'OffscreenCanvas': WebGLKernelValueHTMLImage,
      'HTMLImage': WebGLKernelValueHTMLImage,
      'ImageBitmap': WebGLKernelValueHTMLImage,
      'ImageData': WebGLKernelValueHTMLImage,
      'HTMLImageArray': false,
      'HTMLVideo': WebGLKernelValueHTMLVideo,
    }
  },
  single: {
    dynamic: {
      'Boolean': WebGLKernelValueBoolean,
      'Integer': WebGLKernelValueInteger,
      'Float': WebGLKernelValueFloat,
      'Array': WebGLKernelValueDynamicSingleArray,
      'Array(2)': WebGLKernelValueArray2,
      'Array(3)': WebGLKernelValueArray3,
      'Array(4)': WebGLKernelValueArray4,
      'Array1D(2)': WebGLKernelValueDynamicSingleArray1DI,
      'Array1D(3)': WebGLKernelValueDynamicSingleArray1DI,
      'Array1D(4)': WebGLKernelValueDynamicSingleArray1DI,
      'Array2D(2)': WebGLKernelValueDynamicSingleArray2DI,
      'Array2D(3)': WebGLKernelValueDynamicSingleArray2DI,
      'Array2D(4)': WebGLKernelValueDynamicSingleArray2DI,
      'Array3D(2)': WebGLKernelValueDynamicSingleArray3DI,
      'Array3D(3)': WebGLKernelValueDynamicSingleArray3DI,
      'Array3D(4)': WebGLKernelValueDynamicSingleArray3DI,
      'Input': WebGLKernelValueDynamicSingleInput,
      'NumberTexture': WebGLKernelValueDynamicNumberTexture,
      'ArrayTexture(1)': WebGLKernelValueDynamicNumberTexture,
      'ArrayTexture(2)': WebGLKernelValueDynamicNumberTexture,
      'ArrayTexture(3)': WebGLKernelValueDynamicNumberTexture,
      'ArrayTexture(4)': WebGLKernelValueDynamicNumberTexture,
      'MemoryOptimizedNumberTexture': WebGLKernelValueDynamicMemoryOptimizedNumberTexture,
      'HTMLCanvas': WebGLKernelValueDynamicHTMLImage,
      'OffscreenCanvas': WebGLKernelValueDynamicHTMLImage,
      'HTMLImage': WebGLKernelValueDynamicHTMLImage,
      'ImageBitmap': WebGLKernelValueDynamicHTMLImage,
      'ImageData': WebGLKernelValueDynamicHTMLImage,
      'HTMLImageArray': false,
      'HTMLVideo': WebGLKernelValueDynamicHTMLVideo,
    },
    static: {
      'Boolean': WebGLKernelValueBoolean,
      'Float': WebGLKernelValueFloat,
      'Integer': WebGLKernelValueInteger,
      'Array': WebGLKernelValueSingleArray,
      'Array(2)': WebGLKernelValueArray2,
      'Array(3)': WebGLKernelValueArray3,
      'Array(4)': WebGLKernelValueArray4,
      'Array1D(2)': WebGLKernelValueSingleArray1DI,
      'Array1D(3)': WebGLKernelValueSingleArray1DI,
      'Array1D(4)': WebGLKernelValueSingleArray1DI,
      'Array2D(2)': WebGLKernelValueSingleArray2DI,
      'Array2D(3)': WebGLKernelValueSingleArray2DI,
      'Array2D(4)': WebGLKernelValueSingleArray2DI,
      'Array3D(2)': WebGLKernelValueSingleArray3DI,
      'Array3D(3)': WebGLKernelValueSingleArray3DI,
      'Array3D(4)': WebGLKernelValueSingleArray3DI,
      'Input': WebGLKernelValueSingleInput,
      'NumberTexture': WebGLKernelValueNumberTexture,
      'ArrayTexture(1)': WebGLKernelValueNumberTexture,
      'ArrayTexture(2)': WebGLKernelValueNumberTexture,
      'ArrayTexture(3)': WebGLKernelValueNumberTexture,
      'ArrayTexture(4)': WebGLKernelValueNumberTexture,
      'MemoryOptimizedNumberTexture': WebGLKernelValueMemoryOptimizedNumberTexture,
      'HTMLCanvas': WebGLKernelValueHTMLImage,
      'OffscreenCanvas': WebGLKernelValueHTMLImage,
      'HTMLImage': WebGLKernelValueHTMLImage,
      'ImageBitmap': WebGLKernelValueHTMLImage,
      'ImageData': WebGLKernelValueHTMLImage,
      'HTMLImageArray': false,
      'HTMLVideo': WebGLKernelValueHTMLVideo,
    }
  },
};

function lookupKernelValueType(type, dynamic, precision, value) {
  if (!type) {
    throw new Error('type missing');
  }
  if (!dynamic) {
    throw new Error('dynamic missing');
  }
  if (!precision) {
    throw new Error('precision missing');
  }
  if (value.type) {
    type = value.type;
  }
  const types = kernelValueMaps[precision][dynamic];
  if (types[type] === false) {
    return null;
  } else if (types[type] === undefined) {
    throw new Error(`Could not find a KernelValue for ${ type }`);
  }
  return types[type];
}

module.exports = {
  lookupKernelValueType,
  kernelValueMaps,
};
},{"./kernel-value/array2":41,"./kernel-value/array3":42,"./kernel-value/array4":43,"./kernel-value/boolean":44,"./kernel-value/dynamic-html-image":45,"./kernel-value/dynamic-html-video":46,"./kernel-value/dynamic-memory-optimized-number-texture":47,"./kernel-value/dynamic-number-texture":48,"./kernel-value/dynamic-single-array":49,"./kernel-value/dynamic-single-array1d-i":50,"./kernel-value/dynamic-single-array2d-i":51,"./kernel-value/dynamic-single-array3d-i":52,"./kernel-value/dynamic-single-input":53,"./kernel-value/dynamic-unsigned-array":54,"./kernel-value/dynamic-unsigned-input":55,"./kernel-value/float":56,"./kernel-value/html-image":57,"./kernel-value/html-video":58,"./kernel-value/integer":60,"./kernel-value/memory-optimized-number-texture":61,"./kernel-value/number-texture":62,"./kernel-value/single-array":63,"./kernel-value/single-array1d-i":64,"./kernel-value/single-array2d-i":65,"./kernel-value/single-array3d-i":66,"./kernel-value/single-input":67,"./kernel-value/unsigned-array":68,"./kernel-value/unsigned-input":69}],40:[function(require,module,exports){
const { WebGLKernelValue } = require('./index');
const { Input } = require('../../../input');

class WebGLKernelArray extends WebGLKernelValue {
  checkSize(width, height) {
    if (!this.kernel.validate) return;
    const { maxTextureSize } = this.kernel.constructor.features;
    if (width > maxTextureSize || height > maxTextureSize) {
      if (width > height) {
        throw new Error(`Argument texture width of ${width} larger than maximum size of ${maxTextureSize} for your GPU`);
      } else if (width < height) {
        throw new Error(`Argument texture height of ${height} larger than maximum size of ${maxTextureSize} for your GPU`);
      } else {
        throw new Error(`Argument texture height and width of ${height} larger than maximum size of ${maxTextureSize} for your GPU`);
      }
    }
  }

  setup() {
    this.requestTexture();
    this.setupTexture();
    this.defineTexture();
  }

  requestTexture() {
    this.texture = this.onRequestTexture();
  }

  defineTexture() {
    const { context: gl } = this;
    gl.activeTexture(this.contextHandle);
    gl.bindTexture(gl.TEXTURE_2D, this.texture);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
  }

  setupTexture() {
    this.contextHandle = this.onRequestContextHandle();
    this.index = this.onRequestIndex();
    this.dimensionsId = this.id + 'Dim';
    this.sizeId = this.id + 'Size';
  }

  getBitRatio(value) {
    if (Array.isArray(value[0])) {
      return this.getBitRatio(value[0]);
    } else if (value.constructor === Input) {
      return this.getBitRatio(value.value);
    }
    switch (value.constructor) {
      case Uint8ClampedArray:
      case Uint8Array:
      case Int8Array:
        return 1;
      case Uint16Array:
      case Int16Array:
        return 2;
      case Float32Array:
      case Int32Array:
      default:
        return 4;
    }
  }

  destroy() {
    if (this.prevArg) {
      this.prevArg.delete();
    }
    this.context.deleteTexture(this.texture);
  }
}

module.exports = {
  WebGLKernelArray
};
},{"../../../input":110,"./index":59}],41:[function(require,module,exports){
const { WebGLKernelValue } = require('./index');

class WebGLKernelValueArray2 extends WebGLKernelValue {
  constructor(value, settings) {
    super(value, settings);
    this.uploadValue = value;
  }
  getSource(value) {
    if (this.origin === 'constants') {
      return `const vec2 ${this.id} = vec2(${value[0]},${value[1]});\n`;
    }
    return `uniform vec2 ${this.id};\n`;
  }

  getStringValueHandler() {
    if (this.origin === 'constants') return '';
    return `const uploadValue_${this.name} = ${this.varName};\n`;
  }

  updateValue(value) {
    if (this.origin === 'constants') return;
    this.kernel.setUniform2fv(this.id, this.uploadValue = value);
  }
}

module.exports = {
  WebGLKernelValueArray2
};
},{"./index":59}],42:[function(require,module,exports){
const { WebGLKernelValue } = require('./index');

class WebGLKernelValueArray3 extends WebGLKernelValue {
  constructor(value, settings) {
    super(value, settings);
    this.uploadValue = value;
  }
  getSource(value) {
    if (this.origin === 'constants') {
      return `const vec3 ${this.id} = vec3(${value[0]},${value[1]},${value[2]});\n`;
    }
    return `uniform vec3 ${this.id};\n`;
  }

  getStringValueHandler() {
    if (this.origin === 'constants') return '';
    return `const uploadValue_${this.name} = ${this.varName};\n`;
  }

  updateValue(value) {
    if (this.origin === 'constants') return;
    this.kernel.setUniform3fv(this.id, this.uploadValue = value);
  }
}

module.exports = {
  WebGLKernelValueArray3
};
},{"./index":59}],43:[function(require,module,exports){
const { WebGLKernelValue } = require('./index');

class WebGLKernelValueArray4 extends WebGLKernelValue {
  constructor(value, settings) {
    super(value, settings);
    this.uploadValue = value;
  }
  getSource(value) {
    if (this.origin === 'constants') {
      return `const vec4 ${this.id} = vec4(${value[0]},${value[1]},${value[2]},${value[3]});\n`;
    }
    return `uniform vec4 ${this.id};\n`;
  }

  getStringValueHandler() {
    if (this.origin === 'constants') return '';
    return `const uploadValue_${this.name} = ${this.varName};\n`;
  }

  updateValue(value) {
    if (this.origin === 'constants') return;
    this.kernel.setUniform4fv(this.id, this.uploadValue = value);
  }
}

module.exports = {
  WebGLKernelValueArray4
};
},{"./index":59}],44:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValue } = require('./index');

class WebGLKernelValueBoolean extends WebGLKernelValue {
  constructor(value, settings) {
    super(value, settings);
    this.uploadValue = value;
  }
  getSource(value) {
    if (this.origin === 'constants') {
      return `const bool ${this.id} = ${value};\n`;
    }
    return `uniform bool ${this.id};\n`;
  }

  getStringValueHandler() {
    return `const uploadValue_${this.name} = ${this.varName};\n`;
  }

  updateValue(value) {
    if (this.origin === 'constants') return;
    this.kernel.setUniform1i(this.id, this.uploadValue = value);
  }
}

module.exports = {
  WebGLKernelValueBoolean
};
},{"../../../utils":114,"./index":59}],45:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueHTMLImage } = require('./html-image');

class WebGLKernelValueDynamicHTMLImage extends WebGLKernelValueHTMLImage {
  getSource() {
    return utils.linesToString([
      `uniform sampler2D ${this.id}`,
      `uniform ivec2 ${this.sizeId}`,
      `uniform ivec3 ${this.dimensionsId}`,
    ]);
  }

  updateValue(value) {
    const { width, height } = value;
    this.checkSize(width, height);
    this.dimensions = [width, height, 1];
    this.textureSize = [width, height];
    this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);
    this.kernel.setUniform2iv(this.sizeId, this.textureSize);
    super.updateValue(value);
  }
}

module.exports = {
  WebGLKernelValueDynamicHTMLImage
};
},{"../../../utils":114,"./html-image":57}],46:[function(require,module,exports){
const { WebGLKernelValueDynamicHTMLImage } = require('./dynamic-html-image');

class WebGLKernelValueDynamicHTMLVideo extends WebGLKernelValueDynamicHTMLImage {}

module.exports = {
  WebGLKernelValueDynamicHTMLVideo
};
},{"./dynamic-html-image":45}],47:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueMemoryOptimizedNumberTexture } = require('./memory-optimized-number-texture');

class WebGLKernelValueDynamicMemoryOptimizedNumberTexture extends WebGLKernelValueMemoryOptimizedNumberTexture {
  getSource() {
    return utils.linesToString([
      `uniform sampler2D ${this.id}`,
      `uniform ivec2 ${this.sizeId}`,
      `uniform ivec3 ${this.dimensionsId}`,
    ]);
  }

  updateValue(inputTexture) {
    this.dimensions = inputTexture.dimensions;
    this.checkSize(inputTexture.size[0], inputTexture.size[1]);
    this.textureSize = inputTexture.size;
    this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);
    this.kernel.setUniform2iv(this.sizeId, this.textureSize);
    super.updateValue(inputTexture);
  }
}

module.exports = {
  WebGLKernelValueDynamicMemoryOptimizedNumberTexture
};
},{"../../../utils":114,"./memory-optimized-number-texture":61}],48:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueNumberTexture } = require('./number-texture');

class WebGLKernelValueDynamicNumberTexture extends WebGLKernelValueNumberTexture {
  getSource() {
    return utils.linesToString([
      `uniform sampler2D ${this.id}`,
      `uniform ivec2 ${this.sizeId}`,
      `uniform ivec3 ${this.dimensionsId}`,
    ]);
  }

  updateValue(value) {
    this.dimensions = value.dimensions;
    this.checkSize(value.size[0], value.size[1]);
    this.textureSize = value.size;
    this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);
    this.kernel.setUniform2iv(this.sizeId, this.textureSize);
    super.updateValue(value);
  }
}

module.exports = {
  WebGLKernelValueDynamicNumberTexture
};
},{"../../../utils":114,"./number-texture":62}],49:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueSingleArray } = require('./single-array');

class WebGLKernelValueDynamicSingleArray extends WebGLKernelValueSingleArray {
  getSource() {
    return utils.linesToString([
      `uniform sampler2D ${this.id}`,
      `uniform ivec2 ${this.sizeId}`,
      `uniform ivec3 ${this.dimensionsId}`,
    ]);
  }

  updateValue(value) {
    this.dimensions = utils.getDimensions(value, true);
    this.textureSize = utils.getMemoryOptimizedFloatTextureSize(this.dimensions, this.bitRatio);
    this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * this.bitRatio;
    this.checkSize(this.textureSize[0], this.textureSize[1]);
    this.uploadValue = new Float32Array(this.uploadArrayLength);
    this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);
    this.kernel.setUniform2iv(this.sizeId, this.textureSize);
    super.updateValue(value);
  }
}

module.exports = {
  WebGLKernelValueDynamicSingleArray
};
},{"../../../utils":114,"./single-array":63}],50:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueSingleArray1DI } = require('./single-array1d-i');

class WebGLKernelValueDynamicSingleArray1DI extends WebGLKernelValueSingleArray1DI {
  getSource() {
    return utils.linesToString([
      `uniform sampler2D ${this.id}`,
      `uniform ivec2 ${this.sizeId}`,
      `uniform ivec3 ${this.dimensionsId}`,
    ]);
  }

  updateValue(value) {
    this.setShape(value);
    this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);
    this.kernel.setUniform2iv(this.sizeId, this.textureSize);
    super.updateValue(value);
  }
}

module.exports = {
  WebGLKernelValueDynamicSingleArray1DI
};
},{"../../../utils":114,"./single-array1d-i":64}],51:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueSingleArray2DI } = require('./single-array2d-i');

class WebGLKernelValueDynamicSingleArray2DI extends WebGLKernelValueSingleArray2DI {
  getSource() {
    return utils.linesToString([
      `uniform sampler2D ${this.id}`,
      `uniform ivec2 ${this.sizeId}`,
      `uniform ivec3 ${this.dimensionsId}`,
    ]);
  }

  updateValue(value) {
    this.setShape(value);
    this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);
    this.kernel.setUniform2iv(this.sizeId, this.textureSize);
    super.updateValue(value);
  }
}

module.exports = {
  WebGLKernelValueDynamicSingleArray2DI
};
},{"../../../utils":114,"./single-array2d-i":65}],52:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueSingleArray3DI } = require('./single-array3d-i');

class WebGLKernelValueDynamicSingleArray3DI extends WebGLKernelValueSingleArray3DI {
  getSource() {
    return utils.linesToString([
      `uniform sampler2D ${this.id}`,
      `uniform ivec2 ${this.sizeId}`,
      `uniform ivec3 ${this.dimensionsId}`,
    ]);
  }

  updateValue(value) {
    this.setShape(value);
    this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);
    this.kernel.setUniform2iv(this.sizeId, this.textureSize);
    super.updateValue(value);
  }
}

module.exports = {
  WebGLKernelValueDynamicSingleArray3DI
};
},{"../../../utils":114,"./single-array3d-i":66}],53:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueSingleInput } = require('./single-input');

class WebGLKernelValueDynamicSingleInput extends WebGLKernelValueSingleInput {
  getSource() {
    return utils.linesToString([
      `uniform sampler2D ${this.id}`,
      `uniform ivec2 ${this.sizeId}`,
      `uniform ivec3 ${this.dimensionsId}`,
    ]);
  }

  updateValue(value) {
    let [w, h, d] = value.size;
    this.dimensions = new Int32Array([w || 1, h || 1, d || 1]);
    this.textureSize = utils.getMemoryOptimizedFloatTextureSize(this.dimensions, this.bitRatio);
    this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * this.bitRatio;
    this.checkSize(this.textureSize[0], this.textureSize[1]);
    this.uploadValue = new Float32Array(this.uploadArrayLength);
    this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);
    this.kernel.setUniform2iv(this.sizeId, this.textureSize);
    super.updateValue(value);
  }
}

module.exports = {
  WebGLKernelValueDynamicSingleInput
};
},{"../../../utils":114,"./single-input":67}],54:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueUnsignedArray } = require('./unsigned-array');

class WebGLKernelValueDynamicUnsignedArray extends WebGLKernelValueUnsignedArray {
  getSource() {
    return utils.linesToString([
      `uniform sampler2D ${this.id}`,
      `uniform ivec2 ${this.sizeId}`,
      `uniform ivec3 ${this.dimensionsId}`,
    ]);
  }

  updateValue(value) {
    this.dimensions = utils.getDimensions(value, true);
    this.textureSize = utils.getMemoryOptimizedPackedTextureSize(this.dimensions, this.bitRatio);
    this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * (4 / this.bitRatio);
    this.checkSize(this.textureSize[0], this.textureSize[1]);
    const Type = this.getTransferArrayType(value);
    this.preUploadValue = new Type(this.uploadArrayLength);
    this.uploadValue = new Uint8Array(this.preUploadValue.buffer);
    this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);
    this.kernel.setUniform2iv(this.sizeId, this.textureSize);
    super.updateValue(value);
  }
}

module.exports = {
  WebGLKernelValueDynamicUnsignedArray
};
},{"../../../utils":114,"./unsigned-array":68}],55:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueUnsignedInput } = require('./unsigned-input');

class WebGLKernelValueDynamicUnsignedInput extends WebGLKernelValueUnsignedInput {
  getSource() {
    return utils.linesToString([
      `uniform sampler2D ${this.id}`,
      `uniform ivec2 ${this.sizeId}`,
      `uniform ivec3 ${this.dimensionsId}`,
    ]);
  }

  updateValue(value) {
    let [w, h, d] = value.size;
    this.dimensions = new Int32Array([w || 1, h || 1, d || 1]);
    this.textureSize = utils.getMemoryOptimizedPackedTextureSize(this.dimensions, this.bitRatio);
    this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * (4 / this.bitRatio);
    this.checkSize(this.textureSize[0], this.textureSize[1]);
    const Type = this.getTransferArrayType(value.value);
    this.preUploadValue = new Type(this.uploadArrayLength);
    this.uploadValue = new Uint8Array(this.preUploadValue.buffer);
    this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);
    this.kernel.setUniform2iv(this.sizeId, this.textureSize);
    super.updateValue(value);
  }
}

module.exports = {
  WebGLKernelValueDynamicUnsignedInput
};
},{"../../../utils":114,"./unsigned-input":69}],56:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValue } = require('./index');

class WebGLKernelValueFloat extends WebGLKernelValue {
  constructor(value, settings) {
    super(value, settings);
    this.uploadValue = value;
  }
  getStringValueHandler() {
    return `const uploadValue_${this.name} = ${this.varName};\n`;
  }
  getSource(value) {
    if (this.origin === 'constants') {
      if (Number.isInteger(value)) {
        return `const float ${this.id} = ${value}.0;\n`;
      }
      return `const float ${this.id} = ${value};\n`;
    }
    return `uniform float ${this.id};\n`;
  }

  updateValue(value) {
    if (this.origin === 'constants') return;
    this.kernel.setUniform1f(this.id, this.uploadValue = value);
  }
}

module.exports = {
  WebGLKernelValueFloat
};
},{"../../../utils":114,"./index":59}],57:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelArray } = require('./array');

class WebGLKernelValueHTMLImage extends WebGLKernelArray {
  constructor(value, settings) {
    super(value, settings);
    const { width, height } = value;
    this.checkSize(width, height);
    this.dimensions = [width, height, 1];
    this.textureSize = [width, height];
    this.uploadValue = value;
  }

  getStringValueHandler() {
    return `const uploadValue_${this.name} = ${this.varName};\n`;
  }

  getSource() {
    return utils.linesToString([
      `uniform sampler2D ${this.id}`,
      `ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,
      `ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,
    ]);
  }

  updateValue(inputImage) {
    if (inputImage.constructor !== this.initialValueConstructor) {
      this.onUpdateValueMismatch(inputImage.constructor);
      return;
    }
    const { context: gl } = this;
    gl.activeTexture(this.contextHandle);
    gl.bindTexture(gl.TEXTURE_2D, this.texture);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this.uploadValue = inputImage);
    this.kernel.setUniform1i(this.id, this.index);
  }
}

module.exports = {
  WebGLKernelValueHTMLImage
};
},{"../../../utils":114,"./array":40}],58:[function(require,module,exports){
const { WebGLKernelValueHTMLImage } = require('./html-image');

class WebGLKernelValueHTMLVideo extends WebGLKernelValueHTMLImage {}

module.exports = {
  WebGLKernelValueHTMLVideo
};
},{"./html-image":57}],59:[function(require,module,exports){
const { utils } = require('../../../utils');
const { KernelValue } = require('../../kernel-value');

class WebGLKernelValue extends KernelValue {
  constructor(value, settings) {
    super(value, settings);
    this.dimensionsId = null;
    this.sizeId = null;
    this.initialValueConstructor = value.constructor;
    this.onRequestTexture = settings.onRequestTexture;
    this.onRequestIndex = settings.onRequestIndex;
    this.uploadValue = null;
    this.textureSize = null;
    this.bitRatio = null;
    this.prevArg = null;
  }

  get id() {
    return `${this.origin}_${utils.sanitizeName(this.name)}`;
  }

  setup() {}

  getTransferArrayType(value) {
    if (Array.isArray(value[0])) {
      return this.getTransferArrayType(value[0]);
    }
    switch (value.constructor) {
      case Array:
      case Int32Array:
      case Int16Array:
      case Int8Array:
        return Float32Array;
      case Uint8ClampedArray:
      case Uint8Array:
      case Uint16Array:
      case Uint32Array:
      case Float32Array:
      case Float64Array:
        return value.constructor;
    }
    console.warn('Unfamiliar constructor type.  Will go ahead and use, but likley this may result in a transfer of zeros');
    return value.constructor;
  }

  getStringValueHandler() {
    throw new Error(`"getStringValueHandler" not implemented on ${this.constructor.name}`);
  }

  getVariablePrecisionString() {
    return this.kernel.getVariablePrecisionString(this.textureSize || undefined, this.tactic || undefined);
  }

  destroy() {}
}

module.exports = {
  WebGLKernelValue
};
},{"../../../utils":114,"../../kernel-value":35}],60:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValue } = require('./index');

class WebGLKernelValueInteger extends WebGLKernelValue {
  constructor(value, settings) {
    super(value, settings);
    this.uploadValue = value;
  }
  getStringValueHandler() {
    return `const uploadValue_${this.name} = ${this.varName};\n`;
  }
  getSource(value) {
    if (this.origin === 'constants') {
      return `const int ${this.id} = ${ parseInt(value) };\n`;
    }
    return `uniform int ${this.id};\n`;
  }

  updateValue(value) {
    if (this.origin === 'constants') return;
    this.kernel.setUniform1i(this.id, this.uploadValue = value);
  }
}

module.exports = {
  WebGLKernelValueInteger
};
},{"../../../utils":114,"./index":59}],61:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelArray } = require('./array');

const sameError = `Source and destination textures are the same.  Use immutable = true and manually cleanup kernel output texture memory with texture.delete()`;

class WebGLKernelValueMemoryOptimizedNumberTexture extends WebGLKernelArray {
  constructor(value, settings) {
    super(value, settings);
    const [width, height] = value.size;
    this.checkSize(width, height);
    this.dimensions = value.dimensions;
    this.textureSize = value.size;
    this.uploadValue = value.texture;
    this.forceUploadEachRun = true;
  }

  setup() {
    this.setupTexture();
  }

  getStringValueHandler() {
    return `const uploadValue_${this.name} = ${this.varName}.texture;\n`;
  }

  getSource() {
    return utils.linesToString([
      `uniform sampler2D ${this.id}`,
      `ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,
      `ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,
    ]);
  }

  updateValue(inputTexture) {
    if (inputTexture.constructor !== this.initialValueConstructor) {
      this.onUpdateValueMismatch(inputTexture.constructor);
      return;
    }
    if (this.checkContext && inputTexture.context !== this.context) {
      throw new Error(`Value ${this.name} (${this.type}) must be from same context`);
    }

    const { kernel, context: gl } = this;
    if (kernel.pipeline) {
      if (kernel.immutable) {
        kernel.updateTextureArgumentRefs(this, inputTexture);
      } else {
        if (kernel.texture && kernel.texture.texture === inputTexture.texture) {
          throw new Error(sameError);
        } else if (kernel.mappedTextures) {
          const { mappedTextures } = kernel;
          for (let i = 0; i < mappedTextures.length; i++) {
            if (mappedTextures[i].texture === inputTexture.texture) {
              throw new Error(sameError);
            }
          }
        }
      }
    }

    gl.activeTexture(this.contextHandle);
    gl.bindTexture(gl.TEXTURE_2D, this.uploadValue = inputTexture.texture);
    this.kernel.setUniform1i(this.id, this.index);
  }
}

module.exports = {
  WebGLKernelValueMemoryOptimizedNumberTexture,
  sameError
};
},{"../../../utils":114,"./array":40}],62:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelArray } = require('./array');
const { sameError } = require('./memory-optimized-number-texture');

class WebGLKernelValueNumberTexture extends WebGLKernelArray {
  constructor(value, settings) {
    super(value, settings);
    const [width, height] = value.size;
    this.checkSize(width, height);
    const { size: textureSize, dimensions } = value;
    this.bitRatio = this.getBitRatio(value);
    this.dimensions = dimensions;
    this.textureSize = textureSize;
    this.uploadValue = value.texture;
    this.forceUploadEachRun = true;
  }

  setup() {
    this.setupTexture();
  }

  getStringValueHandler() {
    return `const uploadValue_${this.name} = ${this.varName}.texture;\n`;
  }

  getSource() {
    return utils.linesToString([
      `uniform sampler2D ${this.id}`,
      `ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,
      `ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,
    ]);
  }

  updateValue(inputTexture) {
    if (inputTexture.constructor !== this.initialValueConstructor) {
      this.onUpdateValueMismatch(inputTexture.constructor);
      return;
    }
    if (this.checkContext && inputTexture.context !== this.context) {
      throw new Error(`Value ${this.name} (${this.type}) must be from same context`);
    }

    const { kernel, context: gl } = this;
    if (kernel.pipeline) {
      if (kernel.immutable) {
        kernel.updateTextureArgumentRefs(this, inputTexture);
      } else {
        if (kernel.texture && kernel.texture.texture === inputTexture.texture) {
          throw new Error(sameError);
        } else if (kernel.mappedTextures) {
          const { mappedTextures } = kernel;
          for (let i = 0; i < mappedTextures.length; i++) {
            if (mappedTextures[i].texture === inputTexture.texture) {
              throw new Error(sameError);
            }
          }
        }
      }
    }

    gl.activeTexture(this.contextHandle);
    gl.bindTexture(gl.TEXTURE_2D, this.uploadValue = inputTexture.texture);
    this.kernel.setUniform1i(this.id, this.index);
  }
}

module.exports = {
  WebGLKernelValueNumberTexture
};
},{"../../../utils":114,"./array":40,"./memory-optimized-number-texture":61}],63:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelArray } = require('./array');

class WebGLKernelValueSingleArray extends WebGLKernelArray {
  constructor(value, settings) {
    super(value, settings);
    this.bitRatio = 4;
    this.dimensions = utils.getDimensions(value, true);
    this.textureSize = utils.getMemoryOptimizedFloatTextureSize(this.dimensions, this.bitRatio);
    this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * this.bitRatio;
    this.checkSize(this.textureSize[0], this.textureSize[1]);
    this.uploadValue = new Float32Array(this.uploadArrayLength);
  }

  getStringValueHandler() {
    return utils.linesToString([
      `const uploadValue_${this.name} = new Float32Array(${this.uploadArrayLength})`,
      `flattenTo(${this.varName}, uploadValue_${this.name})`,
    ]);
  }

  getSource() {
    return utils.linesToString([
      `uniform sampler2D ${this.id}`,
      `ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,
      `ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,
    ]);
  }

  updateValue(value) {
    if (value.constructor !== this.initialValueConstructor) {
      this.onUpdateValueMismatch(value.constructor);
      return;
    }
    const { context: gl } = this;
    utils.flattenTo(value, this.uploadValue);
    gl.activeTexture(this.contextHandle);
    gl.bindTexture(gl.TEXTURE_2D, this.texture);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.textureSize[0], this.textureSize[1], 0, gl.RGBA, gl.FLOAT, this.uploadValue);
    this.kernel.setUniform1i(this.id, this.index);
  }
}

module.exports = {
  WebGLKernelValueSingleArray
};
},{"../../../utils":114,"./array":40}],64:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelArray } = require('./array');

class WebGLKernelValueSingleArray1DI extends WebGLKernelArray {
  constructor(value, settings) {
    super(value, settings);
    this.bitRatio = 4;
    this.setShape(value);
  }

  setShape(value) {
    const valueDimensions = utils.getDimensions(value, true);
    this.textureSize = utils.getMemoryOptimizedFloatTextureSize(valueDimensions, this.bitRatio);
    this.dimensions = new Int32Array([valueDimensions[1], 1, 1]);
    this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * this.bitRatio;
    this.checkSize(this.textureSize[0], this.textureSize[1]);
    this.uploadValue = new Float32Array(this.uploadArrayLength);
  }

  getStringValueHandler() {
    return utils.linesToString([
      `const uploadValue_${this.name} = new Float32Array(${this.uploadArrayLength})`,
      `flattenTo(${this.varName}, uploadValue_${this.name})`,
    ]);
  }

  getSource() {
    return utils.linesToString([
      `uniform sampler2D ${this.id}`,
      `ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,
      `ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,
    ]);
  }

  updateValue(value) {
    if (value.constructor !== this.initialValueConstructor) {
      this.onUpdateValueMismatch(value.constructor);
      return;
    }
    const { context: gl } = this;
    utils.flatten2dArrayTo(value, this.uploadValue);
    gl.activeTexture(this.contextHandle);
    gl.bindTexture(gl.TEXTURE_2D, this.texture);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.textureSize[0], this.textureSize[1], 0, gl.RGBA, gl.FLOAT, this.uploadValue);
    this.kernel.setUniform1i(this.id, this.index);
  }
}

module.exports = {
  WebGLKernelValueSingleArray1DI
};
},{"../../../utils":114,"./array":40}],65:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelArray } = require('./array');

class WebGLKernelValueSingleArray2DI extends WebGLKernelArray {
  constructor(value, settings) {
    super(value, settings);
    this.bitRatio = 4;
    this.setShape(value);
  }

  setShape(value) {
    const valueDimensions = utils.getDimensions(value, true);
    this.textureSize = utils.getMemoryOptimizedFloatTextureSize(valueDimensions, this.bitRatio);
    this.dimensions = new Int32Array([valueDimensions[1], valueDimensions[2], 1]);
    this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * this.bitRatio;
    this.checkSize(this.textureSize[0], this.textureSize[1]);
    this.uploadValue = new Float32Array(this.uploadArrayLength);
  }

  getStringValueHandler() {
    return utils.linesToString([
      `const uploadValue_${this.name} = new Float32Array(${this.uploadArrayLength})`,
      `flattenTo(${this.varName}, uploadValue_${this.name})`,
    ]);
  }

  getSource() {
    return utils.linesToString([
      `uniform sampler2D ${this.id}`,
      `ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,
      `ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,
    ]);
  }

  updateValue(value) {
    if (value.constructor !== this.initialValueConstructor) {
      this.onUpdateValueMismatch(value.constructor);
      return;
    }
    const { context: gl } = this;
    utils.flatten3dArrayTo(value, this.uploadValue);
    gl.activeTexture(this.contextHandle);
    gl.bindTexture(gl.TEXTURE_2D, this.texture);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.textureSize[0], this.textureSize[1], 0, gl.RGBA, gl.FLOAT, this.uploadValue);
    this.kernel.setUniform1i(this.id, this.index);
  }
}

module.exports = {
  WebGLKernelValueSingleArray2DI
};
},{"../../../utils":114,"./array":40}],66:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelArray } = require('./array');

class WebGLKernelValueSingleArray3DI extends WebGLKernelArray {
  constructor(value, settings) {
    super(value, settings);
    this.bitRatio = 4;
    this.setShape(value);
  }

  setShape(value) {
    const valueDimensions = utils.getDimensions(value, true);
    this.textureSize = utils.getMemoryOptimizedFloatTextureSize(valueDimensions, this.bitRatio);
    this.dimensions = new Int32Array([valueDimensions[1], valueDimensions[2], valueDimensions[3]]);
    this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * this.bitRatio;
    this.checkSize(this.textureSize[0], this.textureSize[1]);
    this.uploadValue = new Float32Array(this.uploadArrayLength);
  }

  getStringValueHandler() {
    return utils.linesToString([
      `const uploadValue_${this.name} = new Float32Array(${this.uploadArrayLength})`,
      `flattenTo(${this.varName}, uploadValue_${this.name})`,
    ]);
  }

  getSource() {
    return utils.linesToString([
      `uniform sampler2D ${this.id}`,
      `ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,
      `ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,
    ]);
  }

  updateValue(value) {
    if (value.constructor !== this.initialValueConstructor) {
      this.onUpdateValueMismatch(value.constructor);
      return;
    }
    const { context: gl } = this;
    utils.flatten4dArrayTo(value, this.uploadValue);
    gl.activeTexture(this.contextHandle);
    gl.bindTexture(gl.TEXTURE_2D, this.texture);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.textureSize[0], this.textureSize[1], 0, gl.RGBA, gl.FLOAT, this.uploadValue);
    this.kernel.setUniform1i(this.id, this.index);
  }
}

module.exports = {
  WebGLKernelValueSingleArray3DI
};
},{"../../../utils":114,"./array":40}],67:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelArray } = require('./array');

class WebGLKernelValueSingleInput extends WebGLKernelArray {
  constructor(value, settings) {
    super(value, settings);
    this.bitRatio = 4;
    let [w, h, d] = value.size;
    this.dimensions = new Int32Array([w || 1, h || 1, d || 1]);
    this.textureSize = utils.getMemoryOptimizedFloatTextureSize(this.dimensions, this.bitRatio);
    this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * this.bitRatio;
    this.checkSize(this.textureSize[0], this.textureSize[1]);
    this.uploadValue = new Float32Array(this.uploadArrayLength);
  }

  getStringValueHandler() {
    return utils.linesToString([
      `const uploadValue_${this.name} = new Float32Array(${this.uploadArrayLength})`,
      `flattenTo(${this.varName}.value, uploadValue_${this.name})`,
    ]);
  }

  getSource() {
    return utils.linesToString([
      `uniform sampler2D ${this.id}`,
      `ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,
      `ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,
    ]);
  }

  updateValue(input) {
    if (input.constructor !== this.initialValueConstructor) {
      this.onUpdateValueMismatch(input.constructor);
      return;
    }
    const { context: gl } = this;
    utils.flattenTo(input.value, this.uploadValue);
    gl.activeTexture(this.contextHandle);
    gl.bindTexture(gl.TEXTURE_2D, this.texture);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.textureSize[0], this.textureSize[1], 0, gl.RGBA, gl.FLOAT, this.uploadValue);
    this.kernel.setUniform1i(this.id, this.index);
  }
}

module.exports = {
  WebGLKernelValueSingleInput
};
},{"../../../utils":114,"./array":40}],68:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelArray } = require('./array');

class WebGLKernelValueUnsignedArray extends WebGLKernelArray {
  constructor(value, settings) {
    super(value, settings);
    this.bitRatio = this.getBitRatio(value);
    this.dimensions = utils.getDimensions(value, true);
    this.textureSize = utils.getMemoryOptimizedPackedTextureSize(this.dimensions, this.bitRatio);
    this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * (4 / this.bitRatio);
    this.checkSize(this.textureSize[0], this.textureSize[1]);
    this.TranserArrayType = this.getTransferArrayType(value);
    this.preUploadValue = new this.TranserArrayType(this.uploadArrayLength);
    this.uploadValue = new Uint8Array(this.preUploadValue.buffer);
  }

  getStringValueHandler() {
    return utils.linesToString([
      `const preUploadValue_${this.name} = new ${this.TranserArrayType.name}(${this.uploadArrayLength})`,
      `const uploadValue_${this.name} = new Uint8Array(preUploadValue_${this.name}.buffer)`,
      `flattenTo(${this.varName}, preUploadValue_${this.name})`,
    ]);
  }

  getSource() {
    return utils.linesToString([
      `uniform sampler2D ${this.id}`,
      `ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,
      `ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,
    ]);
  }

  updateValue(value) {
    if (value.constructor !== this.initialValueConstructor) {
      this.onUpdateValueMismatch(value.constructor);
      return;
    }
    const { context: gl } = this;
    utils.flattenTo(value, this.preUploadValue);
    gl.activeTexture(this.contextHandle);
    gl.bindTexture(gl.TEXTURE_2D, this.texture);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.textureSize[0], this.textureSize[1], 0, gl.RGBA, gl.UNSIGNED_BYTE, this.uploadValue);
    this.kernel.setUniform1i(this.id, this.index);
  }
}

module.exports = {
  WebGLKernelValueUnsignedArray
};
},{"../../../utils":114,"./array":40}],69:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelArray } = require('./array');

class WebGLKernelValueUnsignedInput extends WebGLKernelArray {
  constructor(value, settings) {
    super(value, settings);
    this.bitRatio = this.getBitRatio(value);
    const [w, h, d] = value.size;
    this.dimensions = new Int32Array([w || 1, h || 1, d || 1]);
    this.textureSize = utils.getMemoryOptimizedPackedTextureSize(this.dimensions, this.bitRatio);
    this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * (4 / this.bitRatio);
    this.checkSize(this.textureSize[0], this.textureSize[1]);
    this.TranserArrayType = this.getTransferArrayType(value.value);
    this.preUploadValue = new this.TranserArrayType(this.uploadArrayLength);
    this.uploadValue = new Uint8Array(this.preUploadValue.buffer);
  }

  getStringValueHandler() {
    return utils.linesToString([
      `const preUploadValue_${this.name} = new ${this.TranserArrayType.name}(${this.uploadArrayLength})`,
      `const uploadValue_${this.name} = new Uint8Array(preUploadValue_${this.name}.buffer)`,
      `flattenTo(${this.varName}.value, preUploadValue_${this.name})`,
    ]);
  }

  getSource() {
    return utils.linesToString([
      `uniform sampler2D ${this.id}`,
      `ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,
      `ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,
    ]);
  }

  updateValue(input) {
    if (input.constructor !== this.initialValueConstructor) {
      this.onUpdateValueMismatch(value.constructor);
      return;
    }
    const { context: gl } = this;
    utils.flattenTo(input.value, this.preUploadValue);
    gl.activeTexture(this.contextHandle);
    gl.bindTexture(gl.TEXTURE_2D, this.texture);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.textureSize[0], this.textureSize[1], 0, gl.RGBA, gl.UNSIGNED_BYTE, this.uploadValue);
    this.kernel.setUniform1i(this.id, this.index);
  }
}

module.exports = {
  WebGLKernelValueUnsignedInput
};
},{"../../../utils":114,"./array":40}],70:[function(require,module,exports){
const { GLKernel } = require('../gl/kernel');
const { FunctionBuilder } = require('../function-builder');
const { WebGLFunctionNode } = require('./function-node');
const { utils } = require('../../utils');
const mrud = require('../../plugins/math-random-uniformly-distributed');
const { fragmentShader } = require('./fragment-shader');
const { vertexShader } = require('./vertex-shader');
const { glKernelString } = require('../gl/kernel-string');
const { lookupKernelValueType } = require('./kernel-value-maps');

let isSupported = null;
let testCanvas = null;
let testContext = null;
let testExtensions = null;
let features = null;

const plugins = [mrud];
const canvases = [];
const maxTexSizes = {};


class WebGLKernel extends GLKernel {
  static get isSupported() {
    if (isSupported !== null) {
      return isSupported;
    }
    this.setupFeatureChecks();
    isSupported = this.isContextMatch(testContext);
    return isSupported;
  }

  static setupFeatureChecks() {
    if (typeof document !== 'undefined') {
      testCanvas = document.createElement('canvas');
    } else if (typeof OffscreenCanvas !== 'undefined') {
      testCanvas = new OffscreenCanvas(0, 0);
    }
    if (!testCanvas) return;
    testContext = testCanvas.getContext('webgl') || testCanvas.getContext('experimental-webgl');
    if (!testContext || !testContext.getExtension) return;
    testExtensions = {
      OES_texture_float: testContext.getExtension('OES_texture_float'),
      OES_texture_float_linear: testContext.getExtension('OES_texture_float_linear'),
      OES_element_index_uint: testContext.getExtension('OES_element_index_uint'),
      WEBGL_draw_buffers: testContext.getExtension('WEBGL_draw_buffers'),
    };
    features = this.getFeatures();
  }

  static isContextMatch(context) {
    if (typeof WebGLRenderingContext !== 'undefined') {
      return context instanceof WebGLRenderingContext;
    }
    return false;
  }

  static getIsTextureFloat() {
    return Boolean(testExtensions.OES_texture_float);
  }

  static getIsDrawBuffers() {
    return Boolean(testExtensions.WEBGL_draw_buffers);
  }

  static getChannelCount() {
    return testExtensions.WEBGL_draw_buffers ?
      testContext.getParameter(testExtensions.WEBGL_draw_buffers.MAX_DRAW_BUFFERS_WEBGL) :
      1;
  }

  static getMaxTextureSize() {
    return testContext.getParameter(testContext.MAX_TEXTURE_SIZE);
  }

  static lookupKernelValueType(type, dynamic, precision, value) {
    return lookupKernelValueType(type, dynamic, precision, value);
  }

  static get testCanvas() {
    return testCanvas;
  }

  static get testContext() {
    return testContext;
  }

  static get features() {
    return features;
  }

  static get fragmentShader() {
    return fragmentShader;
  }

  static get vertexShader() {
    return vertexShader;
  }

  constructor(source, settings) {
    super(source, settings);
    this.program = null;
    this.pipeline = settings.pipeline;
    this.endianness = utils.systemEndianness();
    this.extensions = {};
    this.argumentTextureCount = 0;
    this.constantTextureCount = 0;
    this.fragShader = null;
    this.vertShader = null;
    this.drawBuffersMap = null;

    this.maxTexSize = null;
    this.onRequestSwitchKernel = null;

    this.texture = null;
    this.mappedTextures = null;
    this.mergeSettings(source.settings || settings);

    this.threadDim = null;
    this.framebuffer = null;
    this.buffer = null;

    this.textureCache = [];
    this.programUniformLocationCache = {};
    this.uniform1fCache = {};
    this.uniform1iCache = {};
    this.uniform2fCache = {};
    this.uniform2fvCache = {};
    this.uniform2ivCache = {};
    this.uniform3fvCache = {};
    this.uniform3ivCache = {};
    this.uniform4fvCache = {};
    this.uniform4ivCache = {};
  }

  initCanvas() {
    if (typeof document !== 'undefined') {
      const canvas = document.createElement('canvas');
      canvas.width = 2;
      canvas.height = 2;
      return canvas;
    } else if (typeof OffscreenCanvas !== 'undefined') {
      return new OffscreenCanvas(0, 0);
    }
  }

  initContext() {
    const settings = {
      alpha: false,
      depth: false,
      antialias: false
    };
    return this.canvas.getContext('webgl', settings) || this.canvas.getContext('experimental-webgl', settings);
  }

  initPlugins(settings) {
    const pluginsToUse = [];
    const { source } = this;
    if (typeof source === 'string') {
      for (let i = 0; i < plugins.length; i++) {
        const plugin = plugins[i];
        if (source.match(plugin.functionMatch)) {
          pluginsToUse.push(plugin);
        }
      }
    } else if (typeof source === 'object') {
      if (settings.pluginNames) { 
        for (let i = 0; i < plugins.length; i++) {
          const plugin = plugins[i];
          const usePlugin = settings.pluginNames.some(pluginName => pluginName === plugin.name);
          if (usePlugin) {
            pluginsToUse.push(plugin);
          }
        }
      }
    }
    return pluginsToUse;
  }

  initExtensions() {
    this.extensions = {
      OES_texture_float: this.context.getExtension('OES_texture_float'),
      OES_texture_float_linear: this.context.getExtension('OES_texture_float_linear'),
      OES_element_index_uint: this.context.getExtension('OES_element_index_uint'),
      WEBGL_draw_buffers: this.context.getExtension('WEBGL_draw_buffers'),
      WEBGL_color_buffer_float: this.context.getExtension('WEBGL_color_buffer_float'),
    };
  }

  validateSettings(args) {
    if (!this.validate) {
      this.texSize = utils.getKernelTextureSize({
        optimizeFloatMemory: this.optimizeFloatMemory,
        precision: this.precision,
      }, this.output);
      return;
    }

    const { features } = this.constructor;

    if (this.optimizeFloatMemory === true && !features.isTextureFloat) {
      throw new Error('Float textures are not supported');
    } else if (this.precision === 'single' && !features.isFloatRead) {
      throw new Error('Single precision not supported');
    } else if (!this.graphical && this.precision === null && features.isTextureFloat) {
      this.precision = features.isFloatRead ? 'single' : 'unsigned';
    }

    if (this.subKernels && this.subKernels.length > 0 && !this.extensions.WEBGL_draw_buffers) {
      throw new Error('could not instantiate draw buffers extension');
    }

    if (this.fixIntegerDivisionAccuracy === null) {
      this.fixIntegerDivisionAccuracy = !features.isIntegerDivisionAccurate;
    } else if (this.fixIntegerDivisionAccuracy && features.isIntegerDivisionAccurate) {
      this.fixIntegerDivisionAccuracy = false;
    }

    this.checkOutput();

    if (!this.output || this.output.length === 0) {
      if (args.length !== 1) {
        throw new Error('Auto output only supported for kernels with only one input');
      }

      const argType = utils.getVariableType(args[0], this.strictIntegers);
      switch (argType) {
        case 'Array':
          this.output = utils.getDimensions(argType);
          break;
        case 'NumberTexture':
        case 'MemoryOptimizedNumberTexture':
        case 'ArrayTexture(1)':
        case 'ArrayTexture(2)':
        case 'ArrayTexture(3)':
        case 'ArrayTexture(4)':
          this.output = args[0].output;
          break;
        default:
          throw new Error('Auto output not supported for input type: ' + argType);
      }
    }

    if (this.graphical) {
      if (this.output.length !== 2) {
        throw new Error('Output must have 2 dimensions on graphical mode');
      }

      if (this.precision === 'precision') {
        this.precision = 'unsigned';
        console.warn('Cannot use graphical mode and single precision at the same time');
      }

      this.texSize = utils.clone(this.output);
      return;
    } else if (this.precision === null && features.isTextureFloat) {
      this.precision = 'single';
    }

    this.texSize = utils.getKernelTextureSize({
      optimizeFloatMemory: this.optimizeFloatMemory,
      precision: this.precision,
    }, this.output);

    this.checkTextureSize();
  }

  updateMaxTexSize() {
    const { texSize, canvas } = this;
    if (this.maxTexSize === null) {
      let canvasIndex = canvases.indexOf(canvas);
      if (canvasIndex === -1) {
        canvasIndex = canvases.length;
        canvases.push(canvas);
        maxTexSizes[canvasIndex] = [texSize[0], texSize[1]];
      }
      this.maxTexSize = maxTexSizes[canvasIndex];
    }
    if (this.maxTexSize[0] < texSize[0]) {
      this.maxTexSize[0] = texSize[0];
    }
    if (this.maxTexSize[1] < texSize[1]) {
      this.maxTexSize[1] = texSize[1];
    }
  }

  setupArguments(args) {
    this.kernelArguments = [];
    this.argumentTextureCount = 0;
    const needsArgumentTypes = this.argumentTypes === null;
    if (needsArgumentTypes) {
      this.argumentTypes = [];
    }
    this.argumentSizes = [];
    this.argumentBitRatios = [];

    if (args.length < this.argumentNames.length) {
      throw new Error('not enough arguments for kernel');
    } else if (args.length > this.argumentNames.length) {
      throw new Error('too many arguments for kernel');
    }

    const { context: gl } = this;
    let textureIndexes = 0;

    const onRequestTexture = () => {
      return this.createTexture();
    };
    const onRequestIndex = () => {
      return this.constantTextureCount + textureIndexes++;
    };
    const onUpdateValueMismatch = (constructor) => {
      this.switchKernels({
        type: 'argumentMismatch',
        needed: constructor
      });
    };
    const onRequestContextHandle = () => {
      return gl.TEXTURE0 + this.constantTextureCount + this.argumentTextureCount++;
    };

    for (let index = 0; index < args.length; index++) {
      const value = args[index];
      const name = this.argumentNames[index];
      let type;
      if (needsArgumentTypes) {
        type = utils.getVariableType(value, this.strictIntegers);
        this.argumentTypes.push(type);
      } else {
        type = this.argumentTypes[index];
      }
      const KernelValue = this.constructor.lookupKernelValueType(type, this.dynamicArguments ? 'dynamic' : 'static', this.precision, args[index]);
      if (KernelValue === null) {
        return this.requestFallback(args);
      }
      const kernelArgument = new KernelValue(value, {
        name,
        type,
        tactic: this.tactic,
        origin: 'user',
        context: gl,
        checkContext: this.checkContext,
        kernel: this,
        strictIntegers: this.strictIntegers,
        onRequestTexture,
        onRequestIndex,
        onUpdateValueMismatch,
        onRequestContextHandle,
      });
      this.kernelArguments.push(kernelArgument);
      kernelArgument.setup();
      this.argumentSizes.push(kernelArgument.textureSize);
      this.argumentBitRatios[index] = kernelArgument.bitRatio;
    }
  }

  createTexture() {
    const texture = this.context.createTexture();
    this.textureCache.push(texture);
    return texture;
  }

  setupConstants(args) {
    const { context: gl } = this;
    this.kernelConstants = [];
    this.forceUploadKernelConstants = [];
    let needsConstantTypes = this.constantTypes === null;
    if (needsConstantTypes) {
      this.constantTypes = {};
    }
    this.constantBitRatios = {};
    let textureIndexes = 0;
    for (const name in this.constants) {
      const value = this.constants[name];
      let type;
      if (needsConstantTypes) {
        type = utils.getVariableType(value, this.strictIntegers);
        this.constantTypes[name] = type;
      } else {
        type = this.constantTypes[name];
      }
      const KernelValue = this.constructor.lookupKernelValueType(type, 'static', this.precision, value);
      if (KernelValue === null) {
        return this.requestFallback(args);
      }
      const kernelValue = new KernelValue(value, {
        name,
        type,
        tactic: this.tactic,
        origin: 'constants',
        context: this.context,
        checkContext: this.checkContext,
        kernel: this,
        strictIntegers: this.strictIntegers,
        onRequestTexture: () => {
          return this.createTexture();
        },
        onRequestIndex: () => {
          return textureIndexes++;
        },
        onRequestContextHandle: () => {
          return gl.TEXTURE0 + this.constantTextureCount++;
        }
      });
      this.constantBitRatios[name] = kernelValue.bitRatio;
      this.kernelConstants.push(kernelValue);
      kernelValue.setup();
      if (kernelValue.forceUploadEachRun) {
        this.forceUploadKernelConstants.push(kernelValue);
      }
    }
  }

  build() {
    if (this.built) return;
    this.initExtensions();
    this.validateSettings(arguments);
    this.setupConstants(arguments);
    if (this.fallbackRequested) return;
    this.setupArguments(arguments);
    if (this.fallbackRequested) return;
    this.updateMaxTexSize();
    this.translateSource();
    const failureResult = this.pickRenderStrategy(arguments);
    if (failureResult) {
      return failureResult;
    }
    const { texSize, context: gl, canvas } = this;
    gl.enable(gl.SCISSOR_TEST);
    if (this.pipeline && this.precision === 'single') {
      gl.viewport(0, 0, this.maxTexSize[0], this.maxTexSize[1]);
      canvas.width = this.maxTexSize[0];
      canvas.height = this.maxTexSize[1];
    } else {
      gl.viewport(0, 0, this.maxTexSize[0], this.maxTexSize[1]);
      canvas.width = this.maxTexSize[0];
      canvas.height = this.maxTexSize[1];
    }
    const threadDim = this.threadDim = Array.from(this.output);
    while (threadDim.length < 3) {
      threadDim.push(1);
    }

    const compiledVertexShader = this.getVertexShader(arguments);
    const vertShader = gl.createShader(gl.VERTEX_SHADER);
    gl.shaderSource(vertShader, compiledVertexShader);
    gl.compileShader(vertShader);
    this.vertShader = vertShader;

    const compiledFragmentShader = this.getFragmentShader(arguments);
    const fragShader = gl.createShader(gl.FRAGMENT_SHADER);
    gl.shaderSource(fragShader, compiledFragmentShader);
    gl.compileShader(fragShader);
    this.fragShader = fragShader;

    if (this.debug) {
      console.log('GLSL Shader Output:');
      console.log(compiledFragmentShader);
    }

    if (!gl.getShaderParameter(vertShader, gl.COMPILE_STATUS)) {
      throw new Error('Error compiling vertex shader: ' + gl.getShaderInfoLog(vertShader));
    }
    if (!gl.getShaderParameter(fragShader, gl.COMPILE_STATUS)) {
      throw new Error('Error compiling fragment shader: ' + gl.getShaderInfoLog(fragShader));
    }

    const program = this.program = gl.createProgram();
    gl.attachShader(program, vertShader);
    gl.attachShader(program, fragShader);
    gl.linkProgram(program);
    this.framebuffer = gl.createFramebuffer();
    this.framebuffer.width = texSize[0];
    this.framebuffer.height = texSize[1];
    this.rawValueFramebuffers = {};

    const vertices = new Float32Array([-1, -1,
      1, -1, -1, 1,
      1, 1
    ]);
    const texCoords = new Float32Array([
      0, 0,
      1, 0,
      0, 1,
      1, 1
    ]);

    const texCoordOffset = vertices.byteLength;

    let buffer = this.buffer;
    if (!buffer) {
      buffer = this.buffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
      gl.bufferData(gl.ARRAY_BUFFER, vertices.byteLength + texCoords.byteLength, gl.STATIC_DRAW);
    } else {
      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    }

    gl.bufferSubData(gl.ARRAY_BUFFER, 0, vertices);
    gl.bufferSubData(gl.ARRAY_BUFFER, texCoordOffset, texCoords);

    const aPosLoc = gl.getAttribLocation(this.program, 'aPos');
    gl.enableVertexAttribArray(aPosLoc);
    gl.vertexAttribPointer(aPosLoc, 2, gl.FLOAT, false, 0, 0);
    const aTexCoordLoc = gl.getAttribLocation(this.program, 'aTexCoord');
    gl.enableVertexAttribArray(aTexCoordLoc);
    gl.vertexAttribPointer(aTexCoordLoc, 2, gl.FLOAT, false, 0, texCoordOffset);
    gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);

    let i = 0;
    gl.useProgram(this.program);
    for (let p in this.constants) {
      this.kernelConstants[i++].updateValue(this.constants[p]);
    }

    this._setupOutputTexture();
    if (
      this.subKernels !== null &&
      this.subKernels.length > 0
    ) {
      this._mappedTextureSwitched = {};
      this._setupSubOutputTextures();
    }
    this.buildSignature(arguments);
    this.built = true;
  }

  translateSource() {
    const functionBuilder = FunctionBuilder.fromKernel(this, WebGLFunctionNode, {
      fixIntegerDivisionAccuracy: this.fixIntegerDivisionAccuracy
    });
    this.translatedSource = functionBuilder.getPrototypeString('kernel');
    this.setupReturnTypes(functionBuilder);
  }

  setupReturnTypes(functionBuilder) {
    if (!this.graphical && !this.returnType) {
      this.returnType = functionBuilder.getKernelResultType();
    }

    if (this.subKernels && this.subKernels.length > 0) {
      for (let i = 0; i < this.subKernels.length; i++) {
        const subKernel = this.subKernels[i];
        if (!subKernel.returnType) {
          subKernel.returnType = functionBuilder.getSubKernelResultType(i);
        }
      }
    }
  }

  run() {
    const { kernelArguments, texSize, forceUploadKernelConstants, context: gl } = this;

    gl.useProgram(this.program);
    gl.scissor(0, 0, texSize[0], texSize[1]);
    if (this.dynamicOutput) {
      this.setUniform3iv('uOutputDim', new Int32Array(this.threadDim));
      this.setUniform2iv('uTexSize', texSize);
    }

    this.setUniform2f('ratio', texSize[0] / this.maxTexSize[0], texSize[1] / this.maxTexSize[1]);

    for (let i = 0; i < forceUploadKernelConstants.length; i++) {
      const constant = forceUploadKernelConstants[i];
      constant.updateValue(this.constants[constant.name]);
      if (this.switchingKernels) return;
    }
    for (let i = 0; i < kernelArguments.length; i++) {
      kernelArguments[i].updateValue(arguments[i]);
      if (this.switchingKernels) return;
    }

    if (this.plugins) {
      for (let i = 0; i < this.plugins.length; i++) {
        const plugin = this.plugins[i];
        if (plugin.onBeforeRun) {
          plugin.onBeforeRun(this);
        }
      }
    }

    if (this.graphical) {
      if (this.pipeline) {
        gl.bindRenderbuffer(gl.RENDERBUFFER, null);
        gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);
        if (this.immutable) {
          this._replaceOutputTexture();
        }
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        return this.immutable ? this.texture.clone() : this.texture;
      }
      gl.bindRenderbuffer(gl.RENDERBUFFER, null);
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
      return;
    }

    gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);
    if (this.immutable) {
      this._replaceOutputTexture();
    }

    if (this.subKernels !== null) {
      if (this.immutable) {
        this._replaceSubOutputTextures();
      }
      this.drawBuffers();
    }

    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
  }

  drawBuffers() {
    this.extensions.WEBGL_draw_buffers.drawBuffersWEBGL(this.drawBuffersMap);
  }

  getInternalFormat() {
    return this.context.RGBA;
  }
  getTextureFormat() {
    const { context: gl } = this;
    switch (this.getInternalFormat()) {
      case gl.RGBA:
        return gl.RGBA;
      default:
        throw new Error('Unknown internal format');
    }
  }

  _replaceOutputTexture() {
    if (this.texture.beforeMutate() || this._textureSwitched) {
      const gl = this.context;
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.texture.texture, 0);
      this._textureSwitched = false;
    }
  }

  _setupOutputTexture() {
    const gl = this.context;
    const texSize = this.texSize;
    if (this.texture) {
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.texture.texture, 0);
      return;
    }
    const texture = this.createTexture();
    gl.activeTexture(gl.TEXTURE0 + this.constantTextureCount + this.argumentTextureCount);
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    const format = this.getInternalFormat();
    if (this.precision === 'single') {
      gl.texImage2D(gl.TEXTURE_2D, 0, format, texSize[0], texSize[1], 0, gl.RGBA, gl.FLOAT, null);
    } else {
      gl.texImage2D(gl.TEXTURE_2D, 0, format, texSize[0], texSize[1], 0, format, gl.UNSIGNED_BYTE, null);
    }
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
    this.texture = new this.TextureConstructor({
      texture,
      size: texSize,
      dimensions: this.threadDim,
      output: this.output,
      context: this.context,
      internalFormat: this.getInternalFormat(),
      textureFormat: this.getTextureFormat(),
      kernel: this,
    });
  }

  _replaceSubOutputTextures() {
    const gl = this.context;
    for (let i = 0; i < this.mappedTextures.length; i++) {
      const mappedTexture = this.mappedTextures[i];
      if (mappedTexture.beforeMutate() || this._mappedTextureSwitched[i]) {
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i + 1, gl.TEXTURE_2D, mappedTexture.texture, 0);
        this._mappedTextureSwitched[i] = false;
      }
    }
  }

  _setupSubOutputTextures() {
    const gl = this.context;
    if (this.mappedTextures) {
      for (let i = 0; i < this.subKernels.length; i++) {
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i + 1, gl.TEXTURE_2D, this.mappedTextures[i].texture, 0);
      }
      return;
    }
    const texSize = this.texSize;
    this.drawBuffersMap = [gl.COLOR_ATTACHMENT0];
    this.mappedTextures = [];
    for (let i = 0; i < this.subKernels.length; i++) {
      const texture = this.createTexture();
      this.drawBuffersMap.push(gl.COLOR_ATTACHMENT0 + i + 1);
      gl.activeTexture(gl.TEXTURE0 + this.constantTextureCount + this.argumentTextureCount + i);
      gl.bindTexture(gl.TEXTURE_2D, texture);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
      if (this.precision === 'single') {
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, texSize[0], texSize[1], 0, gl.RGBA, gl.FLOAT, null);
      } else {
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, texSize[0], texSize[1], 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
      }
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i + 1, gl.TEXTURE_2D, texture, 0);

      this.mappedTextures.push(new this.TextureConstructor({
        texture,
        size: texSize,
        dimensions: this.threadDim,
        output: this.output,
        context: this.context,
        internalFormat: this.getInternalFormat(),
        textureFormat: this.getTextureFormat(),
        kernel: this,
      }));
    }
  }

  setUniform1f(name, value) {
    if (this.uniform1fCache.hasOwnProperty(name)) {
      const cache = this.uniform1fCache[name];
      if (value === cache) {
        return;
      }
    }
    this.uniform1fCache[name] = value;
    const loc = this.getUniformLocation(name);
    this.context.uniform1f(loc, value);
  }

  setUniform1i(name, value) {
    if (this.uniform1iCache.hasOwnProperty(name)) {
      const cache = this.uniform1iCache[name];
      if (value === cache) {
        return;
      }
    }
    this.uniform1iCache[name] = value;
    const loc = this.getUniformLocation(name);
    this.context.uniform1i(loc, value);
  }

  setUniform2f(name, value1, value2) {
    if (this.uniform2fCache.hasOwnProperty(name)) {
      const cache = this.uniform2fCache[name];
      if (
        value1 === cache[0] &&
        value2 === cache[1]
      ) {
        return;
      }
    }
    this.uniform2fCache[name] = [value1, value2];
    const loc = this.getUniformLocation(name);
    this.context.uniform2f(loc, value1, value2);
  }

  setUniform2fv(name, value) {
    if (this.uniform2fvCache.hasOwnProperty(name)) {
      const cache = this.uniform2fvCache[name];
      if (
        value[0] === cache[0] &&
        value[1] === cache[1]
      ) {
        return;
      }
    }
    this.uniform2fvCache[name] = value;
    const loc = this.getUniformLocation(name);
    this.context.uniform2fv(loc, value);
  }

  setUniform2iv(name, value) {
    if (this.uniform2ivCache.hasOwnProperty(name)) {
      const cache = this.uniform2ivCache[name];
      if (
        value[0] === cache[0] &&
        value[1] === cache[1]
      ) {
        return;
      }
    }
    this.uniform2ivCache[name] = value;
    const loc = this.getUniformLocation(name);
    this.context.uniform2iv(loc, value);
  }

  setUniform3fv(name, value) {
    if (this.uniform3fvCache.hasOwnProperty(name)) {
      const cache = this.uniform3fvCache[name];
      if (
        value[0] === cache[0] &&
        value[1] === cache[1] &&
        value[2] === cache[2]
      ) {
        return;
      }
    }
    this.uniform3fvCache[name] = value;
    const loc = this.getUniformLocation(name);
    this.context.uniform3fv(loc, value);
  }

  setUniform3iv(name, value) {
    if (this.uniform3ivCache.hasOwnProperty(name)) {
      const cache = this.uniform3ivCache[name];
      if (
        value[0] === cache[0] &&
        value[1] === cache[1] &&
        value[2] === cache[2]
      ) {
        return;
      }
    }
    this.uniform3ivCache[name] = value;
    const loc = this.getUniformLocation(name);
    this.context.uniform3iv(loc, value);
  }

  setUniform4fv(name, value) {
    if (this.uniform4fvCache.hasOwnProperty(name)) {
      const cache = this.uniform4fvCache[name];
      if (
        value[0] === cache[0] &&
        value[1] === cache[1] &&
        value[2] === cache[2] &&
        value[3] === cache[3]
      ) {
        return;
      }
    }
    this.uniform4fvCache[name] = value;
    const loc = this.getUniformLocation(name);
    this.context.uniform4fv(loc, value);
  }

  setUniform4iv(name, value) {
    if (this.uniform4ivCache.hasOwnProperty(name)) {
      const cache = this.uniform4ivCache[name];
      if (
        value[0] === cache[0] &&
        value[1] === cache[1] &&
        value[2] === cache[2] &&
        value[3] === cache[3]
      ) {
        return;
      }
    }
    this.uniform4ivCache[name] = value;
    const loc = this.getUniformLocation(name);
    this.context.uniform4iv(loc, value);
  }

  getUniformLocation(name) {
    if (this.programUniformLocationCache.hasOwnProperty(name)) {
      return this.programUniformLocationCache[name];
    }
    return this.programUniformLocationCache[name] = this.context.getUniformLocation(this.program, name);
  }

  _getFragShaderArtifactMap(args) {
    return {
      HEADER: this._getHeaderString(),
      LOOP_MAX: this._getLoopMaxString(),
      PLUGINS: this._getPluginsString(),
      CONSTANTS: this._getConstantsString(),
      DECODE32_ENDIANNESS: this._getDecode32EndiannessString(),
      ENCODE32_ENDIANNESS: this._getEncode32EndiannessString(),
      DIVIDE_WITH_INTEGER_CHECK: this._getDivideWithIntegerCheckString(),
      INJECTED_NATIVE: this._getInjectedNative(),
      MAIN_CONSTANTS: this._getMainConstantsString(),
      MAIN_ARGUMENTS: this._getMainArgumentsString(args),
      KERNEL: this.getKernelString(),
      MAIN_RESULT: this.getMainResultString(),
      FLOAT_TACTIC_DECLARATION: this.getFloatTacticDeclaration(),
      INT_TACTIC_DECLARATION: this.getIntTacticDeclaration(),
      SAMPLER_2D_TACTIC_DECLARATION: this.getSampler2DTacticDeclaration(),
      SAMPLER_2D_ARRAY_TACTIC_DECLARATION: this.getSampler2DArrayTacticDeclaration(),
    };
  }

  _getVertShaderArtifactMap(args) {
    return {
      FLOAT_TACTIC_DECLARATION: this.getFloatTacticDeclaration(),
      INT_TACTIC_DECLARATION: this.getIntTacticDeclaration(),
      SAMPLER_2D_TACTIC_DECLARATION: this.getSampler2DTacticDeclaration(),
      SAMPLER_2D_ARRAY_TACTIC_DECLARATION: this.getSampler2DArrayTacticDeclaration(),
    };
  }

  _getHeaderString() {
    return (
      this.subKernels !== null ?
      '#extension GL_EXT_draw_buffers : require\n' :
      ''
    );
  }

  _getLoopMaxString() {
    return (
      this.loopMaxIterations ?
      ` ${parseInt(this.loopMaxIterations)};\n` :
      ' 1000;\n'
    );
  }

  _getPluginsString() {
    if (!this.plugins) return '\n';
    return this.plugins.map(plugin => plugin.source && this.source.match(plugin.functionMatch) ? plugin.source : '').join('\n');
  }

  _getConstantsString() {
    const result = [];
    const { threadDim, texSize } = this;
    if (this.dynamicOutput) {
      result.push(
        'uniform ivec3 uOutputDim',
        'uniform ivec2 uTexSize'
      );
    } else {
      result.push(
        `ivec3 uOutputDim = ivec3(${threadDim[0]}, ${threadDim[1]}, ${threadDim[2]})`,
        `ivec2 uTexSize = ivec2(${texSize[0]}, ${texSize[1]})`
      );
    }
    return utils.linesToString(result);
  }

  _getTextureCoordinate() {
    const subKernels = this.subKernels;
    if (subKernels === null || subKernels.length < 1) {
      return 'varying vec2 vTexCoord;\n';
    } else {
      return 'out vec2 vTexCoord;\n';
    }
  }

  _getDecode32EndiannessString() {
    return (
      this.endianness === 'LE' ?
      '' :
      '  texel.rgba = texel.abgr;\n'
    );
  }

  _getEncode32EndiannessString() {
    return (
      this.endianness === 'LE' ?
      '' :
      '  texel.rgba = texel.abgr;\n'
    );
  }

  _getDivideWithIntegerCheckString() {
    return this.fixIntegerDivisionAccuracy ?
      `float divWithIntCheck(float x, float y) {
  if (floor(x) == x && floor(y) == y && integerMod(x, y) == 0.0) {
    return float(int(x) / int(y));
  }
  return x / y;
}

float integerCorrectionModulo(float number, float divisor) {
  if (number < 0.0) {
    number = abs(number);
    if (divisor < 0.0) {
      divisor = abs(divisor);
    }
    return -(number - (divisor * floor(divWithIntCheck(number, divisor))));
  }
  if (divisor < 0.0) {
    divisor = abs(divisor);
  }
  return number - (divisor * floor(divWithIntCheck(number, divisor)));
}` :
      '';
  }

  _getMainArgumentsString(args) {
    const results = [];
    const { argumentNames } = this;
    for (let i = 0; i < argumentNames.length; i++) {
      results.push(this.kernelArguments[i].getSource(args[i]));
    }
    return results.join('');
  }

  _getInjectedNative() {
    return this.injectedNative || '';
  }

  _getMainConstantsString() {
    const result = [];
    const { constants } = this;
    if (constants) {
      let i = 0;
      for (const name in constants) {
        if (!this.constants.hasOwnProperty(name)) continue;
        result.push(this.kernelConstants[i++].getSource(this.constants[name]));
      }
    }
    return result.join('');
  }

  getRawValueFramebuffer(width, height) {
    if (!this.rawValueFramebuffers[width]) {
      this.rawValueFramebuffers[width] = {};
    }
    if (!this.rawValueFramebuffers[width][height]) {
      const framebuffer = this.context.createFramebuffer();
      framebuffer.width = width;
      framebuffer.height = height;
      this.rawValueFramebuffers[width][height] = framebuffer;
    }
    return this.rawValueFramebuffers[width][height];
  }

  getKernelResultDeclaration() {
    switch (this.returnType) {
      case 'Array(2)':
        return 'vec2 kernelResult';
      case 'Array(3)':
        return 'vec3 kernelResult';
      case 'Array(4)':
        return 'vec4 kernelResult';
      case 'LiteralInteger':
      case 'Float':
      case 'Number':
      case 'Integer':
        return 'float kernelResult';
      default:
        if (this.graphical) {
          return 'float kernelResult';
        } else {
          throw new Error(`unrecognized output type "${ this.returnType }"`);
        }
    }
  }
  getKernelString() {
    const result = [this.getKernelResultDeclaration()];
    const { subKernels } = this;
    if (subKernels !== null) {
      switch (this.returnType) {
        case 'Number':
        case 'Float':
        case 'Integer':
          for (let i = 0; i < subKernels.length; i++) {
            const subKernel = subKernels[i];
            result.push(
              subKernel.returnType === 'Integer' ?
              `int subKernelResult_${ subKernel.name } = 0` :
              `float subKernelResult_${ subKernel.name } = 0.0`
            );
          }
          break;
        case 'Array(2)':
          for (let i = 0; i < subKernels.length; i++) {
            result.push(
              `vec2 subKernelResult_${ subKernels[i].name }`
            );
          }
          break;
        case 'Array(3)':
          for (let i = 0; i < subKernels.length; i++) {
            result.push(
              `vec3 subKernelResult_${ subKernels[i].name }`
            );
          }
          break;
        case 'Array(4)':
          for (let i = 0; i < subKernels.length; i++) {
            result.push(
              `vec4 subKernelResult_${ subKernels[i].name }`
            );
          }
          break;
      }
    }

    return utils.linesToString(result) + this.translatedSource;
  }

  getMainResultGraphical() {
    return utils.linesToString([
      '  threadId = indexTo3D(index, uOutputDim)',
      '  kernel()',
      '  gl_FragColor = actualColor',
    ]);
  }

  getMainResultPackedPixels() {
    switch (this.returnType) {
      case 'LiteralInteger':
      case 'Number':
      case 'Integer':
      case 'Float':
        return this.getMainResultKernelPackedPixels() +
          this.getMainResultSubKernelPackedPixels();
      default:
        throw new Error(`packed output only usable with Numbers, "${this.returnType}" specified`);
    }
  }

  getMainResultKernelPackedPixels() {
    return utils.linesToString([
      '  threadId = indexTo3D(index, uOutputDim)',
      '  kernel()',
      `  gl_FragData[0] = ${this.useLegacyEncoder ? 'legacyEncode32' : 'encode32'}(kernelResult)`
    ]);
  }

  getMainResultSubKernelPackedPixels() {
    const result = [];
    if (!this.subKernels) return '';
    for (let i = 0; i < this.subKernels.length; i++) {
      const subKernel = this.subKernels[i];
      if (subKernel.returnType === 'Integer') {
        result.push(
          `  gl_FragData[${i + 1}] = ${this.useLegacyEncoder ? 'legacyEncode32' : 'encode32'}(float(subKernelResult_${this.subKernels[i].name}))`
        );
      } else {
        result.push(
          `  gl_FragData[${i + 1}] = ${this.useLegacyEncoder ? 'legacyEncode32' : 'encode32'}(subKernelResult_${this.subKernels[i].name})`
        );
      }
    }
    return utils.linesToString(result);
  }

  getMainResultMemoryOptimizedFloats() {
    const result = [
      '  index *= 4',
    ];

    switch (this.returnType) {
      case 'Number':
      case 'Integer':
      case 'Float':
        const channels = ['r', 'g', 'b', 'a'];
        for (let i = 0; i < channels.length; i++) {
          const channel = channels[i];
          this.getMainResultKernelMemoryOptimizedFloats(result, channel);
          this.getMainResultSubKernelMemoryOptimizedFloats(result, channel);
          if (i + 1 < channels.length) {
            result.push('  index += 1');
          }
        }
        break;
      default:
        throw new Error(`optimized output only usable with Numbers, ${this.returnType} specified`);
    }

    return utils.linesToString(result);
  }

  getMainResultKernelMemoryOptimizedFloats(result, channel) {
    result.push(
      '  threadId = indexTo3D(index, uOutputDim)',
      '  kernel()',
      `  gl_FragData[0].${channel} = kernelResult`
    );
  }

  getMainResultSubKernelMemoryOptimizedFloats(result, channel) {
    if (!this.subKernels) return result;
    for (let i = 0; i < this.subKernels.length; i++) {
      const subKernel = this.subKernels[i];
      if (subKernel.returnType === 'Integer') {
        result.push(
          `  gl_FragData[${i + 1}].${channel} = float(subKernelResult_${this.subKernels[i].name})`
        );
      } else {
        result.push(
          `  gl_FragData[${i + 1}].${channel} = subKernelResult_${this.subKernels[i].name}`
        );
      }
    }
  }

  getMainResultKernelNumberTexture() {
    return [
      '  threadId = indexTo3D(index, uOutputDim)',
      '  kernel()',
      '  gl_FragData[0][0] = kernelResult',
    ];
  }

  getMainResultSubKernelNumberTexture() {
    const result = [];
    if (!this.subKernels) return result;
    for (let i = 0; i < this.subKernels.length; ++i) {
      const subKernel = this.subKernels[i];
      if (subKernel.returnType === 'Integer') {
        result.push(
          `  gl_FragData[${i + 1}][0] = float(subKernelResult_${subKernel.name})`
        );
      } else {
        result.push(
          `  gl_FragData[${i + 1}][0] = subKernelResult_${subKernel.name}`
        );
      }
    }
    return result;
  }

  getMainResultKernelArray2Texture() {
    return [
      '  threadId = indexTo3D(index, uOutputDim)',
      '  kernel()',
      '  gl_FragData[0][0] = kernelResult[0]',
      '  gl_FragData[0][1] = kernelResult[1]',
    ];
  }

  getMainResultSubKernelArray2Texture() {
    const result = [];
    if (!this.subKernels) return result;
    for (let i = 0; i < this.subKernels.length; ++i) {
      result.push(
        `  gl_FragData[${i + 1}][0] = subKernelResult_${this.subKernels[i].name}[0]`,
        `  gl_FragData[${i + 1}][1] = subKernelResult_${this.subKernels[i].name}[1]`
      );
    }
    return result;
  }

  getMainResultKernelArray3Texture() {
    return [
      '  threadId = indexTo3D(index, uOutputDim)',
      '  kernel()',
      '  gl_FragData[0][0] = kernelResult[0]',
      '  gl_FragData[0][1] = kernelResult[1]',
      '  gl_FragData[0][2] = kernelResult[2]',
    ];
  }

  getMainResultSubKernelArray3Texture() {
    const result = [];
    if (!this.subKernels) return result;
    for (let i = 0; i < this.subKernels.length; ++i) {
      result.push(
        `  gl_FragData[${i + 1}][0] = subKernelResult_${this.subKernels[i].name}[0]`,
        `  gl_FragData[${i + 1}][1] = subKernelResult_${this.subKernels[i].name}[1]`,
        `  gl_FragData[${i + 1}][2] = subKernelResult_${this.subKernels[i].name}[2]`
      );
    }
    return result;
  }

  getMainResultKernelArray4Texture() {
    return [
      '  threadId = indexTo3D(index, uOutputDim)',
      '  kernel()',
      '  gl_FragData[0] = kernelResult',
    ];
  }

  getMainResultSubKernelArray4Texture() {
    const result = [];
    if (!this.subKernels) return result;
    switch (this.returnType) {
      case 'Number':
      case 'Float':
      case 'Integer':
        for (let i = 0; i < this.subKernels.length; ++i) {
          const subKernel = this.subKernels[i];
          if (subKernel.returnType === 'Integer') {
            result.push(
              `  gl_FragData[${i + 1}] = float(subKernelResult_${this.subKernels[i].name})`
            );
          } else {
            result.push(
              `  gl_FragData[${i + 1}] = subKernelResult_${this.subKernels[i].name}`
            );
          }
        }
        break;
      case 'Array(2)':
        for (let i = 0; i < this.subKernels.length; ++i) {
          result.push(
            `  gl_FragData[${i + 1}][0] = subKernelResult_${this.subKernels[i].name}[0]`,
            `  gl_FragData[${i + 1}][1] = subKernelResult_${this.subKernels[i].name}[1]`
          );
        }
        break;
      case 'Array(3)':
        for (let i = 0; i < this.subKernels.length; ++i) {
          result.push(
            `  gl_FragData[${i + 1}][0] = subKernelResult_${this.subKernels[i].name}[0]`,
            `  gl_FragData[${i + 1}][1] = subKernelResult_${this.subKernels[i].name}[1]`,
            `  gl_FragData[${i + 1}][2] = subKernelResult_${this.subKernels[i].name}[2]`
          );
        }
        break;
      case 'Array(4)':
        for (let i = 0; i < this.subKernels.length; ++i) {
          result.push(
            `  gl_FragData[${i + 1}][0] = subKernelResult_${this.subKernels[i].name}[0]`,
            `  gl_FragData[${i + 1}][1] = subKernelResult_${this.subKernels[i].name}[1]`,
            `  gl_FragData[${i + 1}][2] = subKernelResult_${this.subKernels[i].name}[2]`,
            `  gl_FragData[${i + 1}][3] = subKernelResult_${this.subKernels[i].name}[3]`
          );
        }
        break;
    }

    return result;
  }

  replaceArtifacts(src, map) {
    return src.replace(/[ ]*__([A-Z]+[0-9]*([_]?[A-Z]*[0-9]?)*)__;\n/g, (match, artifact) => {
      if (map.hasOwnProperty(artifact)) {
        return map[artifact];
      }
      throw `unhandled artifact ${artifact}`;
    });
  }

  getFragmentShader(args) {
    if (this.compiledFragmentShader !== null) {
      return this.compiledFragmentShader;
    }
    return this.compiledFragmentShader = this.replaceArtifacts(this.constructor.fragmentShader, this._getFragShaderArtifactMap(args));
  }

  getVertexShader(args) {
    if (this.compiledVertexShader !== null) {
      return this.compiledVertexShader;
    }
    return this.compiledVertexShader = this.replaceArtifacts(this.constructor.vertexShader, this._getVertShaderArtifactMap(args));
  }

  toString() {
    const setupContextString = utils.linesToString([
      `const gl = context`,
    ]);
    return glKernelString(this.constructor, arguments, this, setupContextString);
  }

  destroy(removeCanvasReferences) {
    if (!this.context) return;
    if (this.buffer) {
      this.context.deleteBuffer(this.buffer);
    }
    if (this.framebuffer) {
      this.context.deleteFramebuffer(this.framebuffer);
    }
    for (const width in this.rawValueFramebuffers) {
      for (const height in this.rawValueFramebuffers[width]) {
        this.context.deleteFramebuffer(this.rawValueFramebuffers[width][height]);
        delete this.rawValueFramebuffers[width][height];
      }
      delete this.rawValueFramebuffers[width];
    }
    if (this.vertShader) {
      this.context.deleteShader(this.vertShader);
    }
    if (this.fragShader) {
      this.context.deleteShader(this.fragShader);
    }
    if (this.program) {
      this.context.deleteProgram(this.program);
    }
    if (this.texture) {
      this.texture.delete();
      const textureCacheIndex = this.textureCache.indexOf(this.texture.texture);
      if (textureCacheIndex > -1) {
        this.textureCache.splice(textureCacheIndex, 1);
      }
      this.texture = null;
    }
    if (this.mappedTextures && this.mappedTextures.length) {
      for (let i = 0; i < this.mappedTextures.length; i++) {
        const mappedTexture = this.mappedTextures[i];
        mappedTexture.delete();
        const textureCacheIndex = this.textureCache.indexOf(mappedTexture.texture);
        if (textureCacheIndex > -1) {
          this.textureCache.splice(textureCacheIndex, 1);
        }
      }
      this.mappedTextures = null;
    }
    if (this.kernelArguments) {
      for (let i = 0; i < this.kernelArguments.length; i++) {
        this.kernelArguments[i].destroy();
      }
    }
    if (this.kernelConstants) {
      for (let i = 0; i < this.kernelConstants.length; i++) {
        this.kernelConstants[i].destroy();
      }
    }
    while (this.textureCache.length > 0) {
      const texture = this.textureCache.pop();
      this.context.deleteTexture(texture);
    }
    if (removeCanvasReferences) {
      const idx = canvases.indexOf(this.canvas);
      if (idx >= 0) {
        canvases[idx] = null;
        maxTexSizes[idx] = null;
      }
    }
    this.destroyExtensions();
    delete this.context;
    delete this.canvas;
    if (!this.gpu) return;
    const i = this.gpu.kernels.indexOf(this);
    if (i === -1) return;
    this.gpu.kernels.splice(i, 1);
  }

  destroyExtensions() {
    this.extensions.OES_texture_float = null;
    this.extensions.OES_texture_float_linear = null;
    this.extensions.OES_element_index_uint = null;
    this.extensions.WEBGL_draw_buffers = null;
  }

  static destroyContext(context) {
    const extension = context.getExtension('WEBGL_lose_context');
    if (extension) {
      extension.loseContext();
    }
  }

  toJSON() {
    const json = super.toJSON();
    json.functionNodes = FunctionBuilder.fromKernel(this, WebGLFunctionNode).toJSON();
    json.settings.threadDim = this.threadDim;
    return json;
  }
}

module.exports = {
  WebGLKernel
};
},{"../../plugins/math-random-uniformly-distributed":112,"../../utils":114,"../function-builder":9,"../gl/kernel":13,"../gl/kernel-string":12,"./fragment-shader":37,"./function-node":38,"./kernel-value-maps":39,"./vertex-shader":71}],71:[function(require,module,exports){
const vertexShader = `__FLOAT_TACTIC_DECLARATION__;
__INT_TACTIC_DECLARATION__;
__SAMPLER_2D_TACTIC_DECLARATION__;

attribute vec2 aPos;
attribute vec2 aTexCoord;

varying vec2 vTexCoord;
uniform vec2 ratio;

void main(void) {
  gl_Position = vec4((aPos + vec2(1)) * ratio + vec2(-1), 0, 1);
  vTexCoord = aTexCoord;
}`;

module.exports = {
  vertexShader
};
},{}],72:[function(require,module,exports){
const fragmentShader = `#version 300 es
__HEADER__;
__FLOAT_TACTIC_DECLARATION__;
__INT_TACTIC_DECLARATION__;
__SAMPLER_2D_TACTIC_DECLARATION__;
__SAMPLER_2D_ARRAY_TACTIC_DECLARATION__;

const int LOOP_MAX = __LOOP_MAX__;

__PLUGINS__;
__CONSTANTS__;

in vec2 vTexCoord;

float atan2(float v1, float v2) {
  if (v1 == 0.0 || v2 == 0.0) return 0.0;
  return atan(v1 / v2);
}

float cbrt(float x) {
  if (x >= 0.0) {
    return pow(x, 1.0 / 3.0);
  } else {
    return -pow(x, 1.0 / 3.0);
  }
}

float expm1(float x) {
  return pow(${Math.E}, x) - 1.0; 
}

float fround(highp float x) {
  return x;
}

float imul(float v1, float v2) {
  return float(int(v1) * int(v2));
}

float log10(float x) {
  return log2(x) * (1.0 / log2(10.0));
}

float log1p(float x) {
  return log(1.0 + x);
}

float _pow(float v1, float v2) {
  if (v2 == 0.0) return 1.0;
  return pow(v1, v2);
}

float _round(float x) {
  return floor(x + 0.5);
}


const int BIT_COUNT = 32;
int modi(int x, int y) {
  return x - y * (x / y);
}

int bitwiseOr(int a, int b) {
  int result = 0;
  int n = 1;
  
  for (int i = 0; i < BIT_COUNT; i++) {
    if ((modi(a, 2) == 1) || (modi(b, 2) == 1)) {
      result += n;
    }
    a = a / 2;
    b = b / 2;
    n = n * 2;
    if(!(a > 0 || b > 0)) {
      break;
    }
  }
  return result;
}
int bitwiseXOR(int a, int b) {
  int result = 0;
  int n = 1;
  
  for (int i = 0; i < BIT_COUNT; i++) {
    if ((modi(a, 2) == 1) != (modi(b, 2) == 1)) {
      result += n;
    }
    a = a / 2;
    b = b / 2;
    n = n * 2;
    if(!(a > 0 || b > 0)) {
      break;
    }
  }
  return result;
}
int bitwiseAnd(int a, int b) {
  int result = 0;
  int n = 1;
  for (int i = 0; i < BIT_COUNT; i++) {
    if ((modi(a, 2) == 1) && (modi(b, 2) == 1)) {
      result += n;
    }
    a = a / 2;
    b = b / 2;
    n = n * 2;
    if(!(a > 0 && b > 0)) {
      break;
    }
  }
  return result;
}
int bitwiseNot(int a) {
  int result = 0;
  int n = 1;
  
  for (int i = 0; i < BIT_COUNT; i++) {
    if (modi(a, 2) == 0) {
      result += n;    
    }
    a = a / 2;
    n = n * 2;
  }
  return result;
}
int bitwiseZeroFillLeftShift(int n, int shift) {
  int maxBytes = BIT_COUNT;
  for (int i = 0; i < BIT_COUNT; i++) {
    if (maxBytes >= n) {
      break;
    }
    maxBytes *= 2;
  }
  for (int i = 0; i < BIT_COUNT; i++) {
    if (i >= shift) {
      break;
    }
    n *= 2;
  }

  int result = 0;
  int byteVal = 1;
  for (int i = 0; i < BIT_COUNT; i++) {
    if (i >= maxBytes) break;
    if (modi(n, 2) > 0) { result += byteVal; }
    n = int(n / 2);
    byteVal *= 2;
  }
  return result;
}

int bitwiseSignedRightShift(int num, int shifts) {
  return int(floor(float(num) / pow(2.0, float(shifts))));
}

int bitwiseZeroFillRightShift(int n, int shift) {
  int maxBytes = BIT_COUNT;
  for (int i = 0; i < BIT_COUNT; i++) {
    if (maxBytes >= n) {
      break;
    }
    maxBytes *= 2;
  }
  for (int i = 0; i < BIT_COUNT; i++) {
    if (i >= shift) {
      break;
    }
    n /= 2;
  }
  int result = 0;
  int byteVal = 1;
  for (int i = 0; i < BIT_COUNT; i++) {
    if (i >= maxBytes) break;
    if (modi(n, 2) > 0) { result += byteVal; }
    n = int(n / 2);
    byteVal *= 2;
  }
  return result;
}

vec2 integerMod(vec2 x, float y) {
  vec2 res = floor(mod(x, y));
  return res * step(1.0 - floor(y), -res);
}

vec3 integerMod(vec3 x, float y) {
  vec3 res = floor(mod(x, y));
  return res * step(1.0 - floor(y), -res);
}

vec4 integerMod(vec4 x, vec4 y) {
  vec4 res = floor(mod(x, y));
  return res * step(1.0 - floor(y), -res);
}

float integerMod(float x, float y) {
  float res = floor(mod(x, y));
  return res * (res > floor(y) - 1.0 ? 0.0 : 1.0);
}

int integerMod(int x, int y) {
  return x - (y * int(x/y));
}

__DIVIDE_WITH_INTEGER_CHECK__;

// Here be dragons!
// DO NOT OPTIMIZE THIS CODE
// YOU WILL BREAK SOMETHING ON SOMEBODY\'S MACHINE
// LEAVE IT AS IT IS, LEST YOU WASTE YOUR OWN TIME
const vec2 MAGIC_VEC = vec2(1.0, -256.0);
const vec4 SCALE_FACTOR = vec4(1.0, 256.0, 65536.0, 0.0);
const vec4 SCALE_FACTOR_INV = vec4(1.0, 0.00390625, 0.0000152587890625, 0.0); // 1, 1/256, 1/65536
float decode32(vec4 texel) {
  __DECODE32_ENDIANNESS__;
  texel *= 255.0;
  vec2 gte128;
  gte128.x = texel.b >= 128.0 ? 1.0 : 0.0;
  gte128.y = texel.a >= 128.0 ? 1.0 : 0.0;
  float exponent = 2.0 * texel.a - 127.0 + dot(gte128, MAGIC_VEC);
  float res = exp2(round(exponent));
  texel.b = texel.b - 128.0 * gte128.x;
  res = dot(texel, SCALE_FACTOR) * exp2(round(exponent-23.0)) + res;
  res *= gte128.y * -2.0 + 1.0;
  return res;
}

float decode16(vec4 texel, int index) {
  int channel = integerMod(index, 2);
  return texel[channel*2] * 255.0 + texel[channel*2 + 1] * 65280.0;
}

float decode8(vec4 texel, int index) {
  int channel = integerMod(index, 4);
  return texel[channel] * 255.0;
}

vec4 legacyEncode32(float f) {
  float F = abs(f);
  float sign = f < 0.0 ? 1.0 : 0.0;
  float exponent = floor(log2(F));
  float mantissa = (exp2(-exponent) * F);
  // exponent += floor(log2(mantissa));
  vec4 texel = vec4(F * exp2(23.0-exponent)) * SCALE_FACTOR_INV;
  texel.rg = integerMod(texel.rg, 256.0);
  texel.b = integerMod(texel.b, 128.0);
  texel.a = exponent*0.5 + 63.5;
  texel.ba += vec2(integerMod(exponent+127.0, 2.0), sign) * 128.0;
  texel = floor(texel);
  texel *= 0.003921569; // 1/255
  __ENCODE32_ENDIANNESS__;
  return texel;
}

// https://github.com/gpujs/gpu.js/wiki/Encoder-details
vec4 encode32(float value) {
  if (value == 0.0) return vec4(0, 0, 0, 0);

  float exponent;
  float mantissa;
  vec4  result;
  float sgn;

  sgn = step(0.0, -value);
  value = abs(value);

  exponent = floor(log2(value));

  mantissa = value*pow(2.0, -exponent)-1.0;
  exponent = exponent+127.0;
  result   = vec4(0,0,0,0);

  result.a = floor(exponent/2.0);
  exponent = exponent - result.a*2.0;
  result.a = result.a + 128.0*sgn;

  result.b = floor(mantissa * 128.0);
  mantissa = mantissa - result.b / 128.0;
  result.b = result.b + exponent*128.0;

  result.g = floor(mantissa*32768.0);
  mantissa = mantissa - result.g/32768.0;

  result.r = floor(mantissa*8388608.0);
  return result/255.0;
}
// Dragons end here

int index;
ivec3 threadId;

ivec3 indexTo3D(int idx, ivec3 texDim) {
  int z = int(idx / (texDim.x * texDim.y));
  idx -= z * int(texDim.x * texDim.y);
  int y = int(idx / texDim.x);
  int x = int(integerMod(idx, texDim.x));
  return ivec3(x, y, z);
}

float get32(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + texDim.x * (y + texDim.y * z);
  int w = texSize.x;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  vec4 texel = texture(tex, st / vec2(texSize));
  return decode32(texel);
}

float get16(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + (texDim.x * (y + (texDim.y * z)));
  int w = texSize.x * 2;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  vec4 texel = texture(tex, st / vec2(texSize.x * 2, texSize.y));
  return decode16(texel, index);
}

float get8(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + (texDim.x * (y + (texDim.y * z)));
  int w = texSize.x * 4;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  vec4 texel = texture(tex, st / vec2(texSize.x * 4, texSize.y));
  return decode8(texel, index);
}

float getMemoryOptimized32(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + (texDim.x * (y + (texDim.y * z)));
  int channel = integerMod(index, 4);
  index = index / 4;
  int w = texSize.x;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  index = index / 4;
  vec4 texel = texture(tex, st / vec2(texSize));
  return texel[channel];
}

vec4 getImage2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + texDim.x * (y + texDim.y * z);
  int w = texSize.x;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  return texture(tex, st / vec2(texSize));
}

vec4 getImage3D(sampler2DArray tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + texDim.x * (y + texDim.y * z);
  int w = texSize.x;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  return texture(tex, vec3(st / vec2(texSize), z));
}

float getFloatFromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  vec4 result = getImage2D(tex, texSize, texDim, z, y, x);
  return result[0];
}

vec2 getVec2FromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  vec4 result = getImage2D(tex, texSize, texDim, z, y, x);
  return vec2(result[0], result[1]);
}

vec2 getMemoryOptimizedVec2(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + texDim.x * (y + texDim.y * z);
  int channel = integerMod(index, 2);
  index = index / 2;
  int w = texSize.x;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  vec4 texel = texture(tex, st / vec2(texSize));
  if (channel == 0) return vec2(texel.r, texel.g);
  if (channel == 1) return vec2(texel.b, texel.a);
  return vec2(0.0, 0.0);
}

vec3 getVec3FromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  vec4 result = getImage2D(tex, texSize, texDim, z, y, x);
  return vec3(result[0], result[1], result[2]);
}

vec3 getMemoryOptimizedVec3(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int fieldIndex = 3 * (x + texDim.x * (y + texDim.y * z));
  int vectorIndex = fieldIndex / 4;
  int vectorOffset = fieldIndex - vectorIndex * 4;
  int readY = vectorIndex / texSize.x;
  int readX = vectorIndex - readY * texSize.x;
  vec4 tex1 = texture(tex, (vec2(readX, readY) + 0.5) / vec2(texSize));

  if (vectorOffset == 0) {
    return tex1.xyz;
  } else if (vectorOffset == 1) {
    return tex1.yzw;
  } else {
    readX++;
    if (readX >= texSize.x) {
      readX = 0;
      readY++;
    }
    vec4 tex2 = texture(tex, vec2(readX, readY) / vec2(texSize));
    if (vectorOffset == 2) {
      return vec3(tex1.z, tex1.w, tex2.x);
    } else {
      return vec3(tex1.w, tex2.x, tex2.y);
    }
  }
}

vec4 getVec4FromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  return getImage2D(tex, texSize, texDim, z, y, x);
}

vec4 getMemoryOptimizedVec4(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + texDim.x * (y + texDim.y * z);
  int channel = integerMod(index, 2);
  int w = texSize.x;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  vec4 texel = texture(tex, st / vec2(texSize));
  return vec4(texel.r, texel.g, texel.b, texel.a);
}

vec4 actualColor;
void color(float r, float g, float b, float a) {
  actualColor = vec4(r,g,b,a);
}

void color(float r, float g, float b) {
  color(r,g,b,1.0);
}

float modulo(float number, float divisor) {
  if (number < 0.0) {
    number = abs(number);
    if (divisor < 0.0) {
      divisor = abs(divisor);
    }
    return -mod(number, divisor);
  }
  if (divisor < 0.0) {
    divisor = abs(divisor);
  }
  return mod(number, divisor);
}

__INJECTED_NATIVE__;
__MAIN_CONSTANTS__;
__MAIN_ARGUMENTS__;
__KERNEL__;

void main(void) {
  index = int(vTexCoord.s * float(uTexSize.x)) + int(vTexCoord.t * float(uTexSize.y)) * uTexSize.x;
  __MAIN_RESULT__;
}`;

module.exports = {
  fragmentShader
};
},{}],73:[function(require,module,exports){
const { utils } = require('../../utils');
const { WebGLFunctionNode } = require('../web-gl/function-node');

class WebGL2FunctionNode extends WebGLFunctionNode {

  astIdentifierExpression(idtNode, retArr) {
    if (idtNode.type !== 'Identifier') {
      throw this.astErrorOutput(
        'IdentifierExpression - not an Identifier',
        idtNode
      );
    }

    const type = this.getType(idtNode);

    const name = utils.sanitizeName(idtNode.name);
    if (idtNode.name === 'Infinity') {
      retArr.push('intBitsToFloat(2139095039)');
    } else if (type === 'Boolean') {
      if (this.argumentNames.indexOf(name) > -1) {
        retArr.push(`bool(user_${name})`);
      } else {
        retArr.push(`user_${name}`);
      }
    } else {
      retArr.push(`user_${name}`);
    }

    return retArr;
  }
}

module.exports = {
  WebGL2FunctionNode
};
},{"../../utils":114,"../web-gl/function-node":38}],74:[function(require,module,exports){
const { WebGL2KernelValueBoolean } = require('./kernel-value/boolean');
const { WebGL2KernelValueFloat } = require('./kernel-value/float');
const { WebGL2KernelValueInteger } = require('./kernel-value/integer');

const { WebGL2KernelValueHTMLImage } = require('./kernel-value/html-image');
const { WebGL2KernelValueDynamicHTMLImage } = require('./kernel-value/dynamic-html-image');

const { WebGL2KernelValueHTMLImageArray } = require('./kernel-value/html-image-array');
const { WebGL2KernelValueDynamicHTMLImageArray } = require('./kernel-value/dynamic-html-image-array');

const { WebGL2KernelValueHTMLVideo } = require('./kernel-value/html-video');
const { WebGL2KernelValueDynamicHTMLVideo } = require('./kernel-value/dynamic-html-video');

const { WebGL2KernelValueSingleInput } = require('./kernel-value/single-input');
const { WebGL2KernelValueDynamicSingleInput } = require('./kernel-value/dynamic-single-input');

const { WebGL2KernelValueUnsignedInput } = require('./kernel-value/unsigned-input');
const { WebGL2KernelValueDynamicUnsignedInput } = require('./kernel-value/dynamic-unsigned-input');

const { WebGL2KernelValueMemoryOptimizedNumberTexture } = require('./kernel-value/memory-optimized-number-texture');
const { WebGL2KernelValueDynamicMemoryOptimizedNumberTexture } = require('./kernel-value/dynamic-memory-optimized-number-texture');

const { WebGL2KernelValueNumberTexture } = require('./kernel-value/number-texture');
const { WebGL2KernelValueDynamicNumberTexture } = require('./kernel-value/dynamic-number-texture');

const { WebGL2KernelValueSingleArray } = require('./kernel-value/single-array');
const { WebGL2KernelValueDynamicSingleArray } = require('./kernel-value/dynamic-single-array');

const { WebGL2KernelValueSingleArray1DI } = require('./kernel-value/single-array1d-i');
const { WebGL2KernelValueDynamicSingleArray1DI } = require('./kernel-value/dynamic-single-array1d-i');

const { WebGL2KernelValueSingleArray2DI } = require('./kernel-value/single-array2d-i');
const { WebGL2KernelValueDynamicSingleArray2DI } = require('./kernel-value/dynamic-single-array2d-i');

const { WebGL2KernelValueSingleArray3DI } = require('./kernel-value/single-array3d-i');
const { WebGL2KernelValueDynamicSingleArray3DI } = require('./kernel-value/dynamic-single-array3d-i');

const { WebGL2KernelValueArray2 } = require('./kernel-value/array2');
const { WebGL2KernelValueArray3 } = require('./kernel-value/array3');
const { WebGL2KernelValueArray4 } = require('./kernel-value/array4');

const { WebGL2KernelValueUnsignedArray } = require('./kernel-value/unsigned-array');
const { WebGL2KernelValueDynamicUnsignedArray } = require('./kernel-value/dynamic-unsigned-array');

const kernelValueMaps = {
  unsigned: {
    dynamic: {
      'Boolean': WebGL2KernelValueBoolean,
      'Integer': WebGL2KernelValueInteger,
      'Float': WebGL2KernelValueFloat,
      'Array': WebGL2KernelValueDynamicUnsignedArray,
      'Array(2)': WebGL2KernelValueArray2,
      'Array(3)': WebGL2KernelValueArray3,
      'Array(4)': WebGL2KernelValueArray4,
      'Array1D(2)': false,
      'Array1D(3)': false,
      'Array1D(4)': false,
      'Array2D(2)': false,
      'Array2D(3)': false,
      'Array2D(4)': false,
      'Array3D(2)': false,
      'Array3D(3)': false,
      'Array3D(4)': false,
      'Input': WebGL2KernelValueDynamicUnsignedInput,
      'NumberTexture': WebGL2KernelValueDynamicNumberTexture,
      'ArrayTexture(1)': WebGL2KernelValueDynamicNumberTexture,
      'ArrayTexture(2)': WebGL2KernelValueDynamicNumberTexture,
      'ArrayTexture(3)': WebGL2KernelValueDynamicNumberTexture,
      'ArrayTexture(4)': WebGL2KernelValueDynamicNumberTexture,
      'MemoryOptimizedNumberTexture': WebGL2KernelValueDynamicMemoryOptimizedNumberTexture,
      'HTMLCanvas': WebGL2KernelValueDynamicHTMLImage,
      'OffscreenCanvas': WebGL2KernelValueDynamicHTMLImage,
      'HTMLImage': WebGL2KernelValueDynamicHTMLImage,
      'ImageBitmap': WebGL2KernelValueDynamicHTMLImage,
      'ImageData': WebGL2KernelValueDynamicHTMLImage,
      'HTMLImageArray': WebGL2KernelValueDynamicHTMLImageArray,
      'HTMLVideo': WebGL2KernelValueDynamicHTMLVideo,
    },
    static: {
      'Boolean': WebGL2KernelValueBoolean,
      'Float': WebGL2KernelValueFloat,
      'Integer': WebGL2KernelValueInteger,
      'Array': WebGL2KernelValueUnsignedArray,
      'Array(2)': WebGL2KernelValueArray2,
      'Array(3)': WebGL2KernelValueArray3,
      'Array(4)': WebGL2KernelValueArray4,
      'Array1D(2)': false,
      'Array1D(3)': false,
      'Array1D(4)': false,
      'Array2D(2)': false,
      'Array2D(3)': false,
      'Array2D(4)': false,
      'Array3D(2)': false,
      'Array3D(3)': false,
      'Array3D(4)': false,
      'Input': WebGL2KernelValueUnsignedInput,
      'NumberTexture': WebGL2KernelValueNumberTexture,
      'ArrayTexture(1)': WebGL2KernelValueNumberTexture,
      'ArrayTexture(2)': WebGL2KernelValueNumberTexture,
      'ArrayTexture(3)': WebGL2KernelValueNumberTexture,
      'ArrayTexture(4)': WebGL2KernelValueNumberTexture,
      'MemoryOptimizedNumberTexture': WebGL2KernelValueDynamicMemoryOptimizedNumberTexture,
      'HTMLCanvas': WebGL2KernelValueHTMLImage,
      'OffscreenCanvas': WebGL2KernelValueHTMLImage,
      'HTMLImage': WebGL2KernelValueHTMLImage,
      'ImageBitmap': WebGL2KernelValueHTMLImage,
      'ImageData': WebGL2KernelValueHTMLImage,
      'HTMLImageArray': WebGL2KernelValueHTMLImageArray,
      'HTMLVideo': WebGL2KernelValueHTMLVideo,
    }
  },
  single: {
    dynamic: {
      'Boolean': WebGL2KernelValueBoolean,
      'Integer': WebGL2KernelValueInteger,
      'Float': WebGL2KernelValueFloat,
      'Array': WebGL2KernelValueDynamicSingleArray,
      'Array(2)': WebGL2KernelValueArray2,
      'Array(3)': WebGL2KernelValueArray3,
      'Array(4)': WebGL2KernelValueArray4,
      'Array1D(2)': WebGL2KernelValueDynamicSingleArray1DI,
      'Array1D(3)': WebGL2KernelValueDynamicSingleArray1DI,
      'Array1D(4)': WebGL2KernelValueDynamicSingleArray1DI,
      'Array2D(2)': WebGL2KernelValueDynamicSingleArray2DI,
      'Array2D(3)': WebGL2KernelValueDynamicSingleArray2DI,
      'Array2D(4)': WebGL2KernelValueDynamicSingleArray2DI,
      'Array3D(2)': WebGL2KernelValueDynamicSingleArray3DI,
      'Array3D(3)': WebGL2KernelValueDynamicSingleArray3DI,
      'Array3D(4)': WebGL2KernelValueDynamicSingleArray3DI,
      'Input': WebGL2KernelValueDynamicSingleInput,
      'NumberTexture': WebGL2KernelValueDynamicNumberTexture,
      'ArrayTexture(1)': WebGL2KernelValueDynamicNumberTexture,
      'ArrayTexture(2)': WebGL2KernelValueDynamicNumberTexture,
      'ArrayTexture(3)': WebGL2KernelValueDynamicNumberTexture,
      'ArrayTexture(4)': WebGL2KernelValueDynamicNumberTexture,
      'MemoryOptimizedNumberTexture': WebGL2KernelValueDynamicMemoryOptimizedNumberTexture,
      'HTMLCanvas': WebGL2KernelValueDynamicHTMLImage,
      'OffscreenCanvas': WebGL2KernelValueDynamicHTMLImage,
      'HTMLImage': WebGL2KernelValueDynamicHTMLImage,
      'ImageBitmap': WebGL2KernelValueDynamicHTMLImage,
      'ImageData': WebGL2KernelValueDynamicHTMLImage,
      'HTMLImageArray': WebGL2KernelValueDynamicHTMLImageArray,
      'HTMLVideo': WebGL2KernelValueDynamicHTMLVideo,
    },
    static: {
      'Boolean': WebGL2KernelValueBoolean,
      'Float': WebGL2KernelValueFloat,
      'Integer': WebGL2KernelValueInteger,
      'Array': WebGL2KernelValueSingleArray,
      'Array(2)': WebGL2KernelValueArray2,
      'Array(3)': WebGL2KernelValueArray3,
      'Array(4)': WebGL2KernelValueArray4,
      'Array1D(2)': WebGL2KernelValueSingleArray1DI,
      'Array1D(3)': WebGL2KernelValueSingleArray1DI,
      'Array1D(4)': WebGL2KernelValueSingleArray1DI,
      'Array2D(2)': WebGL2KernelValueSingleArray2DI,
      'Array2D(3)': WebGL2KernelValueSingleArray2DI,
      'Array2D(4)': WebGL2KernelValueSingleArray2DI,
      'Array3D(2)': WebGL2KernelValueSingleArray3DI,
      'Array3D(3)': WebGL2KernelValueSingleArray3DI,
      'Array3D(4)': WebGL2KernelValueSingleArray3DI,
      'Input': WebGL2KernelValueSingleInput,
      'NumberTexture': WebGL2KernelValueNumberTexture,
      'ArrayTexture(1)': WebGL2KernelValueNumberTexture,
      'ArrayTexture(2)': WebGL2KernelValueNumberTexture,
      'ArrayTexture(3)': WebGL2KernelValueNumberTexture,
      'ArrayTexture(4)': WebGL2KernelValueNumberTexture,
      'MemoryOptimizedNumberTexture': WebGL2KernelValueMemoryOptimizedNumberTexture,
      'HTMLCanvas': WebGL2KernelValueHTMLImage,
      'OffscreenCanvas': WebGL2KernelValueHTMLImage,
      'HTMLImage': WebGL2KernelValueHTMLImage,
      'ImageBitmap': WebGL2KernelValueHTMLImage,
      'ImageData': WebGL2KernelValueHTMLImage,
      'HTMLImageArray': WebGL2KernelValueHTMLImageArray,
      'HTMLVideo': WebGL2KernelValueHTMLVideo,
    }
  },
};

function lookupKernelValueType(type, dynamic, precision, value) {
  if (!type) {
    throw new Error('type missing');
  }
  if (!dynamic) {
    throw new Error('dynamic missing');
  }
  if (!precision) {
    throw new Error('precision missing');
  }
  if (value.type) {
    type = value.type;
  }
  const types = kernelValueMaps[precision][dynamic];
  if (types[type] === false) {
    return null;
  } else if (types[type] === undefined) {
    throw new Error(`Could not find a KernelValue for ${ type }`);
  }
  return types[type];
}

module.exports = {
  kernelValueMaps,
  lookupKernelValueType
};
},{"./kernel-value/array2":75,"./kernel-value/array3":76,"./kernel-value/array4":77,"./kernel-value/boolean":78,"./kernel-value/dynamic-html-image":80,"./kernel-value/dynamic-html-image-array":79,"./kernel-value/dynamic-html-video":81,"./kernel-value/dynamic-memory-optimized-number-texture":82,"./kernel-value/dynamic-number-texture":83,"./kernel-value/dynamic-single-array":84,"./kernel-value/dynamic-single-array1d-i":85,"./kernel-value/dynamic-single-array2d-i":86,"./kernel-value/dynamic-single-array3d-i":87,"./kernel-value/dynamic-single-input":88,"./kernel-value/dynamic-unsigned-array":89,"./kernel-value/dynamic-unsigned-input":90,"./kernel-value/float":91,"./kernel-value/html-image":93,"./kernel-value/html-image-array":92,"./kernel-value/html-video":94,"./kernel-value/integer":95,"./kernel-value/memory-optimized-number-texture":96,"./kernel-value/number-texture":97,"./kernel-value/single-array":98,"./kernel-value/single-array1d-i":99,"./kernel-value/single-array2d-i":100,"./kernel-value/single-array3d-i":101,"./kernel-value/single-input":102,"./kernel-value/unsigned-array":103,"./kernel-value/unsigned-input":104}],75:[function(require,module,exports){
const { WebGLKernelValueArray2 } = require('../../web-gl/kernel-value/array2');

class WebGL2KernelValueArray2 extends WebGLKernelValueArray2 {}

module.exports = {
  WebGL2KernelValueArray2
};
},{"../../web-gl/kernel-value/array2":41}],76:[function(require,module,exports){
const { WebGLKernelValueArray3 } = require('../../web-gl/kernel-value/array3');

class WebGL2KernelValueArray3 extends WebGLKernelValueArray3 {}

module.exports = {
  WebGL2KernelValueArray3
};
},{"../../web-gl/kernel-value/array3":42}],77:[function(require,module,exports){
const { WebGLKernelValueArray4 } = require('../../web-gl/kernel-value/array4');

class WebGL2KernelValueArray4 extends WebGLKernelValueArray4 {}

module.exports = {
  WebGL2KernelValueArray4
};
},{"../../web-gl/kernel-value/array4":43}],78:[function(require,module,exports){
const { WebGLKernelValueBoolean } = require('../../web-gl/kernel-value/boolean');

class WebGL2KernelValueBoolean extends WebGLKernelValueBoolean {}

module.exports = {
  WebGL2KernelValueBoolean
};
},{"../../web-gl/kernel-value/boolean":44}],79:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGL2KernelValueHTMLImageArray } = require('./html-image-array');

class WebGL2KernelValueDynamicHTMLImageArray extends WebGL2KernelValueHTMLImageArray {
  getSource() {
    const variablePrecision = this.getVariablePrecisionString();
    return utils.linesToString([
      `uniform ${ variablePrecision } sampler2DArray ${this.id}`,
      `uniform ${ variablePrecision } ivec2 ${this.sizeId}`,
      `uniform ${ variablePrecision } ivec3 ${this.dimensionsId}`,
    ]);
  }

  updateValue(images) {
    const { width, height } = images[0];
    this.checkSize(width, height);
    this.dimensions = [width, height, images.length];
    this.textureSize = [width, height];
    this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);
    this.kernel.setUniform2iv(this.sizeId, this.textureSize);
    super.updateValue(images);
  }
}

module.exports = {
  WebGL2KernelValueDynamicHTMLImageArray
};
},{"../../../utils":114,"./html-image-array":92}],80:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueDynamicHTMLImage } = require('../../web-gl/kernel-value/dynamic-html-image');

class WebGL2KernelValueDynamicHTMLImage extends WebGLKernelValueDynamicHTMLImage {
  getSource() {
    const variablePrecision = this.getVariablePrecisionString();
    return utils.linesToString([
      `uniform ${ variablePrecision } sampler2D ${this.id}`,
      `uniform ${ variablePrecision } ivec2 ${this.sizeId}`,
      `uniform ${ variablePrecision } ivec3 ${this.dimensionsId}`,
    ]);
  }
}

module.exports = {
  WebGL2KernelValueDynamicHTMLImage
};
},{"../../../utils":114,"../../web-gl/kernel-value/dynamic-html-image":45}],81:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGL2KernelValueDynamicHTMLImage } = require('./dynamic-html-image');

class WebGL2KernelValueDynamicHTMLVideo extends WebGL2KernelValueDynamicHTMLImage {}

module.exports = {
  WebGL2KernelValueDynamicHTMLVideo
};
},{"../../../utils":114,"./dynamic-html-image":80}],82:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueDynamicMemoryOptimizedNumberTexture } = require('../../web-gl/kernel-value/dynamic-memory-optimized-number-texture');

class WebGL2KernelValueDynamicMemoryOptimizedNumberTexture extends WebGLKernelValueDynamicMemoryOptimizedNumberTexture {
  getSource() {
    return utils.linesToString([
      `uniform sampler2D ${this.id}`,
      `uniform ivec2 ${this.sizeId}`,
      `uniform ivec3 ${this.dimensionsId}`,
    ]);
  }
}

module.exports = {
  WebGL2KernelValueDynamicMemoryOptimizedNumberTexture
};
},{"../../../utils":114,"../../web-gl/kernel-value/dynamic-memory-optimized-number-texture":47}],83:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueDynamicNumberTexture } = require('../../web-gl/kernel-value/dynamic-number-texture');

class WebGL2KernelValueDynamicNumberTexture extends WebGLKernelValueDynamicNumberTexture {
  getSource() {
    const variablePrecision = this.getVariablePrecisionString();
    return utils.linesToString([
      `uniform ${ variablePrecision } sampler2D ${this.id}`,
      `uniform ${ variablePrecision } ivec2 ${this.sizeId}`,
      `uniform ${ variablePrecision } ivec3 ${this.dimensionsId}`,
    ]);
  }
}

module.exports = {
  WebGL2KernelValueDynamicNumberTexture
};
},{"../../../utils":114,"../../web-gl/kernel-value/dynamic-number-texture":48}],84:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGL2KernelValueSingleArray } = require('../../web-gl2/kernel-value/single-array');

class WebGL2KernelValueDynamicSingleArray extends WebGL2KernelValueSingleArray {
  getSource() {
    const variablePrecision = this.getVariablePrecisionString();
    return utils.linesToString([
      `uniform ${ variablePrecision } sampler2D ${this.id}`,
      `uniform ${ variablePrecision } ivec2 ${this.sizeId}`,
      `uniform ${ variablePrecision } ivec3 ${this.dimensionsId}`,
    ]);
  }

  updateValue(value) {
    this.dimensions = utils.getDimensions(value, true);
    this.textureSize = utils.getMemoryOptimizedFloatTextureSize(this.dimensions, this.bitRatio);
    this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * this.bitRatio;
    this.checkSize(this.textureSize[0], this.textureSize[1]);
    this.uploadValue = new Float32Array(this.uploadArrayLength);
    this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);
    this.kernel.setUniform2iv(this.sizeId, this.textureSize);
    super.updateValue(value);
  }
}

module.exports = {
  WebGL2KernelValueDynamicSingleArray
};
},{"../../../utils":114,"../../web-gl2/kernel-value/single-array":98}],85:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGL2KernelValueSingleArray1DI } = require('../../web-gl2/kernel-value/single-array1d-i');

class WebGL2KernelValueDynamicSingleArray1DI extends WebGL2KernelValueSingleArray1DI {
  getSource() {
    const variablePrecision = this.getVariablePrecisionString();
    return utils.linesToString([
      `uniform ${ variablePrecision } sampler2D ${this.id}`,
      `uniform ${ variablePrecision } ivec2 ${this.sizeId}`,
      `uniform ${ variablePrecision } ivec3 ${this.dimensionsId}`,
    ]);
  }

  updateValue(value) {
    this.setShape(value);
    this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);
    this.kernel.setUniform2iv(this.sizeId, this.textureSize);
    super.updateValue(value);
  }
}

module.exports = {
  WebGL2KernelValueDynamicSingleArray1DI
};
},{"../../../utils":114,"../../web-gl2/kernel-value/single-array1d-i":99}],86:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGL2KernelValueSingleArray2DI } = require('../../web-gl2/kernel-value/single-array2d-i');

class WebGL2KernelValueDynamicSingleArray2DI extends WebGL2KernelValueSingleArray2DI {
  getSource() {
    const variablePrecision = this.getVariablePrecisionString();
    return utils.linesToString([
      `uniform ${ variablePrecision } sampler2D ${this.id}`,
      `uniform ${ variablePrecision } ivec2 ${this.sizeId}`,
      `uniform ${ variablePrecision } ivec3 ${this.dimensionsId}`,
    ]);
  }

  updateValue(value) {
    this.setShape(value);
    this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);
    this.kernel.setUniform2iv(this.sizeId, this.textureSize);
    super.updateValue(value);
  }
}

module.exports = {
  WebGL2KernelValueDynamicSingleArray2DI
};
},{"../../../utils":114,"../../web-gl2/kernel-value/single-array2d-i":100}],87:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGL2KernelValueSingleArray3DI } = require('../../web-gl2/kernel-value/single-array3d-i');

class WebGL2KernelValueDynamicSingleArray3DI extends WebGL2KernelValueSingleArray3DI {
  getSource() {
    const variablePrecision = this.getVariablePrecisionString();
    return utils.linesToString([
      `uniform ${ variablePrecision } sampler2D ${this.id}`,
      `uniform ${ variablePrecision } ivec2 ${this.sizeId}`,
      `uniform ${ variablePrecision } ivec3 ${this.dimensionsId}`,
    ]);
  }

  updateValue(value) {
    this.setShape(value);
    this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);
    this.kernel.setUniform2iv(this.sizeId, this.textureSize);
    super.updateValue(value);
  }
}

module.exports = {
  WebGL2KernelValueDynamicSingleArray3DI
};
},{"../../../utils":114,"../../web-gl2/kernel-value/single-array3d-i":101}],88:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGL2KernelValueSingleInput } = require('../../web-gl2/kernel-value/single-input');

class WebGL2KernelValueDynamicSingleInput extends WebGL2KernelValueSingleInput {
  getSource() {
    const variablePrecision = this.getVariablePrecisionString();
    return utils.linesToString([
      `uniform ${ variablePrecision } sampler2D ${this.id}`,
      `uniform ${ variablePrecision } ivec2 ${this.sizeId}`,
      `uniform ${ variablePrecision } ivec3 ${this.dimensionsId}`,
    ]);
  }

  updateValue(value) {
    let [w, h, d] = value.size;
    this.dimensions = new Int32Array([w || 1, h || 1, d || 1]);
    this.textureSize = utils.getMemoryOptimizedFloatTextureSize(this.dimensions, this.bitRatio);
    this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * this.bitRatio;
    this.checkSize(this.textureSize[0], this.textureSize[1]);
    this.uploadValue = new Float32Array(this.uploadArrayLength);
    this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);
    this.kernel.setUniform2iv(this.sizeId, this.textureSize);
    super.updateValue(value);
  }
}

module.exports = {
  WebGL2KernelValueDynamicSingleInput
};
},{"../../../utils":114,"../../web-gl2/kernel-value/single-input":102}],89:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueDynamicUnsignedArray } = require('../../web-gl/kernel-value/dynamic-unsigned-array');

class WebGL2KernelValueDynamicUnsignedArray extends WebGLKernelValueDynamicUnsignedArray {
  getSource() {
    const variablePrecision = this.getVariablePrecisionString();
    return utils.linesToString([
      `uniform ${ variablePrecision } sampler2D ${this.id}`,
      `uniform ${ variablePrecision } ivec2 ${this.sizeId}`,
      `uniform ${ variablePrecision } ivec3 ${this.dimensionsId}`,
    ]);
  }
}

module.exports = {
  WebGL2KernelValueDynamicUnsignedArray
};
},{"../../../utils":114,"../../web-gl/kernel-value/dynamic-unsigned-array":54}],90:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueDynamicUnsignedInput } = require('../../web-gl/kernel-value/dynamic-unsigned-input');

class WebGL2KernelValueDynamicUnsignedInput extends WebGLKernelValueDynamicUnsignedInput {
  getSource() {
    const variablePrecision = this.getVariablePrecisionString();
    return utils.linesToString([
      `uniform ${ variablePrecision } sampler2D ${this.id}`,
      `uniform ${ variablePrecision } ivec2 ${this.sizeId}`,
      `uniform ${ variablePrecision } ivec3 ${this.dimensionsId}`,
    ]);
  }
}

module.exports = {
  WebGL2KernelValueDynamicUnsignedInput
};
},{"../../../utils":114,"../../web-gl/kernel-value/dynamic-unsigned-input":55}],91:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueFloat } = require('../../web-gl/kernel-value/float');

class WebGL2KernelValueFloat extends WebGLKernelValueFloat {}

module.exports = {
  WebGL2KernelValueFloat
};
},{"../../../utils":114,"../../web-gl/kernel-value/float":56}],92:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelArray } = require('../../web-gl/kernel-value/array');

class WebGL2KernelValueHTMLImageArray extends WebGLKernelArray {
  constructor(value, settings) {
    super(value, settings);
    this.checkSize(value[0].width, value[0].height);
    this.dimensions = [value[0].width, value[0].height, value.length];
    this.textureSize = [value[0].width, value[0].height];
  }
  defineTexture() {
    const { context: gl } = this;
    gl.activeTexture(this.contextHandle);
    gl.bindTexture(gl.TEXTURE_2D_ARRAY, this.texture);
    gl.texParameteri(gl.TEXTURE_2D_ARRAY, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D_ARRAY, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
  }

  getStringValueHandler() {
    return `const uploadValue_${this.name} = ${this.varName};\n`;
  }
  getSource() {
    const variablePrecision = this.getVariablePrecisionString();
    return utils.linesToString([
      `uniform ${ variablePrecision } sampler2DArray ${this.id}`,
      `${ variablePrecision } ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,
      `${ variablePrecision } ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,
    ]);
  }

  updateValue(images) {
    const { context: gl } = this;
    gl.activeTexture(this.contextHandle);
    gl.bindTexture(gl.TEXTURE_2D_ARRAY, this.texture);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
    gl.texImage3D(
      gl.TEXTURE_2D_ARRAY,
      0,
      gl.RGBA,
      images[0].width,
      images[0].height,
      images.length,
      0,
      gl.RGBA,
      gl.UNSIGNED_BYTE,
      null
    );
    for (let i = 0; i < images.length; i++) {
      const xOffset = 0;
      const yOffset = 0;
      const imageDepth = 1;
      gl.texSubImage3D(
        gl.TEXTURE_2D_ARRAY,
        0,
        xOffset,
        yOffset,
        i,
        images[i].width,
        images[i].height,
        imageDepth,
        gl.RGBA,
        gl.UNSIGNED_BYTE,
        this.uploadValue = images[i]
      );
    }
    this.kernel.setUniform1i(this.id, this.index);
  }
}

module.exports = {
  WebGL2KernelValueHTMLImageArray
};
},{"../../../utils":114,"../../web-gl/kernel-value/array":40}],93:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueHTMLImage } = require('../../web-gl/kernel-value/html-image');

class WebGL2KernelValueHTMLImage extends WebGLKernelValueHTMLImage {
  getSource() {
    const variablePrecision = this.getVariablePrecisionString();
    return utils.linesToString([
      `uniform ${ variablePrecision } sampler2D ${this.id}`,
      `${ variablePrecision } ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,
      `${ variablePrecision } ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,
    ]);
  }
}

module.exports = {
  WebGL2KernelValueHTMLImage
};
},{"../../../utils":114,"../../web-gl/kernel-value/html-image":57}],94:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGL2KernelValueHTMLImage } = require('./html-image');

class WebGL2KernelValueHTMLVideo extends WebGL2KernelValueHTMLImage {}

module.exports = {
  WebGL2KernelValueHTMLVideo
};
},{"../../../utils":114,"./html-image":93}],95:[function(require,module,exports){
const { WebGLKernelValueInteger } = require('../../web-gl/kernel-value/integer');

class WebGL2KernelValueInteger extends WebGLKernelValueInteger {
  getSource(value) {
    const variablePrecision = this.getVariablePrecisionString();
    if (this.origin === 'constants') {
      return `const ${ variablePrecision } int ${this.id} = ${ parseInt(value) };\n`;
    }
    return `uniform ${ variablePrecision } int ${this.id};\n`;
  }

  updateValue(value) {
    if (this.origin === 'constants') return;
    this.kernel.setUniform1i(this.id, this.uploadValue = value);
  }
}

module.exports = {
  WebGL2KernelValueInteger
};
},{"../../web-gl/kernel-value/integer":60}],96:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueMemoryOptimizedNumberTexture } = require('../../web-gl/kernel-value/memory-optimized-number-texture');

class WebGL2KernelValueMemoryOptimizedNumberTexture extends WebGLKernelValueMemoryOptimizedNumberTexture {
  getSource() {
    const { id, sizeId, textureSize, dimensionsId, dimensions } = this;
    const variablePrecision = this.getVariablePrecisionString();
    return utils.linesToString([
      `uniform sampler2D ${id}`,
      `${ variablePrecision } ivec2 ${sizeId} = ivec2(${textureSize[0]}, ${textureSize[1]})`,
      `${ variablePrecision } ivec3 ${dimensionsId} = ivec3(${dimensions[0]}, ${dimensions[1]}, ${dimensions[2]})`,
    ]);
  }
}

module.exports = {
  WebGL2KernelValueMemoryOptimizedNumberTexture
};
},{"../../../utils":114,"../../web-gl/kernel-value/memory-optimized-number-texture":61}],97:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueNumberTexture } = require('../../web-gl/kernel-value/number-texture');

class WebGL2KernelValueNumberTexture extends WebGLKernelValueNumberTexture {
  getSource() {
    const { id, sizeId, textureSize, dimensionsId, dimensions } = this;
    const variablePrecision = this.getVariablePrecisionString();
    return utils.linesToString([
      `uniform ${ variablePrecision } sampler2D ${id}`,
      `${ variablePrecision } ivec2 ${sizeId} = ivec2(${textureSize[0]}, ${textureSize[1]})`,
      `${ variablePrecision } ivec3 ${dimensionsId} = ivec3(${dimensions[0]}, ${dimensions[1]}, ${dimensions[2]})`,
    ]);
  }
}

module.exports = {
  WebGL2KernelValueNumberTexture
};
},{"../../../utils":114,"../../web-gl/kernel-value/number-texture":62}],98:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueSingleArray } = require('../../web-gl/kernel-value/single-array');

class WebGL2KernelValueSingleArray extends WebGLKernelValueSingleArray {
  getSource() {
    const variablePrecision = this.getVariablePrecisionString();
    return utils.linesToString([
      `uniform ${ variablePrecision } sampler2D ${this.id}`,
      `${ variablePrecision } ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,
      `${ variablePrecision } ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,
    ]);
  }

  updateValue(value) {
    if (value.constructor !== this.initialValueConstructor) {
      this.onUpdateValueMismatch(value.constructor);
      return;
    }
    const { context: gl } = this;
    utils.flattenTo(value, this.uploadValue);
    gl.activeTexture(this.contextHandle);
    gl.bindTexture(gl.TEXTURE_2D, this.texture);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, this.textureSize[0], this.textureSize[1], 0, gl.RGBA, gl.FLOAT, this.uploadValue);
    this.kernel.setUniform1i(this.id, this.index);
  }
}

module.exports = {
  WebGL2KernelValueSingleArray
};
},{"../../../utils":114,"../../web-gl/kernel-value/single-array":63}],99:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueSingleArray1DI } = require('../../web-gl/kernel-value/single-array1d-i');

class WebGL2KernelValueSingleArray1DI extends WebGLKernelValueSingleArray1DI {
  updateValue(value) {
    if (value.constructor !== this.initialValueConstructor) {
      this.onUpdateValueMismatch(value.constructor);
      return;
    }
    const { context: gl } = this;
    utils.flattenTo(value, this.uploadValue);
    gl.activeTexture(this.contextHandle);
    gl.bindTexture(gl.TEXTURE_2D, this.texture);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, this.textureSize[0], this.textureSize[1], 0, gl.RGBA, gl.FLOAT, this.uploadValue);
    this.kernel.setUniform1i(this.id, this.index);
  }
}

module.exports = {
  WebGL2KernelValueSingleArray1DI
};
},{"../../../utils":114,"../../web-gl/kernel-value/single-array1d-i":64}],100:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueSingleArray2DI } = require('../../web-gl/kernel-value/single-array2d-i');

class WebGL2KernelValueSingleArray2DI extends WebGLKernelValueSingleArray2DI {
  updateValue(value) {
    if (value.constructor !== this.initialValueConstructor) {
      this.onUpdateValueMismatch(value.constructor);
      return;
    }
    const { context: gl } = this;
    utils.flattenTo(value, this.uploadValue);
    gl.activeTexture(this.contextHandle);
    gl.bindTexture(gl.TEXTURE_2D, this.texture);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, this.textureSize[0], this.textureSize[1], 0, gl.RGBA, gl.FLOAT, this.uploadValue);
    this.kernel.setUniform1i(this.id, this.index);
  }
}

module.exports = {
  WebGL2KernelValueSingleArray2DI
};
},{"../../../utils":114,"../../web-gl/kernel-value/single-array2d-i":65}],101:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueSingleArray3DI } = require('../../web-gl/kernel-value/single-array3d-i');

class WebGL2KernelValueSingleArray3DI extends WebGLKernelValueSingleArray3DI {
  updateValue(value) {
    if (value.constructor !== this.initialValueConstructor) {
      this.onUpdateValueMismatch(value.constructor);
      return;
    }
    const { context: gl } = this;
    utils.flattenTo(value, this.uploadValue);
    gl.activeTexture(this.contextHandle);
    gl.bindTexture(gl.TEXTURE_2D, this.texture);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, this.textureSize[0], this.textureSize[1], 0, gl.RGBA, gl.FLOAT, this.uploadValue);
    this.kernel.setUniform1i(this.id, this.index);
  }
}

module.exports = {
  WebGL2KernelValueSingleArray3DI
};
},{"../../../utils":114,"../../web-gl/kernel-value/single-array3d-i":66}],102:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueSingleInput } = require('../../web-gl/kernel-value/single-input');

class WebGL2KernelValueSingleInput extends WebGLKernelValueSingleInput {
  getSource() {
    const variablePrecision = this.getVariablePrecisionString();
    return utils.linesToString([
      `uniform ${ variablePrecision } sampler2D ${this.id}`,
      `${ variablePrecision } ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,
      `${ variablePrecision } ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,
    ]);
  }

  updateValue(input) {
    const { context: gl } = this;
    utils.flattenTo(input.value, this.uploadValue);
    gl.activeTexture(this.contextHandle);
    gl.bindTexture(gl.TEXTURE_2D, this.texture);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, this.textureSize[0], this.textureSize[1], 0, gl.RGBA, gl.FLOAT, this.uploadValue);
    this.kernel.setUniform1i(this.id, this.index);
  }
}

module.exports = {
  WebGL2KernelValueSingleInput
};
},{"../../../utils":114,"../../web-gl/kernel-value/single-input":67}],103:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueUnsignedArray } = require('../../web-gl/kernel-value/unsigned-array');

class WebGL2KernelValueUnsignedArray extends WebGLKernelValueUnsignedArray {
  getSource() {
    const variablePrecision = this.getVariablePrecisionString();
    return utils.linesToString([
      `uniform ${ variablePrecision } sampler2D ${this.id}`,
      `${ variablePrecision } ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,
      `${ variablePrecision } ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,
    ]);
  }
}

module.exports = {
  WebGL2KernelValueUnsignedArray
};
},{"../../../utils":114,"../../web-gl/kernel-value/unsigned-array":68}],104:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueUnsignedInput } = require('../../web-gl/kernel-value/unsigned-input');

class WebGL2KernelValueUnsignedInput extends WebGLKernelValueUnsignedInput {
  getSource() {
    const variablePrecision = this.getVariablePrecisionString();
    return utils.linesToString([
      `uniform ${ variablePrecision } sampler2D ${this.id}`,
      `${ variablePrecision } ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,
      `${ variablePrecision } ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,
    ]);
  }
}

module.exports = {
  WebGL2KernelValueUnsignedInput
};
},{"../../../utils":114,"../../web-gl/kernel-value/unsigned-input":69}],105:[function(require,module,exports){
const { WebGLKernel } = require('../web-gl/kernel');
const { WebGL2FunctionNode } = require('./function-node');
const { FunctionBuilder } = require('../function-builder');
const { utils } = require('../../utils');
const { fragmentShader } = require('./fragment-shader');
const { vertexShader } = require('./vertex-shader');
const { lookupKernelValueType } = require('./kernel-value-maps');

let isSupported = null;
let testCanvas = null;
let testContext = null;
let testExtensions = null;

let features = null;

class WebGL2Kernel extends WebGLKernel {
  static get isSupported() {
    if (isSupported !== null) {
      return isSupported;
    }
    this.setupFeatureChecks();
    isSupported = this.isContextMatch(testContext);
    return isSupported;
  }

  static setupFeatureChecks() {
    if (typeof document !== 'undefined') {
      testCanvas = document.createElement('canvas');
    } else if (typeof OffscreenCanvas !== 'undefined') {
      testCanvas = new OffscreenCanvas(0, 0);
    }
    if (!testCanvas) return;
    testContext = testCanvas.getContext('webgl2');
    if (!testContext || !testContext.getExtension) return;
    testExtensions = {
      EXT_color_buffer_float: testContext.getExtension('EXT_color_buffer_float'),
      OES_texture_float_linear: testContext.getExtension('OES_texture_float_linear'),
    };
    features = this.getFeatures();
  }

  static isContextMatch(context) {
    if (typeof WebGL2RenderingContext !== 'undefined') {
      return context instanceof WebGL2RenderingContext;
    }
    return false;
  }

  static getFeatures() {
    const gl = this.testContext;
    return Object.freeze({
      isFloatRead: this.getIsFloatRead(),
      isIntegerDivisionAccurate: this.getIsIntegerDivisionAccurate(),
      isSpeedTacticSupported: this.getIsSpeedTacticSupported(),
      kernelMap: true,
      isTextureFloat: true,
      isDrawBuffers: true,
      channelCount: this.getChannelCount(),
      maxTextureSize: this.getMaxTextureSize(),
      lowIntPrecision: gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.LOW_INT),
      lowFloatPrecision: gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.LOW_FLOAT),
      mediumIntPrecision: gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_INT),
      mediumFloatPrecision: gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT),
      highIntPrecision: gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_INT),
      highFloatPrecision: gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT),
    });
  }

  static getIsTextureFloat() {
    return true;
  }

  static getChannelCount() {
    return testContext.getParameter(testContext.MAX_DRAW_BUFFERS);
  }

  static getMaxTextureSize() {
    return testContext.getParameter(testContext.MAX_TEXTURE_SIZE);
  }

  static lookupKernelValueType(type, dynamic, precision, value) {
    return lookupKernelValueType(type, dynamic, precision, value);
  }

  static get testCanvas() {
    return testCanvas;
  }

  static get testContext() {
    return testContext;
  }

  static get features() {
    return features;
  }

  static get fragmentShader() {
    return fragmentShader;
  }
  static get vertexShader() {
    return vertexShader;
  }

  initContext() {
    const settings = {
      alpha: false,
      depth: false,
      antialias: false
    };
    return this.canvas.getContext('webgl2', settings);
  }

  initExtensions() {
    this.extensions = {
      EXT_color_buffer_float: this.context.getExtension('EXT_color_buffer_float'),
      OES_texture_float_linear: this.context.getExtension('OES_texture_float_linear'),
    };
  }

  validateSettings(args) {
    if (!this.validate) {
      this.texSize = utils.getKernelTextureSize({
        optimizeFloatMemory: this.optimizeFloatMemory,
        precision: this.precision,
      }, this.output);
      return;
    }

    const { features } = this.constructor;
    if (this.precision === 'single' && !features.isFloatRead) {
      throw new Error('Float texture outputs are not supported');
    } else if (!this.graphical && this.precision === null) {
      this.precision = features.isFloatRead ? 'single' : 'unsigned';
    }

    if (this.fixIntegerDivisionAccuracy === null) {
      this.fixIntegerDivisionAccuracy = !features.isIntegerDivisionAccurate;
    } else if (this.fixIntegerDivisionAccuracy && features.isIntegerDivisionAccurate) {
      this.fixIntegerDivisionAccuracy = false;
    }

    this.checkOutput();

    if (!this.output || this.output.length === 0) {
      if (args.length !== 1) {
        throw new Error('Auto output only supported for kernels with only one input');
      }

      const argType = utils.getVariableType(args[0], this.strictIntegers);
      switch (argType) {
        case 'Array':
          this.output = utils.getDimensions(argType);
          break;
        case 'NumberTexture':
        case 'MemoryOptimizedNumberTexture':
        case 'ArrayTexture(1)':
        case 'ArrayTexture(2)':
        case 'ArrayTexture(3)':
        case 'ArrayTexture(4)':
          this.output = args[0].output;
          break;
        default:
          throw new Error('Auto output not supported for input type: ' + argType);
      }
    }

    if (this.graphical) {
      if (this.output.length !== 2) {
        throw new Error('Output must have 2 dimensions on graphical mode');
      }

      if (this.precision === 'single') {
        console.warn('Cannot use graphical mode and single precision at the same time');
        this.precision = 'unsigned';
      }

      this.texSize = utils.clone(this.output);
      return;
    } else if (!this.graphical && this.precision === null && features.isTextureFloat) {
      this.precision = 'single';
    }

    this.texSize = utils.getKernelTextureSize({
      optimizeFloatMemory: this.optimizeFloatMemory,
      precision: this.precision,
    }, this.output);

    this.checkTextureSize();
  }

  translateSource() {
    const functionBuilder = FunctionBuilder.fromKernel(this, WebGL2FunctionNode, {
      fixIntegerDivisionAccuracy: this.fixIntegerDivisionAccuracy
    });
    this.translatedSource = functionBuilder.getPrototypeString('kernel');
    this.setupReturnTypes(functionBuilder);
  }

  drawBuffers() {
    this.context.drawBuffers(this.drawBuffersMap);
  }

  getTextureFormat() {
    const { context: gl } = this;
    switch (this.getInternalFormat()) {
      case gl.R32F:
        return gl.RED;
      case gl.RG32F:
        return gl.RG;
      case gl.RGBA32F:
        return gl.RGBA;
      case gl.RGBA:
        return gl.RGBA;
      default:
        throw new Error('Unknown internal format');
    }
  }
  getInternalFormat() {
    const { context: gl } = this;

    if (this.precision === 'single') {
      if (this.pipeline) {
        switch (this.returnType) {
          case 'Number':
          case 'Float':
          case 'Integer':
            if (this.optimizeFloatMemory) {
              return gl.RGBA32F;
            } else {
              return gl.R32F;
            }
            case 'Array(2)':
              return gl.RG32F;
            case 'Array(3)': 
            case 'Array(4)':
              return gl.RGBA32F;
            default:
              throw new Error('Unhandled return type');
        }
      }
      return gl.RGBA32F;
    }
    return gl.RGBA;
  }

  _setupOutputTexture() {
    const gl = this.context;
    if (this.texture) {
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.texture.texture, 0);
      return;
    }
    gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);
    const texture = gl.createTexture();
    const texSize = this.texSize;
    gl.activeTexture(gl.TEXTURE0 + this.constantTextureCount + this.argumentTextureCount);
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    const format = this.getInternalFormat();
    if (this.precision === 'single') {
      gl.texStorage2D(gl.TEXTURE_2D, 1, format, texSize[0], texSize[1]);
    } else {
      gl.texImage2D(gl.TEXTURE_2D, 0, format, texSize[0], texSize[1], 0, format, gl.UNSIGNED_BYTE, null);
    }
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
    this.texture = new this.TextureConstructor({
      texture,
      size: texSize,
      dimensions: this.threadDim,
      output: this.output,
      context: this.context,
      internalFormat: this.getInternalFormat(),
      textureFormat: this.getTextureFormat(),
      kernel: this,
    });
  }

  _setupSubOutputTextures() {
    const gl = this.context;
    if (this.mappedTextures) {
      for (let i = 0; i < this.subKernels.length; i++) {
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i + 1, gl.TEXTURE_2D, this.mappedTextures[i].texture, 0);
      }
      return;
    }
    const texSize = this.texSize;
    this.drawBuffersMap = [gl.COLOR_ATTACHMENT0];
    this.mappedTextures = [];
    for (let i = 0; i < this.subKernels.length; i++) {
      const texture = this.createTexture();
      this.drawBuffersMap.push(gl.COLOR_ATTACHMENT0 + i + 1);
      gl.activeTexture(gl.TEXTURE0 + this.constantTextureCount + this.argumentTextureCount + i);
      gl.bindTexture(gl.TEXTURE_2D, texture);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
      const format = this.getInternalFormat();
      if (this.precision === 'single') {
        gl.texStorage2D(gl.TEXTURE_2D, 1, format, texSize[0], texSize[1]);
      } else {
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, texSize[0], texSize[1], 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
      }
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i + 1, gl.TEXTURE_2D, texture, 0);

      this.mappedTextures.push(new this.TextureConstructor({
        texture,
        size: texSize,
        dimensions: this.threadDim,
        output: this.output,
        context: this.context,
        internalFormat: this.getInternalFormat(),
        textureFormat: this.getTextureFormat(),
        kernel: this,
      }));
    }
  }

  _getHeaderString() {
    return '';
  }

  _getTextureCoordinate() {
    const subKernels = this.subKernels;
    const variablePrecision = this.getVariablePrecisionString(this.texSize, this.tactic);
    if (subKernels === null || subKernels.length < 1) {
      return `in ${ variablePrecision } vec2 vTexCoord;\n`;
    } else {
      return `out ${ variablePrecision } vec2 vTexCoord;\n`;
    }
  }

  _getMainArgumentsString(args) {
    const result = [];
    const argumentNames = this.argumentNames;
    for (let i = 0; i < argumentNames.length; i++) {
      result.push(this.kernelArguments[i].getSource(args[i]));
    }
    return result.join('');
  }

  getKernelString() {
    const result = [this.getKernelResultDeclaration()];
    const subKernels = this.subKernels;
    if (subKernels !== null) {
      result.push(
        'layout(location = 0) out vec4 data0'
      );
      switch (this.returnType) {
        case 'Number':
        case 'Float':
        case 'Integer':
          for (let i = 0; i < subKernels.length; i++) {
            const subKernel = subKernels[i];
            result.push(
              subKernel.returnType === 'Integer' ?
              `int subKernelResult_${ subKernel.name } = 0` :
              `float subKernelResult_${ subKernel.name } = 0.0`,
              `layout(location = ${ i + 1 }) out vec4 data${ i + 1 }`
            );
          }
          break;
        case 'Array(2)':
          for (let i = 0; i < subKernels.length; i++) {
            result.push(
              `vec2 subKernelResult_${ subKernels[i].name }`,
              `layout(location = ${ i + 1 }) out vec4 data${ i + 1 }`
            );
          }
          break;
        case 'Array(3)':
          for (let i = 0; i < subKernels.length; i++) {
            result.push(
              `vec3 subKernelResult_${ subKernels[i].name }`,
              `layout(location = ${ i + 1 }) out vec4 data${ i + 1 }`
            );
          }
          break;
        case 'Array(4)':
          for (let i = 0; i < subKernels.length; i++) {
            result.push(
              `vec4 subKernelResult_${ subKernels[i].name }`,
              `layout(location = ${ i + 1 }) out vec4 data${ i + 1 }`
            );
          }
          break;
      }
    } else {
      result.push(
        'out vec4 data0'
      );
    }

    return utils.linesToString(result) + this.translatedSource;
  }

  getMainResultGraphical() {
    return utils.linesToString([
      '  threadId = indexTo3D(index, uOutputDim)',
      '  kernel()',
      '  data0 = actualColor',
    ]);
  }

  getMainResultPackedPixels() {
    switch (this.returnType) {
      case 'LiteralInteger':
      case 'Number':
      case 'Integer':
      case 'Float':
        return this.getMainResultKernelPackedPixels() +
          this.getMainResultSubKernelPackedPixels();
      default:
        throw new Error(`packed output only usable with Numbers, "${this.returnType}" specified`);
    }
  }

  getMainResultKernelPackedPixels() {
    return utils.linesToString([
      '  threadId = indexTo3D(index, uOutputDim)',
      '  kernel()',
      `  data0 = ${this.useLegacyEncoder ? 'legacyEncode32' : 'encode32'}(kernelResult)`
    ]);
  }

  getMainResultSubKernelPackedPixels() {
    const result = [];
    if (!this.subKernels) return '';
    for (let i = 0; i < this.subKernels.length; i++) {
      const subKernel = this.subKernels[i];
      if (subKernel.returnType === 'Integer') {
        result.push(
          `  data${i + 1} = ${this.useLegacyEncoder ? 'legacyEncode32' : 'encode32'}(float(subKernelResult_${this.subKernels[i].name}))`
        );
      } else {
        result.push(
          `  data${i + 1} = ${this.useLegacyEncoder ? 'legacyEncode32' : 'encode32'}(subKernelResult_${this.subKernels[i].name})`
        );
      }
    }
    return utils.linesToString(result);
  }

  getMainResultKernelMemoryOptimizedFloats(result, channel) {
    result.push(
      '  threadId = indexTo3D(index, uOutputDim)',
      '  kernel()',
      `  data0.${channel} = kernelResult`
    );
  }

  getMainResultSubKernelMemoryOptimizedFloats(result, channel) {
    if (!this.subKernels) return result;
    for (let i = 0; i < this.subKernels.length; i++) {
      const subKernel = this.subKernels[i];
      if (subKernel.returnType === 'Integer') {
        result.push(
          `  data${i + 1}.${channel} = float(subKernelResult_${subKernel.name})`
        );
      } else {
        result.push(
          `  data${i + 1}.${channel} = subKernelResult_${subKernel.name}`
        );
      }
    }
  }

  getMainResultKernelNumberTexture() {
    return [
      '  threadId = indexTo3D(index, uOutputDim)',
      '  kernel()',
      '  data0[0] = kernelResult',
    ];
  }

  getMainResultSubKernelNumberTexture() {
    const result = [];
    if (!this.subKernels) return result;
    for (let i = 0; i < this.subKernels.length; ++i) {
      const subKernel = this.subKernels[i];
      if (subKernel.returnType === 'Integer') {
        result.push(
          `  data${i + 1}[0] = float(subKernelResult_${subKernel.name})`
        );
      } else {
        result.push(
          `  data${i + 1}[0] = subKernelResult_${subKernel.name}`
        );
      }
    }
    return result;
  }

  getMainResultKernelArray2Texture() {
    return [
      '  threadId = indexTo3D(index, uOutputDim)',
      '  kernel()',
      '  data0[0] = kernelResult[0]',
      '  data0[1] = kernelResult[1]',
    ];
  }

  getMainResultSubKernelArray2Texture() {
    const result = [];
    if (!this.subKernels) return result;
    for (let i = 0; i < this.subKernels.length; ++i) {
      const subKernel = this.subKernels[i];
      result.push(
        `  data${i + 1}[0] = subKernelResult_${subKernel.name}[0]`,
        `  data${i + 1}[1] = subKernelResult_${subKernel.name}[1]`
      );
    }
    return result;
  }

  getMainResultKernelArray3Texture() {
    return [
      '  threadId = indexTo3D(index, uOutputDim)',
      '  kernel()',
      '  data0[0] = kernelResult[0]',
      '  data0[1] = kernelResult[1]',
      '  data0[2] = kernelResult[2]',
    ];
  }

  getMainResultSubKernelArray3Texture() {
    const result = [];
    if (!this.subKernels) return result;
    for (let i = 0; i < this.subKernels.length; ++i) {
      const subKernel = this.subKernels[i];
      result.push(
        `  data${i + 1}[0] = subKernelResult_${subKernel.name}[0]`,
        `  data${i + 1}[1] = subKernelResult_${subKernel.name}[1]`,
        `  data${i + 1}[2] = subKernelResult_${subKernel.name}[2]`
      );
    }
    return result;
  }

  getMainResultKernelArray4Texture() {
    return [
      '  threadId = indexTo3D(index, uOutputDim)',
      '  kernel()',
      '  data0 = kernelResult',
    ];
  }

  getMainResultSubKernelArray4Texture() {
    const result = [];
    if (!this.subKernels) return result;
    for (let i = 0; i < this.subKernels.length; ++i) {
      result.push(
        `  data${i + 1} = subKernelResult_${this.subKernels[i].name}`
      );
    }
    return result;
  }

  destroyExtensions() {
    this.extensions.EXT_color_buffer_float = null;
    this.extensions.OES_texture_float_linear = null;
  }

  toJSON() {
    const json = super.toJSON();
    json.functionNodes = FunctionBuilder.fromKernel(this, WebGL2FunctionNode).toJSON();
    json.settings.threadDim = this.threadDim;
    return json;
  }
}

module.exports = {
  WebGL2Kernel
};
},{"../../utils":114,"../function-builder":9,"../web-gl/kernel":70,"./fragment-shader":72,"./function-node":73,"./kernel-value-maps":74,"./vertex-shader":106}],106:[function(require,module,exports){
const vertexShader = `#version 300 es
__FLOAT_TACTIC_DECLARATION__;
__INT_TACTIC_DECLARATION__;
__SAMPLER_2D_TACTIC_DECLARATION__;

in vec2 aPos;
in vec2 aTexCoord;

out vec2 vTexCoord;
uniform vec2 ratio;

void main(void) {
  gl_Position = vec4((aPos + vec2(1)) * ratio + vec2(-1), 0, 1);
  vTexCoord = aTexCoord;
}`;

module.exports = {
  vertexShader
};
},{}],107:[function(require,module,exports){
const lib = require('./index');
const GPU = lib.GPU;
for (const p in lib) {
  if (!lib.hasOwnProperty(p)) continue;
  if (p === 'GPU') continue; 
  GPU[p] = lib[p];
}

if (typeof window !== 'undefined') {
  bindTo(window);
}
if (typeof self !== 'undefined') {
  bindTo(self);
}

function bindTo(target) {
  if (target.GPU) return;
  Object.defineProperty(target, 'GPU', {
    get() {
      return GPU;
    }
  });
}

module.exports = lib;
},{"./index":109}],108:[function(require,module,exports){
const { gpuMock } = require('gpu-mock.js');
const { utils } = require('./utils');
const { Kernel } = require('./backend/kernel');
const { CPUKernel } = require('./backend/cpu/kernel');
const { HeadlessGLKernel } = require('./backend/headless-gl/kernel');
const { WebGL2Kernel } = require('./backend/web-gl2/kernel');
const { WebGLKernel } = require('./backend/web-gl/kernel');
const { kernelRunShortcut } = require('./kernel-run-shortcut');


const kernelOrder = [HeadlessGLKernel, WebGL2Kernel, WebGLKernel];

const kernelTypes = ['gpu', 'cpu'];

const internalKernels = {
  'headlessgl': HeadlessGLKernel,
  'webgl2': WebGL2Kernel,
  'webgl': WebGLKernel,
};

let validate = true;

class GPU {
  static disableValidation() {
    validate = false;
  }

  static enableValidation() {
    validate = true;
  }

  static get isGPUSupported() {
    return kernelOrder.some(Kernel => Kernel.isSupported);
  }

  static get isKernelMapSupported() {
    return kernelOrder.some(Kernel => Kernel.isSupported && Kernel.features.kernelMap);
  }

  static get isOffscreenCanvasSupported() {
    return (typeof Worker !== 'undefined' && typeof OffscreenCanvas !== 'undefined') || typeof importScripts !== 'undefined';
  }

  static get isWebGLSupported() {
    return WebGLKernel.isSupported;
  }

  static get isWebGL2Supported() {
    return WebGL2Kernel.isSupported;
  }

  static get isHeadlessGLSupported() {
    return HeadlessGLKernel.isSupported;
  }

  static get isCanvasSupported() {
    return typeof HTMLCanvasElement !== 'undefined';
  }

  static get isGPUHTMLImageArraySupported() {
    return WebGL2Kernel.isSupported;
  }

  static get isSinglePrecisionSupported() {
    return kernelOrder.some(Kernel => Kernel.isSupported && Kernel.features.isFloatRead && Kernel.features.isTextureFloat);
  }

  constructor(settings) {
    settings = settings || {};
    this.canvas = settings.canvas || null;
    this.context = settings.context || null;
    this.mode = settings.mode;
    this.Kernel = null;
    this.kernels = [];
    this.functions = [];
    this.nativeFunctions = [];
    this.injectedNative = null;
    if (this.mode === 'dev') return;
    this.chooseKernel();
    if (settings.functions) {
      for (let i = 0; i < settings.functions.length; i++) {
        this.addFunction(settings.functions[i]);
      }
    }

    if (settings.nativeFunctions) {
      for (const p in settings.nativeFunctions) {
        if (!settings.nativeFunctions.hasOwnProperty(p)) continue;
        const s = settings.nativeFunctions[p];
        const { name, source } = s;
        this.addNativeFunction(name, source, s);
      }
    }
  }

  chooseKernel() {
    if (this.Kernel) return;

    let Kernel = null;

    if (this.context) {
      for (let i = 0; i < kernelOrder.length; i++) {
        const ExternalKernel = kernelOrder[i];
        if (ExternalKernel.isContextMatch(this.context)) {
          if (!ExternalKernel.isSupported) {
            throw new Error(`Kernel type ${ExternalKernel.name} not supported`);
          }
          Kernel = ExternalKernel;
          break;
        }
      }
      if (Kernel === null) {
        throw new Error('unknown Context');
      }
    } else if (this.mode) {
      if (this.mode in internalKernels) {
        if (!validate || internalKernels[this.mode].isSupported) {
          Kernel = internalKernels[this.mode];
        }
      } else if (this.mode === 'gpu') {
        for (let i = 0; i < kernelOrder.length; i++) {
          if (kernelOrder[i].isSupported) {
            Kernel = kernelOrder[i];
            break;
          }
        }
      } else if (this.mode === 'cpu') {
        Kernel = CPUKernel;
      }
      if (!Kernel) {
        throw new Error(`A requested mode of "${this.mode}" and is not supported`);
      }
    } else {
      for (let i = 0; i < kernelOrder.length; i++) {
        if (kernelOrder[i].isSupported) {
          Kernel = kernelOrder[i];
          break;
        }
      }
      if (!Kernel) {
        Kernel = CPUKernel;
      }
    }

    if (!this.mode) {
      this.mode = Kernel.mode;
    }
    this.Kernel = Kernel;
  }

  createKernel(source, settings) {
    if (typeof source === 'undefined') {
      throw new Error('Missing source parameter');
    }
    if (typeof source !== 'object' && !utils.isFunction(source) && typeof source !== 'string') {
      throw new Error('source parameter not a function');
    }

    const kernels = this.kernels;
    if (this.mode === 'dev') {
      const devKernel = gpuMock(source, upgradeDeprecatedCreateKernelSettings(settings));
      kernels.push(devKernel);
      return devKernel;
    }

    source = typeof source === 'function' ? source.toString() : source;
    const switchableKernels = {};
    const settingsCopy = upgradeDeprecatedCreateKernelSettings(settings) || {};
    if (settings && typeof settings.argumentTypes === 'object') {
      settingsCopy.argumentTypes = Object.keys(settings.argumentTypes).map(argumentName => settings.argumentTypes[argumentName]);
    }

    function onRequestFallback(args) {
      console.warn('Falling back to CPU');
      const fallbackKernel = new CPUKernel(source, {
        argumentTypes: kernelRun.argumentTypes,
        constantTypes: kernelRun.constantTypes,
        graphical: kernelRun.graphical,
        loopMaxIterations: kernelRun.loopMaxIterations,
        constants: kernelRun.constants,
        dynamicOutput: kernelRun.dynamicOutput,
        dynamicArgument: kernelRun.dynamicArguments,
        output: kernelRun.output,
        precision: kernelRun.precision,
        pipeline: kernelRun.pipeline,
        immutable: kernelRun.immutable,
        optimizeFloatMemory: kernelRun.optimizeFloatMemory,
        fixIntegerDivisionAccuracy: kernelRun.fixIntegerDivisionAccuracy,
        functions: kernelRun.functions,
        nativeFunctions: kernelRun.nativeFunctions,
        injectedNative: kernelRun.injectedNative,
        subKernels: kernelRun.subKernels,
        strictIntegers: kernelRun.strictIntegers,
        debug: kernelRun.debug,
      });
      fallbackKernel.build.apply(fallbackKernel, args);
      const result = fallbackKernel.run.apply(fallbackKernel, args);
      kernelRun.replaceKernel(fallbackKernel);
      return result;
    }

    function onRequestSwitchKernel(reasons, args, _kernel) {
      if (_kernel.debug) {
        console.warn('Switching kernels');
      }
      let newOutput = null;
      if (_kernel.signature && !switchableKernels[_kernel.signature]) {
        switchableKernels[_kernel.signature] = _kernel;
      }
      if (_kernel.dynamicOutput) {
        for (let i = reasons.length - 1; i >= 0; i--) {
          const reason = reasons[i];
          if (reason.type === 'outputPrecisionMismatch') {
            newOutput = reason.needed;
          }
        }
      }

      const Constructor = _kernel.constructor;
      const argumentTypes = Constructor.getArgumentTypes(_kernel, args);
      const signature = Constructor.getSignature(_kernel, argumentTypes);
      const existingKernel = switchableKernels[signature];
      if (existingKernel) {
        existingKernel.onActivate(_kernel);
        return existingKernel;
      }

      const newKernel = switchableKernels[signature] = new Constructor(source, {
        argumentTypes,
        constantTypes: _kernel.constantTypes,
        graphical: _kernel.graphical,
        loopMaxIterations: _kernel.loopMaxIterations,
        constants: _kernel.constants,
        dynamicOutput: _kernel.dynamicOutput,
        dynamicArgument: _kernel.dynamicArguments,
        context: _kernel.context,
        canvas: _kernel.canvas,
        output: newOutput || _kernel.output,
        precision: _kernel.precision,
        pipeline: _kernel.pipeline,
        immutable: _kernel.immutable,
        optimizeFloatMemory: _kernel.optimizeFloatMemory,
        fixIntegerDivisionAccuracy: _kernel.fixIntegerDivisionAccuracy,
        functions: _kernel.functions,
        nativeFunctions: _kernel.nativeFunctions,
        injectedNative: _kernel.injectedNative,
        subKernels: _kernel.subKernels,
        strictIntegers: _kernel.strictIntegers,
        debug: _kernel.debug,
        gpu: _kernel.gpu,
        validate,
        returnType: _kernel.returnType,
        tactic: _kernel.tactic,
        onRequestFallback,
        onRequestSwitchKernel,
        texture: _kernel.texture,
        mappedTextures: _kernel.mappedTextures,
        drawBuffersMap: _kernel.drawBuffersMap,
      });
      newKernel.build.apply(newKernel, args);
      kernelRun.replaceKernel(newKernel);
      kernels.push(newKernel);
      return newKernel;
    }
    const mergedSettings = Object.assign({
      context: this.context,
      canvas: this.canvas,
      functions: this.functions,
      nativeFunctions: this.nativeFunctions,
      injectedNative: this.injectedNative,
      gpu: this,
      validate,
      onRequestFallback,
      onRequestSwitchKernel
    }, settingsCopy);

    const kernel = new this.Kernel(source, mergedSettings);
    const kernelRun = kernelRunShortcut(kernel);

    if (!this.canvas) {
      this.canvas = kernel.canvas;
    }

    if (!this.context) {
      this.context = kernel.context;
    }

    kernels.push(kernel);

    return kernelRun;
  }

  createKernelMap() {
    let fn;
    let settings;
    const argument2Type = typeof arguments[arguments.length - 2];
    if (argument2Type === 'function' || argument2Type === 'string') {
      fn = arguments[arguments.length - 2];
      settings = arguments[arguments.length - 1];
    } else {
      fn = arguments[arguments.length - 1];
    }

    if (this.mode !== 'dev') {
      if (!this.Kernel.isSupported || !this.Kernel.features.kernelMap) {
        if (this.mode && kernelTypes.indexOf(this.mode) < 0) {
          throw new Error(`kernelMap not supported on ${this.Kernel.name}`);
        }
      }
    }

    const settingsCopy = upgradeDeprecatedCreateKernelSettings(settings);
    if (settings && typeof settings.argumentTypes === 'object') {
      settingsCopy.argumentTypes = Object.keys(settings.argumentTypes).map(argumentName => settings.argumentTypes[argumentName]);
    }

    if (Array.isArray(arguments[0])) {
      settingsCopy.subKernels = [];
      const functions = arguments[0];
      for (let i = 0; i < functions.length; i++) {
        const source = functions[i].toString();
        const name = utils.getFunctionNameFromString(source);
        settingsCopy.subKernels.push({
          name,
          source,
          property: i,
        });
      }
    } else {
      settingsCopy.subKernels = [];
      const functions = arguments[0];
      for (let p in functions) {
        if (!functions.hasOwnProperty(p)) continue;
        const source = functions[p].toString();
        const name = utils.getFunctionNameFromString(source);
        settingsCopy.subKernels.push({
          name: name || p,
          source,
          property: p,
        });
      }
    }
    return this.createKernel(fn, settingsCopy);
  }

  combineKernels() {
    const firstKernel = arguments[0];
    const combinedKernel = arguments[arguments.length - 1];
    if (firstKernel.kernel.constructor.mode === 'cpu') return combinedKernel;
    const canvas = arguments[0].canvas;
    const context = arguments[0].context;
    const max = arguments.length - 1;
    for (let i = 0; i < max; i++) {
      arguments[i]
        .setCanvas(canvas)
        .setContext(context)
        .setPipeline(true);
    }

    return function() {
      const texture = combinedKernel.apply(this, arguments);
      if (texture.toArray) {
        return texture.toArray();
      }
      return texture;
    };
  }

  setFunctions(functions) {
    this.functions = functions;
    return this;
  }

  setNativeFunctions(nativeFunctions) {
    this.nativeFunctions = nativeFunctions;
    return this;
  }

  addFunction(source, settings) {
    this.functions.push({ source, settings });
    return this;
  }

  addNativeFunction(name, source, settings) {
    if (this.kernels.length > 0) {
      throw new Error('Cannot call "addNativeFunction" after "createKernels" has been called.');
    }
    this.nativeFunctions.push(Object.assign({ name, source }, settings));
    return this;
  }

  injectNative(source) {
    this.injectedNative = source;
    return this;
  }

  destroy() {
    return new Promise((resolve, reject) => {
      if (!this.kernels) {
        resolve();
      }
      setTimeout(() => {
        try {
          for (let i = 0; i < this.kernels.length; i++) {
            this.kernels[i].destroy(true); 
          }
          let firstKernel = this.kernels[0];
          if (firstKernel) {
            if (firstKernel.kernel) {
              firstKernel = firstKernel.kernel;
            }
            if (firstKernel.constructor.destroyContext) {
              firstKernel.constructor.destroyContext(this.context);
            }
          }
        } catch (e) {
          reject(e);
        }
        resolve();
      }, 0);
    });
  }
}


function upgradeDeprecatedCreateKernelSettings(settings) {
  if (!settings) {
    return {};
  }
  const upgradedSettings = Object.assign({}, settings);

  if (settings.hasOwnProperty('floatOutput')) {
    utils.warnDeprecated('setting', 'floatOutput', 'precision');
    upgradedSettings.precision = settings.floatOutput ? 'single' : 'unsigned';
  }
  if (settings.hasOwnProperty('outputToTexture')) {
    utils.warnDeprecated('setting', 'outputToTexture', 'pipeline');
    upgradedSettings.pipeline = Boolean(settings.outputToTexture);
  }
  if (settings.hasOwnProperty('outputImmutable')) {
    utils.warnDeprecated('setting', 'outputImmutable', 'immutable');
    upgradedSettings.immutable = Boolean(settings.outputImmutable);
  }
  if (settings.hasOwnProperty('floatTextures')) {
    utils.warnDeprecated('setting', 'floatTextures', 'optimizeFloatMemory');
    upgradedSettings.optimizeFloatMemory = Boolean(settings.floatTextures);
  }
  return upgradedSettings;
}

module.exports = {
  GPU,
  kernelOrder,
  kernelTypes
};
},{"./backend/cpu/kernel":8,"./backend/headless-gl/kernel":34,"./backend/kernel":36,"./backend/web-gl/kernel":70,"./backend/web-gl2/kernel":105,"./kernel-run-shortcut":111,"./utils":114,"gpu-mock.js":4}],109:[function(require,module,exports){
const { GPU } = require('./gpu');
const { alias } = require('./alias');
const { utils } = require('./utils');
const { Input, input } = require('./input');
const { Texture } = require('./texture');
const { FunctionBuilder } = require('./backend/function-builder');
const { FunctionNode } = require('./backend/function-node');
const { CPUFunctionNode } = require('./backend/cpu/function-node');
const { CPUKernel } = require('./backend/cpu/kernel');

const { HeadlessGLKernel } = require('./backend/headless-gl/kernel');

const { WebGLFunctionNode } = require('./backend/web-gl/function-node');
const { WebGLKernel } = require('./backend/web-gl/kernel');
const { kernelValueMaps: webGLKernelValueMaps } = require('./backend/web-gl/kernel-value-maps');

const { WebGL2FunctionNode } = require('./backend/web-gl2/function-node');
const { WebGL2Kernel } = require('./backend/web-gl2/kernel');
const { kernelValueMaps: webGL2KernelValueMaps } = require('./backend/web-gl2/kernel-value-maps');

const { GLKernel } = require('./backend/gl/kernel');

const { Kernel } = require('./backend/kernel');

const { FunctionTracer } = require('./backend/function-tracer');

const mathRandom = require('./plugins/math-random-uniformly-distributed');

module.exports = {
  alias,
  CPUFunctionNode,
  CPUKernel,
  GPU,
  FunctionBuilder,
  FunctionNode,
  HeadlessGLKernel,
  Input,
  input,
  Texture,
  utils,

  WebGL2FunctionNode,
  WebGL2Kernel,
  webGL2KernelValueMaps,

  WebGLFunctionNode,
  WebGLKernel,
  webGLKernelValueMaps,

  GLKernel,
  Kernel,
  FunctionTracer,

  plugins: {
    mathRandom
  }
};
},{"./alias":5,"./backend/cpu/function-node":6,"./backend/cpu/kernel":8,"./backend/function-builder":9,"./backend/function-node":10,"./backend/function-tracer":11,"./backend/gl/kernel":13,"./backend/headless-gl/kernel":34,"./backend/kernel":36,"./backend/web-gl/function-node":38,"./backend/web-gl/kernel":70,"./backend/web-gl/kernel-value-maps":39,"./backend/web-gl2/function-node":73,"./backend/web-gl2/kernel":105,"./backend/web-gl2/kernel-value-maps":74,"./gpu":108,"./input":110,"./plugins/math-random-uniformly-distributed":112,"./texture":113,"./utils":114}],110:[function(require,module,exports){
class Input {
  constructor(value, size) {
    this.value = value;
    if (Array.isArray(size)) {
      this.size = size;
    } else {
      this.size = new Int32Array(3);
      if (size.z) {
        this.size = new Int32Array([size.x, size.y, size.z]);
      } else if (size.y) {
        this.size = new Int32Array([size.x, size.y]);
      } else {
        this.size = new Int32Array([size.x]);
      }
    }

    const [w, h, d] = this.size;
    if (d) {
      if (this.value.length !== (w * h * d)) {
        throw new Error(`Input size ${this.value.length} does not match ${w} * ${h} * ${d} = ${(h * w * d)}`);
      }
    } else if (h) {
      if (this.value.length !== (w * h)) {
        throw new Error(`Input size ${this.value.length} does not match ${w} * ${h} = ${(h * w)}`);
      }
    } else {
      if (this.value.length !== w) {
        throw new Error(`Input size ${this.value.length} does not match ${w}`);
      }
    }

  }

  toArray() {
    const { utils } = require('./utils');
    const [w, h, d] = this.size;
    if (d) {
      return utils.erectMemoryOptimized3DFloat(this.value.subarray ? this.value : new Float32Array(this.value), w, h, d);
    } else if (h) {
      return utils.erectMemoryOptimized2DFloat(this.value.subarray ? this.value : new Float32Array(this.value), w, h);
    } else {
      return this.value;
    }
  }
}

function input(value, size) {
  return new Input(value, size);
}

module.exports = {
  Input,
  input
};
},{"./utils":114}],111:[function(require,module,exports){
const { utils } = require('./utils');

function kernelRunShortcut(kernel) {
  let run = function() {
    kernel.build.apply(kernel, arguments);
    run = function() {
      let result = kernel.run.apply(kernel, arguments);
      if (kernel.switchingKernels) {
        const reasons = kernel.resetSwitchingKernels();
        const newKernel = kernel.onRequestSwitchKernel(reasons, arguments, kernel);
        shortcut.kernel = kernel = newKernel;
        result = newKernel.run.apply(newKernel, arguments);
      }
      if (kernel.renderKernels) {
        return kernel.renderKernels();
      } else if (kernel.renderOutput) {
        return kernel.renderOutput();
      } else {
        return result;
      }
    };
    return run.apply(kernel, arguments);
  };
  const shortcut = function() {
    return run.apply(kernel, arguments);
  };
  shortcut.exec = function() {
    return new Promise((accept, reject) => {
      try {
        accept(run.apply(this, arguments));
      } catch (e) {
        reject(e);
      }
    });
  };
  shortcut.replaceKernel = function(replacementKernel) {
    kernel = replacementKernel;
    bindKernelToShortcut(kernel, shortcut);
  };

  bindKernelToShortcut(kernel, shortcut);
  return shortcut;
}

function bindKernelToShortcut(kernel, shortcut) {
  if (shortcut.kernel) {
    shortcut.kernel = kernel;
    return;
  }
  const properties = utils.allPropertiesOf(kernel);
  for (let i = 0; i < properties.length; i++) {
    const property = properties[i];
    if (property[0] === '_' && property[1] === '_') continue;
    if (typeof kernel[property] === 'function') {
      if (property.substring(0, 3) === 'add' || property.substring(0, 3) === 'set') {
        shortcut[property] = function() {
          shortcut.kernel[property].apply(shortcut.kernel, arguments);
          return shortcut;
        };
      } else {
        shortcut[property] = function() {
          return shortcut.kernel[property].apply(shortcut.kernel, arguments);
        };
      }
    } else {
      shortcut.__defineGetter__(property, () => shortcut.kernel[property]);
      shortcut.__defineSetter__(property, (value) => {
        shortcut.kernel[property] = value;
      });
    }
  }
  shortcut.kernel = kernel;
}
module.exports = {
  kernelRunShortcut
};
},{"./utils":114}],112:[function(require,module,exports){
const source = `// https://www.shadertoy.com/view/4t2SDh
//note: uniformly distributed, normalized rand, [0,1]
highp float randomSeedShift = 1.0;
highp float slide = 1.0;
uniform highp float randomSeed1;
uniform highp float randomSeed2;

highp float nrand(highp vec2 n) {
  highp float result = fract(sin(dot((n.xy + 1.0) * vec2(randomSeed1 * slide, randomSeed2 * randomSeedShift), vec2(12.9898, 78.233))) * 43758.5453);
  randomSeedShift = result;
  if (randomSeedShift > 0.5) {
    slide += 0.00009; 
  } else {
    slide += 0.0009;
  }
  return result;
}`;

const name = 'math-random-uniformly-distributed';

const functionMatch = `Math.random()`;

const functionReplace = `nrand(vTexCoord)`;

const functionReturnType = 'Number';
const onBeforeRun = (kernel) => {
  kernel.setUniform1f('randomSeed1', Math.random());
  kernel.setUniform1f('randomSeed2', Math.random());
};

const plugin = {
  name,
  onBeforeRun,
  functionMatch,
  functionReplace,
  functionReturnType,
  source
};

module.exports = plugin;
},{}],113:[function(require,module,exports){
class Texture {
  constructor(settings) {
    const {
      texture,
      size,
      dimensions,
      output,
      context,
      type = 'NumberTexture',
      kernel,
      internalFormat,
      textureFormat
    } = settings;
    if (!output) throw new Error('settings property "output" required.');
    if (!context) throw new Error('settings property "context" required.');
    if (!texture) throw new Error('settings property "texture" required.');
    if (!kernel) throw new Error('settings property "kernel" required.');
    this.texture = texture;
    if (texture._refs) {
      texture._refs++;
    } else {
      texture._refs = 1;
    }
    this.size = size;
    this.dimensions = dimensions;
    this.output = output;
    this.context = context;
    this.kernel = kernel;
    this.type = type;
    this._deleted = false;
    this.internalFormat = internalFormat;
    this.textureFormat = textureFormat;
  }

  toArray() {
    throw new Error(`Not implemented on ${this.constructor.name}`);
  }

  clone() {
    throw new Error(`Not implemented on ${this.constructor.name}`);
  }

  delete() {
    throw new Error(`Not implemented on ${this.constructor.name}`);
  }

  clear() {
    throw new Error(`Not implemented on ${this.constructor.name}`);
  }
}

module.exports = {
  Texture
};
},{}],114:[function(require,module,exports){
const acorn = require('acorn');
const { Input } = require('./input');
const { Texture } = require('./texture');

const FUNCTION_NAME = /function ([^(]*)/;
const STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg;
const ARGUMENT_NAMES = /([^\s,]+)/g;

const utils = {
  systemEndianness() {
    return _systemEndianness;
  },
  getSystemEndianness() {
    const b = new ArrayBuffer(4);
    const a = new Uint32Array(b);
    const c = new Uint8Array(b);
    a[0] = 0xdeadbeef;
    if (c[0] === 0xef) return 'LE';
    if (c[0] === 0xde) return 'BE';
    throw new Error('unknown endianness');
  },

  isFunction(funcObj) {
    return typeof(funcObj) === 'function';
  },

  isFunctionString(fn) {
    if (typeof fn === 'string') {
      return (fn
        .slice(0, 'function'.length)
        .toLowerCase() === 'function');
    }
    return false;
  },

  getFunctionNameFromString(funcStr) {
    const result = FUNCTION_NAME.exec(funcStr);
    if (!result || result.length === 0) return null;
    return result[1].trim();
  },

  getFunctionBodyFromString(funcStr) {
    return funcStr.substring(funcStr.indexOf('{') + 1, funcStr.lastIndexOf('}'));
  },

  getArgumentNamesFromString(fn) {
    const fnStr = fn.replace(STRIP_COMMENTS, '');
    let result = fnStr.slice(fnStr.indexOf('(') + 1, fnStr.indexOf(')')).match(ARGUMENT_NAMES);
    if (result === null) {
      result = [];
    }
    return result;
  },

  clone(obj) {
    if (obj === null || typeof obj !== 'object' || obj.hasOwnProperty('isActiveClone')) return obj;

    const temp = obj.constructor(); 

    for (let key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        obj.isActiveClone = null;
        temp[key] = utils.clone(obj[key]);
        delete obj.isActiveClone;
      }
    }

    return temp;
  },

  isArray(array) {
    return !isNaN(array.length);
  },

  getVariableType(value, strictIntegers) {
    if (utils.isArray(value)) {
      if (value.length > 0 && value[0].nodeName === 'IMG') {
        return 'HTMLImageArray';
      }
      return 'Array';
    }

    switch (value.constructor) {
      case Boolean:
        return 'Boolean';
      case Number:
        if (strictIntegers && Number.isInteger(value)) {
          return 'Integer';
        }
        return 'Float';
      case Texture:
        return value.type;
      case Input:
        return 'Input';
    }
    if ('nodeName'  in value) {
      switch (value.nodeName) {
        case 'IMG':
          return 'HTMLImage';
        case 'CANVAS':
          return 'HTMLImage';
        case 'VIDEO':
          return 'HTMLVideo';
      }
    } else if (value.hasOwnProperty('type')) {
      return value.type;
    } else if (typeof OffscreenCanvas !== 'undefined' && value instanceof OffscreenCanvas) {
      return 'OffscreenCanvas';
    } else if (typeof ImageBitmap !== 'undefined' && value instanceof ImageBitmap) {
      return 'ImageBitmap';
    } else if (typeof ImageData !== 'undefined' && value instanceof ImageData) {
      return 'ImageData';
    }
    return 'Unknown';
  },

  getKernelTextureSize(settings, dimensions) {
    let [w, h, d] = dimensions;
    let texelCount = (w || 1) * (h || 1) * (d || 1);

    if (settings.optimizeFloatMemory && settings.precision === 'single') {
      w = texelCount = Math.ceil(texelCount / 4);
    }
    if (h > 1 && w * h === texelCount) {
      return new Int32Array([w, h]);
    }
    return utils.closestSquareDimensions(texelCount);
  },

  closestSquareDimensions(length) {
    const sqrt = Math.sqrt(length);
    let high = Math.ceil(sqrt);
    let low = Math.floor(sqrt);
    while (high * low < length) {
      high--;
      low = Math.ceil(length / high);
    }
    return new Int32Array([low, Math.ceil(length / low)]);
  },

  getMemoryOptimizedFloatTextureSize(dimensions, bitRatio) {
    const totalArea = utils.roundTo((dimensions[0] || 1) * (dimensions[1] || 1) * (dimensions[2] || 1) * (dimensions[3] || 1), 4);
    const texelCount = totalArea / bitRatio;
    return utils.closestSquareDimensions(texelCount);
  },

  getMemoryOptimizedPackedTextureSize(dimensions, bitRatio) {
    const [w, h, d] = dimensions;
    const totalArea = utils.roundTo((w || 1) * (h || 1) * (d || 1), 4);
    const texelCount = totalArea / (4 / bitRatio);
    return utils.closestSquareDimensions(texelCount);
  },

  roundTo(n, d) {
    return Math.floor((n + d - 1) / d) * d;
  },
  getDimensions(x, pad) {
    let ret;
    if (utils.isArray(x)) {
      const dim = [];
      let temp = x;
      while (utils.isArray(temp)) {
        dim.push(temp.length);
        temp = temp[0];
      }
      ret = dim.reverse();
    } else if (x instanceof Texture) {
      ret = x.output;
    } else if (x instanceof Input) {
      ret = x.size;
    } else {
      throw new Error(`Unknown dimensions of ${x}`);
    }

    if (pad) {
      ret = Array.from(ret);
      while (ret.length < 3) {
        ret.push(1);
      }
    }

    return new Int32Array(ret);
  },

  flatten2dArrayTo(array, target) {
    let offset = 0;
    for (let y = 0; y < array.length; y++) {
      target.set(array[y], offset);
      offset += array[y].length;
    }
  },

  flatten3dArrayTo(array, target) {
    let offset = 0;
    for (let z = 0; z < array.length; z++) {
      for (let y = 0; y < array[z].length; y++) {
        target.set(array[z][y], offset);
        offset += array[z][y].length;
      }
    }
  },

  flatten4dArrayTo(array, target) {
    let offset = 0;
    for (let l = 0; l < array.length; l++) {
      for (let z = 0; z < array[l].length; z++) {
        for (let y = 0; y < array[l][z].length; y++) {
          target.set(array[l][z][y], offset);
          offset += array[l][z][y].length;
        }
      }
    }
  },

  flattenTo(array, target) {
    if (utils.isArray(array[0])) {
      if (utils.isArray(array[0][0])) {
        if (utils.isArray(array[0][0][0])) {
          utils.flatten4dArrayTo(array, target);
        } else {
          utils.flatten3dArrayTo(array, target);
        }
      } else {
        utils.flatten2dArrayTo(array, target);
      }
    } else {
      target.set(array);
    }
  },

  splitArray(array, part) {
    const result = [];
    for (let i = 0; i < array.length; i += part) {
      result.push(new array.constructor(array.buffer, i * 4 + array.byteOffset, part));
    }
    return result;
  },

  getAstString(source, ast) {
    const lines = Array.isArray(source) ? source : source.split(/\r?\n/g);
    const start = ast.loc.start;
    const end = ast.loc.end;
    const result = [];
    if (start.line === end.line) {
      result.push(lines[start.line - 1].substring(start.column, end.column));
    } else {
      result.push(lines[start.line - 1].slice(start.column));
      for (let i = start.line; i < end.line; i++) {
        result.push(lines[i]);
      }
      result.push(lines[end.line - 1].slice(0, end.column));
    }
    return result.join('\n');
  },

  allPropertiesOf(obj) {
    const props = [];

    do {
      props.push.apply(props, Object.getOwnPropertyNames(obj));
    } while (obj = Object.getPrototypeOf(obj));

    return props;
  },

  linesToString(lines) {
    if (lines.length > 0) {
      return lines.join(';\n') + ';\n';
    } else {
      return '\n';
    }
  },
  warnDeprecated(type, oldName, newName) {
    if (newName) {
      console.warn(`You are using a deprecated ${ type } "${ oldName }". It has been replaced with "${ newName }". Fixing, but please upgrade as it will soon be removed.`);
    } else {
      console.warn(`You are using a deprecated ${ type } "${ oldName }". It has been removed. Fixing, but please upgrade as it will soon be removed.`);
    }
  },
  flipPixels: (pixels, width, height) => {
    const halfHeight = height / 2 | 0; 
    const bytesPerRow = width * 4;
    const temp = new Uint8ClampedArray(width * 4);
    const result = pixels.slice(0);
    for (let y = 0; y < halfHeight; ++y) {
      const topOffset = y * bytesPerRow;
      const bottomOffset = (height - y - 1) * bytesPerRow;

      temp.set(result.subarray(topOffset, topOffset + bytesPerRow));

      result.copyWithin(topOffset, bottomOffset, bottomOffset + bytesPerRow);

      result.set(temp, bottomOffset);
    }
    return result;
  },
  erectPackedFloat: (array, width) => {
    return array.subarray(0, width);
  },
  erect2DPackedFloat: (array, width, height) => {
    const yResults = new Array(height);
    for (let y = 0; y < height; y++) {
      const xStart = y * width;
      const xEnd = xStart + width;
      yResults[y] = array.subarray(xStart, xEnd);
    }
    return yResults;
  },
  erect3DPackedFloat: (array, width, height, depth) => {
    const zResults = new Array(depth);
    for (let z = 0; z < depth; z++) {
      const yResults = new Array(height);
      for (let y = 0; y < height; y++) {
        const xStart = (z * height * width) + y * width;
        const xEnd = xStart + width;
        yResults[y] = array.subarray(xStart, xEnd);
      }
      zResults[z] = yResults;
    }
    return zResults;
  },
  erectMemoryOptimizedFloat: (array, width) => {
    return array.subarray(0, width);
  },
  erectMemoryOptimized2DFloat: (array, width, height) => {
    const yResults = new Array(height);
    for (let y = 0; y < height; y++) {
      const offset = y * width;
      yResults[y] = array.subarray(offset, offset + width);
    }
    return yResults;
  },
  erectMemoryOptimized3DFloat: (array, width, height, depth) => {
    const zResults = new Array(depth);
    for (let z = 0; z < depth; z++) {
      const yResults = new Array(height);
      for (let y = 0; y < height; y++) {
        const offset = (z * height * width) + (y * width);
        yResults[y] = array.subarray(offset, offset + width);
      }
      zResults[z] = yResults;
    }
    return zResults;
  },
  erectFloat: (array, width) => {
    const xResults = new Float32Array(width);
    let i = 0;
    for (let x = 0; x < width; x++) {
      xResults[x] = array[i];
      i += 4;
    }
    return xResults;
  },
  erect2DFloat: (array, width, height) => {
    const yResults = new Array(height);
    let i = 0;
    for (let y = 0; y < height; y++) {
      const xResults = new Float32Array(width);
      for (let x = 0; x < width; x++) {
        xResults[x] = array[i];
        i += 4;
      }
      yResults[y] = xResults;
    }
    return yResults;
  },
  erect3DFloat: (array, width, height, depth) => {
    const zResults = new Array(depth);
    let i = 0;
    for (let z = 0; z < depth; z++) {
      const yResults = new Array(height);
      for (let y = 0; y < height; y++) {
        const xResults = new Float32Array(width);
        for (let x = 0; x < width; x++) {
          xResults[x] = array[i];
          i += 4;
        }
        yResults[y] = xResults;
      }
      zResults[z] = yResults;
    }
    return zResults;
  },
  erectArray2: (array, width) => {
    const xResults = new Array(width);
    const xResultsMax = width * 4;
    let i = 0;
    for (let x = 0; x < xResultsMax; x += 4) {
      xResults[i++] = array.subarray(x, x + 2);
    }
    return xResults;
  },
  erect2DArray2: (array, width, height) => {
    const yResults = new Array(height);
    const XResultsMax = width * 4;
    for (let y = 0; y < height; y++) {
      const xResults = new Array(width);
      const offset = y * XResultsMax;
      let i = 0;
      for (let x = 0; x < XResultsMax; x += 4) {
        xResults[i++] = array.subarray(x + offset, x + offset + 2);
      }
      yResults[y] = xResults;
    }
    return yResults;
  },
  erect3DArray2: (array, width, height, depth) => {
    const xResultsMax = width * 4;
    const zResults = new Array(depth);
    for (let z = 0; z < depth; z++) {
      const yResults = new Array(height);
      for (let y = 0; y < height; y++) {
        const xResults = new Array(width);
        const offset = (z * xResultsMax * height) + (y * xResultsMax);
        let i = 0;
        for (let x = 0; x < xResultsMax; x += 4) {
          xResults[i++] = array.subarray(x + offset, x + offset + 2);
        }
        yResults[y] = xResults;
      }
      zResults[z] = yResults;
    }
    return zResults;
  },
  erectArray3: (array, width) => {
    const xResults = new Array(width);
    const xResultsMax = width * 4;
    let i = 0;
    for (let x = 0; x < xResultsMax; x += 4) {
      xResults[i++] = array.subarray(x, x + 3);
    }
    return xResults;
  },
  erect2DArray3: (array, width, height) => {
    const xResultsMax = width * 4;
    const yResults = new Array(height);
    for (let y = 0; y < height; y++) {
      const xResults = new Array(width);
      const offset = y * xResultsMax;
      let i = 0;
      for (let x = 0; x < xResultsMax; x += 4) {
        xResults[i++] = array.subarray(x + offset, x + offset + 3);
      }
      yResults[y] = xResults;
    }
    return yResults;
  },
  erect3DArray3: (array, width, height, depth) => {
    const xResultsMax = width * 4;
    const zResults = new Array(depth);
    for (let z = 0; z < depth; z++) {
      const yResults = new Array(height);
      for (let y = 0; y < height; y++) {
        const xResults = new Array(width);
        const offset = (z * xResultsMax * height) + (y * xResultsMax);
        let i = 0;
        for (let x = 0; x < xResultsMax; x += 4) {
          xResults[i++] = array.subarray(x + offset, x + offset + 3);
        }
        yResults[y] = xResults;
      }
      zResults[z] = yResults;
    }
    return zResults;
  },
  erectArray4: (array, width) => {
    const xResults = new Array(array);
    const xResultsMax = width * 4;
    let i = 0;
    for (let x = 0; x < xResultsMax; x += 4) {
      xResults[i++] = array.subarray(x, x + 4);
    }
    return xResults;
  },
  erect2DArray4: (array, width, height) => {
    const xResultsMax = width * 4;
    const yResults = new Array(height);
    for (let y = 0; y < height; y++) {
      const xResults = new Array(width);
      const offset = y * xResultsMax;
      let i = 0;
      for (let x = 0; x < xResultsMax; x += 4) {
        xResults[i++] = array.subarray(x + offset, x + offset + 4);
      }
      yResults[y] = xResults;
    }
    return yResults;
  },
  erect3DArray4: (array, width, height, depth) => {
    const xResultsMax = width * 4;
    const zResults = new Array(depth);
    for (let z = 0; z < depth; z++) {
      const yResults = new Array(height);
      for (let y = 0; y < height; y++) {
        const xResults = new Array(width);
        const offset = (z * xResultsMax * height) + (y * xResultsMax);
        let i = 0;
        for (let x = 0; x < xResultsMax; x += 4) {
          xResults[i++] = array.subarray(x + offset, x + offset + 4);
        }
        yResults[y] = xResults;
      }
      zResults[z] = yResults;
    }
    return zResults;
  },

  flattenFunctionToString: (source, settings) => {
    const { findDependency, thisLookup, doNotDefine } = settings;
    let flattened = settings.flattened;
    if (!flattened) {
      flattened = settings.flattened = {};
    }
    const ast = acorn.parse(source);
    const functionDependencies = [];
    let indent = 0;

    function flatten(ast) {
      if (Array.isArray(ast)) {
        const results = [];
        for (let i = 0; i < ast.length; i++) {
          results.push(flatten(ast[i]));
        }
        return results.join('');
      }
      switch (ast.type) {
        case 'Program':
          return flatten(ast.body) + (ast.body[0].type === 'VariableDeclaration' ? ';' : '');
        case 'FunctionDeclaration':
          return `function ${ast.id.name}(${ast.params.map(flatten).join(', ')}) ${ flatten(ast.body) }`;
        case 'BlockStatement': {
          const result = [];
          indent += 2;
          for (let i = 0; i < ast.body.length; i++) {
            const flat = flatten(ast.body[i]);
            if (flat) {
              result.push(' '.repeat(indent) + flat, ';\n');
            }
          }
          indent -= 2;
          return `{\n${result.join('')}}`;
        }
        case 'VariableDeclaration':
          const declarations = utils.normalizeDeclarations(ast)
            .map(flatten)
            .filter(r => r !== null);
          if (declarations.length < 1) {
            return '';
          } else {
            return `${ast.kind} ${declarations.join(',')}`;
          }
          case 'VariableDeclarator':
            if (ast.init.object && ast.init.object.type === 'ThisExpression') {
              const lookup = thisLookup(ast.init.property.name, true);
              if (lookup) {
                return `${ast.id.name} = ${flatten(ast.init)}`;
              } else {
                return null;
              }
            } else {
              return `${ast.id.name} = ${flatten(ast.init)}`;
            }
            case 'CallExpression': {
              if (ast.callee.property.name === 'subarray') {
                return `${flatten(ast.callee.object)}.${flatten(ast.callee.property)}(${ast.arguments.map(value => flatten(value)).join(', ')})`;
              }
              if (ast.callee.object.name === 'gl' || ast.callee.object.name === 'context') {
                return `${flatten(ast.callee.object)}.${flatten(ast.callee.property)}(${ast.arguments.map(value => flatten(value)).join(', ')})`;
              }
              if (ast.callee.object.type === 'ThisExpression') {
                functionDependencies.push(findDependency('this', ast.callee.property.name));
                return `${ast.callee.property.name}(${ast.arguments.map(value => flatten(value)).join(', ')})`;
              } else if (ast.callee.object.name) {
                const foundSource = findDependency(ast.callee.object.name, ast.callee.property.name);
                if (foundSource === null) {
                  return `${ast.callee.object.name}.${ast.callee.property.name}(${ast.arguments.map(value => flatten(value)).join(', ')})`;
                } else {
                  functionDependencies.push(foundSource);
                  return `${ast.callee.property.name}(${ast.arguments.map(value => flatten(value)).join(', ')})`;
                }
              } else if (ast.callee.object.type === 'MemberExpression') {
                return `${flatten(ast.callee.object)}.${ast.callee.property.name}(${ast.arguments.map(value => flatten(value)).join(', ')})`;
              } else {
                throw new Error('unknown ast.callee');
              }
            }
            case 'ReturnStatement':
              return `return ${flatten(ast.argument)}`;
            case 'BinaryExpression':
              return `(${flatten(ast.left)}${ast.operator}${flatten(ast.right)})`;
            case 'UnaryExpression':
              if (ast.prefix) {
                return `${ast.operator} ${flatten(ast.argument)}`;
              } else {
                return `${flatten(ast.argument)} ${ast.operator}`;
              }
              case 'ExpressionStatement':
                return `${flatten(ast.expression)}`;
              case 'SequenceExpression':
                return `(${flatten(ast.expressions)})`;
              case 'ArrowFunctionExpression':
                return `(${ast.params.map(flatten).join(', ')}) => ${flatten(ast.body)}`;
              case 'Literal':
                return ast.raw;
              case 'Identifier':
                return ast.name;
              case 'MemberExpression':
                if (ast.object.type === 'ThisExpression') {
                  return thisLookup(ast.property.name);
                }
                if (ast.computed) {
                  return `${flatten(ast.object)}[${flatten(ast.property)}]`;
                }
                return flatten(ast.object) + '.' + flatten(ast.property);
              case 'ThisExpression':
                return 'this';
              case 'NewExpression':
                return `new ${flatten(ast.callee)}(${ast.arguments.map(value => flatten(value)).join(', ')})`;
              case 'ForStatement':
                return `for (${flatten(ast.init)};${flatten(ast.test)};${flatten(ast.update)}) ${flatten(ast.body)}`;
              case 'AssignmentExpression':
                return `${flatten(ast.left)}${ast.operator}${flatten(ast.right)}`;
              case 'UpdateExpression':
                return `${flatten(ast.argument)}${ast.operator}`;
              case 'IfStatement':
                return `if (${flatten(ast.test)}) ${flatten(ast.consequent)}`;
              case 'ThrowStatement':
                return `throw ${flatten(ast.argument)}`;
              case 'ObjectPattern':
                return ast.properties.map(flatten).join(', ');
              case 'ArrayPattern':
                return ast.elements.map(flatten).join(', ');
              case 'DebuggerStatement':
                return 'debugger;';
              case 'ConditionalExpression':
                return `${flatten(ast.test)}?${flatten(ast.consequent)}:${flatten(ast.alternate)}`;
              case 'Property':
                if (ast.kind === 'init') {
                  return flatten(ast.key);
                }
      }
      throw new Error(`unhandled ast.type of ${ ast.type }`);
    }
    const result = flatten(ast);
    if (functionDependencies.length > 0) {
      const flattenedFunctionDependencies = [];
      for (let i = 0; i < functionDependencies.length; i++) {
        const functionDependency = functionDependencies[i];
        if (!flattened[functionDependency]) {
          flattened[functionDependency] = true;
        }
        functionDependency ? flattenedFunctionDependencies.push(utils.flattenFunctionToString(functionDependency, settings) + '\n') : '';
      }
      return flattenedFunctionDependencies.join('') + result;
    }
    return result;
  },

  normalizeDeclarations: (ast) => {
    if (ast.type !== 'VariableDeclaration') throw new Error('Ast is not of type "VariableDeclaration"');
    const normalizedDeclarations = [];
    for (let declarationIndex = 0; declarationIndex < ast.declarations.length; declarationIndex++) {
      const declaration = ast.declarations[declarationIndex];
      if (declaration.id && declaration.id.type === 'ObjectPattern' && declaration.id.properties) {
        const { properties } = declaration.id;
        for (let propertyIndex = 0; propertyIndex < properties.length; propertyIndex++) {
          const property = properties[propertyIndex];
          if (property.value.type === 'ObjectPattern' && property.value.properties) {
            for (let subPropertyIndex = 0; subPropertyIndex < property.value.properties.length; subPropertyIndex++) {
              const subProperty = property.value.properties[subPropertyIndex];
              if (subProperty.type === 'Property') {
                normalizedDeclarations.push({
                  type: 'VariableDeclarator',
                  id: {
                    type: 'Identifier',
                    name: subProperty.key.name
                  },
                  init: {
                    type: 'MemberExpression',
                    object: {
                      type: 'MemberExpression',
                      object: declaration.init,
                      property: {
                        type: 'Identifier',
                        name: property.key.name
                      },
                      computed: false
                    },
                    property: {
                      type: 'Identifier',
                      name: subProperty.key.name
                    },
                    computed: false
                  }
                });
              } else {
                throw new Error('unexpected state');
              }
            }
          } else if (property.value.type === 'Identifier') {
            normalizedDeclarations.push({
              type: 'VariableDeclarator',
              id: {
                type: 'Identifier',
                name: property.value && property.value.name ? property.value.name : property.key.name
              },
              init: {
                type: 'MemberExpression',
                object: declaration.init,
                property: {
                  type: 'Identifier',
                  name: property.key.name
                },
                computed: false
              }
            });
          } else {
            throw new Error('unexpected state');
          }
        }
      } else if (declaration.id && declaration.id.type === 'ArrayPattern' && declaration.id.elements) {
        const { elements } = declaration.id;
        for (let elementIndex = 0; elementIndex < elements.length; elementIndex++) {
          const element = elements[elementIndex];
          if (element.type === 'Identifier') {
            normalizedDeclarations.push({
              type: 'VariableDeclarator',
              id: {
                type: 'Identifier',
                name: element.name
              },
              init: {
                type: 'MemberExpression',
                object: declaration.init,
                property: {
                  type: 'Literal',
                  value: elementIndex,
                  raw: elementIndex.toString(),
                  start: element.start,
                  end: element.end
                },
                computed: true
              }
            });
          } else {
            throw new Error('unexpected state');
          }
        }
      } else {
        normalizedDeclarations.push(declaration);
      }
    }
    return normalizedDeclarations;
  },

  splitHTMLImageToRGB: (gpu, image) => {
    const rKernel = gpu.createKernel(function(a) {
      const pixel = a[this.thread.y][this.thread.x];
      return pixel.r * 255;
    }, {
      output: [image.width, image.height],
      precision: 'unsigned',
      argumentTypes: { a: 'HTMLImage' },
    });
    const gKernel = gpu.createKernel(function(a) {
      const pixel = a[this.thread.y][this.thread.x];
      return pixel.g * 255;
    }, {
      output: [image.width, image.height],
      precision: 'unsigned',
      argumentTypes: { a: 'HTMLImage' },
    });
    const bKernel = gpu.createKernel(function(a) {
      const pixel = a[this.thread.y][this.thread.x];
      return pixel.b * 255;
    }, {
      output: [image.width, image.height],
      precision: 'unsigned',
      argumentTypes: { a: 'HTMLImage' },
    });
    const aKernel = gpu.createKernel(function(a) {
      const pixel = a[this.thread.y][this.thread.x];
      return pixel.a * 255;
    }, {
      output: [image.width, image.height],
      precision: 'unsigned',
      argumentTypes: { a: 'HTMLImage' },
    });
    const result = [
      rKernel(image),
      gKernel(image),
      bKernel(image),
      aKernel(image),
    ];
    result.rKernel = rKernel;
    result.gKernel = gKernel;
    result.bKernel = bKernel;
    result.aKernel = aKernel;
    result.gpu = gpu;
    return result;
  },

  splitRGBAToCanvases: (gpu, rgba, width, height) => {
    const visualKernelR = gpu.createKernel(function(v) {
      const pixel = v[this.thread.y][this.thread.x];
      this.color(pixel.r / 255, 0, 0, 255);
    }, {
      output: [width, height],
      graphical: true,
      argumentTypes: { v: 'Array2D(4)' }
    });
    visualKernelR(rgba);

    const visualKernelG = gpu.createKernel(function(v) {
      const pixel = v[this.thread.y][this.thread.x];
      this.color(0, pixel.g / 255, 0, 255);
    }, {
      output: [width, height],
      graphical: true,
      argumentTypes: { v: 'Array2D(4)' }
    });
    visualKernelG(rgba);

    const visualKernelB = gpu.createKernel(function(v) {
      const pixel = v[this.thread.y][this.thread.x];
      this.color(0, 0, pixel.b / 255, 255);
    }, {
      output: [width, height],
      graphical: true,
      argumentTypes: { v: 'Array2D(4)' }
    });
    visualKernelB(rgba);

    const visualKernelA = gpu.createKernel(function(v) {
      const pixel = v[this.thread.y][this.thread.x];
      this.color(255, 255, 255, pixel.a / 255);
    }, {
      output: [width, height],
      graphical: true,
      argumentTypes: { v: 'Array2D(4)' }
    });
    visualKernelA(rgba);
    return [
      visualKernelR.canvas,
      visualKernelG.canvas,
      visualKernelB.canvas,
      visualKernelA.canvas,
    ];
  },

  getMinifySafeName: (fn) => {
    try {
      const ast = acorn.parse(`const value = ${fn.toString()}`);
      const { init } = ast.body[0].declarations[0];
      return init.body.name || init.body.body[0].argument.name;
    } catch (e) {
      throw new Error('Unrecognized function type.  Please use `() => yourFunctionVariableHere` or function() { return yourFunctionVariableHere; }');
    }
  },
  sanitizeName: function(name) {
    if (dollarSign.test(name)) {
      name = name.replace(dollarSign, 'S_S');
    }
    if (doubleUnderscore.test(name)) {
      name = name.replace(doubleUnderscore, 'U_U');
    } else if (singleUnderscore.test(name)) {
      name = name.replace(singleUnderscore, 'u_u');
    }
    return name;
  }
};

const dollarSign = /\$/;
const doubleUnderscore = /__/;
const singleUnderscore = /_/;

const _systemEndianness = utils.getSystemEndianness();

module.exports = {
  utils
};

},{"./input":110,"./texture":113,"acorn":1}]},{},[107])(107)
});


/***/ }),

/***/ "./src/renderer.ts":
/*!*************************!*\
  !*** ./src/renderer.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Renderer": () => (/* binding */ Renderer)
/* harmony export */ });
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var Renderer = /** @class */ (function () {
    function Renderer() {
        this.renderSettings = {
            mouseX: 1,
            mouseY: 1,
        };
        this.isDrawing = false;
    }
    Renderer.prototype.createRenderer = function (gpu, canvas) {
        return __awaiter(this, void 0, void 0, function () {
            var redr, redraw;
            var _this = this;
            return __generator(this, function (_a) {
                redr = gpu
                    .createKernel(function (mouseX, mouseY) {
                    function dist(x, y) {
                        return Math.sqrt(x * x + y * y);
                    }
                    var dst1 = dist(this.thread.x - mouseX, this.thread.y - mouseY);
                    /*
                      dist(
                        this.thread.x - (mouseX as number),
                        this.thread.y - (mouseY as number)
                      ) / dist(this.output.x, this.output.y)*/
                    /*
                      Math.sqrt(
                        (this.thread.x - num(mouseX)) *
                          (this.thread.x - (mouseX as number)) +
                          (this.output.y - this.thread.y - (mouseY as number)) *
                            (this.output.y - this.thread.y - (mouseY as number))
                      ) /
                      Math.sqrt(
                        this.output.x * this.output.x + this.output.y * this.output.y
                      )*/
                    this.color(0.3, Math.max(1 - 2 * dst1, 0), Math.max(1 - 2 * dst1, 0), 1);
                })
                    .setOutput([canvas.width, canvas.height])
                    .setDynamicOutput(true)
                    .setGraphical(true)
                    .setDebug(true);
                redraw = (function () {
                    redr(_this.renderSettings.mouseX, _this.renderSettings.mouseY);
                });
                redraw.change = redr;
                this.redraw = redraw;
                redraw();
                return [2 /*return*/];
            });
        });
    };
    Renderer.prototype.setVar = function (name, val) {
        this.renderSettings["".concat(name)] = val;
    };
    return Renderer;
}());



/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var gpu_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! gpu.js */ "./node_modules/gpu.js/dist/gpu-browser.js");
/* harmony import */ var gpu_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(gpu_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _renderer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/renderer */ "./src/renderer.ts");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();


// interface Physics {}
var DrawingApp = /** @class */ (function (_super) {
    __extends(DrawingApp, _super);
    function DrawingApp() {
        var _this = _super.call(this) || this;
        // private context: WebGL2RenderingContext
        _this.pressed = false;
        _this.focusEventHandler = function () {
            requestAnimationFrame(_this.redraw);
        };
        _this.resizeEventHandler = function () {
            _this.redraw.change.setOutput([window.innerWidth, window.innerHeight]);
            _this.canvas.width = window.innerWidth;
            _this.canvas.height = window.innerHeight;
        };
        _this.releaseEventHandler = function () {
            _this.pressed = false;
        };
        _this.cancelEventHandler = function () {
            _this.pressed = false;
        };
        _this.pressEventHandler = function (e) {
            var mouseX = e.changedTouches
                ? e.changedTouches[0].pageX
                : e.pageX;
            var mouseY = e.changedTouches
                ? e.changedTouches[0].pageY
                : e.pageY;
            mouseX -= _this.canvas.offsetLeft;
            mouseY -= _this.canvas.offsetTop;
            _this.pressed = true;
            _this.clickX = mouseX;
            _this.clickY = mouseY;
            _this.setVar('mouseX', mouseX);
            _this.setVar('mouseY', mouseY);
            e.preventDefault();
        };
        _this.dragEventHandler = function (e) {
            var mouseX = e.changedTouches
                ? e.changedTouches[0].pageX
                : e.pageX;
            var mouseY = e.changedTouches
                ? e.changedTouches[0].pageY
                : e.pageY;
            mouseX -= _this.canvas.offsetLeft;
            mouseY -= _this.canvas.offsetTop;
            if (_this.pressed) {
                _this.clickX = mouseX;
                _this.clickY = mouseY;
                _this.setVar('mouseX', mouseX);
                _this.setVar('mouseY', mouseY);
            }
            // game.redraw()
            e.preventDefault();
        };
        var body = document.getElementsByTagName('body')[0];
        var canvas = document.createElement('canvas');
        var context = canvas.getContext('webgl2');
        var gpu = new gpu_js__WEBPACK_IMPORTED_MODULE_0__.GPU({ canvas: canvas, context: context });
        body.style.margin = '0px';
        body.style.overflow = 'hidden';
        body.appendChild(canvas);
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        _this.canvas = canvas;
        // this.context = context
        _this.gpu = gpu;
        _this.createUserEvents();
        _this.createRenderer(gpu, canvas);
        return _this;
    }
    DrawingApp.prototype.createUserEvents = function () {
        var _this = this;
        var canvas = this.canvas;
        document.addEventListener('pointe', this.focusEventHandler);
        document.addEventListener('pointerout', function () { return (_this.isDrawing = false); });
        canvas.addEventListener('mousedown', this.pressEventHandler);
        canvas.addEventListener('mousemove', this.dragEventHandler);
        canvas.addEventListener('mouseup', this.releaseEventHandler);
        canvas.addEventListener('mouseout', this.cancelEventHandler);
        canvas.addEventListener('touchstart', this.pressEventHandler);
        canvas.addEventListener('touchmove', this.dragEventHandler);
        canvas.addEventListener('touchend', this.releaseEventHandler);
        canvas.addEventListener('touchcancel', this.cancelEventHandler);
        window.addEventListener('resize', this.resizeEventHandler);
    };
    return DrawingApp;
}(_renderer__WEBPACK_IMPORTED_MODULE_1__.Renderer));
var game = new DrawingApp();
(function loop() {
    game.redraw();
    requestAnimationFrame(loop);
})();

})();

/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsZUFBZTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSxxQ0FBcUM7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw0QkFBNEI7QUFDNUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFD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QzdCLDZCQUE2QjtBQUM3Qiw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBLDJEQUEyRCxrQ0FBa0M7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTs7QUFFUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0EsMENBQTBDLFFBQVE7QUFDbEQ7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsaUJBQWlCO0FBQ3RFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFlBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7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UztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1YsNERBQTRELFNBQVM7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELFdBQVc7QUFDbEU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1Q0FBdUMsVUFBVTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSLHdCQUF3QixtQkFBbUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1Isd0JBQXdCLG1CQUFtQjtBQUMzQztBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsVUFBVSxFQUFFLFVBQVUsRUFBRSxRQUFRO0FBQzlDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFFLGdEQUFnRDtBQUNuRCxRQUFRLFFBQVE7O0FBRWhCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sMERBQTBELE1BQU07QUFDaEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVDQUF1Qyw2QkFBNkI7QUFDcEU7QUFDQTtBQUNBO0FBQ0EsWUFBWSx5QkFBeUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLDBEQUEwRDtBQUN0RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixnQkFBZ0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7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QUMvRDs7QUFFQTtBQUNBLHFEQUFxRCxXQUFXO0FBQ2hFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLDREQUE0RCxXQUFXO0FBQ3ZFOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLFdBQVc7QUFDdkI7QUFDQSx1Q0FBdUMsZ0JBQWdCLEdBQUcsZ0JBQWdCLHVEQUF1RCx3QkFBd0IsR0FBRyx3QkFBd0I7QUFDcEw7QUFDQTs7QUFFQTtBQUNBLHdEQUF3RCxzQkFBc0I7QUFDOUU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FB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QUNBLGtCQUFrQixlQUFlO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGVBQWU7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGVBQWU7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZUFBZTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixlQUFlO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZUFBZTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsZUFBZTtBQUNqQztBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLGVBQWU7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixlQUFlO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGVBQWU7QUFDakM7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUVBQXlFLElBQUk7QUFDN0U7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLGNBQWM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksK0JBQStCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0IsNEJBQTRCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxvRUFBb0U7O0FBRWhGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxvQkFBb0IsdUNBQXVDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDRCQUE0QjtBQUNoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0IseUJBQXlCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxjQUFjO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsZ0NBQWdDO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiw0QkFBNEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNEJBQTRCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLENBQUMsR0FBRztBQUNKLFFBQVEsUUFBUTtBQUNoQixRQUFRLG9CQUFvQjs7QUFFNUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsaUNBQWlDLEtBQUs7QUFDdEMsUUFBUTtBQUNSLDRCQUE0QixLQUFLO0FBQ2pDO0FBQ0EsTUFBTTtBQUNOLDBCQUEwQixLQUFLO0FBQy9COztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUUsK0NBQStDO0FBQ2xELFFBQVEsMkJBQTJCO0FBQ25DLFFBQVEseUJBQXlCO0FBQ2pDLFFBQVEsMkJBQTJCOztBQUVuQyxRQUFRLDZCQUE2QjtBQUNyQyxRQUFRLG9DQUFvQzs7QUFFNUMsUUFBUSxrQ0FBa0M7QUFDMUMsUUFBUSx5Q0FBeUM7O0FBRWpELFFBQVEsNkJBQTZCO0FBQ3JDLFFBQVEsb0NBQW9DOztBQUU1QyxRQUFRLCtCQUErQjtBQUN2QyxRQUFRLHNDQUFzQzs7QUFFOUMsUUFBUSxpQ0FBaUM7QUFDekMsUUFBUSx3Q0FBd0M7O0FBRWhELFFBQVEsZ0RBQWdEO0FBQ3hELFFBQVEsdURBQXVEOztBQUUvRCxRQUFRLGlDQUFpQztBQUN6QyxRQUFRLHdDQUF3Qzs7QUFFaEQsUUFBUSwrQkFBK0I7QUFDdkMsUUFBUSxzQ0FBc0M7O0FBRTlDLFFBQVEsa0NBQWtDO0FBQzFDLFFBQVEseUNBQXlDOztBQUVqRCxRQUFRLGtDQUFrQztBQUMxQyxRQUFRLHlDQUF5Qzs7QUFFakQsUUFBUSxrQ0FBa0M7QUFDMUMsUUFBUSx5Q0FBeUM7O0FBRWpELFFBQVEsMEJBQTBCO0FBQ2xDLFFBQVEsMEJBQTBCO0FBQ2xDLFFBQVEsMEJBQTBCOztBQUVsQyxRQUFRLGlDQUFpQztBQUN6QyxRQUFRLHdDQUF3Qzs7QUFFaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLHlEQUF5RCxNQUFNO0FBQy9EO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBRSwwbUNBQTBtQztBQUM3bUMsUUFBUSx5QkFBeUI7O0FBRWpDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBRSxzQ0FBc0M7QUFDekMsUUFBUSx5QkFBeUI7O0FBRWpDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBRSxzQ0FBc0M7QUFDekMsUUFBUSx5QkFBeUI7O0FBRWpDOztBQUVBO0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSxZQUFZLFdBQVc7QUFDdkI7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLGNBQWM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksY0FBYzs7QUFFMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFFBQVE7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxpQkFBaUI7QUFDekU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixzQkFBc0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUMsZ0JBQWdCLENBQUMsV0FBVyxFQUFFLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQztRQUMzRCxNQUFNLENBQUMsZ0JBQWdCLENBQUMsVUFBVSxFQUFFLElBQUksQ0FBQyxtQkFBbUIsQ0FBQztRQUM3RCxNQUFNLENBQUMsZ0JBQWdCLENBQUMsYUFBYSxFQUFFLElBQUksQ0FBQyxrQkFBa0IsQ0FBQztRQUUvRCxNQUFNLENBQUMsZ0JBQWdCLENBQUMsUUFBUSxFQUFFLElBQUksQ0FBQyxrQkFBa0IsQ0FBQztJQUM1RCxDQUFDO0lBeURILGlCQUFDO0FBQUQsQ0FBQyxDQXpHd0IsK0NBQVEsR0F5R2hDO0FBRUQsSUFBTSxJQUFJLEdBQUcsSUFBSSxVQUFVLEVBQUUsQ0FDNUI7QUFBQSxDQUFDLFNBQVMsSUFBSTtJQUNiLElBQUksQ0FBQyxNQUFNLEVBQUU7SUFDYixxQkFBcUIsQ0FBQyxJQUFJLENBQUM7QUFDN0IsQ0FBQyxDQUFDLEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zbXRoLy4vbm9kZV9tb2R1bGVzL2dwdS5qcy9kaXN0L2dwdS1icm93c2VyLmpzIiwid2VicGFjazovL3NtdGgvLi9zcmMvcmVuZGVyZXIudHMiLCJ3ZWJwYWNrOi8vc210aC93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly9zbXRoL3dlYnBhY2svcnVudGltZS9jb21wYXQgZ2V0IGRlZmF1bHQgZXhwb3J0Iiwid2VicGFjazovL3NtdGgvd2VicGFjay9ydW50aW1lL2RlZmluZSBwcm9wZXJ0eSBnZXR0ZXJzIiwid2VicGFjazovL3NtdGgvd2VicGFjay9ydW50aW1lL2hhc093blByb3BlcnR5IHNob3J0aGFuZCIsIndlYnBhY2s6Ly9zbXRoL3dlYnBhY2svcnVudGltZS9tYWtlIG5hbWVzcGFjZSBvYmplY3QiLCJ3ZWJwYWNrOi8vc210aC8uL3NyYy9pbmRleC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIGdwdS5qc1xuICogaHR0cDovL2dwdS5yb2Nrcy9cbiAqXG4gKiBHUFUgQWNjZWxlcmF0ZWQgSmF2YVNjcmlwdFxuICpcbiAqIEB2ZXJzaW9uIDIuMTUuMlxuICogQGRhdGUgTW9uIE1hciAyOCAyMDIyIDEwOjUxOjA2IEdNVC0wNDAwIChFYXN0ZXJuIERheWxpZ2h0IFRpbWUpXG4gKlxuICogQGxpY2Vuc2UgTUlUXG4gKiBUaGUgTUlUIExpY2Vuc2VcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjIgZ3B1LmpzIFRlYW1cbiAqLyhmdW5jdGlvbihmKXtpZih0eXBlb2YgZXhwb3J0cz09PVwib2JqZWN0XCImJnR5cGVvZiBtb2R1bGUhPT1cInVuZGVmaW5lZFwiKXttb2R1bGUuZXhwb3J0cz1mKCl9ZWxzZSBpZih0eXBlb2YgZGVmaW5lPT09XCJmdW5jdGlvblwiJiZkZWZpbmUuYW1kKXtkZWZpbmUoW10sZil9ZWxzZXt2YXIgZztpZih0eXBlb2Ygd2luZG93IT09XCJ1bmRlZmluZWRcIil7Zz13aW5kb3d9ZWxzZSBpZih0eXBlb2YgZ2xvYmFsIT09XCJ1bmRlZmluZWRcIil7Zz1nbG9iYWx9ZWxzZSBpZih0eXBlb2Ygc2VsZiE9PVwidW5kZWZpbmVkXCIpe2c9c2VsZn1lbHNle2c9dGhpc31nLkdQVSA9IGYoKX19KShmdW5jdGlvbigpe3ZhciBkZWZpbmUsbW9kdWxlLGV4cG9ydHM7cmV0dXJuIChmdW5jdGlvbigpe2Z1bmN0aW9uIHIoZSxuLHQpe2Z1bmN0aW9uIG8oaSxmKXtpZighbltpXSl7aWYoIWVbaV0pe3ZhciBjPVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmU7aWYoIWYmJmMpcmV0dXJuIGMoaSwhMCk7aWYodSlyZXR1cm4gdShpLCEwKTt2YXIgYT1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK2krXCInXCIpO3Rocm93IGEuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixhfXZhciBwPW5baV09e2V4cG9ydHM6e319O2VbaV1bMF0uY2FsbChwLmV4cG9ydHMsZnVuY3Rpb24ocil7dmFyIG49ZVtpXVsxXVtyXTtyZXR1cm4gbyhufHxyKX0scCxwLmV4cG9ydHMscixlLG4sdCl9cmV0dXJuIG5baV0uZXhwb3J0c31mb3IodmFyIHU9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZSxpPTA7aTx0Lmxlbmd0aDtpKyspbyh0W2ldKTtyZXR1cm4gb31yZXR1cm4gcn0pKCkoezE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzKSA6XG4gIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnXSwgZmFjdG9yeSkgOlxuICAoZ2xvYmFsID0gZ2xvYmFsIHx8IHNlbGYsIGZhY3RvcnkoZ2xvYmFsLmFjb3JuID0ge30pKTtcbn0odGhpcywgKGZ1bmN0aW9uIChleHBvcnRzKSB7ICd1c2Ugc3RyaWN0JztcblxuXG4gIHZhciByZXNlcnZlZFdvcmRzID0ge1xuICAgIDM6IFwiYWJzdHJhY3QgYm9vbGVhbiBieXRlIGNoYXIgY2xhc3MgZG91YmxlIGVudW0gZXhwb3J0IGV4dGVuZHMgZmluYWwgZmxvYXQgZ290byBpbXBsZW1lbnRzIGltcG9ydCBpbnQgaW50ZXJmYWNlIGxvbmcgbmF0aXZlIHBhY2thZ2UgcHJpdmF0ZSBwcm90ZWN0ZWQgcHVibGljIHNob3J0IHN0YXRpYyBzdXBlciBzeW5jaHJvbml6ZWQgdGhyb3dzIHRyYW5zaWVudCB2b2xhdGlsZVwiLFxuICAgIDU6IFwiY2xhc3MgZW51bSBleHRlbmRzIHN1cGVyIGNvbnN0IGV4cG9ydCBpbXBvcnRcIixcbiAgICA2OiBcImVudW1cIixcbiAgICBzdHJpY3Q6IFwiaW1wbGVtZW50cyBpbnRlcmZhY2UgbGV0IHBhY2thZ2UgcHJpdmF0ZSBwcm90ZWN0ZWQgcHVibGljIHN0YXRpYyB5aWVsZFwiLFxuICAgIHN0cmljdEJpbmQ6IFwiZXZhbCBhcmd1bWVudHNcIlxuICB9O1xuXG5cbiAgdmFyIGVjbWE1QW5kTGVzc0tleXdvcmRzID0gXCJicmVhayBjYXNlIGNhdGNoIGNvbnRpbnVlIGRlYnVnZ2VyIGRlZmF1bHQgZG8gZWxzZSBmaW5hbGx5IGZvciBmdW5jdGlvbiBpZiByZXR1cm4gc3dpdGNoIHRocm93IHRyeSB2YXIgd2hpbGUgd2l0aCBudWxsIHRydWUgZmFsc2UgaW5zdGFuY2VvZiB0eXBlb2Ygdm9pZCBkZWxldGUgbmV3IGluIHRoaXNcIjtcblxuICB2YXIga2V5d29yZHMgPSB7XG4gICAgNTogZWNtYTVBbmRMZXNzS2V5d29yZHMsXG4gICAgXCI1bW9kdWxlXCI6IGVjbWE1QW5kTGVzc0tleXdvcmRzICsgXCIgZXhwb3J0IGltcG9ydFwiLFxuICAgIDY6IGVjbWE1QW5kTGVzc0tleXdvcmRzICsgXCIgY29uc3QgY2xhc3MgZXh0ZW5kcyBleHBvcnQgaW1wb3J0IHN1cGVyXCJcbiAgfTtcblxuICB2YXIga2V5d29yZFJlbGF0aW9uYWxPcGVyYXRvciA9IC9eaW4oc3RhbmNlb2YpPyQvO1xuXG5cbiAgdmFyIG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0Q2hhcnMgPSBcIlxceGFhXFx4YjVcXHhiYVxceGMwLVxceGQ2XFx4ZDgtXFx4ZjZcXHhmOC1cXHUwMmMxXFx1MDJjNi1cXHUwMmQxXFx1MDJlMC1cXHUwMmU0XFx1MDJlY1xcdTAyZWVcXHUwMzcwLVxcdTAzNzRcXHUwMzc2XFx1MDM3N1xcdTAzN2EtXFx1MDM3ZFxcdTAzN2ZcXHUwMzg2XFx1MDM4OC1cXHUwMzhhXFx1MDM4Y1xcdTAzOGUtXFx1MDNhMVxcdTAzYTMtXFx1MDNmNVxcdTAzZjctXFx1MDQ4MVxcdTA0OGEtXFx1MDUyZlxcdTA1MzEtXFx1MDU1NlxcdTA1NTlcXHUwNTYwLVxcdTA1ODhcXHUwNWQwLVxcdTA1ZWFcXHUwNWVmLVxcdTA1ZjJcXHUwNjIwLVxcdTA2NGFcXHUwNjZlXFx1MDY2ZlxcdTA2NzEtXFx1MDZkM1xcdTA2ZDVcXHUwNmU1XFx1MDZlNlxcdTA2ZWVcXHUwNmVmXFx1MDZmYS1cXHUwNmZjXFx1MDZmZlxcdTA3MTBcXHUwNzEyLVxcdTA3MmZcXHUwNzRkLVxcdTA3YTVcXHUwN2IxXFx1MDdjYS1cXHUwN2VhXFx1MDdmNFxcdTA3ZjVcXHUwN2ZhXFx1MDgwMC1cXHUwODE1XFx1MDgxYVxcdTA4MjRcXHUwODI4XFx1MDg0MC1cXHUwODU4XFx1MDg2MC1cXHUwODZhXFx1MDhhMC1cXHUwOGI0XFx1MDhiNi1cXHUwOGM3XFx1MDkwNC1cXHUwOTM5XFx1MDkzZFxcdTA5NTBcXHUwOTU4LVxcdTA5NjFcXHUwOTcxLVxcdTA5ODBcXHUwOTg1LVxcdTA5OGNcXHUwOThmXFx1MDk5MFxcdTA5OTMtXFx1MDlhOFxcdTA5YWEtXFx1MDliMFxcdTA5YjJcXHUwOWI2LVxcdTA5YjlcXHUwOWJkXFx1MDljZVxcdTA5ZGNcXHUwOWRkXFx1MDlkZi1cXHUwOWUxXFx1MDlmMFxcdTA5ZjFcXHUwOWZjXFx1MGEwNS1cXHUwYTBhXFx1MGEwZlxcdTBhMTBcXHUwYTEzLVxcdTBhMjhcXHUwYTJhLVxcdTBhMzBcXHUwYTMyXFx1MGEzM1xcdTBhMzVcXHUwYTM2XFx1MGEzOFxcdTBhMzlcXHUwYTU5LVxcdTBhNWNcXHUwYTVlXFx1MGE3Mi1cXHUwYTc0XFx1MGE4NS1cXHUwYThkXFx1MGE4Zi1cXHUwYTkxXFx1MGE5My1cXHUwYWE4XFx1MGFhYS1cXHUwYWIwXFx1MGFiMlxcdTBhYjNcXHUwYWI1LVxcdTBhYjlcXHUwYWJkXFx1MGFkMFxcdTBhZTBcXHUwYWUxXFx1MGFmOVxcdTBiMDUtXFx1MGIwY1xcdTBiMGZcXHUwYjEwXFx1MGIxMy1cXHUwYjI4XFx1MGIyYS1cXHUwYjMwXFx1MGIzMlxcdTBiMzNcXHUwYjM1LVxcdTBiMzlcXHUwYjNkXFx1MGI1Y1xcdTBiNWRcXHUwYjVmLVxcdTBiNjFcXHUwYjcxXFx1MGI4M1xcdTBiODUtXFx1MGI4YVxcdTBiOGUtXFx1MGI5MFxcdTBiOTItXFx1MGI5NVxcdTBiOTlcXHUwYjlhXFx1MGI5Y1xcdTBiOWVcXHUwYjlmXFx1MGJhM1xcdTBiYTRcXHUwYmE4LVxcdTBiYWFcXHUwYmFlLVxcdTBiYjlcXHUwYmQwXFx1MGMwNS1cXHUwYzBjXFx1MGMwZS1cXHUwYzEwXFx1MGMxMi1cXHUwYzI4XFx1MGMyYS1cXHUwYzM5XFx1MGMzZFxcdTBjNTgtXFx1MGM1YVxcdTBjNjBcXHUwYzYxXFx1MGM4MFxcdTBjODUtXFx1MGM4Y1xcdTBjOGUtXFx1MGM5MFxcdTBjOTItXFx1MGNhOFxcdTBjYWEtXFx1MGNiM1xcdTBjYjUtXFx1MGNiOVxcdTBjYmRcXHUwY2RlXFx1MGNlMFxcdTBjZTFcXHUwY2YxXFx1MGNmMlxcdTBkMDQtXFx1MGQwY1xcdTBkMGUtXFx1MGQxMFxcdTBkMTItXFx1MGQzYVxcdTBkM2RcXHUwZDRlXFx1MGQ1NC1cXHUwZDU2XFx1MGQ1Zi1cXHUwZDYxXFx1MGQ3YS1cXHUwZDdmXFx1MGQ4NS1cXHUwZDk2XFx1MGQ5YS1cXHUwZGIxXFx1MGRiMy1cXHUwZGJiXFx1MGRiZFxcdTBkYzAtXFx1MGRjNlxcdTBlMDEtXFx1MGUzMFxcdTBlMzJcXHUwZTMzXFx1MGU0MC1cXHUwZTQ2XFx1MGU4MVxcdTBlODJcXHUwZTg0XFx1MGU4Ni1cXHUwZThhXFx1MGU4Yy1cXHUwZWEzXFx1MGVhNVxcdTBlYTctXFx1MGViMFxcdTBlYjJcXHUwZWIzXFx1MGViZFxcdTBlYzAtXFx1MGVjNFxcdTBlYzZcXHUwZWRjLVxcdTBlZGZcXHUwZjAwXFx1MGY0MC1cXHUwZjQ3XFx1MGY0OS1cXHUwZjZjXFx1MGY4OC1cXHUwZjhjXFx1MTAwMC1cXHUxMDJhXFx1MTAzZlxcdTEwNTAtXFx1MTA1NVxcdTEwNWEtXFx1MTA1ZFxcdTEwNjFcXHUxMDY1XFx1MTA2NlxcdTEwNmUtXFx1MTA3MFxcdTEwNzUtXFx1MTA4MVxcdTEwOGVcXHUxMGEwLVxcdTEwYzVcXHUxMGM3XFx1MTBjZFxcdTEwZDAtXFx1MTBmYVxcdTEwZmMtXFx1MTI0OFxcdTEyNGEtXFx1MTI0ZFxcdTEyNTAtXFx1MTI1NlxcdTEyNThcXHUxMjVhLVxcdTEyNWRcXHUxMjYwLVxcdTEyODhcXHUxMjhhLVxcdTEyOGRcXHUxMjkwLVxcdTEyYjBcXHUxMmIyLVxcdTEyYjVcXHUxMmI4LVxcdTEyYmVcXHUxMmMwXFx1MTJjMi1cXHUxMmM1XFx1MTJjOC1cXHUxMmQ2XFx1MTJkOC1cXHUxMzEwXFx1MTMxMi1cXHUxMzE1XFx1MTMxOC1cXHUxMzVhXFx1MTM4MC1cXHUxMzhmXFx1MTNhMC1cXHUxM2Y1XFx1MTNmOC1cXHUxM2ZkXFx1MTQwMS1cXHUxNjZjXFx1MTY2Zi1cXHUxNjdmXFx1MTY4MS1cXHUxNjlhXFx1MTZhMC1cXHUxNmVhXFx1MTZlZS1cXHUxNmY4XFx1MTcwMC1cXHUxNzBjXFx1MTcwZS1cXHUxNzExXFx1MTcyMC1cXHUxNzMxXFx1MTc0MC1cXHUxNzUxXFx1MTc2MC1cXHUxNzZjXFx1MTc2ZS1cXHUxNzcwXFx1MTc4MC1cXHUxN2IzXFx1MTdkN1xcdTE3ZGNcXHUxODIwLVxcdTE4NzhcXHUxODgwLVxcdTE4YThcXHUxOGFhXFx1MThiMC1cXHUxOGY1XFx1MTkwMC1cXHUxOTFlXFx1MTk1MC1cXHUxOTZkXFx1MTk3MC1cXHUxOTc0XFx1MTk4MC1cXHUxOWFiXFx1MTliMC1cXHUxOWM5XFx1MWEwMC1cXHUxYTE2XFx1MWEyMC1cXHUxYTU0XFx1MWFhN1xcdTFiMDUtXFx1MWIzM1xcdTFiNDUtXFx1MWI0YlxcdTFiODMtXFx1MWJhMFxcdTFiYWVcXHUxYmFmXFx1MWJiYS1cXHUxYmU1XFx1MWMwMC1cXHUxYzIzXFx1MWM0ZC1cXHUxYzRmXFx1MWM1YS1cXHUxYzdkXFx1MWM4MC1cXHUxYzg4XFx1MWM5MC1cXHUxY2JhXFx1MWNiZC1cXHUxY2JmXFx1MWNlOS1cXHUxY2VjXFx1MWNlZS1cXHUxY2YzXFx1MWNmNVxcdTFjZjZcXHUxY2ZhXFx1MWQwMC1cXHUxZGJmXFx1MWUwMC1cXHUxZjE1XFx1MWYxOC1cXHUxZjFkXFx1MWYyMC1cXHUxZjQ1XFx1MWY0OC1cXHUxZjRkXFx1MWY1MC1cXHUxZjU3XFx1MWY1OVxcdTFmNWJcXHUxZjVkXFx1MWY1Zi1cXHUxZjdkXFx1MWY4MC1cXHUxZmI0XFx1MWZiNi1cXHUxZmJjXFx1MWZiZVxcdTFmYzItXFx1MWZjNFxcdTFmYzYtXFx1MWZjY1xcdTFmZDAtXFx1MWZkM1xcdTFmZDYtXFx1MWZkYlxcdTFmZTAtXFx1MWZlY1xcdTFmZjItXFx1MWZmNFxcdTFmZjYtXFx1MWZmY1xcdTIwNzFcXHUyMDdmXFx1MjA5MC1cXHUyMDljXFx1MjEwMlxcdTIxMDdcXHUyMTBhLVxcdTIxMTNcXHUyMTE1XFx1MjExOC1cXHUyMTFkXFx1MjEyNFxcdTIxMjZcXHUyMTI4XFx1MjEyYS1cXHUyMTM5XFx1MjEzYy1cXHUyMTNmXFx1MjE0NS1cXHUyMTQ5XFx1MjE0ZVxcdTIxNjAtXFx1MjE4OFxcdTJjMDAtXFx1MmMyZVxcdTJjMzAtXFx1MmM1ZVxcdTJjNjAtXFx1MmNlNFxcdTJjZWItXFx1MmNlZVxcdTJjZjJcXHUyY2YzXFx1MmQwMC1cXHUyZDI1XFx1MmQyN1xcdTJkMmRcXHUyZDMwLVxcdTJkNjdcXHUyZDZmXFx1MmQ4MC1cXHUyZDk2XFx1MmRhMC1cXHUyZGE2XFx1MmRhOC1cXHUyZGFlXFx1MmRiMC1cXHUyZGI2XFx1MmRiOC1cXHUyZGJlXFx1MmRjMC1cXHUyZGM2XFx1MmRjOC1cXHUyZGNlXFx1MmRkMC1cXHUyZGQ2XFx1MmRkOC1cXHUyZGRlXFx1MzAwNS1cXHUzMDA3XFx1MzAyMS1cXHUzMDI5XFx1MzAzMS1cXHUzMDM1XFx1MzAzOC1cXHUzMDNjXFx1MzA0MS1cXHUzMDk2XFx1MzA5Yi1cXHUzMDlmXFx1MzBhMS1cXHUzMGZhXFx1MzBmYy1cXHUzMGZmXFx1MzEwNS1cXHUzMTJmXFx1MzEzMS1cXHUzMThlXFx1MzFhMC1cXHUzMWJmXFx1MzFmMC1cXHUzMWZmXFx1MzQwMC1cXHU0ZGJmXFx1NGUwMC1cXHU5ZmZjXFx1YTAwMC1cXHVhNDhjXFx1YTRkMC1cXHVhNGZkXFx1YTUwMC1cXHVhNjBjXFx1YTYxMC1cXHVhNjFmXFx1YTYyYVxcdWE2MmJcXHVhNjQwLVxcdWE2NmVcXHVhNjdmLVxcdWE2OWRcXHVhNmEwLVxcdWE2ZWZcXHVhNzE3LVxcdWE3MWZcXHVhNzIyLVxcdWE3ODhcXHVhNzhiLVxcdWE3YmZcXHVhN2MyLVxcdWE3Y2FcXHVhN2Y1LVxcdWE4MDFcXHVhODAzLVxcdWE4MDVcXHVhODA3LVxcdWE4MGFcXHVhODBjLVxcdWE4MjJcXHVhODQwLVxcdWE4NzNcXHVhODgyLVxcdWE4YjNcXHVhOGYyLVxcdWE4ZjdcXHVhOGZiXFx1YThmZFxcdWE4ZmVcXHVhOTBhLVxcdWE5MjVcXHVhOTMwLVxcdWE5NDZcXHVhOTYwLVxcdWE5N2NcXHVhOTg0LVxcdWE5YjJcXHVhOWNmXFx1YTllMC1cXHVhOWU0XFx1YTllNi1cXHVhOWVmXFx1YTlmYS1cXHVhOWZlXFx1YWEwMC1cXHVhYTI4XFx1YWE0MC1cXHVhYTQyXFx1YWE0NC1cXHVhYTRiXFx1YWE2MC1cXHVhYTc2XFx1YWE3YVxcdWFhN2UtXFx1YWFhZlxcdWFhYjFcXHVhYWI1XFx1YWFiNlxcdWFhYjktXFx1YWFiZFxcdWFhYzBcXHVhYWMyXFx1YWFkYi1cXHVhYWRkXFx1YWFlMC1cXHVhYWVhXFx1YWFmMi1cXHVhYWY0XFx1YWIwMS1cXHVhYjA2XFx1YWIwOS1cXHVhYjBlXFx1YWIxMS1cXHVhYjE2XFx1YWIyMC1cXHVhYjI2XFx1YWIyOC1cXHVhYjJlXFx1YWIzMC1cXHVhYjVhXFx1YWI1Yy1cXHVhYjY5XFx1YWI3MC1cXHVhYmUyXFx1YWMwMC1cXHVkN2EzXFx1ZDdiMC1cXHVkN2M2XFx1ZDdjYi1cXHVkN2ZiXFx1ZjkwMC1cXHVmYTZkXFx1ZmE3MC1cXHVmYWQ5XFx1ZmIwMC1cXHVmYjA2XFx1ZmIxMy1cXHVmYjE3XFx1ZmIxZFxcdWZiMWYtXFx1ZmIyOFxcdWZiMmEtXFx1ZmIzNlxcdWZiMzgtXFx1ZmIzY1xcdWZiM2VcXHVmYjQwXFx1ZmI0MVxcdWZiNDNcXHVmYjQ0XFx1ZmI0Ni1cXHVmYmIxXFx1ZmJkMy1cXHVmZDNkXFx1ZmQ1MC1cXHVmZDhmXFx1ZmQ5Mi1cXHVmZGM3XFx1ZmRmMC1cXHVmZGZiXFx1ZmU3MC1cXHVmZTc0XFx1ZmU3Ni1cXHVmZWZjXFx1ZmYyMS1cXHVmZjNhXFx1ZmY0MS1cXHVmZjVhXFx1ZmY2Ni1cXHVmZmJlXFx1ZmZjMi1cXHVmZmM3XFx1ZmZjYS1cXHVmZmNmXFx1ZmZkMi1cXHVmZmQ3XFx1ZmZkYS1cXHVmZmRjXCI7XG4gIHZhciBub25BU0NJSWlkZW50aWZpZXJDaGFycyA9IFwiXFx1MjAwY1xcdTIwMGRcXHhiN1xcdTAzMDAtXFx1MDM2ZlxcdTAzODdcXHUwNDgzLVxcdTA0ODdcXHUwNTkxLVxcdTA1YmRcXHUwNWJmXFx1MDVjMVxcdTA1YzJcXHUwNWM0XFx1MDVjNVxcdTA1YzdcXHUwNjEwLVxcdTA2MWFcXHUwNjRiLVxcdTA2NjlcXHUwNjcwXFx1MDZkNi1cXHUwNmRjXFx1MDZkZi1cXHUwNmU0XFx1MDZlN1xcdTA2ZThcXHUwNmVhLVxcdTA2ZWRcXHUwNmYwLVxcdTA2ZjlcXHUwNzExXFx1MDczMC1cXHUwNzRhXFx1MDdhNi1cXHUwN2IwXFx1MDdjMC1cXHUwN2M5XFx1MDdlYi1cXHUwN2YzXFx1MDdmZFxcdTA4MTYtXFx1MDgxOVxcdTA4MWItXFx1MDgyM1xcdTA4MjUtXFx1MDgyN1xcdTA4MjktXFx1MDgyZFxcdTA4NTktXFx1MDg1YlxcdTA4ZDMtXFx1MDhlMVxcdTA4ZTMtXFx1MDkwM1xcdTA5M2EtXFx1MDkzY1xcdTA5M2UtXFx1MDk0ZlxcdTA5NTEtXFx1MDk1N1xcdTA5NjJcXHUwOTYzXFx1MDk2Ni1cXHUwOTZmXFx1MDk4MS1cXHUwOTgzXFx1MDliY1xcdTA5YmUtXFx1MDljNFxcdTA5YzdcXHUwOWM4XFx1MDljYi1cXHUwOWNkXFx1MDlkN1xcdTA5ZTJcXHUwOWUzXFx1MDllNi1cXHUwOWVmXFx1MDlmZVxcdTBhMDEtXFx1MGEwM1xcdTBhM2NcXHUwYTNlLVxcdTBhNDJcXHUwYTQ3XFx1MGE0OFxcdTBhNGItXFx1MGE0ZFxcdTBhNTFcXHUwYTY2LVxcdTBhNzFcXHUwYTc1XFx1MGE4MS1cXHUwYTgzXFx1MGFiY1xcdTBhYmUtXFx1MGFjNVxcdTBhYzctXFx1MGFjOVxcdTBhY2ItXFx1MGFjZFxcdTBhZTJcXHUwYWUzXFx1MGFlNi1cXHUwYWVmXFx1MGFmYS1cXHUwYWZmXFx1MGIwMS1cXHUwYjAzXFx1MGIzY1xcdTBiM2UtXFx1MGI0NFxcdTBiNDdcXHUwYjQ4XFx1MGI0Yi1cXHUwYjRkXFx1MGI1NS1cXHUwYjU3XFx1MGI2MlxcdTBiNjNcXHUwYjY2LVxcdTBiNmZcXHUwYjgyXFx1MGJiZS1cXHUwYmMyXFx1MGJjNi1cXHUwYmM4XFx1MGJjYS1cXHUwYmNkXFx1MGJkN1xcdTBiZTYtXFx1MGJlZlxcdTBjMDAtXFx1MGMwNFxcdTBjM2UtXFx1MGM0NFxcdTBjNDYtXFx1MGM0OFxcdTBjNGEtXFx1MGM0ZFxcdTBjNTVcXHUwYzU2XFx1MGM2MlxcdTBjNjNcXHUwYzY2LVxcdTBjNmZcXHUwYzgxLVxcdTBjODNcXHUwY2JjXFx1MGNiZS1cXHUwY2M0XFx1MGNjNi1cXHUwY2M4XFx1MGNjYS1cXHUwY2NkXFx1MGNkNVxcdTBjZDZcXHUwY2UyXFx1MGNlM1xcdTBjZTYtXFx1MGNlZlxcdTBkMDAtXFx1MGQwM1xcdTBkM2JcXHUwZDNjXFx1MGQzZS1cXHUwZDQ0XFx1MGQ0Ni1cXHUwZDQ4XFx1MGQ0YS1cXHUwZDRkXFx1MGQ1N1xcdTBkNjJcXHUwZDYzXFx1MGQ2Ni1cXHUwZDZmXFx1MGQ4MS1cXHUwZDgzXFx1MGRjYVxcdTBkY2YtXFx1MGRkNFxcdTBkZDZcXHUwZGQ4LVxcdTBkZGZcXHUwZGU2LVxcdTBkZWZcXHUwZGYyXFx1MGRmM1xcdTBlMzFcXHUwZTM0LVxcdTBlM2FcXHUwZTQ3LVxcdTBlNGVcXHUwZTUwLVxcdTBlNTlcXHUwZWIxXFx1MGViNC1cXHUwZWJjXFx1MGVjOC1cXHUwZWNkXFx1MGVkMC1cXHUwZWQ5XFx1MGYxOFxcdTBmMTlcXHUwZjIwLVxcdTBmMjlcXHUwZjM1XFx1MGYzN1xcdTBmMzlcXHUwZjNlXFx1MGYzZlxcdTBmNzEtXFx1MGY4NFxcdTBmODZcXHUwZjg3XFx1MGY4ZC1cXHUwZjk3XFx1MGY5OS1cXHUwZmJjXFx1MGZjNlxcdTEwMmItXFx1MTAzZVxcdTEwNDAtXFx1MTA0OVxcdTEwNTYtXFx1MTA1OVxcdTEwNWUtXFx1MTA2MFxcdTEwNjItXFx1MTA2NFxcdTEwNjctXFx1MTA2ZFxcdTEwNzEtXFx1MTA3NFxcdTEwODItXFx1MTA4ZFxcdTEwOGYtXFx1MTA5ZFxcdTEzNWQtXFx1MTM1ZlxcdTEzNjktXFx1MTM3MVxcdTE3MTItXFx1MTcxNFxcdTE3MzItXFx1MTczNFxcdTE3NTJcXHUxNzUzXFx1MTc3MlxcdTE3NzNcXHUxN2I0LVxcdTE3ZDNcXHUxN2RkXFx1MTdlMC1cXHUxN2U5XFx1MTgwYi1cXHUxODBkXFx1MTgxMC1cXHUxODE5XFx1MThhOVxcdTE5MjAtXFx1MTkyYlxcdTE5MzAtXFx1MTkzYlxcdTE5NDYtXFx1MTk0ZlxcdTE5ZDAtXFx1MTlkYVxcdTFhMTctXFx1MWExYlxcdTFhNTUtXFx1MWE1ZVxcdTFhNjAtXFx1MWE3Y1xcdTFhN2YtXFx1MWE4OVxcdTFhOTAtXFx1MWE5OVxcdTFhYjAtXFx1MWFiZFxcdTFhYmZcXHUxYWMwXFx1MWIwMC1cXHUxYjA0XFx1MWIzNC1cXHUxYjQ0XFx1MWI1MC1cXHUxYjU5XFx1MWI2Yi1cXHUxYjczXFx1MWI4MC1cXHUxYjgyXFx1MWJhMS1cXHUxYmFkXFx1MWJiMC1cXHUxYmI5XFx1MWJlNi1cXHUxYmYzXFx1MWMyNC1cXHUxYzM3XFx1MWM0MC1cXHUxYzQ5XFx1MWM1MC1cXHUxYzU5XFx1MWNkMC1cXHUxY2QyXFx1MWNkNC1cXHUxY2U4XFx1MWNlZFxcdTFjZjRcXHUxY2Y3LVxcdTFjZjlcXHUxZGMwLVxcdTFkZjlcXHUxZGZiLVxcdTFkZmZcXHUyMDNmXFx1MjA0MFxcdTIwNTRcXHUyMGQwLVxcdTIwZGNcXHUyMGUxXFx1MjBlNS1cXHUyMGYwXFx1MmNlZi1cXHUyY2YxXFx1MmQ3ZlxcdTJkZTAtXFx1MmRmZlxcdTMwMmEtXFx1MzAyZlxcdTMwOTlcXHUzMDlhXFx1YTYyMC1cXHVhNjI5XFx1YTY2ZlxcdWE2NzQtXFx1YTY3ZFxcdWE2OWVcXHVhNjlmXFx1YTZmMFxcdWE2ZjFcXHVhODAyXFx1YTgwNlxcdWE4MGJcXHVhODIzLVxcdWE4MjdcXHVhODJjXFx1YTg4MFxcdWE4ODFcXHVhOGI0LVxcdWE4YzVcXHVhOGQwLVxcdWE4ZDlcXHVhOGUwLVxcdWE4ZjFcXHVhOGZmLVxcdWE5MDlcXHVhOTI2LVxcdWE5MmRcXHVhOTQ3LVxcdWE5NTNcXHVhOTgwLVxcdWE5ODNcXHVhOWIzLVxcdWE5YzBcXHVhOWQwLVxcdWE5ZDlcXHVhOWU1XFx1YTlmMC1cXHVhOWY5XFx1YWEyOS1cXHVhYTM2XFx1YWE0M1xcdWFhNGNcXHVhYTRkXFx1YWE1MC1cXHVhYTU5XFx1YWE3Yi1cXHVhYTdkXFx1YWFiMFxcdWFhYjItXFx1YWFiNFxcdWFhYjdcXHVhYWI4XFx1YWFiZVxcdWFhYmZcXHVhYWMxXFx1YWFlYi1cXHVhYWVmXFx1YWFmNVxcdWFhZjZcXHVhYmUzLVxcdWFiZWFcXHVhYmVjXFx1YWJlZFxcdWFiZjAtXFx1YWJmOVxcdWZiMWVcXHVmZTAwLVxcdWZlMGZcXHVmZTIwLVxcdWZlMmZcXHVmZTMzXFx1ZmUzNFxcdWZlNGQtXFx1ZmU0ZlxcdWZmMTAtXFx1ZmYxOVxcdWZmM2ZcIjtcblxuICB2YXIgbm9uQVNDSUlpZGVudGlmaWVyU3RhcnQgPSBuZXcgUmVnRXhwKFwiW1wiICsgbm9uQVNDSUlpZGVudGlmaWVyU3RhcnRDaGFycyArIFwiXVwiKTtcbiAgdmFyIG5vbkFTQ0lJaWRlbnRpZmllciA9IG5ldyBSZWdFeHAoXCJbXCIgKyBub25BU0NJSWlkZW50aWZpZXJTdGFydENoYXJzICsgbm9uQVNDSUlpZGVudGlmaWVyQ2hhcnMgKyBcIl1cIik7XG5cbiAgbm9uQVNDSUlpZGVudGlmaWVyU3RhcnRDaGFycyA9IG5vbkFTQ0lJaWRlbnRpZmllckNoYXJzID0gbnVsbDtcblxuXG4gIHZhciBhc3RyYWxJZGVudGlmaWVyU3RhcnRDb2RlcyA9IFswLDExLDIsMjUsMiwxOCwyLDEsMiwxNCwzLDEzLDM1LDEyMiw3MCw1MiwyNjgsMjgsNCw0OCw0OCwzMSwxNCwyOSw2LDM3LDExLDI5LDMsMzUsNSw3LDIsNCw0MywxNTcsMTksMzUsNSwzNSw1LDM5LDksNTEsMTU3LDMxMCwxMCwyMSwxMSw3LDE1Myw1LDMsMCwyLDQzLDIsMSw0LDAsMywyMiwxMSwyMiwxMCwzMCw2NiwxOCwyLDEsMTEsMjEsMTEsMjUsNzEsNTUsNywxLDY1LDAsMTYsMywyLDIsMiwyOCw0MywyOCw0LDI4LDM2LDcsMiwyNywyOCw1MywxMSwyMSwxMSwxOCwxNCwxNywxMTEsNzIsNTYsNTAsMTQsNTAsMTQsMzUsMzQ5LDQxLDcsMSw3OSwyOCwxMSwwLDksMjEsMTA3LDIwLDI4LDIyLDEzLDUyLDc2LDQ0LDMzLDI0LDI3LDM1LDMwLDAsMywwLDksMzQsNCwwLDEzLDQ3LDE1LDMsMjIsMCwyLDAsMzYsMTcsMiwyNCw4NSw2LDIsMCwyLDMsMiwxNCwyLDksOCw0NiwzOSw3LDMsMSwzLDIxLDIsNiwyLDEsMiw0LDQsMCwxOSwwLDEzLDQsMTU5LDUyLDE5LDMsMjEsMiwzMSw0NywyMSwxLDIsMCwxODUsNDYsNDIsMywzNyw0NywyMSwwLDYwLDQyLDE0LDAsNzIsMjYsMjMwLDQzLDExNyw2MywzMiw3LDMsMCwzLDcsMiwxLDIsMjMsMTYsMCwyLDAsOTUsNywzLDM4LDE3LDAsMiwwLDI5LDAsMTEsMzksOCwwLDIyLDAsMTIsNDUsMjAsMCwzNSw1NiwyNjQsOCwyLDM2LDE4LDAsNTAsMjksMTEzLDYsMiwxLDIsMzcsMjIsMCwyNiw1LDIsMSwyLDMxLDE1LDAsMzI4LDE4LDE5MCwwLDgwLDkyMSwxMDMsMTEwLDE4LDE5NSwyNzQ5LDEwNzAsNDA1MCw1ODIsODYzNCw1NjgsOCwzMCwxMTQsMjksMTksNDcsMTcsMywzMiwyMCw2LDE4LDY4OSw2MywxMjksNzQsNiwwLDY3LDEyLDY1LDEsMiwwLDI5LDYxMzUsOSwxMjM3LDQzLDgsODk1MiwyODYsNTAsMiwxOCwzLDksMzk1LDIzMDksMTA2LDYsMTIsNCw4LDgsOSw1OTkxLDg0LDIsNzAsMiwxLDMsMCwzLDEsMywzLDIsMTEsMiwwLDIsNiwyLDY0LDIsMywzLDcsMiw2LDIsMjcsMiwzLDIsNCwyLDAsNCw2LDIsMzM5LDMsMjQsMiwyNCwyLDMwLDIsMjQsMiwzMCwyLDI0LDIsMzAsMiwyNCwyLDMwLDIsMjQsMiw3LDIzNTcsNDQsMTEsNiwxNywwLDM3MCw0MywxMzAxLDE5Niw2MCw2Nyw4LDAsMTIwNSwzLDIsMjYsMiwxLDIsMCwzLDAsMiw5LDIsMywyLDAsMiwwLDcsMCw1LDAsMiwwLDIsMCwyLDIsMiwxLDIsMCwzLDAsMiwwLDIsMCwyLDAsMiwwLDIsMSwyLDAsMywzLDIsNiwyLDMsMiwzLDIsMCwyLDksMiwxNiw2LDIsMiw0LDIsMTYsNDQyMSw0MjcxNywzNSw0MTQ4LDEyLDIyMSwzLDU3NjEsMTUsNzQ3MiwzMTA0LDU0MSwxNTA3LDQ5MzhdO1xuXG4gIHZhciBhc3RyYWxJZGVudGlmaWVyQ29kZXMgPSBbNTA5LDAsMjI3LDAsMTUwLDQsMjk0LDksMTM2OCwyLDIsMSw2LDMsNDEsMiw1LDAsMTY2LDEsNTc0LDMsOSw5LDM3MCwxLDE1NCwxMCwxNzYsMiw1NCwxNCwzMiw5LDE2LDMsNDYsMTAsNTQsOSw3LDIsMzcsMTMsMiw5LDYsMSw0NSwwLDEzLDIsNDksMTMsOSwzLDIsMTEsODMsMTEsNywwLDE2MSwxMSw2LDksNywzLDU2LDEsMiw2LDMsMSwzLDIsMTAsMCwxMSwxLDMsNiw0LDQsMTkzLDE3LDEwLDksNSwwLDgyLDE5LDEzLDksMjE0LDYsMyw4LDI4LDEsODMsMTYsMTYsOSw4MiwxMiw5LDksODQsMTQsNSw5LDI0MywxNCwxNjYsOSw3MSw1LDIsMSwzLDMsMiwwLDIsMSwxMyw5LDEyMCw2LDMsNiw0LDAsMjksOSw0MSw2LDIsMyw5LDAsMTAsMTAsNDcsMTUsNDA2LDcsMiw3LDE3LDksNTcsMjEsMiwxMywxMjMsNSw0LDAsMiwxLDIsNiwyLDAsOSw5LDQ5LDQsMiwxLDIsNCw5LDksMzMwLDMsMTkzMDYsOSwxMzUsNCw2MCw2LDI2LDksMTAxNCwwLDIsNTQsOCwzLDgyLDAsMTIsMSwxOTYyOCwxLDUzMTksNCw0LDUsOSw3LDMsNiwzMSwzLDE0OSwyLDE0MTgsNDksNTEzLDU0LDUsNDksOSwwLDE1LDAsMjMsNCwyLDE0LDEzNjEsNiwyLDE2LDMsNiwyLDEsMiw0LDI2Miw2LDEwLDksNDE5LDEzLDE0OTUsNiwxMTAsNiw2LDksNDc1OSw5LDc4NzcxOSwyMzldO1xuXG4gIGZ1bmN0aW9uIGlzSW5Bc3RyYWxTZXQoY29kZSwgc2V0KSB7XG4gICAgdmFyIHBvcyA9IDB4MTAwMDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZXQubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgIHBvcyArPSBzZXRbaV07XG4gICAgICBpZiAocG9zID4gY29kZSkgeyByZXR1cm4gZmFsc2UgfVxuICAgICAgcG9zICs9IHNldFtpICsgMV07XG4gICAgICBpZiAocG9zID49IGNvZGUpIHsgcmV0dXJuIHRydWUgfVxuICAgIH1cbiAgfVxuXG5cbiAgZnVuY3Rpb24gaXNJZGVudGlmaWVyU3RhcnQoY29kZSwgYXN0cmFsKSB7XG4gICAgaWYgKGNvZGUgPCA2NSkgeyByZXR1cm4gY29kZSA9PT0gMzYgfVxuICAgIGlmIChjb2RlIDwgOTEpIHsgcmV0dXJuIHRydWUgfVxuICAgIGlmIChjb2RlIDwgOTcpIHsgcmV0dXJuIGNvZGUgPT09IDk1IH1cbiAgICBpZiAoY29kZSA8IDEyMykgeyByZXR1cm4gdHJ1ZSB9XG4gICAgaWYgKGNvZGUgPD0gMHhmZmZmKSB7IHJldHVybiBjb2RlID49IDB4YWEgJiYgbm9uQVNDSUlpZGVudGlmaWVyU3RhcnQudGVzdChTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpKSB9XG4gICAgaWYgKGFzdHJhbCA9PT0gZmFsc2UpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICByZXR1cm4gaXNJbkFzdHJhbFNldChjb2RlLCBhc3RyYWxJZGVudGlmaWVyU3RhcnRDb2RlcylcbiAgfVxuXG5cbiAgZnVuY3Rpb24gaXNJZGVudGlmaWVyQ2hhcihjb2RlLCBhc3RyYWwpIHtcbiAgICBpZiAoY29kZSA8IDQ4KSB7IHJldHVybiBjb2RlID09PSAzNiB9XG4gICAgaWYgKGNvZGUgPCA1OCkgeyByZXR1cm4gdHJ1ZSB9XG4gICAgaWYgKGNvZGUgPCA2NSkgeyByZXR1cm4gZmFsc2UgfVxuICAgIGlmIChjb2RlIDwgOTEpIHsgcmV0dXJuIHRydWUgfVxuICAgIGlmIChjb2RlIDwgOTcpIHsgcmV0dXJuIGNvZGUgPT09IDk1IH1cbiAgICBpZiAoY29kZSA8IDEyMykgeyByZXR1cm4gdHJ1ZSB9XG4gICAgaWYgKGNvZGUgPD0gMHhmZmZmKSB7IHJldHVybiBjb2RlID49IDB4YWEgJiYgbm9uQVNDSUlpZGVudGlmaWVyLnRlc3QoU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKSkgfVxuICAgIGlmIChhc3RyYWwgPT09IGZhbHNlKSB7IHJldHVybiBmYWxzZSB9XG4gICAgcmV0dXJuIGlzSW5Bc3RyYWxTZXQoY29kZSwgYXN0cmFsSWRlbnRpZmllclN0YXJ0Q29kZXMpIHx8IGlzSW5Bc3RyYWxTZXQoY29kZSwgYXN0cmFsSWRlbnRpZmllckNvZGVzKVxuICB9XG5cblxuXG5cblxuICB2YXIgVG9rZW5UeXBlID0gZnVuY3Rpb24gVG9rZW5UeXBlKGxhYmVsLCBjb25mKSB7XG4gICAgaWYgKCBjb25mID09PSB2b2lkIDAgKSBjb25mID0ge307XG5cbiAgICB0aGlzLmxhYmVsID0gbGFiZWw7XG4gICAgdGhpcy5rZXl3b3JkID0gY29uZi5rZXl3b3JkO1xuICAgIHRoaXMuYmVmb3JlRXhwciA9ICEhY29uZi5iZWZvcmVFeHByO1xuICAgIHRoaXMuc3RhcnRzRXhwciA9ICEhY29uZi5zdGFydHNFeHByO1xuICAgIHRoaXMuaXNMb29wID0gISFjb25mLmlzTG9vcDtcbiAgICB0aGlzLmlzQXNzaWduID0gISFjb25mLmlzQXNzaWduO1xuICAgIHRoaXMucHJlZml4ID0gISFjb25mLnByZWZpeDtcbiAgICB0aGlzLnBvc3RmaXggPSAhIWNvbmYucG9zdGZpeDtcbiAgICB0aGlzLmJpbm9wID0gY29uZi5iaW5vcCB8fCBudWxsO1xuICAgIHRoaXMudXBkYXRlQ29udGV4dCA9IG51bGw7XG4gIH07XG5cbiAgZnVuY3Rpb24gYmlub3AobmFtZSwgcHJlYykge1xuICAgIHJldHVybiBuZXcgVG9rZW5UeXBlKG5hbWUsIHtiZWZvcmVFeHByOiB0cnVlLCBiaW5vcDogcHJlY30pXG4gIH1cbiAgdmFyIGJlZm9yZUV4cHIgPSB7YmVmb3JlRXhwcjogdHJ1ZX0sIHN0YXJ0c0V4cHIgPSB7c3RhcnRzRXhwcjogdHJ1ZX07XG5cblxuICB2YXIga2V5d29yZHMkMSA9IHt9O1xuXG4gIGZ1bmN0aW9uIGt3KG5hbWUsIG9wdGlvbnMpIHtcbiAgICBpZiAoIG9wdGlvbnMgPT09IHZvaWQgMCApIG9wdGlvbnMgPSB7fTtcblxuICAgIG9wdGlvbnMua2V5d29yZCA9IG5hbWU7XG4gICAgcmV0dXJuIGtleXdvcmRzJDFbbmFtZV0gPSBuZXcgVG9rZW5UeXBlKG5hbWUsIG9wdGlvbnMpXG4gIH1cblxuICB2YXIgdHlwZXMgPSB7XG4gICAgbnVtOiBuZXcgVG9rZW5UeXBlKFwibnVtXCIsIHN0YXJ0c0V4cHIpLFxuICAgIHJlZ2V4cDogbmV3IFRva2VuVHlwZShcInJlZ2V4cFwiLCBzdGFydHNFeHByKSxcbiAgICBzdHJpbmc6IG5ldyBUb2tlblR5cGUoXCJzdHJpbmdcIiwgc3RhcnRzRXhwciksXG4gICAgbmFtZTogbmV3IFRva2VuVHlwZShcIm5hbWVcIiwgc3RhcnRzRXhwciksXG4gICAgZW9mOiBuZXcgVG9rZW5UeXBlKFwiZW9mXCIpLFxuXG4gICAgYnJhY2tldEw6IG5ldyBUb2tlblR5cGUoXCJbXCIsIHtiZWZvcmVFeHByOiB0cnVlLCBzdGFydHNFeHByOiB0cnVlfSksXG4gICAgYnJhY2tldFI6IG5ldyBUb2tlblR5cGUoXCJdXCIpLFxuICAgIGJyYWNlTDogbmV3IFRva2VuVHlwZShcIntcIiwge2JlZm9yZUV4cHI6IHRydWUsIHN0YXJ0c0V4cHI6IHRydWV9KSxcbiAgICBicmFjZVI6IG5ldyBUb2tlblR5cGUoXCJ9XCIpLFxuICAgIHBhcmVuTDogbmV3IFRva2VuVHlwZShcIihcIiwge2JlZm9yZUV4cHI6IHRydWUsIHN0YXJ0c0V4cHI6IHRydWV9KSxcbiAgICBwYXJlblI6IG5ldyBUb2tlblR5cGUoXCIpXCIpLFxuICAgIGNvbW1hOiBuZXcgVG9rZW5UeXBlKFwiLFwiLCBiZWZvcmVFeHByKSxcbiAgICBzZW1pOiBuZXcgVG9rZW5UeXBlKFwiO1wiLCBiZWZvcmVFeHByKSxcbiAgICBjb2xvbjogbmV3IFRva2VuVHlwZShcIjpcIiwgYmVmb3JlRXhwciksXG4gICAgZG90OiBuZXcgVG9rZW5UeXBlKFwiLlwiKSxcbiAgICBxdWVzdGlvbjogbmV3IFRva2VuVHlwZShcIj9cIiwgYmVmb3JlRXhwciksXG4gICAgcXVlc3Rpb25Eb3Q6IG5ldyBUb2tlblR5cGUoXCI/LlwiKSxcbiAgICBhcnJvdzogbmV3IFRva2VuVHlwZShcIj0+XCIsIGJlZm9yZUV4cHIpLFxuICAgIHRlbXBsYXRlOiBuZXcgVG9rZW5UeXBlKFwidGVtcGxhdGVcIiksXG4gICAgaW52YWxpZFRlbXBsYXRlOiBuZXcgVG9rZW5UeXBlKFwiaW52YWxpZFRlbXBsYXRlXCIpLFxuICAgIGVsbGlwc2lzOiBuZXcgVG9rZW5UeXBlKFwiLi4uXCIsIGJlZm9yZUV4cHIpLFxuICAgIGJhY2tRdW90ZTogbmV3IFRva2VuVHlwZShcImBcIiwgc3RhcnRzRXhwciksXG4gICAgZG9sbGFyQnJhY2VMOiBuZXcgVG9rZW5UeXBlKFwiJHtcIiwge2JlZm9yZUV4cHI6IHRydWUsIHN0YXJ0c0V4cHI6IHRydWV9KSxcblxuXG4gICAgZXE6IG5ldyBUb2tlblR5cGUoXCI9XCIsIHtiZWZvcmVFeHByOiB0cnVlLCBpc0Fzc2lnbjogdHJ1ZX0pLFxuICAgIGFzc2lnbjogbmV3IFRva2VuVHlwZShcIl89XCIsIHtiZWZvcmVFeHByOiB0cnVlLCBpc0Fzc2lnbjogdHJ1ZX0pLFxuICAgIGluY0RlYzogbmV3IFRva2VuVHlwZShcIisrLy0tXCIsIHtwcmVmaXg6IHRydWUsIHBvc3RmaXg6IHRydWUsIHN0YXJ0c0V4cHI6IHRydWV9KSxcbiAgICBwcmVmaXg6IG5ldyBUb2tlblR5cGUoXCIhL35cIiwge2JlZm9yZUV4cHI6IHRydWUsIHByZWZpeDogdHJ1ZSwgc3RhcnRzRXhwcjogdHJ1ZX0pLFxuICAgIGxvZ2ljYWxPUjogYmlub3AoXCJ8fFwiLCAxKSxcbiAgICBsb2dpY2FsQU5EOiBiaW5vcChcIiYmXCIsIDIpLFxuICAgIGJpdHdpc2VPUjogYmlub3AoXCJ8XCIsIDMpLFxuICAgIGJpdHdpc2VYT1I6IGJpbm9wKFwiXlwiLCA0KSxcbiAgICBiaXR3aXNlQU5EOiBiaW5vcChcIiZcIiwgNSksXG4gICAgZXF1YWxpdHk6IGJpbm9wKFwiPT0vIT0vPT09LyE9PVwiLCA2KSxcbiAgICByZWxhdGlvbmFsOiBiaW5vcChcIjwvPi88PS8+PVwiLCA3KSxcbiAgICBiaXRTaGlmdDogYmlub3AoXCI8PC8+Pi8+Pj5cIiwgOCksXG4gICAgcGx1c01pbjogbmV3IFRva2VuVHlwZShcIisvLVwiLCB7YmVmb3JlRXhwcjogdHJ1ZSwgYmlub3A6IDksIHByZWZpeDogdHJ1ZSwgc3RhcnRzRXhwcjogdHJ1ZX0pLFxuICAgIG1vZHVsbzogYmlub3AoXCIlXCIsIDEwKSxcbiAgICBzdGFyOiBiaW5vcChcIipcIiwgMTApLFxuICAgIHNsYXNoOiBiaW5vcChcIi9cIiwgMTApLFxuICAgIHN0YXJzdGFyOiBuZXcgVG9rZW5UeXBlKFwiKipcIiwge2JlZm9yZUV4cHI6IHRydWV9KSxcbiAgICBjb2FsZXNjZTogYmlub3AoXCI/P1wiLCAxKSxcblxuICAgIF9icmVhazoga3coXCJicmVha1wiKSxcbiAgICBfY2FzZToga3coXCJjYXNlXCIsIGJlZm9yZUV4cHIpLFxuICAgIF9jYXRjaDoga3coXCJjYXRjaFwiKSxcbiAgICBfY29udGludWU6IGt3KFwiY29udGludWVcIiksXG4gICAgX2RlYnVnZ2VyOiBrdyhcImRlYnVnZ2VyXCIpLFxuICAgIF9kZWZhdWx0OiBrdyhcImRlZmF1bHRcIiwgYmVmb3JlRXhwciksXG4gICAgX2RvOiBrdyhcImRvXCIsIHtpc0xvb3A6IHRydWUsIGJlZm9yZUV4cHI6IHRydWV9KSxcbiAgICBfZWxzZToga3coXCJlbHNlXCIsIGJlZm9yZUV4cHIpLFxuICAgIF9maW5hbGx5OiBrdyhcImZpbmFsbHlcIiksXG4gICAgX2Zvcjoga3coXCJmb3JcIiwge2lzTG9vcDogdHJ1ZX0pLFxuICAgIF9mdW5jdGlvbjoga3coXCJmdW5jdGlvblwiLCBzdGFydHNFeHByKSxcbiAgICBfaWY6IGt3KFwiaWZcIiksXG4gICAgX3JldHVybjoga3coXCJyZXR1cm5cIiwgYmVmb3JlRXhwciksXG4gICAgX3N3aXRjaDoga3coXCJzd2l0Y2hcIiksXG4gICAgX3Rocm93OiBrdyhcInRocm93XCIsIGJlZm9yZUV4cHIpLFxuICAgIF90cnk6IGt3KFwidHJ5XCIpLFxuICAgIF92YXI6IGt3KFwidmFyXCIpLFxuICAgIF9jb25zdDoga3coXCJjb25zdFwiKSxcbiAgICBfd2hpbGU6IGt3KFwid2hpbGVcIiwge2lzTG9vcDogdHJ1ZX0pLFxuICAgIF93aXRoOiBrdyhcIndpdGhcIiksXG4gICAgX25ldzoga3coXCJuZXdcIiwge2JlZm9yZUV4cHI6IHRydWUsIHN0YXJ0c0V4cHI6IHRydWV9KSxcbiAgICBfdGhpczoga3coXCJ0aGlzXCIsIHN0YXJ0c0V4cHIpLFxuICAgIF9zdXBlcjoga3coXCJzdXBlclwiLCBzdGFydHNFeHByKSxcbiAgICBfY2xhc3M6IGt3KFwiY2xhc3NcIiwgc3RhcnRzRXhwciksXG4gICAgX2V4dGVuZHM6IGt3KFwiZXh0ZW5kc1wiLCBiZWZvcmVFeHByKSxcbiAgICBfZXhwb3J0OiBrdyhcImV4cG9ydFwiKSxcbiAgICBfaW1wb3J0OiBrdyhcImltcG9ydFwiLCBzdGFydHNFeHByKSxcbiAgICBfbnVsbDoga3coXCJudWxsXCIsIHN0YXJ0c0V4cHIpLFxuICAgIF90cnVlOiBrdyhcInRydWVcIiwgc3RhcnRzRXhwciksXG4gICAgX2ZhbHNlOiBrdyhcImZhbHNlXCIsIHN0YXJ0c0V4cHIpLFxuICAgIF9pbjoga3coXCJpblwiLCB7YmVmb3JlRXhwcjogdHJ1ZSwgYmlub3A6IDd9KSxcbiAgICBfaW5zdGFuY2VvZjoga3coXCJpbnN0YW5jZW9mXCIsIHtiZWZvcmVFeHByOiB0cnVlLCBiaW5vcDogN30pLFxuICAgIF90eXBlb2Y6IGt3KFwidHlwZW9mXCIsIHtiZWZvcmVFeHByOiB0cnVlLCBwcmVmaXg6IHRydWUsIHN0YXJ0c0V4cHI6IHRydWV9KSxcbiAgICBfdm9pZDoga3coXCJ2b2lkXCIsIHtiZWZvcmVFeHByOiB0cnVlLCBwcmVmaXg6IHRydWUsIHN0YXJ0c0V4cHI6IHRydWV9KSxcbiAgICBfZGVsZXRlOiBrdyhcImRlbGV0ZVwiLCB7YmVmb3JlRXhwcjogdHJ1ZSwgcHJlZml4OiB0cnVlLCBzdGFydHNFeHByOiB0cnVlfSlcbiAgfTtcblxuXG4gIHZhciBsaW5lQnJlYWsgPSAvXFxyXFxuP3xcXG58XFx1MjAyOHxcXHUyMDI5LztcbiAgdmFyIGxpbmVCcmVha0cgPSBuZXcgUmVnRXhwKGxpbmVCcmVhay5zb3VyY2UsIFwiZ1wiKTtcblxuICBmdW5jdGlvbiBpc05ld0xpbmUoY29kZSwgZWNtYTIwMTlTdHJpbmcpIHtcbiAgICByZXR1cm4gY29kZSA9PT0gMTAgfHwgY29kZSA9PT0gMTMgfHwgKCFlY21hMjAxOVN0cmluZyAmJiAoY29kZSA9PT0gMHgyMDI4IHx8IGNvZGUgPT09IDB4MjAyOSkpXG4gIH1cblxuICB2YXIgbm9uQVNDSUl3aGl0ZXNwYWNlID0gL1tcXHUxNjgwXFx1MjAwMC1cXHUyMDBhXFx1MjAyZlxcdTIwNWZcXHUzMDAwXFx1ZmVmZl0vO1xuXG4gIHZhciBza2lwV2hpdGVTcGFjZSA9IC8oPzpcXHN8XFwvXFwvLip8XFwvXFwqW15dKj9cXCpcXC8pKi9nO1xuXG4gIHZhciByZWYgPSBPYmplY3QucHJvdG90eXBlO1xuICB2YXIgaGFzT3duUHJvcGVydHkgPSByZWYuaGFzT3duUHJvcGVydHk7XG4gIHZhciB0b1N0cmluZyA9IHJlZi50b1N0cmluZztcblxuXG4gIGZ1bmN0aW9uIGhhcyhvYmosIHByb3BOYW1lKSB7XG4gICAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wTmFtZSlcbiAgfVxuXG4gIHZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCAoZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gKFxuICAgIHRvU3RyaW5nLmNhbGwob2JqKSA9PT0gXCJbb2JqZWN0IEFycmF5XVwiXG4gICk7IH0pO1xuXG4gIGZ1bmN0aW9uIHdvcmRzUmVnZXhwKHdvcmRzKSB7XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoXCJeKD86XCIgKyB3b3Jkcy5yZXBsYWNlKC8gL2csIFwifFwiKSArIFwiKSRcIilcbiAgfVxuXG5cbiAgdmFyIFBvc2l0aW9uID0gZnVuY3Rpb24gUG9zaXRpb24obGluZSwgY29sKSB7XG4gICAgdGhpcy5saW5lID0gbGluZTtcbiAgICB0aGlzLmNvbHVtbiA9IGNvbDtcbiAgfTtcblxuICBQb3NpdGlvbi5wcm90b3R5cGUub2Zmc2V0ID0gZnVuY3Rpb24gb2Zmc2V0IChuKSB7XG4gICAgcmV0dXJuIG5ldyBQb3NpdGlvbih0aGlzLmxpbmUsIHRoaXMuY29sdW1uICsgbilcbiAgfTtcblxuICB2YXIgU291cmNlTG9jYXRpb24gPSBmdW5jdGlvbiBTb3VyY2VMb2NhdGlvbihwLCBzdGFydCwgZW5kKSB7XG4gICAgdGhpcy5zdGFydCA9IHN0YXJ0O1xuICAgIHRoaXMuZW5kID0gZW5kO1xuICAgIGlmIChwLnNvdXJjZUZpbGUgIT09IG51bGwpIHsgdGhpcy5zb3VyY2UgPSBwLnNvdXJjZUZpbGU7IH1cbiAgfTtcblxuXG4gIGZ1bmN0aW9uIGdldExpbmVJbmZvKGlucHV0LCBvZmZzZXQpIHtcbiAgICBmb3IgKHZhciBsaW5lID0gMSwgY3VyID0gMDs7KSB7XG4gICAgICBsaW5lQnJlYWtHLmxhc3RJbmRleCA9IGN1cjtcbiAgICAgIHZhciBtYXRjaCA9IGxpbmVCcmVha0cuZXhlYyhpbnB1dCk7XG4gICAgICBpZiAobWF0Y2ggJiYgbWF0Y2guaW5kZXggPCBvZmZzZXQpIHtcbiAgICAgICAgKytsaW5lO1xuICAgICAgICBjdXIgPSBtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXcgUG9zaXRpb24obGluZSwgb2Zmc2V0IC0gY3VyKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG5cbiAgdmFyIGRlZmF1bHRPcHRpb25zID0ge1xuICAgIGVjbWFWZXJzaW9uOiAxMCxcbiAgICBzb3VyY2VUeXBlOiBcInNjcmlwdFwiLFxuICAgIG9uSW5zZXJ0ZWRTZW1pY29sb246IG51bGwsXG4gICAgb25UcmFpbGluZ0NvbW1hOiBudWxsLFxuICAgIGFsbG93UmVzZXJ2ZWQ6IG51bGwsXG4gICAgYWxsb3dSZXR1cm5PdXRzaWRlRnVuY3Rpb246IGZhbHNlLFxuICAgIGFsbG93SW1wb3J0RXhwb3J0RXZlcnl3aGVyZTogZmFsc2UsXG4gICAgYWxsb3dBd2FpdE91dHNpZGVGdW5jdGlvbjogZmFsc2UsXG4gICAgYWxsb3dIYXNoQmFuZzogZmFsc2UsXG4gICAgbG9jYXRpb25zOiBmYWxzZSxcbiAgICBvblRva2VuOiBudWxsLFxuICAgIG9uQ29tbWVudDogbnVsbCxcbiAgICByYW5nZXM6IGZhbHNlLFxuICAgIHByb2dyYW06IG51bGwsXG4gICAgc291cmNlRmlsZTogbnVsbCxcbiAgICBkaXJlY3RTb3VyY2VGaWxlOiBudWxsLFxuICAgIHByZXNlcnZlUGFyZW5zOiBmYWxzZVxuICB9O1xuXG5cbiAgZnVuY3Rpb24gZ2V0T3B0aW9ucyhvcHRzKSB7XG4gICAgdmFyIG9wdGlvbnMgPSB7fTtcblxuICAgIGZvciAodmFyIG9wdCBpbiBkZWZhdWx0T3B0aW9ucylcbiAgICAgIHsgb3B0aW9uc1tvcHRdID0gb3B0cyAmJiBoYXMob3B0cywgb3B0KSA/IG9wdHNbb3B0XSA6IGRlZmF1bHRPcHRpb25zW29wdF07IH1cblxuICAgIGlmIChvcHRpb25zLmVjbWFWZXJzaW9uID49IDIwMTUpXG4gICAgICB7IG9wdGlvbnMuZWNtYVZlcnNpb24gLT0gMjAwOTsgfVxuXG4gICAgaWYgKG9wdGlvbnMuYWxsb3dSZXNlcnZlZCA9PSBudWxsKVxuICAgICAgeyBvcHRpb25zLmFsbG93UmVzZXJ2ZWQgPSBvcHRpb25zLmVjbWFWZXJzaW9uIDwgNTsgfVxuXG4gICAgaWYgKGlzQXJyYXkob3B0aW9ucy5vblRva2VuKSkge1xuICAgICAgdmFyIHRva2VucyA9IG9wdGlvbnMub25Ub2tlbjtcbiAgICAgIG9wdGlvbnMub25Ub2tlbiA9IGZ1bmN0aW9uICh0b2tlbikgeyByZXR1cm4gdG9rZW5zLnB1c2godG9rZW4pOyB9O1xuICAgIH1cbiAgICBpZiAoaXNBcnJheShvcHRpb25zLm9uQ29tbWVudCkpXG4gICAgICB7IG9wdGlvbnMub25Db21tZW50ID0gcHVzaENvbW1lbnQob3B0aW9ucywgb3B0aW9ucy5vbkNvbW1lbnQpOyB9XG5cbiAgICByZXR1cm4gb3B0aW9uc1xuICB9XG5cbiAgZnVuY3Rpb24gcHVzaENvbW1lbnQob3B0aW9ucywgYXJyYXkpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oYmxvY2ssIHRleHQsIHN0YXJ0LCBlbmQsIHN0YXJ0TG9jLCBlbmRMb2MpIHtcbiAgICAgIHZhciBjb21tZW50ID0ge1xuICAgICAgICB0eXBlOiBibG9jayA/IFwiQmxvY2tcIiA6IFwiTGluZVwiLFxuICAgICAgICB2YWx1ZTogdGV4dCxcbiAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICBlbmQ6IGVuZFxuICAgICAgfTtcbiAgICAgIGlmIChvcHRpb25zLmxvY2F0aW9ucylcbiAgICAgICAgeyBjb21tZW50LmxvYyA9IG5ldyBTb3VyY2VMb2NhdGlvbih0aGlzLCBzdGFydExvYywgZW5kTG9jKTsgfVxuICAgICAgaWYgKG9wdGlvbnMucmFuZ2VzKVxuICAgICAgICB7IGNvbW1lbnQucmFuZ2UgPSBbc3RhcnQsIGVuZF07IH1cbiAgICAgIGFycmF5LnB1c2goY29tbWVudCk7XG4gICAgfVxuICB9XG5cbiAgdmFyXG4gICAgICBTQ09QRV9UT1AgPSAxLFxuICAgICAgU0NPUEVfRlVOQ1RJT04gPSAyLFxuICAgICAgU0NPUEVfVkFSID0gU0NPUEVfVE9QIHwgU0NPUEVfRlVOQ1RJT04sXG4gICAgICBTQ09QRV9BU1lOQyA9IDQsXG4gICAgICBTQ09QRV9HRU5FUkFUT1IgPSA4LFxuICAgICAgU0NPUEVfQVJST1cgPSAxNixcbiAgICAgIFNDT1BFX1NJTVBMRV9DQVRDSCA9IDMyLFxuICAgICAgU0NPUEVfU1VQRVIgPSA2NCxcbiAgICAgIFNDT1BFX0RJUkVDVF9TVVBFUiA9IDEyODtcblxuICBmdW5jdGlvbiBmdW5jdGlvbkZsYWdzKGFzeW5jLCBnZW5lcmF0b3IpIHtcbiAgICByZXR1cm4gU0NPUEVfRlVOQ1RJT04gfCAoYXN5bmMgPyBTQ09QRV9BU1lOQyA6IDApIHwgKGdlbmVyYXRvciA/IFNDT1BFX0dFTkVSQVRPUiA6IDApXG4gIH1cblxuICB2YXJcbiAgICAgIEJJTkRfTk9ORSA9IDAsIFxuICAgICAgQklORF9WQVIgPSAxLCBcbiAgICAgIEJJTkRfTEVYSUNBTCA9IDIsIFxuICAgICAgQklORF9GVU5DVElPTiA9IDMsIFxuICAgICAgQklORF9TSU1QTEVfQ0FUQ0ggPSA0LCBcbiAgICAgIEJJTkRfT1VUU0lERSA9IDU7IFxuXG4gIHZhciBQYXJzZXIgPSBmdW5jdGlvbiBQYXJzZXIob3B0aW9ucywgaW5wdXQsIHN0YXJ0UG9zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyA9IGdldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgdGhpcy5zb3VyY2VGaWxlID0gb3B0aW9ucy5zb3VyY2VGaWxlO1xuICAgIHRoaXMua2V5d29yZHMgPSB3b3Jkc1JlZ2V4cChrZXl3b3Jkc1tvcHRpb25zLmVjbWFWZXJzaW9uID49IDYgPyA2IDogb3B0aW9ucy5zb3VyY2VUeXBlID09PSBcIm1vZHVsZVwiID8gXCI1bW9kdWxlXCIgOiA1XSk7XG4gICAgdmFyIHJlc2VydmVkID0gXCJcIjtcbiAgICBpZiAob3B0aW9ucy5hbGxvd1Jlc2VydmVkICE9PSB0cnVlKSB7XG4gICAgICBmb3IgKHZhciB2ID0gb3B0aW9ucy5lY21hVmVyc2lvbjs7IHYtLSlcbiAgICAgICAgeyBpZiAocmVzZXJ2ZWQgPSByZXNlcnZlZFdvcmRzW3ZdKSB7IGJyZWFrIH0gfVxuICAgICAgaWYgKG9wdGlvbnMuc291cmNlVHlwZSA9PT0gXCJtb2R1bGVcIikgeyByZXNlcnZlZCArPSBcIiBhd2FpdFwiOyB9XG4gICAgfVxuICAgIHRoaXMucmVzZXJ2ZWRXb3JkcyA9IHdvcmRzUmVnZXhwKHJlc2VydmVkKTtcbiAgICB2YXIgcmVzZXJ2ZWRTdHJpY3QgPSAocmVzZXJ2ZWQgPyByZXNlcnZlZCArIFwiIFwiIDogXCJcIikgKyByZXNlcnZlZFdvcmRzLnN0cmljdDtcbiAgICB0aGlzLnJlc2VydmVkV29yZHNTdHJpY3QgPSB3b3Jkc1JlZ2V4cChyZXNlcnZlZFN0cmljdCk7XG4gICAgdGhpcy5yZXNlcnZlZFdvcmRzU3RyaWN0QmluZCA9IHdvcmRzUmVnZXhwKHJlc2VydmVkU3RyaWN0ICsgXCIgXCIgKyByZXNlcnZlZFdvcmRzLnN0cmljdEJpbmQpO1xuICAgIHRoaXMuaW5wdXQgPSBTdHJpbmcoaW5wdXQpO1xuXG4gICAgdGhpcy5jb250YWluc0VzYyA9IGZhbHNlO1xuXG5cbiAgICBpZiAoc3RhcnRQb3MpIHtcbiAgICAgIHRoaXMucG9zID0gc3RhcnRQb3M7XG4gICAgICB0aGlzLmxpbmVTdGFydCA9IHRoaXMuaW5wdXQubGFzdEluZGV4T2YoXCJcXG5cIiwgc3RhcnRQb3MgLSAxKSArIDE7XG4gICAgICB0aGlzLmN1ckxpbmUgPSB0aGlzLmlucHV0LnNsaWNlKDAsIHRoaXMubGluZVN0YXJ0KS5zcGxpdChsaW5lQnJlYWspLmxlbmd0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wb3MgPSB0aGlzLmxpbmVTdGFydCA9IDA7XG4gICAgICB0aGlzLmN1ckxpbmUgPSAxO1xuICAgIH1cblxuICAgIHRoaXMudHlwZSA9IHR5cGVzLmVvZjtcbiAgICB0aGlzLnZhbHVlID0gbnVsbDtcbiAgICB0aGlzLnN0YXJ0ID0gdGhpcy5lbmQgPSB0aGlzLnBvcztcbiAgICB0aGlzLnN0YXJ0TG9jID0gdGhpcy5lbmRMb2MgPSB0aGlzLmN1clBvc2l0aW9uKCk7XG5cbiAgICB0aGlzLmxhc3RUb2tFbmRMb2MgPSB0aGlzLmxhc3RUb2tTdGFydExvYyA9IG51bGw7XG4gICAgdGhpcy5sYXN0VG9rU3RhcnQgPSB0aGlzLmxhc3RUb2tFbmQgPSB0aGlzLnBvcztcblxuICAgIHRoaXMuY29udGV4dCA9IHRoaXMuaW5pdGlhbENvbnRleHQoKTtcbiAgICB0aGlzLmV4cHJBbGxvd2VkID0gdHJ1ZTtcblxuICAgIHRoaXMuaW5Nb2R1bGUgPSBvcHRpb25zLnNvdXJjZVR5cGUgPT09IFwibW9kdWxlXCI7XG4gICAgdGhpcy5zdHJpY3QgPSB0aGlzLmluTW9kdWxlIHx8IHRoaXMuc3RyaWN0RGlyZWN0aXZlKHRoaXMucG9zKTtcblxuICAgIHRoaXMucG90ZW50aWFsQXJyb3dBdCA9IC0xO1xuXG4gICAgdGhpcy55aWVsZFBvcyA9IHRoaXMuYXdhaXRQb3MgPSB0aGlzLmF3YWl0SWRlbnRQb3MgPSAwO1xuICAgIHRoaXMubGFiZWxzID0gW107XG4gICAgdGhpcy51bmRlZmluZWRFeHBvcnRzID0ge307XG5cbiAgICBpZiAodGhpcy5wb3MgPT09IDAgJiYgb3B0aW9ucy5hbGxvd0hhc2hCYW5nICYmIHRoaXMuaW5wdXQuc2xpY2UoMCwgMikgPT09IFwiIyFcIilcbiAgICAgIHsgdGhpcy5za2lwTGluZUNvbW1lbnQoMik7IH1cblxuICAgIHRoaXMuc2NvcGVTdGFjayA9IFtdO1xuICAgIHRoaXMuZW50ZXJTY29wZShTQ09QRV9UT1ApO1xuXG4gICAgdGhpcy5yZWdleHBTdGF0ZSA9IG51bGw7XG4gIH07XG5cbiAgdmFyIHByb3RvdHlwZUFjY2Vzc29ycyA9IHsgaW5GdW5jdGlvbjogeyBjb25maWd1cmFibGU6IHRydWUgfSxpbkdlbmVyYXRvcjogeyBjb25maWd1cmFibGU6IHRydWUgfSxpbkFzeW5jOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LGFsbG93U3VwZXI6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sYWxsb3dEaXJlY3RTdXBlcjogeyBjb25maWd1cmFibGU6IHRydWUgfSx0cmVhdEZ1bmN0aW9uc0FzVmFyOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5cbiAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlICgpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMub3B0aW9ucy5wcm9ncmFtIHx8IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdGhpcy5uZXh0VG9rZW4oKTtcbiAgICByZXR1cm4gdGhpcy5wYXJzZVRvcExldmVsKG5vZGUpXG4gIH07XG5cbiAgcHJvdG90eXBlQWNjZXNzb3JzLmluRnVuY3Rpb24uZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gKHRoaXMuY3VycmVudFZhclNjb3BlKCkuZmxhZ3MgJiBTQ09QRV9GVU5DVElPTikgPiAwIH07XG4gIHByb3RvdHlwZUFjY2Vzc29ycy5pbkdlbmVyYXRvci5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAodGhpcy5jdXJyZW50VmFyU2NvcGUoKS5mbGFncyAmIFNDT1BFX0dFTkVSQVRPUikgPiAwIH07XG4gIHByb3RvdHlwZUFjY2Vzc29ycy5pbkFzeW5jLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICh0aGlzLmN1cnJlbnRWYXJTY29wZSgpLmZsYWdzICYgU0NPUEVfQVNZTkMpID4gMCB9O1xuICBwcm90b3R5cGVBY2Nlc3NvcnMuYWxsb3dTdXBlci5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAodGhpcy5jdXJyZW50VGhpc1Njb3BlKCkuZmxhZ3MgJiBTQ09QRV9TVVBFUikgPiAwIH07XG4gIHByb3RvdHlwZUFjY2Vzc29ycy5hbGxvd0RpcmVjdFN1cGVyLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICh0aGlzLmN1cnJlbnRUaGlzU2NvcGUoKS5mbGFncyAmIFNDT1BFX0RJUkVDVF9TVVBFUikgPiAwIH07XG4gIHByb3RvdHlwZUFjY2Vzc29ycy50cmVhdEZ1bmN0aW9uc0FzVmFyLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMudHJlYXRGdW5jdGlvbnNBc1ZhckluU2NvcGUodGhpcy5jdXJyZW50U2NvcGUoKSkgfTtcblxuICBQYXJzZXIucHJvdG90eXBlLmluTm9uQXJyb3dGdW5jdGlvbiA9IGZ1bmN0aW9uIGluTm9uQXJyb3dGdW5jdGlvbiAoKSB7IHJldHVybiAodGhpcy5jdXJyZW50VGhpc1Njb3BlKCkuZmxhZ3MgJiBTQ09QRV9GVU5DVElPTikgPiAwIH07XG5cbiAgUGFyc2VyLmV4dGVuZCA9IGZ1bmN0aW9uIGV4dGVuZCAoKSB7XG4gICAgICB2YXIgcGx1Z2lucyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgd2hpbGUgKCBsZW4tLSApIHBsdWdpbnNbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgIHZhciBjbHMgPSB0aGlzO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGx1Z2lucy5sZW5ndGg7IGkrKykgeyBjbHMgPSBwbHVnaW5zW2ldKGNscyk7IH1cbiAgICByZXR1cm4gY2xzXG4gIH07XG5cbiAgUGFyc2VyLnBhcnNlID0gZnVuY3Rpb24gcGFyc2UgKGlucHV0LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyB0aGlzKG9wdGlvbnMsIGlucHV0KS5wYXJzZSgpXG4gIH07XG5cbiAgUGFyc2VyLnBhcnNlRXhwcmVzc2lvbkF0ID0gZnVuY3Rpb24gcGFyc2VFeHByZXNzaW9uQXQgKGlucHV0LCBwb3MsIG9wdGlvbnMpIHtcbiAgICB2YXIgcGFyc2VyID0gbmV3IHRoaXMob3B0aW9ucywgaW5wdXQsIHBvcyk7XG4gICAgcGFyc2VyLm5leHRUb2tlbigpO1xuICAgIHJldHVybiBwYXJzZXIucGFyc2VFeHByZXNzaW9uKClcbiAgfTtcblxuICBQYXJzZXIudG9rZW5pemVyID0gZnVuY3Rpb24gdG9rZW5pemVyIChpbnB1dCwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgdGhpcyhvcHRpb25zLCBpbnB1dClcbiAgfTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyggUGFyc2VyLnByb3RvdHlwZSwgcHJvdG90eXBlQWNjZXNzb3JzICk7XG5cbiAgdmFyIHBwID0gUGFyc2VyLnByb3RvdHlwZTtcblxuXG4gIHZhciBsaXRlcmFsID0gL14oPzonKCg/OlxcXFwufFteJ10pKj8pJ3xcIigoPzpcXFxcLnxbXlwiXSkqPylcIikvO1xuICBwcC5zdHJpY3REaXJlY3RpdmUgPSBmdW5jdGlvbihzdGFydCkge1xuICAgIGZvciAoOzspIHtcbiAgICAgIHNraXBXaGl0ZVNwYWNlLmxhc3RJbmRleCA9IHN0YXJ0O1xuICAgICAgc3RhcnQgKz0gc2tpcFdoaXRlU3BhY2UuZXhlYyh0aGlzLmlucHV0KVswXS5sZW5ndGg7XG4gICAgICB2YXIgbWF0Y2ggPSBsaXRlcmFsLmV4ZWModGhpcy5pbnB1dC5zbGljZShzdGFydCkpO1xuICAgICAgaWYgKCFtYXRjaCkgeyByZXR1cm4gZmFsc2UgfVxuICAgICAgaWYgKChtYXRjaFsxXSB8fCBtYXRjaFsyXSkgPT09IFwidXNlIHN0cmljdFwiKSB7XG4gICAgICAgIHNraXBXaGl0ZVNwYWNlLmxhc3RJbmRleCA9IHN0YXJ0ICsgbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICB2YXIgc3BhY2VBZnRlciA9IHNraXBXaGl0ZVNwYWNlLmV4ZWModGhpcy5pbnB1dCksIGVuZCA9IHNwYWNlQWZ0ZXIuaW5kZXggKyBzcGFjZUFmdGVyWzBdLmxlbmd0aDtcbiAgICAgICAgdmFyIG5leHQgPSB0aGlzLmlucHV0LmNoYXJBdChlbmQpO1xuICAgICAgICByZXR1cm4gbmV4dCA9PT0gXCI7XCIgfHwgbmV4dCA9PT0gXCJ9XCIgfHxcbiAgICAgICAgICAobGluZUJyZWFrLnRlc3Qoc3BhY2VBZnRlclswXSkgJiZcbiAgICAgICAgICAgISgvWyhgLlsrXFwtLyolPD49LD9eJl0vLnRlc3QobmV4dCkgfHwgbmV4dCA9PT0gXCIhXCIgJiYgdGhpcy5pbnB1dC5jaGFyQXQoZW5kICsgMSkgPT09IFwiPVwiKSlcbiAgICAgIH1cbiAgICAgIHN0YXJ0ICs9IG1hdGNoWzBdLmxlbmd0aDtcblxuICAgICAgc2tpcFdoaXRlU3BhY2UubGFzdEluZGV4ID0gc3RhcnQ7XG4gICAgICBzdGFydCArPSBza2lwV2hpdGVTcGFjZS5leGVjKHRoaXMuaW5wdXQpWzBdLmxlbmd0aDtcbiAgICAgIGlmICh0aGlzLmlucHV0W3N0YXJ0XSA9PT0gXCI7XCIpXG4gICAgICAgIHsgc3RhcnQrKzsgfVxuICAgIH1cbiAgfTtcblxuXG4gIHBwLmVhdCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICBpZiAodGhpcy50eXBlID09PSB0eXBlKSB7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfTtcblxuXG4gIHBwLmlzQ29udGV4dHVhbCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy50eXBlID09PSB0eXBlcy5uYW1lICYmIHRoaXMudmFsdWUgPT09IG5hbWUgJiYgIXRoaXMuY29udGFpbnNFc2NcbiAgfTtcblxuXG4gIHBwLmVhdENvbnRleHR1YWwgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgaWYgKCF0aGlzLmlzQ29udGV4dHVhbChuYW1lKSkgeyByZXR1cm4gZmFsc2UgfVxuICAgIHRoaXMubmV4dCgpO1xuICAgIHJldHVybiB0cnVlXG4gIH07XG5cblxuICBwcC5leHBlY3RDb250ZXh0dWFsID0gZnVuY3Rpb24obmFtZSkge1xuICAgIGlmICghdGhpcy5lYXRDb250ZXh0dWFsKG5hbWUpKSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gIH07XG5cblxuICBwcC5jYW5JbnNlcnRTZW1pY29sb24gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy50eXBlID09PSB0eXBlcy5lb2YgfHxcbiAgICAgIHRoaXMudHlwZSA9PT0gdHlwZXMuYnJhY2VSIHx8XG4gICAgICBsaW5lQnJlYWsudGVzdCh0aGlzLmlucHV0LnNsaWNlKHRoaXMubGFzdFRva0VuZCwgdGhpcy5zdGFydCkpXG4gIH07XG5cbiAgcHAuaW5zZXJ0U2VtaWNvbG9uID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCkpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMub25JbnNlcnRlZFNlbWljb2xvbilcbiAgICAgICAgeyB0aGlzLm9wdGlvbnMub25JbnNlcnRlZFNlbWljb2xvbih0aGlzLmxhc3RUb2tFbmQsIHRoaXMubGFzdFRva0VuZExvYyk7IH1cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9O1xuXG5cbiAgcHAuc2VtaWNvbG9uID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLmVhdCh0eXBlcy5zZW1pKSAmJiAhdGhpcy5pbnNlcnRTZW1pY29sb24oKSkgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICB9O1xuXG4gIHBwLmFmdGVyVHJhaWxpbmdDb21tYSA9IGZ1bmN0aW9uKHRva1R5cGUsIG5vdE5leHQpIHtcbiAgICBpZiAodGhpcy50eXBlID09PSB0b2tUeXBlKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLm9uVHJhaWxpbmdDb21tYSlcbiAgICAgICAgeyB0aGlzLm9wdGlvbnMub25UcmFpbGluZ0NvbW1hKHRoaXMubGFzdFRva1N0YXJ0LCB0aGlzLmxhc3RUb2tTdGFydExvYyk7IH1cbiAgICAgIGlmICghbm90TmV4dClcbiAgICAgICAgeyB0aGlzLm5leHQoKTsgfVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH07XG5cblxuICBwcC5leHBlY3QgPSBmdW5jdGlvbih0eXBlKSB7XG4gICAgdGhpcy5lYXQodHlwZSkgfHwgdGhpcy51bmV4cGVjdGVkKCk7XG4gIH07XG5cblxuICBwcC51bmV4cGVjdGVkID0gZnVuY3Rpb24ocG9zKSB7XG4gICAgdGhpcy5yYWlzZShwb3MgIT0gbnVsbCA/IHBvcyA6IHRoaXMuc3RhcnQsIFwiVW5leHBlY3RlZCB0b2tlblwiKTtcbiAgfTtcblxuICBmdW5jdGlvbiBEZXN0cnVjdHVyaW5nRXJyb3JzKCkge1xuICAgIHRoaXMuc2hvcnRoYW5kQXNzaWduID1cbiAgICB0aGlzLnRyYWlsaW5nQ29tbWEgPVxuICAgIHRoaXMucGFyZW50aGVzaXplZEFzc2lnbiA9XG4gICAgdGhpcy5wYXJlbnRoZXNpemVkQmluZCA9XG4gICAgdGhpcy5kb3VibGVQcm90byA9XG4gICAgICAtMTtcbiAgfVxuXG4gIHBwLmNoZWNrUGF0dGVybkVycm9ycyA9IGZ1bmN0aW9uKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIGlzQXNzaWduKSB7XG4gICAgaWYgKCFyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7IHJldHVybiB9XG4gICAgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMudHJhaWxpbmdDb21tYSA+IC0xKVxuICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy50cmFpbGluZ0NvbW1hLCBcIkNvbW1hIGlzIG5vdCBwZXJtaXR0ZWQgYWZ0ZXIgdGhlIHJlc3QgZWxlbWVudFwiKTsgfVxuICAgIHZhciBwYXJlbnMgPSBpc0Fzc2lnbiA/IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEFzc2lnbiA6IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEJpbmQ7XG4gICAgaWYgKHBhcmVucyA+IC0xKSB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShwYXJlbnMsIFwiUGFyZW50aGVzaXplZCBwYXR0ZXJuXCIpOyB9XG4gIH07XG5cbiAgcHAuY2hlY2tFeHByZXNzaW9uRXJyb3JzID0gZnVuY3Rpb24ocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgYW5kVGhyb3cpIHtcbiAgICBpZiAoIXJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICB2YXIgc2hvcnRoYW5kQXNzaWduID0gcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5zaG9ydGhhbmRBc3NpZ247XG4gICAgdmFyIGRvdWJsZVByb3RvID0gcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5kb3VibGVQcm90bztcbiAgICBpZiAoIWFuZFRocm93KSB7IHJldHVybiBzaG9ydGhhbmRBc3NpZ24gPj0gMCB8fCBkb3VibGVQcm90byA+PSAwIH1cbiAgICBpZiAoc2hvcnRoYW5kQXNzaWduID49IDApXG4gICAgICB7IHRoaXMucmFpc2Uoc2hvcnRoYW5kQXNzaWduLCBcIlNob3J0aGFuZCBwcm9wZXJ0eSBhc3NpZ25tZW50cyBhcmUgdmFsaWQgb25seSBpbiBkZXN0cnVjdHVyaW5nIHBhdHRlcm5zXCIpOyB9XG4gICAgaWYgKGRvdWJsZVByb3RvID49IDApXG4gICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShkb3VibGVQcm90bywgXCJSZWRlZmluaXRpb24gb2YgX19wcm90b19fIHByb3BlcnR5XCIpOyB9XG4gIH07XG5cbiAgcHAuY2hlY2tZaWVsZEF3YWl0SW5EZWZhdWx0UGFyYW1zID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMueWllbGRQb3MgJiYgKCF0aGlzLmF3YWl0UG9zIHx8IHRoaXMueWllbGRQb3MgPCB0aGlzLmF3YWl0UG9zKSlcbiAgICAgIHsgdGhpcy5yYWlzZSh0aGlzLnlpZWxkUG9zLCBcIllpZWxkIGV4cHJlc3Npb24gY2Fubm90IGJlIGEgZGVmYXVsdCB2YWx1ZVwiKTsgfVxuICAgIGlmICh0aGlzLmF3YWl0UG9zKVxuICAgICAgeyB0aGlzLnJhaXNlKHRoaXMuYXdhaXRQb3MsIFwiQXdhaXQgZXhwcmVzc2lvbiBjYW5ub3QgYmUgYSBkZWZhdWx0IHZhbHVlXCIpOyB9XG4gIH07XG5cbiAgcHAuaXNTaW1wbGVBc3NpZ25UYXJnZXQgPSBmdW5jdGlvbihleHByKSB7XG4gICAgaWYgKGV4cHIudHlwZSA9PT0gXCJQYXJlbnRoZXNpemVkRXhwcmVzc2lvblwiKVxuICAgICAgeyByZXR1cm4gdGhpcy5pc1NpbXBsZUFzc2lnblRhcmdldChleHByLmV4cHJlc3Npb24pIH1cbiAgICByZXR1cm4gZXhwci50eXBlID09PSBcIklkZW50aWZpZXJcIiB8fCBleHByLnR5cGUgPT09IFwiTWVtYmVyRXhwcmVzc2lvblwiXG4gIH07XG5cbiAgdmFyIHBwJDEgPSBQYXJzZXIucHJvdG90eXBlO1xuXG5cblxuICBwcCQxLnBhcnNlVG9wTGV2ZWwgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgdmFyIGV4cG9ydHMgPSB7fTtcbiAgICBpZiAoIW5vZGUuYm9keSkgeyBub2RlLmJvZHkgPSBbXTsgfVxuICAgIHdoaWxlICh0aGlzLnR5cGUgIT09IHR5cGVzLmVvZikge1xuICAgICAgdmFyIHN0bXQgPSB0aGlzLnBhcnNlU3RhdGVtZW50KG51bGwsIHRydWUsIGV4cG9ydHMpO1xuICAgICAgbm9kZS5ib2R5LnB1c2goc3RtdCk7XG4gICAgfVxuICAgIGlmICh0aGlzLmluTW9kdWxlKVxuICAgICAgeyBmb3IgKHZhciBpID0gMCwgbGlzdCA9IE9iamVjdC5rZXlzKHRoaXMudW5kZWZpbmVkRXhwb3J0cyk7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKVxuICAgICAgICB7XG4gICAgICAgICAgdmFyIG5hbWUgPSBsaXN0W2ldO1xuXG4gICAgICAgICAgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHRoaXMudW5kZWZpbmVkRXhwb3J0c1tuYW1lXS5zdGFydCwgKFwiRXhwb3J0ICdcIiArIG5hbWUgKyBcIicgaXMgbm90IGRlZmluZWRcIikpO1xuICAgICAgICB9IH1cbiAgICB0aGlzLmFkYXB0RGlyZWN0aXZlUHJvbG9ndWUobm9kZS5ib2R5KTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBub2RlLnNvdXJjZVR5cGUgPSB0aGlzLm9wdGlvbnMuc291cmNlVHlwZTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiUHJvZ3JhbVwiKVxuICB9O1xuXG4gIHZhciBsb29wTGFiZWwgPSB7a2luZDogXCJsb29wXCJ9LCBzd2l0Y2hMYWJlbCA9IHtraW5kOiBcInN3aXRjaFwifTtcblxuICBwcCQxLmlzTGV0ID0gZnVuY3Rpb24oY29udGV4dCkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPCA2IHx8ICF0aGlzLmlzQ29udGV4dHVhbChcImxldFwiKSkgeyByZXR1cm4gZmFsc2UgfVxuICAgIHNraXBXaGl0ZVNwYWNlLmxhc3RJbmRleCA9IHRoaXMucG9zO1xuICAgIHZhciBza2lwID0gc2tpcFdoaXRlU3BhY2UuZXhlYyh0aGlzLmlucHV0KTtcbiAgICB2YXIgbmV4dCA9IHRoaXMucG9zICsgc2tpcFswXS5sZW5ndGgsIG5leHRDaCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdChuZXh0KTtcbiAgICBpZiAobmV4dENoID09PSA5MSkgeyByZXR1cm4gdHJ1ZSB9IFxuICAgIGlmIChjb250ZXh0KSB7IHJldHVybiBmYWxzZSB9XG5cbiAgICBpZiAobmV4dENoID09PSAxMjMpIHsgcmV0dXJuIHRydWUgfSBcbiAgICBpZiAoaXNJZGVudGlmaWVyU3RhcnQobmV4dENoLCB0cnVlKSkge1xuICAgICAgdmFyIHBvcyA9IG5leHQgKyAxO1xuICAgICAgd2hpbGUgKGlzSWRlbnRpZmllckNoYXIodGhpcy5pbnB1dC5jaGFyQ29kZUF0KHBvcyksIHRydWUpKSB7ICsrcG9zOyB9XG4gICAgICB2YXIgaWRlbnQgPSB0aGlzLmlucHV0LnNsaWNlKG5leHQsIHBvcyk7XG4gICAgICBpZiAoIWtleXdvcmRSZWxhdGlvbmFsT3BlcmF0b3IudGVzdChpZGVudCkpIHsgcmV0dXJuIHRydWUgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcblxuICBwcCQxLmlzQXN5bmNGdW5jdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPCA4IHx8ICF0aGlzLmlzQ29udGV4dHVhbChcImFzeW5jXCIpKVxuICAgICAgeyByZXR1cm4gZmFsc2UgfVxuXG4gICAgc2tpcFdoaXRlU3BhY2UubGFzdEluZGV4ID0gdGhpcy5wb3M7XG4gICAgdmFyIHNraXAgPSBza2lwV2hpdGVTcGFjZS5leGVjKHRoaXMuaW5wdXQpO1xuICAgIHZhciBuZXh0ID0gdGhpcy5wb3MgKyBza2lwWzBdLmxlbmd0aDtcbiAgICByZXR1cm4gIWxpbmVCcmVhay50ZXN0KHRoaXMuaW5wdXQuc2xpY2UodGhpcy5wb3MsIG5leHQpKSAmJlxuICAgICAgdGhpcy5pbnB1dC5zbGljZShuZXh0LCBuZXh0ICsgOCkgPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgKG5leHQgKyA4ID09PSB0aGlzLmlucHV0Lmxlbmd0aCB8fCAhaXNJZGVudGlmaWVyQ2hhcih0aGlzLmlucHV0LmNoYXJBdChuZXh0ICsgOCkpKVxuICB9O1xuXG5cbiAgcHAkMS5wYXJzZVN0YXRlbWVudCA9IGZ1bmN0aW9uKGNvbnRleHQsIHRvcExldmVsLCBleHBvcnRzKSB7XG4gICAgdmFyIHN0YXJ0dHlwZSA9IHRoaXMudHlwZSwgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCksIGtpbmQ7XG5cbiAgICBpZiAodGhpcy5pc0xldChjb250ZXh0KSkge1xuICAgICAgc3RhcnR0eXBlID0gdHlwZXMuX3ZhcjtcbiAgICAgIGtpbmQgPSBcImxldFwiO1xuICAgIH1cblxuXG4gICAgc3dpdGNoIChzdGFydHR5cGUpIHtcbiAgICBjYXNlIHR5cGVzLl9icmVhazogY2FzZSB0eXBlcy5fY29udGludWU6IHJldHVybiB0aGlzLnBhcnNlQnJlYWtDb250aW51ZVN0YXRlbWVudChub2RlLCBzdGFydHR5cGUua2V5d29yZClcbiAgICBjYXNlIHR5cGVzLl9kZWJ1Z2dlcjogcmV0dXJuIHRoaXMucGFyc2VEZWJ1Z2dlclN0YXRlbWVudChub2RlKVxuICAgIGNhc2UgdHlwZXMuX2RvOiByZXR1cm4gdGhpcy5wYXJzZURvU3RhdGVtZW50KG5vZGUpXG4gICAgY2FzZSB0eXBlcy5fZm9yOiByZXR1cm4gdGhpcy5wYXJzZUZvclN0YXRlbWVudChub2RlKVxuICAgIGNhc2UgdHlwZXMuX2Z1bmN0aW9uOlxuICAgICAgaWYgKChjb250ZXh0ICYmICh0aGlzLnN0cmljdCB8fCBjb250ZXh0ICE9PSBcImlmXCIgJiYgY29udGV4dCAhPT0gXCJsYWJlbFwiKSkgJiYgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYpIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICAgIHJldHVybiB0aGlzLnBhcnNlRnVuY3Rpb25TdGF0ZW1lbnQobm9kZSwgZmFsc2UsICFjb250ZXh0KVxuICAgIGNhc2UgdHlwZXMuX2NsYXNzOlxuICAgICAgaWYgKGNvbnRleHQpIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICAgIHJldHVybiB0aGlzLnBhcnNlQ2xhc3Mobm9kZSwgdHJ1ZSlcbiAgICBjYXNlIHR5cGVzLl9pZjogcmV0dXJuIHRoaXMucGFyc2VJZlN0YXRlbWVudChub2RlKVxuICAgIGNhc2UgdHlwZXMuX3JldHVybjogcmV0dXJuIHRoaXMucGFyc2VSZXR1cm5TdGF0ZW1lbnQobm9kZSlcbiAgICBjYXNlIHR5cGVzLl9zd2l0Y2g6IHJldHVybiB0aGlzLnBhcnNlU3dpdGNoU3RhdGVtZW50KG5vZGUpXG4gICAgY2FzZSB0eXBlcy5fdGhyb3c6IHJldHVybiB0aGlzLnBhcnNlVGhyb3dTdGF0ZW1lbnQobm9kZSlcbiAgICBjYXNlIHR5cGVzLl90cnk6IHJldHVybiB0aGlzLnBhcnNlVHJ5U3RhdGVtZW50KG5vZGUpXG4gICAgY2FzZSB0eXBlcy5fY29uc3Q6IGNhc2UgdHlwZXMuX3ZhcjpcbiAgICAgIGtpbmQgPSBraW5kIHx8IHRoaXMudmFsdWU7XG4gICAgICBpZiAoY29udGV4dCAmJiBraW5kICE9PSBcInZhclwiKSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZVZhclN0YXRlbWVudChub2RlLCBraW5kKVxuICAgIGNhc2UgdHlwZXMuX3doaWxlOiByZXR1cm4gdGhpcy5wYXJzZVdoaWxlU3RhdGVtZW50KG5vZGUpXG4gICAgY2FzZSB0eXBlcy5fd2l0aDogcmV0dXJuIHRoaXMucGFyc2VXaXRoU3RhdGVtZW50KG5vZGUpXG4gICAgY2FzZSB0eXBlcy5icmFjZUw6IHJldHVybiB0aGlzLnBhcnNlQmxvY2sodHJ1ZSwgbm9kZSlcbiAgICBjYXNlIHR5cGVzLnNlbWk6IHJldHVybiB0aGlzLnBhcnNlRW1wdHlTdGF0ZW1lbnQobm9kZSlcbiAgICBjYXNlIHR5cGVzLl9leHBvcnQ6XG4gICAgY2FzZSB0eXBlcy5faW1wb3J0OlxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+IDEwICYmIHN0YXJ0dHlwZSA9PT0gdHlwZXMuX2ltcG9ydCkge1xuICAgICAgICBza2lwV2hpdGVTcGFjZS5sYXN0SW5kZXggPSB0aGlzLnBvcztcbiAgICAgICAgdmFyIHNraXAgPSBza2lwV2hpdGVTcGFjZS5leGVjKHRoaXMuaW5wdXQpO1xuICAgICAgICB2YXIgbmV4dCA9IHRoaXMucG9zICsgc2tpcFswXS5sZW5ndGgsIG5leHRDaCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdChuZXh0KTtcbiAgICAgICAgaWYgKG5leHRDaCA9PT0gNDAgfHwgbmV4dENoID09PSA0NikgXG4gICAgICAgICAgeyByZXR1cm4gdGhpcy5wYXJzZUV4cHJlc3Npb25TdGF0ZW1lbnQobm9kZSwgdGhpcy5wYXJzZUV4cHJlc3Npb24oKSkgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy5hbGxvd0ltcG9ydEV4cG9ydEV2ZXJ5d2hlcmUpIHtcbiAgICAgICAgaWYgKCF0b3BMZXZlbClcbiAgICAgICAgICB7IHRoaXMucmFpc2UodGhpcy5zdGFydCwgXCInaW1wb3J0JyBhbmQgJ2V4cG9ydCcgbWF5IG9ubHkgYXBwZWFyIGF0IHRoZSB0b3AgbGV2ZWxcIik7IH1cbiAgICAgICAgaWYgKCF0aGlzLmluTW9kdWxlKVxuICAgICAgICAgIHsgdGhpcy5yYWlzZSh0aGlzLnN0YXJ0LCBcIidpbXBvcnQnIGFuZCAnZXhwb3J0JyBtYXkgYXBwZWFyIG9ubHkgd2l0aCAnc291cmNlVHlwZTogbW9kdWxlJ1wiKTsgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHN0YXJ0dHlwZSA9PT0gdHlwZXMuX2ltcG9ydCA/IHRoaXMucGFyc2VJbXBvcnQobm9kZSkgOiB0aGlzLnBhcnNlRXhwb3J0KG5vZGUsIGV4cG9ydHMpXG5cbiAgICBkZWZhdWx0OlxuICAgICAgaWYgKHRoaXMuaXNBc3luY0Z1bmN0aW9uKCkpIHtcbiAgICAgICAgaWYgKGNvbnRleHQpIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlRnVuY3Rpb25TdGF0ZW1lbnQobm9kZSwgdHJ1ZSwgIWNvbnRleHQpXG4gICAgICB9XG5cbiAgICAgIHZhciBtYXliZU5hbWUgPSB0aGlzLnZhbHVlLCBleHByID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcbiAgICAgIGlmIChzdGFydHR5cGUgPT09IHR5cGVzLm5hbWUgJiYgZXhwci50eXBlID09PSBcIklkZW50aWZpZXJcIiAmJiB0aGlzLmVhdCh0eXBlcy5jb2xvbikpXG4gICAgICAgIHsgcmV0dXJuIHRoaXMucGFyc2VMYWJlbGVkU3RhdGVtZW50KG5vZGUsIG1heWJlTmFtZSwgZXhwciwgY29udGV4dCkgfVxuICAgICAgZWxzZSB7IHJldHVybiB0aGlzLnBhcnNlRXhwcmVzc2lvblN0YXRlbWVudChub2RlLCBleHByKSB9XG4gICAgfVxuICB9O1xuXG4gIHBwJDEucGFyc2VCcmVha0NvbnRpbnVlU3RhdGVtZW50ID0gZnVuY3Rpb24obm9kZSwga2V5d29yZCkge1xuICAgIHZhciBpc0JyZWFrID0ga2V5d29yZCA9PT0gXCJicmVha1wiO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIGlmICh0aGlzLmVhdCh0eXBlcy5zZW1pKSB8fCB0aGlzLmluc2VydFNlbWljb2xvbigpKSB7IG5vZGUubGFiZWwgPSBudWxsOyB9XG4gICAgZWxzZSBpZiAodGhpcy50eXBlICE9PSB0eXBlcy5uYW1lKSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgZWxzZSB7XG4gICAgICBub2RlLmxhYmVsID0gdGhpcy5wYXJzZUlkZW50KCk7XG4gICAgICB0aGlzLnNlbWljb2xvbigpO1xuICAgIH1cblxuICAgIHZhciBpID0gMDtcbiAgICBmb3IgKDsgaSA8IHRoaXMubGFiZWxzLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgbGFiID0gdGhpcy5sYWJlbHNbaV07XG4gICAgICBpZiAobm9kZS5sYWJlbCA9PSBudWxsIHx8IGxhYi5uYW1lID09PSBub2RlLmxhYmVsLm5hbWUpIHtcbiAgICAgICAgaWYgKGxhYi5raW5kICE9IG51bGwgJiYgKGlzQnJlYWsgfHwgbGFiLmtpbmQgPT09IFwibG9vcFwiKSkgeyBicmVhayB9XG4gICAgICAgIGlmIChub2RlLmxhYmVsICYmIGlzQnJlYWspIHsgYnJlYWsgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaSA9PT0gdGhpcy5sYWJlbHMubGVuZ3RoKSB7IHRoaXMucmFpc2Uobm9kZS5zdGFydCwgXCJVbnN5bnRhY3RpYyBcIiArIGtleXdvcmQpOyB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBpc0JyZWFrID8gXCJCcmVha1N0YXRlbWVudFwiIDogXCJDb250aW51ZVN0YXRlbWVudFwiKVxuICB9O1xuXG4gIHBwJDEucGFyc2VEZWJ1Z2dlclN0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICB0aGlzLm5leHQoKTtcbiAgICB0aGlzLnNlbWljb2xvbigpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJEZWJ1Z2dlclN0YXRlbWVudFwiKVxuICB9O1xuXG4gIHBwJDEucGFyc2VEb1N0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICB0aGlzLm5leHQoKTtcbiAgICB0aGlzLmxhYmVscy5wdXNoKGxvb3BMYWJlbCk7XG4gICAgbm9kZS5ib2R5ID0gdGhpcy5wYXJzZVN0YXRlbWVudChcImRvXCIpO1xuICAgIHRoaXMubGFiZWxzLnBvcCgpO1xuICAgIHRoaXMuZXhwZWN0KHR5cGVzLl93aGlsZSk7XG4gICAgbm9kZS50ZXN0ID0gdGhpcy5wYXJzZVBhcmVuRXhwcmVzc2lvbigpO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNilcbiAgICAgIHsgdGhpcy5lYXQodHlwZXMuc2VtaSk7IH1cbiAgICBlbHNlXG4gICAgICB7IHRoaXMuc2VtaWNvbG9uKCk7IH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRG9XaGlsZVN0YXRlbWVudFwiKVxuICB9O1xuXG5cbiAgcHAkMS5wYXJzZUZvclN0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICB0aGlzLm5leHQoKTtcbiAgICB2YXIgYXdhaXRBdCA9ICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOSAmJiAodGhpcy5pbkFzeW5jIHx8ICghdGhpcy5pbkZ1bmN0aW9uICYmIHRoaXMub3B0aW9ucy5hbGxvd0F3YWl0T3V0c2lkZUZ1bmN0aW9uKSkgJiYgdGhpcy5lYXRDb250ZXh0dWFsKFwiYXdhaXRcIikpID8gdGhpcy5sYXN0VG9rU3RhcnQgOiAtMTtcbiAgICB0aGlzLmxhYmVscy5wdXNoKGxvb3BMYWJlbCk7XG4gICAgdGhpcy5lbnRlclNjb3BlKDApO1xuICAgIHRoaXMuZXhwZWN0KHR5cGVzLnBhcmVuTCk7XG4gICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuc2VtaSkge1xuICAgICAgaWYgKGF3YWl0QXQgPiAtMSkgeyB0aGlzLnVuZXhwZWN0ZWQoYXdhaXRBdCk7IH1cbiAgICAgIHJldHVybiB0aGlzLnBhcnNlRm9yKG5vZGUsIG51bGwpXG4gICAgfVxuICAgIHZhciBpc0xldCA9IHRoaXMuaXNMZXQoKTtcbiAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5fdmFyIHx8IHRoaXMudHlwZSA9PT0gdHlwZXMuX2NvbnN0IHx8IGlzTGV0KSB7XG4gICAgICB2YXIgaW5pdCQxID0gdGhpcy5zdGFydE5vZGUoKSwga2luZCA9IGlzTGV0ID8gXCJsZXRcIiA6IHRoaXMudmFsdWU7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIHRoaXMucGFyc2VWYXIoaW5pdCQxLCB0cnVlLCBraW5kKTtcbiAgICAgIHRoaXMuZmluaXNoTm9kZShpbml0JDEsIFwiVmFyaWFibGVEZWNsYXJhdGlvblwiKTtcbiAgICAgIGlmICgodGhpcy50eXBlID09PSB0eXBlcy5faW4gfHwgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2ICYmIHRoaXMuaXNDb250ZXh0dWFsKFwib2ZcIikpKSAmJiBpbml0JDEuZGVjbGFyYXRpb25zLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkpIHtcbiAgICAgICAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5faW4pIHtcbiAgICAgICAgICAgIGlmIChhd2FpdEF0ID4gLTEpIHsgdGhpcy51bmV4cGVjdGVkKGF3YWl0QXQpOyB9XG4gICAgICAgICAgfSBlbHNlIHsgbm9kZS5hd2FpdCA9IGF3YWl0QXQgPiAtMTsgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlRm9ySW4obm9kZSwgaW5pdCQxKVxuICAgICAgfVxuICAgICAgaWYgKGF3YWl0QXQgPiAtMSkgeyB0aGlzLnVuZXhwZWN0ZWQoYXdhaXRBdCk7IH1cbiAgICAgIHJldHVybiB0aGlzLnBhcnNlRm9yKG5vZGUsIGluaXQkMSlcbiAgICB9XG4gICAgdmFyIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMgPSBuZXcgRGVzdHJ1Y3R1cmluZ0Vycm9ycztcbiAgICB2YXIgaW5pdCA9IHRoaXMucGFyc2VFeHByZXNzaW9uKHRydWUsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLl9pbiB8fCAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYgJiYgdGhpcy5pc0NvbnRleHR1YWwoXCJvZlwiKSkpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOSkge1xuICAgICAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5faW4pIHtcbiAgICAgICAgICBpZiAoYXdhaXRBdCA+IC0xKSB7IHRoaXMudW5leHBlY3RlZChhd2FpdEF0KTsgfVxuICAgICAgICB9IGVsc2UgeyBub2RlLmF3YWl0ID0gYXdhaXRBdCA+IC0xOyB9XG4gICAgICB9XG4gICAgICB0aGlzLnRvQXNzaWduYWJsZShpbml0LCBmYWxzZSwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gICAgICB0aGlzLmNoZWNrTFZhbChpbml0KTtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlRm9ySW4obm9kZSwgaW5pdClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jaGVja0V4cHJlc3Npb25FcnJvcnMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgdHJ1ZSk7XG4gICAgfVxuICAgIGlmIChhd2FpdEF0ID4gLTEpIHsgdGhpcy51bmV4cGVjdGVkKGF3YWl0QXQpOyB9XG4gICAgcmV0dXJuIHRoaXMucGFyc2VGb3Iobm9kZSwgaW5pdClcbiAgfTtcblxuICBwcCQxLnBhcnNlRnVuY3Rpb25TdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlLCBpc0FzeW5jLCBkZWNsYXJhdGlvblBvc2l0aW9uKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VGdW5jdGlvbihub2RlLCBGVU5DX1NUQVRFTUVOVCB8IChkZWNsYXJhdGlvblBvc2l0aW9uID8gMCA6IEZVTkNfSEFOR0lOR19TVEFURU1FTlQpLCBmYWxzZSwgaXNBc3luYylcbiAgfTtcblxuICBwcCQxLnBhcnNlSWZTdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgbm9kZS50ZXN0ID0gdGhpcy5wYXJzZVBhcmVuRXhwcmVzc2lvbigpO1xuICAgIG5vZGUuY29uc2VxdWVudCA9IHRoaXMucGFyc2VTdGF0ZW1lbnQoXCJpZlwiKTtcbiAgICBub2RlLmFsdGVybmF0ZSA9IHRoaXMuZWF0KHR5cGVzLl9lbHNlKSA/IHRoaXMucGFyc2VTdGF0ZW1lbnQoXCJpZlwiKSA6IG51bGw7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIklmU3RhdGVtZW50XCIpXG4gIH07XG5cbiAgcHAkMS5wYXJzZVJldHVyblN0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICBpZiAoIXRoaXMuaW5GdW5jdGlvbiAmJiAhdGhpcy5vcHRpb25zLmFsbG93UmV0dXJuT3V0c2lkZUZ1bmN0aW9uKVxuICAgICAgeyB0aGlzLnJhaXNlKHRoaXMuc3RhcnQsIFwiJ3JldHVybicgb3V0c2lkZSBvZiBmdW5jdGlvblwiKTsgfVxuICAgIHRoaXMubmV4dCgpO1xuXG5cbiAgICBpZiAodGhpcy5lYXQodHlwZXMuc2VtaSkgfHwgdGhpcy5pbnNlcnRTZW1pY29sb24oKSkgeyBub2RlLmFyZ3VtZW50ID0gbnVsbDsgfVxuICAgIGVsc2UgeyBub2RlLmFyZ3VtZW50ID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTsgdGhpcy5zZW1pY29sb24oKTsgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJSZXR1cm5TdGF0ZW1lbnRcIilcbiAgfTtcblxuICBwcCQxLnBhcnNlU3dpdGNoU3RhdGVtZW50ID0gZnVuY3Rpb24obm9kZSkge1xuICAgIHRoaXMubmV4dCgpO1xuICAgIG5vZGUuZGlzY3JpbWluYW50ID0gdGhpcy5wYXJzZVBhcmVuRXhwcmVzc2lvbigpO1xuICAgIG5vZGUuY2FzZXMgPSBbXTtcbiAgICB0aGlzLmV4cGVjdCh0eXBlcy5icmFjZUwpO1xuICAgIHRoaXMubGFiZWxzLnB1c2goc3dpdGNoTGFiZWwpO1xuICAgIHRoaXMuZW50ZXJTY29wZSgwKTtcblxuXG4gICAgdmFyIGN1cjtcbiAgICBmb3IgKHZhciBzYXdEZWZhdWx0ID0gZmFsc2U7IHRoaXMudHlwZSAhPT0gdHlwZXMuYnJhY2VSOykge1xuICAgICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuX2Nhc2UgfHwgdGhpcy50eXBlID09PSB0eXBlcy5fZGVmYXVsdCkge1xuICAgICAgICB2YXIgaXNDYXNlID0gdGhpcy50eXBlID09PSB0eXBlcy5fY2FzZTtcbiAgICAgICAgaWYgKGN1cikgeyB0aGlzLmZpbmlzaE5vZGUoY3VyLCBcIlN3aXRjaENhc2VcIik7IH1cbiAgICAgICAgbm9kZS5jYXNlcy5wdXNoKGN1ciA9IHRoaXMuc3RhcnROb2RlKCkpO1xuICAgICAgICBjdXIuY29uc2VxdWVudCA9IFtdO1xuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgaWYgKGlzQ2FzZSkge1xuICAgICAgICAgIGN1ci50ZXN0ID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoc2F3RGVmYXVsdCkgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUodGhpcy5sYXN0VG9rU3RhcnQsIFwiTXVsdGlwbGUgZGVmYXVsdCBjbGF1c2VzXCIpOyB9XG4gICAgICAgICAgc2F3RGVmYXVsdCA9IHRydWU7XG4gICAgICAgICAgY3VyLnRlc3QgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZXhwZWN0KHR5cGVzLmNvbG9uKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghY3VyKSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgICAgIGN1ci5jb25zZXF1ZW50LnB1c2godGhpcy5wYXJzZVN0YXRlbWVudChudWxsKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuZXhpdFNjb3BlKCk7XG4gICAgaWYgKGN1cikgeyB0aGlzLmZpbmlzaE5vZGUoY3VyLCBcIlN3aXRjaENhc2VcIik7IH1cbiAgICB0aGlzLm5leHQoKTsgXG4gICAgdGhpcy5sYWJlbHMucG9wKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlN3aXRjaFN0YXRlbWVudFwiKVxuICB9O1xuXG4gIHBwJDEucGFyc2VUaHJvd1N0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBpZiAobGluZUJyZWFrLnRlc3QodGhpcy5pbnB1dC5zbGljZSh0aGlzLmxhc3RUb2tFbmQsIHRoaXMuc3RhcnQpKSlcbiAgICAgIHsgdGhpcy5yYWlzZSh0aGlzLmxhc3RUb2tFbmQsIFwiSWxsZWdhbCBuZXdsaW5lIGFmdGVyIHRocm93XCIpOyB9XG4gICAgbm9kZS5hcmd1bWVudCA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG4gICAgdGhpcy5zZW1pY29sb24oKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVGhyb3dTdGF0ZW1lbnRcIilcbiAgfTtcblxuXG4gIHZhciBlbXB0eSA9IFtdO1xuXG4gIHBwJDEucGFyc2VUcnlTdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgbm9kZS5ibG9jayA9IHRoaXMucGFyc2VCbG9jaygpO1xuICAgIG5vZGUuaGFuZGxlciA9IG51bGw7XG4gICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuX2NhdGNoKSB7XG4gICAgICB2YXIgY2xhdXNlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgaWYgKHRoaXMuZWF0KHR5cGVzLnBhcmVuTCkpIHtcbiAgICAgICAgY2xhdXNlLnBhcmFtID0gdGhpcy5wYXJzZUJpbmRpbmdBdG9tKCk7XG4gICAgICAgIHZhciBzaW1wbGUgPSBjbGF1c2UucGFyYW0udHlwZSA9PT0gXCJJZGVudGlmaWVyXCI7XG4gICAgICAgIHRoaXMuZW50ZXJTY29wZShzaW1wbGUgPyBTQ09QRV9TSU1QTEVfQ0FUQ0ggOiAwKTtcbiAgICAgICAgdGhpcy5jaGVja0xWYWwoY2xhdXNlLnBhcmFtLCBzaW1wbGUgPyBCSU5EX1NJTVBMRV9DQVRDSCA6IEJJTkRfTEVYSUNBTCk7XG4gICAgICAgIHRoaXMuZXhwZWN0KHR5cGVzLnBhcmVuUik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uIDwgMTApIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICAgICAgY2xhdXNlLnBhcmFtID0gbnVsbDtcbiAgICAgICAgdGhpcy5lbnRlclNjb3BlKDApO1xuICAgICAgfVxuICAgICAgY2xhdXNlLmJvZHkgPSB0aGlzLnBhcnNlQmxvY2soZmFsc2UpO1xuICAgICAgdGhpcy5leGl0U2NvcGUoKTtcbiAgICAgIG5vZGUuaGFuZGxlciA9IHRoaXMuZmluaXNoTm9kZShjbGF1c2UsIFwiQ2F0Y2hDbGF1c2VcIik7XG4gICAgfVxuICAgIG5vZGUuZmluYWxpemVyID0gdGhpcy5lYXQodHlwZXMuX2ZpbmFsbHkpID8gdGhpcy5wYXJzZUJsb2NrKCkgOiBudWxsO1xuICAgIGlmICghbm9kZS5oYW5kbGVyICYmICFub2RlLmZpbmFsaXplcilcbiAgICAgIHsgdGhpcy5yYWlzZShub2RlLnN0YXJ0LCBcIk1pc3NpbmcgY2F0Y2ggb3IgZmluYWxseSBjbGF1c2VcIik7IH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVHJ5U3RhdGVtZW50XCIpXG4gIH07XG5cbiAgcHAkMS5wYXJzZVZhclN0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUsIGtpbmQpIHtcbiAgICB0aGlzLm5leHQoKTtcbiAgICB0aGlzLnBhcnNlVmFyKG5vZGUsIGZhbHNlLCBraW5kKTtcbiAgICB0aGlzLnNlbWljb2xvbigpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJWYXJpYWJsZURlY2xhcmF0aW9uXCIpXG4gIH07XG5cbiAgcHAkMS5wYXJzZVdoaWxlU3RhdGVtZW50ID0gZnVuY3Rpb24obm9kZSkge1xuICAgIHRoaXMubmV4dCgpO1xuICAgIG5vZGUudGVzdCA9IHRoaXMucGFyc2VQYXJlbkV4cHJlc3Npb24oKTtcbiAgICB0aGlzLmxhYmVscy5wdXNoKGxvb3BMYWJlbCk7XG4gICAgbm9kZS5ib2R5ID0gdGhpcy5wYXJzZVN0YXRlbWVudChcIndoaWxlXCIpO1xuICAgIHRoaXMubGFiZWxzLnBvcCgpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJXaGlsZVN0YXRlbWVudFwiKVxuICB9O1xuXG4gIHBwJDEucGFyc2VXaXRoU3RhdGVtZW50ID0gZnVuY3Rpb24obm9kZSkge1xuICAgIGlmICh0aGlzLnN0cmljdCkgeyB0aGlzLnJhaXNlKHRoaXMuc3RhcnQsIFwiJ3dpdGgnIGluIHN0cmljdCBtb2RlXCIpOyB9XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgbm9kZS5vYmplY3QgPSB0aGlzLnBhcnNlUGFyZW5FeHByZXNzaW9uKCk7XG4gICAgbm9kZS5ib2R5ID0gdGhpcy5wYXJzZVN0YXRlbWVudChcIndpdGhcIik7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIldpdGhTdGF0ZW1lbnRcIilcbiAgfTtcblxuICBwcCQxLnBhcnNlRW1wdHlTdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkVtcHR5U3RhdGVtZW50XCIpXG4gIH07XG5cbiAgcHAkMS5wYXJzZUxhYmVsZWRTdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlLCBtYXliZU5hbWUsIGV4cHIsIGNvbnRleHQpIHtcbiAgICBmb3IgKHZhciBpJDEgPSAwLCBsaXN0ID0gdGhpcy5sYWJlbHM7IGkkMSA8IGxpc3QubGVuZ3RoOyBpJDEgKz0gMSlcbiAgICAgIHtcbiAgICAgIHZhciBsYWJlbCA9IGxpc3RbaSQxXTtcblxuICAgICAgaWYgKGxhYmVsLm5hbWUgPT09IG1heWJlTmFtZSlcbiAgICAgICAgeyB0aGlzLnJhaXNlKGV4cHIuc3RhcnQsIFwiTGFiZWwgJ1wiICsgbWF5YmVOYW1lICsgXCInIGlzIGFscmVhZHkgZGVjbGFyZWRcIik7XG4gICAgfSB9XG4gICAgdmFyIGtpbmQgPSB0aGlzLnR5cGUuaXNMb29wID8gXCJsb29wXCIgOiB0aGlzLnR5cGUgPT09IHR5cGVzLl9zd2l0Y2ggPyBcInN3aXRjaFwiIDogbnVsbDtcbiAgICBmb3IgKHZhciBpID0gdGhpcy5sYWJlbHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBsYWJlbCQxID0gdGhpcy5sYWJlbHNbaV07XG4gICAgICBpZiAobGFiZWwkMS5zdGF0ZW1lbnRTdGFydCA9PT0gbm9kZS5zdGFydCkge1xuICAgICAgICBsYWJlbCQxLnN0YXRlbWVudFN0YXJ0ID0gdGhpcy5zdGFydDtcbiAgICAgICAgbGFiZWwkMS5raW5kID0ga2luZDtcbiAgICAgIH0gZWxzZSB7IGJyZWFrIH1cbiAgICB9XG4gICAgdGhpcy5sYWJlbHMucHVzaCh7bmFtZTogbWF5YmVOYW1lLCBraW5kOiBraW5kLCBzdGF0ZW1lbnRTdGFydDogdGhpcy5zdGFydH0pO1xuICAgIG5vZGUuYm9keSA9IHRoaXMucGFyc2VTdGF0ZW1lbnQoY29udGV4dCA/IGNvbnRleHQuaW5kZXhPZihcImxhYmVsXCIpID09PSAtMSA/IGNvbnRleHQgKyBcImxhYmVsXCIgOiBjb250ZXh0IDogXCJsYWJlbFwiKTtcbiAgICB0aGlzLmxhYmVscy5wb3AoKTtcbiAgICBub2RlLmxhYmVsID0gZXhwcjtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiTGFiZWxlZFN0YXRlbWVudFwiKVxuICB9O1xuXG4gIHBwJDEucGFyc2VFeHByZXNzaW9uU3RhdGVtZW50ID0gZnVuY3Rpb24obm9kZSwgZXhwcikge1xuICAgIG5vZGUuZXhwcmVzc2lvbiA9IGV4cHI7XG4gICAgdGhpcy5zZW1pY29sb24oKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRXhwcmVzc2lvblN0YXRlbWVudFwiKVxuICB9O1xuXG5cbiAgcHAkMS5wYXJzZUJsb2NrID0gZnVuY3Rpb24oY3JlYXRlTmV3TGV4aWNhbFNjb3BlLCBub2RlLCBleGl0U3RyaWN0KSB7XG4gICAgaWYgKCBjcmVhdGVOZXdMZXhpY2FsU2NvcGUgPT09IHZvaWQgMCApIGNyZWF0ZU5ld0xleGljYWxTY29wZSA9IHRydWU7XG4gICAgaWYgKCBub2RlID09PSB2b2lkIDAgKSBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcblxuICAgIG5vZGUuYm9keSA9IFtdO1xuICAgIHRoaXMuZXhwZWN0KHR5cGVzLmJyYWNlTCk7XG4gICAgaWYgKGNyZWF0ZU5ld0xleGljYWxTY29wZSkgeyB0aGlzLmVudGVyU2NvcGUoMCk7IH1cbiAgICB3aGlsZSAodGhpcy50eXBlICE9PSB0eXBlcy5icmFjZVIpIHtcbiAgICAgIHZhciBzdG10ID0gdGhpcy5wYXJzZVN0YXRlbWVudChudWxsKTtcbiAgICAgIG5vZGUuYm9keS5wdXNoKHN0bXQpO1xuICAgIH1cbiAgICBpZiAoZXhpdFN0cmljdCkgeyB0aGlzLnN0cmljdCA9IGZhbHNlOyB9XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgaWYgKGNyZWF0ZU5ld0xleGljYWxTY29wZSkgeyB0aGlzLmV4aXRTY29wZSgpOyB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkJsb2NrU3RhdGVtZW50XCIpXG4gIH07XG5cblxuICBwcCQxLnBhcnNlRm9yID0gZnVuY3Rpb24obm9kZSwgaW5pdCkge1xuICAgIG5vZGUuaW5pdCA9IGluaXQ7XG4gICAgdGhpcy5leHBlY3QodHlwZXMuc2VtaSk7XG4gICAgbm9kZS50ZXN0ID0gdGhpcy50eXBlID09PSB0eXBlcy5zZW1pID8gbnVsbCA6IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG4gICAgdGhpcy5leHBlY3QodHlwZXMuc2VtaSk7XG4gICAgbm9kZS51cGRhdGUgPSB0aGlzLnR5cGUgPT09IHR5cGVzLnBhcmVuUiA/IG51bGwgOiB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuICAgIHRoaXMuZXhwZWN0KHR5cGVzLnBhcmVuUik7XG4gICAgbm9kZS5ib2R5ID0gdGhpcy5wYXJzZVN0YXRlbWVudChcImZvclwiKTtcbiAgICB0aGlzLmV4aXRTY29wZSgpO1xuICAgIHRoaXMubGFiZWxzLnBvcCgpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJGb3JTdGF0ZW1lbnRcIilcbiAgfTtcblxuXG4gIHBwJDEucGFyc2VGb3JJbiA9IGZ1bmN0aW9uKG5vZGUsIGluaXQpIHtcbiAgICB2YXIgaXNGb3JJbiA9IHRoaXMudHlwZSA9PT0gdHlwZXMuX2luO1xuICAgIHRoaXMubmV4dCgpO1xuXG4gICAgaWYgKFxuICAgICAgaW5pdC50eXBlID09PSBcIlZhcmlhYmxlRGVjbGFyYXRpb25cIiAmJlxuICAgICAgaW5pdC5kZWNsYXJhdGlvbnNbMF0uaW5pdCAhPSBudWxsICYmXG4gICAgICAoXG4gICAgICAgICFpc0ZvckluIHx8XG4gICAgICAgIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA8IDggfHxcbiAgICAgICAgdGhpcy5zdHJpY3QgfHxcbiAgICAgICAgaW5pdC5raW5kICE9PSBcInZhclwiIHx8XG4gICAgICAgIGluaXQuZGVjbGFyYXRpb25zWzBdLmlkLnR5cGUgIT09IFwiSWRlbnRpZmllclwiXG4gICAgICApXG4gICAgKSB7XG4gICAgICB0aGlzLnJhaXNlKFxuICAgICAgICBpbml0LnN0YXJ0LFxuICAgICAgICAoKGlzRm9ySW4gPyBcImZvci1pblwiIDogXCJmb3Itb2ZcIikgKyBcIiBsb29wIHZhcmlhYmxlIGRlY2xhcmF0aW9uIG1heSBub3QgaGF2ZSBhbiBpbml0aWFsaXplclwiKVxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKGluaXQudHlwZSA9PT0gXCJBc3NpZ25tZW50UGF0dGVyblwiKSB7XG4gICAgICB0aGlzLnJhaXNlKGluaXQuc3RhcnQsIFwiSW52YWxpZCBsZWZ0LWhhbmQgc2lkZSBpbiBmb3ItbG9vcFwiKTtcbiAgICB9XG4gICAgbm9kZS5sZWZ0ID0gaW5pdDtcbiAgICBub2RlLnJpZ2h0ID0gaXNGb3JJbiA/IHRoaXMucGFyc2VFeHByZXNzaW9uKCkgOiB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oKTtcbiAgICB0aGlzLmV4cGVjdCh0eXBlcy5wYXJlblIpO1xuICAgIG5vZGUuYm9keSA9IHRoaXMucGFyc2VTdGF0ZW1lbnQoXCJmb3JcIik7XG4gICAgdGhpcy5leGl0U2NvcGUoKTtcbiAgICB0aGlzLmxhYmVscy5wb3AoKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIGlzRm9ySW4gPyBcIkZvckluU3RhdGVtZW50XCIgOiBcIkZvck9mU3RhdGVtZW50XCIpXG4gIH07XG5cblxuICBwcCQxLnBhcnNlVmFyID0gZnVuY3Rpb24obm9kZSwgaXNGb3IsIGtpbmQpIHtcbiAgICBub2RlLmRlY2xhcmF0aW9ucyA9IFtdO1xuICAgIG5vZGUua2luZCA9IGtpbmQ7XG4gICAgZm9yICg7Oykge1xuICAgICAgdmFyIGRlY2wgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgdGhpcy5wYXJzZVZhcklkKGRlY2wsIGtpbmQpO1xuICAgICAgaWYgKHRoaXMuZWF0KHR5cGVzLmVxKSkge1xuICAgICAgICBkZWNsLmluaXQgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oaXNGb3IpO1xuICAgICAgfSBlbHNlIGlmIChraW5kID09PSBcImNvbnN0XCIgJiYgISh0aGlzLnR5cGUgPT09IHR5cGVzLl9pbiB8fCAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYgJiYgdGhpcy5pc0NvbnRleHR1YWwoXCJvZlwiKSkpKSB7XG4gICAgICAgIHRoaXMudW5leHBlY3RlZCgpO1xuICAgICAgfSBlbHNlIGlmIChkZWNsLmlkLnR5cGUgIT09IFwiSWRlbnRpZmllclwiICYmICEoaXNGb3IgJiYgKHRoaXMudHlwZSA9PT0gdHlwZXMuX2luIHx8IHRoaXMuaXNDb250ZXh0dWFsKFwib2ZcIikpKSkge1xuICAgICAgICB0aGlzLnJhaXNlKHRoaXMubGFzdFRva0VuZCwgXCJDb21wbGV4IGJpbmRpbmcgcGF0dGVybnMgcmVxdWlyZSBhbiBpbml0aWFsaXphdGlvbiB2YWx1ZVwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlY2wuaW5pdCA9IG51bGw7XG4gICAgICB9XG4gICAgICBub2RlLmRlY2xhcmF0aW9ucy5wdXNoKHRoaXMuZmluaXNoTm9kZShkZWNsLCBcIlZhcmlhYmxlRGVjbGFyYXRvclwiKSk7XG4gICAgICBpZiAoIXRoaXMuZWF0KHR5cGVzLmNvbW1hKSkgeyBicmVhayB9XG4gICAgfVxuICAgIHJldHVybiBub2RlXG4gIH07XG5cbiAgcHAkMS5wYXJzZVZhcklkID0gZnVuY3Rpb24oZGVjbCwga2luZCkge1xuICAgIGRlY2wuaWQgPSB0aGlzLnBhcnNlQmluZGluZ0F0b20oKTtcbiAgICB0aGlzLmNoZWNrTFZhbChkZWNsLmlkLCBraW5kID09PSBcInZhclwiID8gQklORF9WQVIgOiBCSU5EX0xFWElDQUwsIGZhbHNlKTtcbiAgfTtcblxuICB2YXIgRlVOQ19TVEFURU1FTlQgPSAxLCBGVU5DX0hBTkdJTkdfU1RBVEVNRU5UID0gMiwgRlVOQ19OVUxMQUJMRV9JRCA9IDQ7XG5cblxuICBwcCQxLnBhcnNlRnVuY3Rpb24gPSBmdW5jdGlvbihub2RlLCBzdGF0ZW1lbnQsIGFsbG93RXhwcmVzc2lvbkJvZHksIGlzQXN5bmMpIHtcbiAgICB0aGlzLmluaXRGdW5jdGlvbihub2RlKTtcbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkgfHwgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYgJiYgIWlzQXN5bmMpIHtcbiAgICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLnN0YXIgJiYgKHN0YXRlbWVudCAmIEZVTkNfSEFOR0lOR19TVEFURU1FTlQpKVxuICAgICAgICB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgICBub2RlLmdlbmVyYXRvciA9IHRoaXMuZWF0KHR5cGVzLnN0YXIpO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDgpXG4gICAgICB7IG5vZGUuYXN5bmMgPSAhIWlzQXN5bmM7IH1cblxuICAgIGlmIChzdGF0ZW1lbnQgJiBGVU5DX1NUQVRFTUVOVCkge1xuICAgICAgbm9kZS5pZCA9IChzdGF0ZW1lbnQgJiBGVU5DX05VTExBQkxFX0lEKSAmJiB0aGlzLnR5cGUgIT09IHR5cGVzLm5hbWUgPyBudWxsIDogdGhpcy5wYXJzZUlkZW50KCk7XG4gICAgICBpZiAobm9kZS5pZCAmJiAhKHN0YXRlbWVudCAmIEZVTkNfSEFOR0lOR19TVEFURU1FTlQpKVxuICAgICAgICB7IHRoaXMuY2hlY2tMVmFsKG5vZGUuaWQsICh0aGlzLnN0cmljdCB8fCBub2RlLmdlbmVyYXRvciB8fCBub2RlLmFzeW5jKSA/IHRoaXMudHJlYXRGdW5jdGlvbnNBc1ZhciA/IEJJTkRfVkFSIDogQklORF9MRVhJQ0FMIDogQklORF9GVU5DVElPTik7IH1cbiAgICB9XG5cbiAgICB2YXIgb2xkWWllbGRQb3MgPSB0aGlzLnlpZWxkUG9zLCBvbGRBd2FpdFBvcyA9IHRoaXMuYXdhaXRQb3MsIG9sZEF3YWl0SWRlbnRQb3MgPSB0aGlzLmF3YWl0SWRlbnRQb3M7XG4gICAgdGhpcy55aWVsZFBvcyA9IDA7XG4gICAgdGhpcy5hd2FpdFBvcyA9IDA7XG4gICAgdGhpcy5hd2FpdElkZW50UG9zID0gMDtcbiAgICB0aGlzLmVudGVyU2NvcGUoZnVuY3Rpb25GbGFncyhub2RlLmFzeW5jLCBub2RlLmdlbmVyYXRvcikpO1xuXG4gICAgaWYgKCEoc3RhdGVtZW50ICYgRlVOQ19TVEFURU1FTlQpKVxuICAgICAgeyBub2RlLmlkID0gdGhpcy50eXBlID09PSB0eXBlcy5uYW1lID8gdGhpcy5wYXJzZUlkZW50KCkgOiBudWxsOyB9XG5cbiAgICB0aGlzLnBhcnNlRnVuY3Rpb25QYXJhbXMobm9kZSk7XG4gICAgdGhpcy5wYXJzZUZ1bmN0aW9uQm9keShub2RlLCBhbGxvd0V4cHJlc3Npb25Cb2R5LCBmYWxzZSk7XG5cbiAgICB0aGlzLnlpZWxkUG9zID0gb2xkWWllbGRQb3M7XG4gICAgdGhpcy5hd2FpdFBvcyA9IG9sZEF3YWl0UG9zO1xuICAgIHRoaXMuYXdhaXRJZGVudFBvcyA9IG9sZEF3YWl0SWRlbnRQb3M7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCAoc3RhdGVtZW50ICYgRlVOQ19TVEFURU1FTlQpID8gXCJGdW5jdGlvbkRlY2xhcmF0aW9uXCIgOiBcIkZ1bmN0aW9uRXhwcmVzc2lvblwiKVxuICB9O1xuXG4gIHBwJDEucGFyc2VGdW5jdGlvblBhcmFtcyA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICB0aGlzLmV4cGVjdCh0eXBlcy5wYXJlbkwpO1xuICAgIG5vZGUucGFyYW1zID0gdGhpcy5wYXJzZUJpbmRpbmdMaXN0KHR5cGVzLnBhcmVuUiwgZmFsc2UsIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA4KTtcbiAgICB0aGlzLmNoZWNrWWllbGRBd2FpdEluRGVmYXVsdFBhcmFtcygpO1xuICB9O1xuXG5cbiAgcHAkMS5wYXJzZUNsYXNzID0gZnVuY3Rpb24obm9kZSwgaXNTdGF0ZW1lbnQpIHtcbiAgICB0aGlzLm5leHQoKTtcblxuICAgIHZhciBvbGRTdHJpY3QgPSB0aGlzLnN0cmljdDtcbiAgICB0aGlzLnN0cmljdCA9IHRydWU7XG5cbiAgICB0aGlzLnBhcnNlQ2xhc3NJZChub2RlLCBpc1N0YXRlbWVudCk7XG4gICAgdGhpcy5wYXJzZUNsYXNzU3VwZXIobm9kZSk7XG4gICAgdmFyIGNsYXNzQm9keSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdmFyIGhhZENvbnN0cnVjdG9yID0gZmFsc2U7XG4gICAgY2xhc3NCb2R5LmJvZHkgPSBbXTtcbiAgICB0aGlzLmV4cGVjdCh0eXBlcy5icmFjZUwpO1xuICAgIHdoaWxlICh0aGlzLnR5cGUgIT09IHR5cGVzLmJyYWNlUikge1xuICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLnBhcnNlQ2xhc3NFbGVtZW50KG5vZGUuc3VwZXJDbGFzcyAhPT0gbnVsbCk7XG4gICAgICBpZiAoZWxlbWVudCkge1xuICAgICAgICBjbGFzc0JvZHkuYm9keS5wdXNoKGVsZW1lbnQpO1xuICAgICAgICBpZiAoZWxlbWVudC50eXBlID09PSBcIk1ldGhvZERlZmluaXRpb25cIiAmJiBlbGVtZW50LmtpbmQgPT09IFwiY29uc3RydWN0b3JcIikge1xuICAgICAgICAgIGlmIChoYWRDb25zdHJ1Y3RvcikgeyB0aGlzLnJhaXNlKGVsZW1lbnQuc3RhcnQsIFwiRHVwbGljYXRlIGNvbnN0cnVjdG9yIGluIHRoZSBzYW1lIGNsYXNzXCIpOyB9XG4gICAgICAgICAgaGFkQ29uc3RydWN0b3IgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuc3RyaWN0ID0gb2xkU3RyaWN0O1xuICAgIHRoaXMubmV4dCgpO1xuICAgIG5vZGUuYm9keSA9IHRoaXMuZmluaXNoTm9kZShjbGFzc0JvZHksIFwiQ2xhc3NCb2R5XCIpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgaXNTdGF0ZW1lbnQgPyBcIkNsYXNzRGVjbGFyYXRpb25cIiA6IFwiQ2xhc3NFeHByZXNzaW9uXCIpXG4gIH07XG5cbiAgcHAkMS5wYXJzZUNsYXNzRWxlbWVudCA9IGZ1bmN0aW9uKGNvbnN0cnVjdG9yQWxsb3dzU3VwZXIpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIGlmICh0aGlzLmVhdCh0eXBlcy5zZW1pKSkgeyByZXR1cm4gbnVsbCB9XG5cbiAgICB2YXIgbWV0aG9kID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB2YXIgdHJ5Q29udGV4dHVhbCA9IGZ1bmN0aW9uIChrLCBub0xpbmVCcmVhaykge1xuICAgICAgaWYgKCBub0xpbmVCcmVhayA9PT0gdm9pZCAwICkgbm9MaW5lQnJlYWsgPSBmYWxzZTtcblxuICAgICAgdmFyIHN0YXJ0ID0gdGhpcyQxLnN0YXJ0LCBzdGFydExvYyA9IHRoaXMkMS5zdGFydExvYztcbiAgICAgIGlmICghdGhpcyQxLmVhdENvbnRleHR1YWwoaykpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICAgIGlmICh0aGlzJDEudHlwZSAhPT0gdHlwZXMucGFyZW5MICYmICghbm9MaW5lQnJlYWsgfHwgIXRoaXMkMS5jYW5JbnNlcnRTZW1pY29sb24oKSkpIHsgcmV0dXJuIHRydWUgfVxuICAgICAgaWYgKG1ldGhvZC5rZXkpIHsgdGhpcyQxLnVuZXhwZWN0ZWQoKTsgfVxuICAgICAgbWV0aG9kLmNvbXB1dGVkID0gZmFsc2U7XG4gICAgICBtZXRob2Qua2V5ID0gdGhpcyQxLnN0YXJ0Tm9kZUF0KHN0YXJ0LCBzdGFydExvYyk7XG4gICAgICBtZXRob2Qua2V5Lm5hbWUgPSBrO1xuICAgICAgdGhpcyQxLmZpbmlzaE5vZGUobWV0aG9kLmtleSwgXCJJZGVudGlmaWVyXCIpO1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfTtcblxuICAgIG1ldGhvZC5raW5kID0gXCJtZXRob2RcIjtcbiAgICBtZXRob2Quc3RhdGljID0gdHJ5Q29udGV4dHVhbChcInN0YXRpY1wiKTtcbiAgICB2YXIgaXNHZW5lcmF0b3IgPSB0aGlzLmVhdCh0eXBlcy5zdGFyKTtcbiAgICB2YXIgaXNBc3luYyA9IGZhbHNlO1xuICAgIGlmICghaXNHZW5lcmF0b3IpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOCAmJiB0cnlDb250ZXh0dWFsKFwiYXN5bmNcIiwgdHJ1ZSkpIHtcbiAgICAgICAgaXNBc3luYyA9IHRydWU7XG4gICAgICAgIGlzR2VuZXJhdG9yID0gdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkgJiYgdGhpcy5lYXQodHlwZXMuc3Rhcik7XG4gICAgICB9IGVsc2UgaWYgKHRyeUNvbnRleHR1YWwoXCJnZXRcIikpIHtcbiAgICAgICAgbWV0aG9kLmtpbmQgPSBcImdldFwiO1xuICAgICAgfSBlbHNlIGlmICh0cnlDb250ZXh0dWFsKFwic2V0XCIpKSB7XG4gICAgICAgIG1ldGhvZC5raW5kID0gXCJzZXRcIjtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFtZXRob2Qua2V5KSB7IHRoaXMucGFyc2VQcm9wZXJ0eU5hbWUobWV0aG9kKTsgfVxuICAgIHZhciBrZXkgPSBtZXRob2Qua2V5O1xuICAgIHZhciBhbGxvd3NEaXJlY3RTdXBlciA9IGZhbHNlO1xuICAgIGlmICghbWV0aG9kLmNvbXB1dGVkICYmICFtZXRob2Quc3RhdGljICYmIChrZXkudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiYga2V5Lm5hbWUgPT09IFwiY29uc3RydWN0b3JcIiB8fFxuICAgICAgICBrZXkudHlwZSA9PT0gXCJMaXRlcmFsXCIgJiYga2V5LnZhbHVlID09PSBcImNvbnN0cnVjdG9yXCIpKSB7XG4gICAgICBpZiAobWV0aG9kLmtpbmQgIT09IFwibWV0aG9kXCIpIHsgdGhpcy5yYWlzZShrZXkuc3RhcnQsIFwiQ29uc3RydWN0b3IgY2FuJ3QgaGF2ZSBnZXQvc2V0IG1vZGlmaWVyXCIpOyB9XG4gICAgICBpZiAoaXNHZW5lcmF0b3IpIHsgdGhpcy5yYWlzZShrZXkuc3RhcnQsIFwiQ29uc3RydWN0b3IgY2FuJ3QgYmUgYSBnZW5lcmF0b3JcIik7IH1cbiAgICAgIGlmIChpc0FzeW5jKSB7IHRoaXMucmFpc2Uoa2V5LnN0YXJ0LCBcIkNvbnN0cnVjdG9yIGNhbid0IGJlIGFuIGFzeW5jIG1ldGhvZFwiKTsgfVxuICAgICAgbWV0aG9kLmtpbmQgPSBcImNvbnN0cnVjdG9yXCI7XG4gICAgICBhbGxvd3NEaXJlY3RTdXBlciA9IGNvbnN0cnVjdG9yQWxsb3dzU3VwZXI7XG4gICAgfSBlbHNlIGlmIChtZXRob2Quc3RhdGljICYmIGtleS50eXBlID09PSBcIklkZW50aWZpZXJcIiAmJiBrZXkubmFtZSA9PT0gXCJwcm90b3R5cGVcIikge1xuICAgICAgdGhpcy5yYWlzZShrZXkuc3RhcnQsIFwiQ2xhc3NlcyBtYXkgbm90IGhhdmUgYSBzdGF0aWMgcHJvcGVydHkgbmFtZWQgcHJvdG90eXBlXCIpO1xuICAgIH1cbiAgICB0aGlzLnBhcnNlQ2xhc3NNZXRob2QobWV0aG9kLCBpc0dlbmVyYXRvciwgaXNBc3luYywgYWxsb3dzRGlyZWN0U3VwZXIpO1xuICAgIGlmIChtZXRob2Qua2luZCA9PT0gXCJnZXRcIiAmJiBtZXRob2QudmFsdWUucGFyYW1zLmxlbmd0aCAhPT0gMClcbiAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKG1ldGhvZC52YWx1ZS5zdGFydCwgXCJnZXR0ZXIgc2hvdWxkIGhhdmUgbm8gcGFyYW1zXCIpOyB9XG4gICAgaWYgKG1ldGhvZC5raW5kID09PSBcInNldFwiICYmIG1ldGhvZC52YWx1ZS5wYXJhbXMubGVuZ3RoICE9PSAxKVxuICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUobWV0aG9kLnZhbHVlLnN0YXJ0LCBcInNldHRlciBzaG91bGQgaGF2ZSBleGFjdGx5IG9uZSBwYXJhbVwiKTsgfVxuICAgIGlmIChtZXRob2Qua2luZCA9PT0gXCJzZXRcIiAmJiBtZXRob2QudmFsdWUucGFyYW1zWzBdLnR5cGUgPT09IFwiUmVzdEVsZW1lbnRcIilcbiAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKG1ldGhvZC52YWx1ZS5wYXJhbXNbMF0uc3RhcnQsIFwiU2V0dGVyIGNhbm5vdCB1c2UgcmVzdCBwYXJhbXNcIik7IH1cbiAgICByZXR1cm4gbWV0aG9kXG4gIH07XG5cbiAgcHAkMS5wYXJzZUNsYXNzTWV0aG9kID0gZnVuY3Rpb24obWV0aG9kLCBpc0dlbmVyYXRvciwgaXNBc3luYywgYWxsb3dzRGlyZWN0U3VwZXIpIHtcbiAgICBtZXRob2QudmFsdWUgPSB0aGlzLnBhcnNlTWV0aG9kKGlzR2VuZXJhdG9yLCBpc0FzeW5jLCBhbGxvd3NEaXJlY3RTdXBlcik7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShtZXRob2QsIFwiTWV0aG9kRGVmaW5pdGlvblwiKVxuICB9O1xuXG4gIHBwJDEucGFyc2VDbGFzc0lkID0gZnVuY3Rpb24obm9kZSwgaXNTdGF0ZW1lbnQpIHtcbiAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5uYW1lKSB7XG4gICAgICBub2RlLmlkID0gdGhpcy5wYXJzZUlkZW50KCk7XG4gICAgICBpZiAoaXNTdGF0ZW1lbnQpXG4gICAgICAgIHsgdGhpcy5jaGVja0xWYWwobm9kZS5pZCwgQklORF9MRVhJQ0FMLCBmYWxzZSk7IH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGlzU3RhdGVtZW50ID09PSB0cnVlKVxuICAgICAgICB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgICBub2RlLmlkID0gbnVsbDtcbiAgICB9XG4gIH07XG5cbiAgcHAkMS5wYXJzZUNsYXNzU3VwZXIgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgbm9kZS5zdXBlckNsYXNzID0gdGhpcy5lYXQodHlwZXMuX2V4dGVuZHMpID8gdGhpcy5wYXJzZUV4cHJTdWJzY3JpcHRzKCkgOiBudWxsO1xuICB9O1xuXG5cbiAgcHAkMS5wYXJzZUV4cG9ydCA9IGZ1bmN0aW9uKG5vZGUsIGV4cG9ydHMpIHtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBpZiAodGhpcy5lYXQodHlwZXMuc3RhcikpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gMTEpIHtcbiAgICAgICAgaWYgKHRoaXMuZWF0Q29udGV4dHVhbChcImFzXCIpKSB7XG4gICAgICAgICAgbm9kZS5leHBvcnRlZCA9IHRoaXMucGFyc2VJZGVudCh0cnVlKTtcbiAgICAgICAgICB0aGlzLmNoZWNrRXhwb3J0KGV4cG9ydHMsIG5vZGUuZXhwb3J0ZWQubmFtZSwgdGhpcy5sYXN0VG9rU3RhcnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vZGUuZXhwb3J0ZWQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmV4cGVjdENvbnRleHR1YWwoXCJmcm9tXCIpO1xuICAgICAgaWYgKHRoaXMudHlwZSAhPT0gdHlwZXMuc3RyaW5nKSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgICBub2RlLnNvdXJjZSA9IHRoaXMucGFyc2VFeHByQXRvbSgpO1xuICAgICAgdGhpcy5zZW1pY29sb24oKTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJFeHBvcnRBbGxEZWNsYXJhdGlvblwiKVxuICAgIH1cbiAgICBpZiAodGhpcy5lYXQodHlwZXMuX2RlZmF1bHQpKSB7IFxuICAgICAgdGhpcy5jaGVja0V4cG9ydChleHBvcnRzLCBcImRlZmF1bHRcIiwgdGhpcy5sYXN0VG9rU3RhcnQpO1xuICAgICAgdmFyIGlzQXN5bmM7XG4gICAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5fZnVuY3Rpb24gfHwgKGlzQXN5bmMgPSB0aGlzLmlzQXN5bmNGdW5jdGlvbigpKSkge1xuICAgICAgICB2YXIgZk5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgaWYgKGlzQXN5bmMpIHsgdGhpcy5uZXh0KCk7IH1cbiAgICAgICAgbm9kZS5kZWNsYXJhdGlvbiA9IHRoaXMucGFyc2VGdW5jdGlvbihmTm9kZSwgRlVOQ19TVEFURU1FTlQgfCBGVU5DX05VTExBQkxFX0lELCBmYWxzZSwgaXNBc3luYyk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuX2NsYXNzKSB7XG4gICAgICAgIHZhciBjTm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICAgIG5vZGUuZGVjbGFyYXRpb24gPSB0aGlzLnBhcnNlQ2xhc3MoY05vZGUsIFwibnVsbGFibGVJRFwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUuZGVjbGFyYXRpb24gPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oKTtcbiAgICAgICAgdGhpcy5zZW1pY29sb24oKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJFeHBvcnREZWZhdWx0RGVjbGFyYXRpb25cIilcbiAgICB9XG4gICAgaWYgKHRoaXMuc2hvdWxkUGFyc2VFeHBvcnRTdGF0ZW1lbnQoKSkge1xuICAgICAgbm9kZS5kZWNsYXJhdGlvbiA9IHRoaXMucGFyc2VTdGF0ZW1lbnQobnVsbCk7XG4gICAgICBpZiAobm9kZS5kZWNsYXJhdGlvbi50eXBlID09PSBcIlZhcmlhYmxlRGVjbGFyYXRpb25cIilcbiAgICAgICAgeyB0aGlzLmNoZWNrVmFyaWFibGVFeHBvcnQoZXhwb3J0cywgbm9kZS5kZWNsYXJhdGlvbi5kZWNsYXJhdGlvbnMpOyB9XG4gICAgICBlbHNlXG4gICAgICAgIHsgdGhpcy5jaGVja0V4cG9ydChleHBvcnRzLCBub2RlLmRlY2xhcmF0aW9uLmlkLm5hbWUsIG5vZGUuZGVjbGFyYXRpb24uaWQuc3RhcnQpOyB9XG4gICAgICBub2RlLnNwZWNpZmllcnMgPSBbXTtcbiAgICAgIG5vZGUuc291cmNlID0gbnVsbDtcbiAgICB9IGVsc2UgeyBcbiAgICAgIG5vZGUuZGVjbGFyYXRpb24gPSBudWxsO1xuICAgICAgbm9kZS5zcGVjaWZpZXJzID0gdGhpcy5wYXJzZUV4cG9ydFNwZWNpZmllcnMoZXhwb3J0cyk7XG4gICAgICBpZiAodGhpcy5lYXRDb250ZXh0dWFsKFwiZnJvbVwiKSkge1xuICAgICAgICBpZiAodGhpcy50eXBlICE9PSB0eXBlcy5zdHJpbmcpIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICAgICAgbm9kZS5zb3VyY2UgPSB0aGlzLnBhcnNlRXhwckF0b20oKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gbm9kZS5zcGVjaWZpZXJzOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgIHZhciBzcGVjID0gbGlzdFtpXTtcblxuICAgICAgICAgIHRoaXMuY2hlY2tVbnJlc2VydmVkKHNwZWMubG9jYWwpO1xuICAgICAgICAgIHRoaXMuY2hlY2tMb2NhbEV4cG9ydChzcGVjLmxvY2FsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5vZGUuc291cmNlID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJFeHBvcnROYW1lZERlY2xhcmF0aW9uXCIpXG4gIH07XG5cbiAgcHAkMS5jaGVja0V4cG9ydCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIHBvcykge1xuICAgIGlmICghZXhwb3J0cykgeyByZXR1cm4gfVxuICAgIGlmIChoYXMoZXhwb3J0cywgbmFtZSkpXG4gICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShwb3MsIFwiRHVwbGljYXRlIGV4cG9ydCAnXCIgKyBuYW1lICsgXCInXCIpOyB9XG4gICAgZXhwb3J0c1tuYW1lXSA9IHRydWU7XG4gIH07XG5cbiAgcHAkMS5jaGVja1BhdHRlcm5FeHBvcnQgPSBmdW5jdGlvbihleHBvcnRzLCBwYXQpIHtcbiAgICB2YXIgdHlwZSA9IHBhdC50eXBlO1xuICAgIGlmICh0eXBlID09PSBcIklkZW50aWZpZXJcIilcbiAgICAgIHsgdGhpcy5jaGVja0V4cG9ydChleHBvcnRzLCBwYXQubmFtZSwgcGF0LnN0YXJ0KTsgfVxuICAgIGVsc2UgaWYgKHR5cGUgPT09IFwiT2JqZWN0UGF0dGVyblwiKVxuICAgICAgeyBmb3IgKHZhciBpID0gMCwgbGlzdCA9IHBhdC5wcm9wZXJ0aWVzOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSlcbiAgICAgICAge1xuICAgICAgICAgIHZhciBwcm9wID0gbGlzdFtpXTtcblxuICAgICAgICAgIHRoaXMuY2hlY2tQYXR0ZXJuRXhwb3J0KGV4cG9ydHMsIHByb3ApO1xuICAgICAgICB9IH1cbiAgICBlbHNlIGlmICh0eXBlID09PSBcIkFycmF5UGF0dGVyblwiKVxuICAgICAgeyBmb3IgKHZhciBpJDEgPSAwLCBsaXN0JDEgPSBwYXQuZWxlbWVudHM7IGkkMSA8IGxpc3QkMS5sZW5ndGg7IGkkMSArPSAxKSB7XG4gICAgICAgIHZhciBlbHQgPSBsaXN0JDFbaSQxXTtcblxuICAgICAgICAgIGlmIChlbHQpIHsgdGhpcy5jaGVja1BhdHRlcm5FeHBvcnQoZXhwb3J0cywgZWx0KTsgfVxuICAgICAgfSB9XG4gICAgZWxzZSBpZiAodHlwZSA9PT0gXCJQcm9wZXJ0eVwiKVxuICAgICAgeyB0aGlzLmNoZWNrUGF0dGVybkV4cG9ydChleHBvcnRzLCBwYXQudmFsdWUpOyB9XG4gICAgZWxzZSBpZiAodHlwZSA9PT0gXCJBc3NpZ25tZW50UGF0dGVyblwiKVxuICAgICAgeyB0aGlzLmNoZWNrUGF0dGVybkV4cG9ydChleHBvcnRzLCBwYXQubGVmdCk7IH1cbiAgICBlbHNlIGlmICh0eXBlID09PSBcIlJlc3RFbGVtZW50XCIpXG4gICAgICB7IHRoaXMuY2hlY2tQYXR0ZXJuRXhwb3J0KGV4cG9ydHMsIHBhdC5hcmd1bWVudCk7IH1cbiAgICBlbHNlIGlmICh0eXBlID09PSBcIlBhcmVudGhlc2l6ZWRFeHByZXNzaW9uXCIpXG4gICAgICB7IHRoaXMuY2hlY2tQYXR0ZXJuRXhwb3J0KGV4cG9ydHMsIHBhdC5leHByZXNzaW9uKTsgfVxuICB9O1xuXG4gIHBwJDEuY2hlY2tWYXJpYWJsZUV4cG9ydCA9IGZ1bmN0aW9uKGV4cG9ydHMsIGRlY2xzKSB7XG4gICAgaWYgKCFleHBvcnRzKSB7IHJldHVybiB9XG4gICAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBkZWNsczsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpXG4gICAgICB7XG4gICAgICB2YXIgZGVjbCA9IGxpc3RbaV07XG5cbiAgICAgIHRoaXMuY2hlY2tQYXR0ZXJuRXhwb3J0KGV4cG9ydHMsIGRlY2wuaWQpO1xuICAgIH1cbiAgfTtcblxuICBwcCQxLnNob3VsZFBhcnNlRXhwb3J0U3RhdGVtZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMudHlwZS5rZXl3b3JkID09PSBcInZhclwiIHx8XG4gICAgICB0aGlzLnR5cGUua2V5d29yZCA9PT0gXCJjb25zdFwiIHx8XG4gICAgICB0aGlzLnR5cGUua2V5d29yZCA9PT0gXCJjbGFzc1wiIHx8XG4gICAgICB0aGlzLnR5cGUua2V5d29yZCA9PT0gXCJmdW5jdGlvblwiIHx8XG4gICAgICB0aGlzLmlzTGV0KCkgfHxcbiAgICAgIHRoaXMuaXNBc3luY0Z1bmN0aW9uKClcbiAgfTtcblxuXG4gIHBwJDEucGFyc2VFeHBvcnRTcGVjaWZpZXJzID0gZnVuY3Rpb24oZXhwb3J0cykge1xuICAgIHZhciBub2RlcyA9IFtdLCBmaXJzdCA9IHRydWU7XG4gICAgdGhpcy5leHBlY3QodHlwZXMuYnJhY2VMKTtcbiAgICB3aGlsZSAoIXRoaXMuZWF0KHR5cGVzLmJyYWNlUikpIHtcbiAgICAgIGlmICghZmlyc3QpIHtcbiAgICAgICAgdGhpcy5leHBlY3QodHlwZXMuY29tbWEpO1xuICAgICAgICBpZiAodGhpcy5hZnRlclRyYWlsaW5nQ29tbWEodHlwZXMuYnJhY2VSKSkgeyBicmVhayB9XG4gICAgICB9IGVsc2UgeyBmaXJzdCA9IGZhbHNlOyB9XG5cbiAgICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgIG5vZGUubG9jYWwgPSB0aGlzLnBhcnNlSWRlbnQodHJ1ZSk7XG4gICAgICBub2RlLmV4cG9ydGVkID0gdGhpcy5lYXRDb250ZXh0dWFsKFwiYXNcIikgPyB0aGlzLnBhcnNlSWRlbnQodHJ1ZSkgOiBub2RlLmxvY2FsO1xuICAgICAgdGhpcy5jaGVja0V4cG9ydChleHBvcnRzLCBub2RlLmV4cG9ydGVkLm5hbWUsIG5vZGUuZXhwb3J0ZWQuc3RhcnQpO1xuICAgICAgbm9kZXMucHVzaCh0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJFeHBvcnRTcGVjaWZpZXJcIikpO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZXNcbiAgfTtcblxuXG4gIHBwJDEucGFyc2VJbXBvcnQgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuc3RyaW5nKSB7XG4gICAgICBub2RlLnNwZWNpZmllcnMgPSBlbXB0eTtcbiAgICAgIG5vZGUuc291cmNlID0gdGhpcy5wYXJzZUV4cHJBdG9tKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUuc3BlY2lmaWVycyA9IHRoaXMucGFyc2VJbXBvcnRTcGVjaWZpZXJzKCk7XG4gICAgICB0aGlzLmV4cGVjdENvbnRleHR1YWwoXCJmcm9tXCIpO1xuICAgICAgbm9kZS5zb3VyY2UgPSB0aGlzLnR5cGUgPT09IHR5cGVzLnN0cmluZyA/IHRoaXMucGFyc2VFeHByQXRvbSgpIDogdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgfVxuICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkltcG9ydERlY2xhcmF0aW9uXCIpXG4gIH07XG5cblxuICBwcCQxLnBhcnNlSW1wb3J0U3BlY2lmaWVycyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBub2RlcyA9IFtdLCBmaXJzdCA9IHRydWU7XG4gICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMubmFtZSkge1xuICAgICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgbm9kZS5sb2NhbCA9IHRoaXMucGFyc2VJZGVudCgpO1xuICAgICAgdGhpcy5jaGVja0xWYWwobm9kZS5sb2NhbCwgQklORF9MRVhJQ0FMKTtcbiAgICAgIG5vZGVzLnB1c2godGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiSW1wb3J0RGVmYXVsdFNwZWNpZmllclwiKSk7XG4gICAgICBpZiAoIXRoaXMuZWF0KHR5cGVzLmNvbW1hKSkgeyByZXR1cm4gbm9kZXMgfVxuICAgIH1cbiAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5zdGFyKSB7XG4gICAgICB2YXIgbm9kZSQxID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgdGhpcy5leHBlY3RDb250ZXh0dWFsKFwiYXNcIik7XG4gICAgICBub2RlJDEubG9jYWwgPSB0aGlzLnBhcnNlSWRlbnQoKTtcbiAgICAgIHRoaXMuY2hlY2tMVmFsKG5vZGUkMS5sb2NhbCwgQklORF9MRVhJQ0FMKTtcbiAgICAgIG5vZGVzLnB1c2godGhpcy5maW5pc2hOb2RlKG5vZGUkMSwgXCJJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXJcIikpO1xuICAgICAgcmV0dXJuIG5vZGVzXG4gICAgfVxuICAgIHRoaXMuZXhwZWN0KHR5cGVzLmJyYWNlTCk7XG4gICAgd2hpbGUgKCF0aGlzLmVhdCh0eXBlcy5icmFjZVIpKSB7XG4gICAgICBpZiAoIWZpcnN0KSB7XG4gICAgICAgIHRoaXMuZXhwZWN0KHR5cGVzLmNvbW1hKTtcbiAgICAgICAgaWYgKHRoaXMuYWZ0ZXJUcmFpbGluZ0NvbW1hKHR5cGVzLmJyYWNlUikpIHsgYnJlYWsgfVxuICAgICAgfSBlbHNlIHsgZmlyc3QgPSBmYWxzZTsgfVxuXG4gICAgICB2YXIgbm9kZSQyID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgIG5vZGUkMi5pbXBvcnRlZCA9IHRoaXMucGFyc2VJZGVudCh0cnVlKTtcbiAgICAgIGlmICh0aGlzLmVhdENvbnRleHR1YWwoXCJhc1wiKSkge1xuICAgICAgICBub2RlJDIubG9jYWwgPSB0aGlzLnBhcnNlSWRlbnQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY2hlY2tVbnJlc2VydmVkKG5vZGUkMi5pbXBvcnRlZCk7XG4gICAgICAgIG5vZGUkMi5sb2NhbCA9IG5vZGUkMi5pbXBvcnRlZDtcbiAgICAgIH1cbiAgICAgIHRoaXMuY2hlY2tMVmFsKG5vZGUkMi5sb2NhbCwgQklORF9MRVhJQ0FMKTtcbiAgICAgIG5vZGVzLnB1c2godGhpcy5maW5pc2hOb2RlKG5vZGUkMiwgXCJJbXBvcnRTcGVjaWZpZXJcIikpO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZXNcbiAgfTtcblxuICBwcCQxLmFkYXB0RGlyZWN0aXZlUHJvbG9ndWUgPSBmdW5jdGlvbihzdGF0ZW1lbnRzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGF0ZW1lbnRzLmxlbmd0aCAmJiB0aGlzLmlzRGlyZWN0aXZlQ2FuZGlkYXRlKHN0YXRlbWVudHNbaV0pOyArK2kpIHtcbiAgICAgIHN0YXRlbWVudHNbaV0uZGlyZWN0aXZlID0gc3RhdGVtZW50c1tpXS5leHByZXNzaW9uLnJhdy5zbGljZSgxLCAtMSk7XG4gICAgfVxuICB9O1xuICBwcCQxLmlzRGlyZWN0aXZlQ2FuZGlkYXRlID0gZnVuY3Rpb24oc3RhdGVtZW50KSB7XG4gICAgcmV0dXJuIChcbiAgICAgIHN0YXRlbWVudC50eXBlID09PSBcIkV4cHJlc3Npb25TdGF0ZW1lbnRcIiAmJlxuICAgICAgc3RhdGVtZW50LmV4cHJlc3Npb24udHlwZSA9PT0gXCJMaXRlcmFsXCIgJiZcbiAgICAgIHR5cGVvZiBzdGF0ZW1lbnQuZXhwcmVzc2lvbi52YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJlxuICAgICAgKHRoaXMuaW5wdXRbc3RhdGVtZW50LnN0YXJ0XSA9PT0gXCJcXFwiXCIgfHwgdGhpcy5pbnB1dFtzdGF0ZW1lbnQuc3RhcnRdID09PSBcIidcIilcbiAgICApXG4gIH07XG5cbiAgdmFyIHBwJDIgPSBQYXJzZXIucHJvdG90eXBlO1xuXG5cbiAgcHAkMi50b0Fzc2lnbmFibGUgPSBmdW5jdGlvbihub2RlLCBpc0JpbmRpbmcsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYgJiYgbm9kZSkge1xuICAgICAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICAgIGNhc2UgXCJJZGVudGlmaWVyXCI6XG4gICAgICAgIGlmICh0aGlzLmluQXN5bmMgJiYgbm9kZS5uYW1lID09PSBcImF3YWl0XCIpXG4gICAgICAgICAgeyB0aGlzLnJhaXNlKG5vZGUuc3RhcnQsIFwiQ2Fubm90IHVzZSAnYXdhaXQnIGFzIGlkZW50aWZpZXIgaW5zaWRlIGFuIGFzeW5jIGZ1bmN0aW9uXCIpOyB9XG4gICAgICAgIGJyZWFrXG5cbiAgICAgIGNhc2UgXCJPYmplY3RQYXR0ZXJuXCI6XG4gICAgICBjYXNlIFwiQXJyYXlQYXR0ZXJuXCI6XG4gICAgICBjYXNlIFwiUmVzdEVsZW1lbnRcIjpcbiAgICAgICAgYnJlYWtcblxuICAgICAgY2FzZSBcIk9iamVjdEV4cHJlc3Npb25cIjpcbiAgICAgICAgbm9kZS50eXBlID0gXCJPYmplY3RQYXR0ZXJuXCI7XG4gICAgICAgIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7IHRoaXMuY2hlY2tQYXR0ZXJuRXJyb3JzKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIHRydWUpOyB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gbm9kZS5wcm9wZXJ0aWVzOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgIHZhciBwcm9wID0gbGlzdFtpXTtcblxuICAgICAgICB0aGlzLnRvQXNzaWduYWJsZShwcm9wLCBpc0JpbmRpbmcpO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIHByb3AudHlwZSA9PT0gXCJSZXN0RWxlbWVudFwiICYmXG4gICAgICAgICAgICAocHJvcC5hcmd1bWVudC50eXBlID09PSBcIkFycmF5UGF0dGVyblwiIHx8IHByb3AuYXJndW1lbnQudHlwZSA9PT0gXCJPYmplY3RQYXR0ZXJuXCIpXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICB0aGlzLnJhaXNlKHByb3AuYXJndW1lbnQuc3RhcnQsIFwiVW5leHBlY3RlZCB0b2tlblwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWtcblxuICAgICAgY2FzZSBcIlByb3BlcnR5XCI6XG4gICAgICAgIGlmIChub2RlLmtpbmQgIT09IFwiaW5pdFwiKSB7IHRoaXMucmFpc2Uobm9kZS5rZXkuc3RhcnQsIFwiT2JqZWN0IHBhdHRlcm4gY2FuJ3QgY29udGFpbiBnZXR0ZXIgb3Igc2V0dGVyXCIpOyB9XG4gICAgICAgIHRoaXMudG9Bc3NpZ25hYmxlKG5vZGUudmFsdWUsIGlzQmluZGluZyk7XG4gICAgICAgIGJyZWFrXG5cbiAgICAgIGNhc2UgXCJBcnJheUV4cHJlc3Npb25cIjpcbiAgICAgICAgbm9kZS50eXBlID0gXCJBcnJheVBhdHRlcm5cIjtcbiAgICAgICAgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHsgdGhpcy5jaGVja1BhdHRlcm5FcnJvcnMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgdHJ1ZSk7IH1cbiAgICAgICAgdGhpcy50b0Fzc2lnbmFibGVMaXN0KG5vZGUuZWxlbWVudHMsIGlzQmluZGluZyk7XG4gICAgICAgIGJyZWFrXG5cbiAgICAgIGNhc2UgXCJTcHJlYWRFbGVtZW50XCI6XG4gICAgICAgIG5vZGUudHlwZSA9IFwiUmVzdEVsZW1lbnRcIjtcbiAgICAgICAgdGhpcy50b0Fzc2lnbmFibGUobm9kZS5hcmd1bWVudCwgaXNCaW5kaW5nKTtcbiAgICAgICAgaWYgKG5vZGUuYXJndW1lbnQudHlwZSA9PT0gXCJBc3NpZ25tZW50UGF0dGVyblwiKVxuICAgICAgICAgIHsgdGhpcy5yYWlzZShub2RlLmFyZ3VtZW50LnN0YXJ0LCBcIlJlc3QgZWxlbWVudHMgY2Fubm90IGhhdmUgYSBkZWZhdWx0IHZhbHVlXCIpOyB9XG4gICAgICAgIGJyZWFrXG5cbiAgICAgIGNhc2UgXCJBc3NpZ25tZW50RXhwcmVzc2lvblwiOlxuICAgICAgICBpZiAobm9kZS5vcGVyYXRvciAhPT0gXCI9XCIpIHsgdGhpcy5yYWlzZShub2RlLmxlZnQuZW5kLCBcIk9ubHkgJz0nIG9wZXJhdG9yIGNhbiBiZSB1c2VkIGZvciBzcGVjaWZ5aW5nIGRlZmF1bHQgdmFsdWUuXCIpOyB9XG4gICAgICAgIG5vZGUudHlwZSA9IFwiQXNzaWdubWVudFBhdHRlcm5cIjtcbiAgICAgICAgZGVsZXRlIG5vZGUub3BlcmF0b3I7XG4gICAgICAgIHRoaXMudG9Bc3NpZ25hYmxlKG5vZGUubGVmdCwgaXNCaW5kaW5nKTtcblxuICAgICAgY2FzZSBcIkFzc2lnbm1lbnRQYXR0ZXJuXCI6XG4gICAgICAgIGJyZWFrXG5cbiAgICAgIGNhc2UgXCJQYXJlbnRoZXNpemVkRXhwcmVzc2lvblwiOlxuICAgICAgICB0aGlzLnRvQXNzaWduYWJsZShub2RlLmV4cHJlc3Npb24sIGlzQmluZGluZywgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gICAgICAgIGJyZWFrXG5cbiAgICAgIGNhc2UgXCJDaGFpbkV4cHJlc3Npb25cIjpcbiAgICAgICAgdGhpcy5yYWlzZVJlY292ZXJhYmxlKG5vZGUuc3RhcnQsIFwiT3B0aW9uYWwgY2hhaW5pbmcgY2Fubm90IGFwcGVhciBpbiBsZWZ0LWhhbmQgc2lkZVwiKTtcbiAgICAgICAgYnJlYWtcblxuICAgICAgY2FzZSBcIk1lbWJlckV4cHJlc3Npb25cIjpcbiAgICAgICAgaWYgKCFpc0JpbmRpbmcpIHsgYnJlYWsgfVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aGlzLnJhaXNlKG5vZGUuc3RhcnQsIFwiQXNzaWduaW5nIHRvIHJ2YWx1ZVwiKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHsgdGhpcy5jaGVja1BhdHRlcm5FcnJvcnMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgdHJ1ZSk7IH1cbiAgICByZXR1cm4gbm9kZVxuICB9O1xuXG5cbiAgcHAkMi50b0Fzc2lnbmFibGVMaXN0ID0gZnVuY3Rpb24oZXhwckxpc3QsIGlzQmluZGluZykge1xuICAgIHZhciBlbmQgPSBleHByTGlzdC5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgdmFyIGVsdCA9IGV4cHJMaXN0W2ldO1xuICAgICAgaWYgKGVsdCkgeyB0aGlzLnRvQXNzaWduYWJsZShlbHQsIGlzQmluZGluZyk7IH1cbiAgICB9XG4gICAgaWYgKGVuZCkge1xuICAgICAgdmFyIGxhc3QgPSBleHByTGlzdFtlbmQgLSAxXTtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPT09IDYgJiYgaXNCaW5kaW5nICYmIGxhc3QgJiYgbGFzdC50eXBlID09PSBcIlJlc3RFbGVtZW50XCIgJiYgbGFzdC5hcmd1bWVudC50eXBlICE9PSBcIklkZW50aWZpZXJcIilcbiAgICAgICAgeyB0aGlzLnVuZXhwZWN0ZWQobGFzdC5hcmd1bWVudC5zdGFydCk7IH1cbiAgICB9XG4gICAgcmV0dXJuIGV4cHJMaXN0XG4gIH07XG5cblxuICBwcCQyLnBhcnNlU3ByZWFkID0gZnVuY3Rpb24ocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBub2RlLmFyZ3VtZW50ID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKGZhbHNlLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiU3ByZWFkRWxlbWVudFwiKVxuICB9O1xuXG4gIHBwJDIucGFyc2VSZXN0QmluZGluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB0aGlzLm5leHQoKTtcblxuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPT09IDYgJiYgdGhpcy50eXBlICE9PSB0eXBlcy5uYW1lKVxuICAgICAgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuXG4gICAgbm9kZS5hcmd1bWVudCA9IHRoaXMucGFyc2VCaW5kaW5nQXRvbSgpO1xuXG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlJlc3RFbGVtZW50XCIpXG4gIH07XG5cblxuICBwcCQyLnBhcnNlQmluZGluZ0F0b20gPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYpIHtcbiAgICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XG4gICAgICBjYXNlIHR5cGVzLmJyYWNrZXRMOlxuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICBub2RlLmVsZW1lbnRzID0gdGhpcy5wYXJzZUJpbmRpbmdMaXN0KHR5cGVzLmJyYWNrZXRSLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkFycmF5UGF0dGVyblwiKVxuXG4gICAgICBjYXNlIHR5cGVzLmJyYWNlTDpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPYmoodHJ1ZSlcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucGFyc2VJZGVudCgpXG4gIH07XG5cbiAgcHAkMi5wYXJzZUJpbmRpbmdMaXN0ID0gZnVuY3Rpb24oY2xvc2UsIGFsbG93RW1wdHksIGFsbG93VHJhaWxpbmdDb21tYSkge1xuICAgIHZhciBlbHRzID0gW10sIGZpcnN0ID0gdHJ1ZTtcbiAgICB3aGlsZSAoIXRoaXMuZWF0KGNsb3NlKSkge1xuICAgICAgaWYgKGZpcnN0KSB7IGZpcnN0ID0gZmFsc2U7IH1cbiAgICAgIGVsc2UgeyB0aGlzLmV4cGVjdCh0eXBlcy5jb21tYSk7IH1cbiAgICAgIGlmIChhbGxvd0VtcHR5ICYmIHRoaXMudHlwZSA9PT0gdHlwZXMuY29tbWEpIHtcbiAgICAgICAgZWx0cy5wdXNoKG51bGwpO1xuICAgICAgfSBlbHNlIGlmIChhbGxvd1RyYWlsaW5nQ29tbWEgJiYgdGhpcy5hZnRlclRyYWlsaW5nQ29tbWEoY2xvc2UpKSB7XG4gICAgICAgIGJyZWFrXG4gICAgICB9IGVsc2UgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuZWxsaXBzaXMpIHtcbiAgICAgICAgdmFyIHJlc3QgPSB0aGlzLnBhcnNlUmVzdEJpbmRpbmcoKTtcbiAgICAgICAgdGhpcy5wYXJzZUJpbmRpbmdMaXN0SXRlbShyZXN0KTtcbiAgICAgICAgZWx0cy5wdXNoKHJlc3QpO1xuICAgICAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5jb21tYSkgeyB0aGlzLnJhaXNlKHRoaXMuc3RhcnQsIFwiQ29tbWEgaXMgbm90IHBlcm1pdHRlZCBhZnRlciB0aGUgcmVzdCBlbGVtZW50XCIpOyB9XG4gICAgICAgIHRoaXMuZXhwZWN0KGNsb3NlKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBlbGVtID0gdGhpcy5wYXJzZU1heWJlRGVmYXVsdCh0aGlzLnN0YXJ0LCB0aGlzLnN0YXJ0TG9jKTtcbiAgICAgICAgdGhpcy5wYXJzZUJpbmRpbmdMaXN0SXRlbShlbGVtKTtcbiAgICAgICAgZWx0cy5wdXNoKGVsZW0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZWx0c1xuICB9O1xuXG4gIHBwJDIucGFyc2VCaW5kaW5nTGlzdEl0ZW0gPSBmdW5jdGlvbihwYXJhbSkge1xuICAgIHJldHVybiBwYXJhbVxuICB9O1xuXG5cbiAgcHAkMi5wYXJzZU1heWJlRGVmYXVsdCA9IGZ1bmN0aW9uKHN0YXJ0UG9zLCBzdGFydExvYywgbGVmdCkge1xuICAgIGxlZnQgPSBsZWZ0IHx8IHRoaXMucGFyc2VCaW5kaW5nQXRvbSgpO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPCA2IHx8ICF0aGlzLmVhdCh0eXBlcy5lcSkpIHsgcmV0dXJuIGxlZnQgfVxuICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICAgIG5vZGUubGVmdCA9IGxlZnQ7XG4gICAgbm9kZS5yaWdodCA9IHRoaXMucGFyc2VNYXliZUFzc2lnbigpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJBc3NpZ25tZW50UGF0dGVyblwiKVxuICB9O1xuXG5cbiAgcHAkMi5jaGVja0xWYWwgPSBmdW5jdGlvbihleHByLCBiaW5kaW5nVHlwZSwgY2hlY2tDbGFzaGVzKSB7XG4gICAgaWYgKCBiaW5kaW5nVHlwZSA9PT0gdm9pZCAwICkgYmluZGluZ1R5cGUgPSBCSU5EX05PTkU7XG5cbiAgICBzd2l0Y2ggKGV4cHIudHlwZSkge1xuICAgIGNhc2UgXCJJZGVudGlmaWVyXCI6XG4gICAgICBpZiAoYmluZGluZ1R5cGUgPT09IEJJTkRfTEVYSUNBTCAmJiBleHByLm5hbWUgPT09IFwibGV0XCIpXG4gICAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKGV4cHIuc3RhcnQsIFwibGV0IGlzIGRpc2FsbG93ZWQgYXMgYSBsZXhpY2FsbHkgYm91bmQgbmFtZVwiKTsgfVxuICAgICAgaWYgKHRoaXMuc3RyaWN0ICYmIHRoaXMucmVzZXJ2ZWRXb3Jkc1N0cmljdEJpbmQudGVzdChleHByLm5hbWUpKVxuICAgICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShleHByLnN0YXJ0LCAoYmluZGluZ1R5cGUgPyBcIkJpbmRpbmcgXCIgOiBcIkFzc2lnbmluZyB0byBcIikgKyBleHByLm5hbWUgKyBcIiBpbiBzdHJpY3QgbW9kZVwiKTsgfVxuICAgICAgaWYgKGNoZWNrQ2xhc2hlcykge1xuICAgICAgICBpZiAoaGFzKGNoZWNrQ2xhc2hlcywgZXhwci5uYW1lKSlcbiAgICAgICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShleHByLnN0YXJ0LCBcIkFyZ3VtZW50IG5hbWUgY2xhc2hcIik7IH1cbiAgICAgICAgY2hlY2tDbGFzaGVzW2V4cHIubmFtZV0gPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGJpbmRpbmdUeXBlICE9PSBCSU5EX05PTkUgJiYgYmluZGluZ1R5cGUgIT09IEJJTkRfT1VUU0lERSkgeyB0aGlzLmRlY2xhcmVOYW1lKGV4cHIubmFtZSwgYmluZGluZ1R5cGUsIGV4cHIuc3RhcnQpOyB9XG4gICAgICBicmVha1xuXG4gICAgY2FzZSBcIkNoYWluRXhwcmVzc2lvblwiOlxuICAgICAgdGhpcy5yYWlzZVJlY292ZXJhYmxlKGV4cHIuc3RhcnQsIFwiT3B0aW9uYWwgY2hhaW5pbmcgY2Fubm90IGFwcGVhciBpbiBsZWZ0LWhhbmQgc2lkZVwiKTtcbiAgICAgIGJyZWFrXG5cbiAgICBjYXNlIFwiTWVtYmVyRXhwcmVzc2lvblwiOlxuICAgICAgaWYgKGJpbmRpbmdUeXBlKSB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShleHByLnN0YXJ0LCBcIkJpbmRpbmcgbWVtYmVyIGV4cHJlc3Npb25cIik7IH1cbiAgICAgIGJyZWFrXG5cbiAgICBjYXNlIFwiT2JqZWN0UGF0dGVyblwiOlxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBleHByLnByb3BlcnRpZXM7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKVxuICAgICAgICB7XG4gICAgICB2YXIgcHJvcCA9IGxpc3RbaV07XG5cbiAgICAgIHRoaXMuY2hlY2tMVmFsKHByb3AsIGJpbmRpbmdUeXBlLCBjaGVja0NsYXNoZXMpO1xuICAgIH1cbiAgICAgIGJyZWFrXG5cbiAgICBjYXNlIFwiUHJvcGVydHlcIjpcbiAgICAgIHRoaXMuY2hlY2tMVmFsKGV4cHIudmFsdWUsIGJpbmRpbmdUeXBlLCBjaGVja0NsYXNoZXMpO1xuICAgICAgYnJlYWtcblxuICAgIGNhc2UgXCJBcnJheVBhdHRlcm5cIjpcbiAgICAgIGZvciAodmFyIGkkMSA9IDAsIGxpc3QkMSA9IGV4cHIuZWxlbWVudHM7IGkkMSA8IGxpc3QkMS5sZW5ndGg7IGkkMSArPSAxKSB7XG4gICAgICAgIHZhciBlbGVtID0gbGlzdCQxW2kkMV07XG5cbiAgICAgIGlmIChlbGVtKSB7IHRoaXMuY2hlY2tMVmFsKGVsZW0sIGJpbmRpbmdUeXBlLCBjaGVja0NsYXNoZXMpOyB9XG4gICAgICB9XG4gICAgICBicmVha1xuXG4gICAgY2FzZSBcIkFzc2lnbm1lbnRQYXR0ZXJuXCI6XG4gICAgICB0aGlzLmNoZWNrTFZhbChleHByLmxlZnQsIGJpbmRpbmdUeXBlLCBjaGVja0NsYXNoZXMpO1xuICAgICAgYnJlYWtcblxuICAgIGNhc2UgXCJSZXN0RWxlbWVudFwiOlxuICAgICAgdGhpcy5jaGVja0xWYWwoZXhwci5hcmd1bWVudCwgYmluZGluZ1R5cGUsIGNoZWNrQ2xhc2hlcyk7XG4gICAgICBicmVha1xuXG4gICAgY2FzZSBcIlBhcmVudGhlc2l6ZWRFeHByZXNzaW9uXCI6XG4gICAgICB0aGlzLmNoZWNrTFZhbChleHByLmV4cHJlc3Npb24sIGJpbmRpbmdUeXBlLCBjaGVja0NsYXNoZXMpO1xuICAgICAgYnJlYWtcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aGlzLnJhaXNlKGV4cHIuc3RhcnQsIChiaW5kaW5nVHlwZSA/IFwiQmluZGluZ1wiIDogXCJBc3NpZ25pbmcgdG9cIikgKyBcIiBydmFsdWVcIik7XG4gICAgfVxuICB9O1xuXG5cbiAgdmFyIHBwJDMgPSBQYXJzZXIucHJvdG90eXBlO1xuXG5cbiAgcHAkMy5jaGVja1Byb3BDbGFzaCA9IGZ1bmN0aW9uKHByb3AsIHByb3BIYXNoLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA5ICYmIHByb3AudHlwZSA9PT0gXCJTcHJlYWRFbGVtZW50XCIpXG4gICAgICB7IHJldHVybiB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2ICYmIChwcm9wLmNvbXB1dGVkIHx8IHByb3AubWV0aG9kIHx8IHByb3Auc2hvcnRoYW5kKSlcbiAgICAgIHsgcmV0dXJuIH1cbiAgICB2YXIga2V5ID0gcHJvcC5rZXk7XG4gICAgdmFyIG5hbWU7XG4gICAgc3dpdGNoIChrZXkudHlwZSkge1xuICAgIGNhc2UgXCJJZGVudGlmaWVyXCI6IG5hbWUgPSBrZXkubmFtZTsgYnJlYWtcbiAgICBjYXNlIFwiTGl0ZXJhbFwiOiBuYW1lID0gU3RyaW5nKGtleS52YWx1ZSk7IGJyZWFrXG4gICAgZGVmYXVsdDogcmV0dXJuXG4gICAgfVxuICAgIHZhciBraW5kID0gcHJvcC5raW5kO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNikge1xuICAgICAgaWYgKG5hbWUgPT09IFwiX19wcm90b19fXCIgJiYga2luZCA9PT0gXCJpbml0XCIpIHtcbiAgICAgICAgaWYgKHByb3BIYXNoLnByb3RvKSB7XG4gICAgICAgICAgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgICAgICAgICAgIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLmRvdWJsZVByb3RvIDwgMClcbiAgICAgICAgICAgICAgeyByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLmRvdWJsZVByb3RvID0ga2V5LnN0YXJ0OyB9XG4gICAgICAgICAgfSBlbHNlIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKGtleS5zdGFydCwgXCJSZWRlZmluaXRpb24gb2YgX19wcm90b19fIHByb3BlcnR5XCIpOyB9XG4gICAgICAgIH1cbiAgICAgICAgcHJvcEhhc2gucHJvdG8gPSB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIG5hbWUgPSBcIiRcIiArIG5hbWU7XG4gICAgdmFyIG90aGVyID0gcHJvcEhhc2hbbmFtZV07XG4gICAgaWYgKG90aGVyKSB7XG4gICAgICB2YXIgcmVkZWZpbml0aW9uO1xuICAgICAgaWYgKGtpbmQgPT09IFwiaW5pdFwiKSB7XG4gICAgICAgIHJlZGVmaW5pdGlvbiA9IHRoaXMuc3RyaWN0ICYmIG90aGVyLmluaXQgfHwgb3RoZXIuZ2V0IHx8IG90aGVyLnNldDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlZGVmaW5pdGlvbiA9IG90aGVyLmluaXQgfHwgb3RoZXJba2luZF07XG4gICAgICB9XG4gICAgICBpZiAocmVkZWZpbml0aW9uKVxuICAgICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShrZXkuc3RhcnQsIFwiUmVkZWZpbml0aW9uIG9mIHByb3BlcnR5XCIpOyB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG90aGVyID0gcHJvcEhhc2hbbmFtZV0gPSB7XG4gICAgICAgIGluaXQ6IGZhbHNlLFxuICAgICAgICBnZXQ6IGZhbHNlLFxuICAgICAgICBzZXQ6IGZhbHNlXG4gICAgICB9O1xuICAgIH1cbiAgICBvdGhlcltraW5kXSA9IHRydWU7XG4gIH07XG5cblxuXG5cbiAgcHAkMy5wYXJzZUV4cHJlc3Npb24gPSBmdW5jdGlvbihub0luLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gICAgdmFyIHN0YXJ0UG9zID0gdGhpcy5zdGFydCwgc3RhcnRMb2MgPSB0aGlzLnN0YXJ0TG9jO1xuICAgIHZhciBleHByID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKG5vSW4sIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLmNvbW1hKSB7XG4gICAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICAgIG5vZGUuZXhwcmVzc2lvbnMgPSBbZXhwcl07XG4gICAgICB3aGlsZSAodGhpcy5lYXQodHlwZXMuY29tbWEpKSB7IG5vZGUuZXhwcmVzc2lvbnMucHVzaCh0aGlzLnBhcnNlTWF5YmVBc3NpZ24obm9JbiwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykpOyB9XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiU2VxdWVuY2VFeHByZXNzaW9uXCIpXG4gICAgfVxuICAgIHJldHVybiBleHByXG4gIH07XG5cblxuICBwcCQzLnBhcnNlTWF5YmVBc3NpZ24gPSBmdW5jdGlvbihub0luLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCBhZnRlckxlZnRQYXJzZSkge1xuICAgIGlmICh0aGlzLmlzQ29udGV4dHVhbChcInlpZWxkXCIpKSB7XG4gICAgICBpZiAodGhpcy5pbkdlbmVyYXRvcikgeyByZXR1cm4gdGhpcy5wYXJzZVlpZWxkKG5vSW4pIH1cbiAgICAgIGVsc2UgeyB0aGlzLmV4cHJBbGxvd2VkID0gZmFsc2U7IH1cbiAgICB9XG5cbiAgICB2YXIgb3duRGVzdHJ1Y3R1cmluZ0Vycm9ycyA9IGZhbHNlLCBvbGRQYXJlbkFzc2lnbiA9IC0xLCBvbGRUcmFpbGluZ0NvbW1hID0gLTE7XG4gICAgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgICAgIG9sZFBhcmVuQXNzaWduID0gcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQXNzaWduO1xuICAgICAgb2xkVHJhaWxpbmdDb21tYSA9IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMudHJhaWxpbmdDb21tYTtcbiAgICAgIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEFzc2lnbiA9IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMudHJhaWxpbmdDb21tYSA9IC0xO1xuICAgIH0gZWxzZSB7XG4gICAgICByZWZEZXN0cnVjdHVyaW5nRXJyb3JzID0gbmV3IERlc3RydWN0dXJpbmdFcnJvcnM7XG4gICAgICBvd25EZXN0cnVjdHVyaW5nRXJyb3JzID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgc3RhcnRQb3MgPSB0aGlzLnN0YXJ0LCBzdGFydExvYyA9IHRoaXMuc3RhcnRMb2M7XG4gICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMucGFyZW5MIHx8IHRoaXMudHlwZSA9PT0gdHlwZXMubmFtZSlcbiAgICAgIHsgdGhpcy5wb3RlbnRpYWxBcnJvd0F0ID0gdGhpcy5zdGFydDsgfVxuICAgIHZhciBsZWZ0ID0gdGhpcy5wYXJzZU1heWJlQ29uZGl0aW9uYWwobm9JbiwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gICAgaWYgKGFmdGVyTGVmdFBhcnNlKSB7IGxlZnQgPSBhZnRlckxlZnRQYXJzZS5jYWxsKHRoaXMsIGxlZnQsIHN0YXJ0UG9zLCBzdGFydExvYyk7IH1cbiAgICBpZiAodGhpcy50eXBlLmlzQXNzaWduKSB7XG4gICAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICAgIG5vZGUub3BlcmF0b3IgPSB0aGlzLnZhbHVlO1xuICAgICAgbm9kZS5sZWZ0ID0gdGhpcy50eXBlID09PSB0eXBlcy5lcSA/IHRoaXMudG9Bc3NpZ25hYmxlKGxlZnQsIGZhbHNlLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSA6IGxlZnQ7XG4gICAgICBpZiAoIW93bkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgICAgICAgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQXNzaWduID0gcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy50cmFpbGluZ0NvbW1hID0gcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5kb3VibGVQcm90byA9IC0xO1xuICAgICAgfVxuICAgICAgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMuc2hvcnRoYW5kQXNzaWduID49IG5vZGUubGVmdC5zdGFydClcbiAgICAgICAgeyByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnNob3J0aGFuZEFzc2lnbiA9IC0xOyB9IFxuICAgICAgdGhpcy5jaGVja0xWYWwobGVmdCk7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIG5vZGUucmlnaHQgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24obm9Jbik7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQXNzaWdubWVudEV4cHJlc3Npb25cIilcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKG93bkRlc3RydWN0dXJpbmdFcnJvcnMpIHsgdGhpcy5jaGVja0V4cHJlc3Npb25FcnJvcnMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgdHJ1ZSk7IH1cbiAgICB9XG4gICAgaWYgKG9sZFBhcmVuQXNzaWduID4gLTEpIHsgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQXNzaWduID0gb2xkUGFyZW5Bc3NpZ247IH1cbiAgICBpZiAob2xkVHJhaWxpbmdDb21tYSA+IC0xKSB7IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMudHJhaWxpbmdDb21tYSA9IG9sZFRyYWlsaW5nQ29tbWE7IH1cbiAgICByZXR1cm4gbGVmdFxuICB9O1xuXG5cbiAgcHAkMy5wYXJzZU1heWJlQ29uZGl0aW9uYWwgPSBmdW5jdGlvbihub0luLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gICAgdmFyIHN0YXJ0UG9zID0gdGhpcy5zdGFydCwgc3RhcnRMb2MgPSB0aGlzLnN0YXJ0TG9jO1xuICAgIHZhciBleHByID0gdGhpcy5wYXJzZUV4cHJPcHMobm9JbiwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gICAgaWYgKHRoaXMuY2hlY2tFeHByZXNzaW9uRXJyb3JzKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpKSB7IHJldHVybiBleHByIH1cbiAgICBpZiAodGhpcy5lYXQodHlwZXMucXVlc3Rpb24pKSB7XG4gICAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICAgIG5vZGUudGVzdCA9IGV4cHI7XG4gICAgICBub2RlLmNvbnNlcXVlbnQgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oKTtcbiAgICAgIHRoaXMuZXhwZWN0KHR5cGVzLmNvbG9uKTtcbiAgICAgIG5vZGUuYWx0ZXJuYXRlID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKG5vSW4pO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkNvbmRpdGlvbmFsRXhwcmVzc2lvblwiKVxuICAgIH1cbiAgICByZXR1cm4gZXhwclxuICB9O1xuXG5cbiAgcHAkMy5wYXJzZUV4cHJPcHMgPSBmdW5jdGlvbihub0luLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gICAgdmFyIHN0YXJ0UG9zID0gdGhpcy5zdGFydCwgc3RhcnRMb2MgPSB0aGlzLnN0YXJ0TG9jO1xuICAgIHZhciBleHByID0gdGhpcy5wYXJzZU1heWJlVW5hcnkocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgZmFsc2UpO1xuICAgIGlmICh0aGlzLmNoZWNrRXhwcmVzc2lvbkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSkgeyByZXR1cm4gZXhwciB9XG4gICAgcmV0dXJuIGV4cHIuc3RhcnQgPT09IHN0YXJ0UG9zICYmIGV4cHIudHlwZSA9PT0gXCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwiID8gZXhwciA6IHRoaXMucGFyc2VFeHByT3AoZXhwciwgc3RhcnRQb3MsIHN0YXJ0TG9jLCAtMSwgbm9JbilcbiAgfTtcblxuXG4gIHBwJDMucGFyc2VFeHByT3AgPSBmdW5jdGlvbihsZWZ0LCBsZWZ0U3RhcnRQb3MsIGxlZnRTdGFydExvYywgbWluUHJlYywgbm9Jbikge1xuICAgIHZhciBwcmVjID0gdGhpcy50eXBlLmJpbm9wO1xuICAgIGlmIChwcmVjICE9IG51bGwgJiYgKCFub0luIHx8IHRoaXMudHlwZSAhPT0gdHlwZXMuX2luKSkge1xuICAgICAgaWYgKHByZWMgPiBtaW5QcmVjKSB7XG4gICAgICAgIHZhciBsb2dpY2FsID0gdGhpcy50eXBlID09PSB0eXBlcy5sb2dpY2FsT1IgfHwgdGhpcy50eXBlID09PSB0eXBlcy5sb2dpY2FsQU5EO1xuICAgICAgICB2YXIgY29hbGVzY2UgPSB0aGlzLnR5cGUgPT09IHR5cGVzLmNvYWxlc2NlO1xuICAgICAgICBpZiAoY29hbGVzY2UpIHtcbiAgICAgICAgICBwcmVjID0gdHlwZXMubG9naWNhbEFORC5iaW5vcDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb3AgPSB0aGlzLnZhbHVlO1xuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgdmFyIHN0YXJ0UG9zID0gdGhpcy5zdGFydCwgc3RhcnRMb2MgPSB0aGlzLnN0YXJ0TG9jO1xuICAgICAgICB2YXIgcmlnaHQgPSB0aGlzLnBhcnNlRXhwck9wKHRoaXMucGFyc2VNYXliZVVuYXJ5KG51bGwsIGZhbHNlKSwgc3RhcnRQb3MsIHN0YXJ0TG9jLCBwcmVjLCBub0luKTtcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmJ1aWxkQmluYXJ5KGxlZnRTdGFydFBvcywgbGVmdFN0YXJ0TG9jLCBsZWZ0LCByaWdodCwgb3AsIGxvZ2ljYWwgfHwgY29hbGVzY2UpO1xuICAgICAgICBpZiAoKGxvZ2ljYWwgJiYgdGhpcy50eXBlID09PSB0eXBlcy5jb2FsZXNjZSkgfHwgKGNvYWxlc2NlICYmICh0aGlzLnR5cGUgPT09IHR5cGVzLmxvZ2ljYWxPUiB8fCB0aGlzLnR5cGUgPT09IHR5cGVzLmxvZ2ljYWxBTkQpKSkge1xuICAgICAgICAgIHRoaXMucmFpc2VSZWNvdmVyYWJsZSh0aGlzLnN0YXJ0LCBcIkxvZ2ljYWwgZXhwcmVzc2lvbnMgYW5kIGNvYWxlc2NlIGV4cHJlc3Npb25zIGNhbm5vdCBiZSBtaXhlZC4gV3JhcCBlaXRoZXIgYnkgcGFyZW50aGVzZXNcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VFeHByT3Aobm9kZSwgbGVmdFN0YXJ0UG9zLCBsZWZ0U3RhcnRMb2MsIG1pblByZWMsIG5vSW4pXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBsZWZ0XG4gIH07XG5cbiAgcHAkMy5idWlsZEJpbmFyeSA9IGZ1bmN0aW9uKHN0YXJ0UG9zLCBzdGFydExvYywgbGVmdCwgcmlnaHQsIG9wLCBsb2dpY2FsKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gICAgbm9kZS5sZWZ0ID0gbGVmdDtcbiAgICBub2RlLm9wZXJhdG9yID0gb3A7XG4gICAgbm9kZS5yaWdodCA9IHJpZ2h0O1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgbG9naWNhbCA/IFwiTG9naWNhbEV4cHJlc3Npb25cIiA6IFwiQmluYXJ5RXhwcmVzc2lvblwiKVxuICB9O1xuXG5cbiAgcHAkMy5wYXJzZU1heWJlVW5hcnkgPSBmdW5jdGlvbihyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCBzYXdVbmFyeSkge1xuICAgIHZhciBzdGFydFBvcyA9IHRoaXMuc3RhcnQsIHN0YXJ0TG9jID0gdGhpcy5zdGFydExvYywgZXhwcjtcbiAgICBpZiAodGhpcy5pc0NvbnRleHR1YWwoXCJhd2FpdFwiKSAmJiAodGhpcy5pbkFzeW5jIHx8ICghdGhpcy5pbkZ1bmN0aW9uICYmIHRoaXMub3B0aW9ucy5hbGxvd0F3YWl0T3V0c2lkZUZ1bmN0aW9uKSkpIHtcbiAgICAgIGV4cHIgPSB0aGlzLnBhcnNlQXdhaXQoKTtcbiAgICAgIHNhd1VuYXJ5ID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHRoaXMudHlwZS5wcmVmaXgpIHtcbiAgICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKSwgdXBkYXRlID0gdGhpcy50eXBlID09PSB0eXBlcy5pbmNEZWM7XG4gICAgICBub2RlLm9wZXJhdG9yID0gdGhpcy52YWx1ZTtcbiAgICAgIG5vZGUucHJlZml4ID0gdHJ1ZTtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgbm9kZS5hcmd1bWVudCA9IHRoaXMucGFyc2VNYXliZVVuYXJ5KG51bGwsIHRydWUpO1xuICAgICAgdGhpcy5jaGVja0V4cHJlc3Npb25FcnJvcnMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgdHJ1ZSk7XG4gICAgICBpZiAodXBkYXRlKSB7IHRoaXMuY2hlY2tMVmFsKG5vZGUuYXJndW1lbnQpOyB9XG4gICAgICBlbHNlIGlmICh0aGlzLnN0cmljdCAmJiBub2RlLm9wZXJhdG9yID09PSBcImRlbGV0ZVwiICYmXG4gICAgICAgICAgICAgICBub2RlLmFyZ3VtZW50LnR5cGUgPT09IFwiSWRlbnRpZmllclwiKVxuICAgICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShub2RlLnN0YXJ0LCBcIkRlbGV0aW5nIGxvY2FsIHZhcmlhYmxlIGluIHN0cmljdCBtb2RlXCIpOyB9XG4gICAgICBlbHNlIHsgc2F3VW5hcnkgPSB0cnVlOyB9XG4gICAgICBleHByID0gdGhpcy5maW5pc2hOb2RlKG5vZGUsIHVwZGF0ZSA/IFwiVXBkYXRlRXhwcmVzc2lvblwiIDogXCJVbmFyeUV4cHJlc3Npb25cIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4cHIgPSB0aGlzLnBhcnNlRXhwclN1YnNjcmlwdHMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gICAgICBpZiAodGhpcy5jaGVja0V4cHJlc3Npb25FcnJvcnMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykpIHsgcmV0dXJuIGV4cHIgfVxuICAgICAgd2hpbGUgKHRoaXMudHlwZS5wb3N0Zml4ICYmICF0aGlzLmNhbkluc2VydFNlbWljb2xvbigpKSB7XG4gICAgICAgIHZhciBub2RlJDEgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gICAgICAgIG5vZGUkMS5vcGVyYXRvciA9IHRoaXMudmFsdWU7XG4gICAgICAgIG5vZGUkMS5wcmVmaXggPSBmYWxzZTtcbiAgICAgICAgbm9kZSQxLmFyZ3VtZW50ID0gZXhwcjtcbiAgICAgICAgdGhpcy5jaGVja0xWYWwoZXhwcik7XG4gICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICBleHByID0gdGhpcy5maW5pc2hOb2RlKG5vZGUkMSwgXCJVcGRhdGVFeHByZXNzaW9uXCIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghc2F3VW5hcnkgJiYgdGhpcy5lYXQodHlwZXMuc3RhcnN0YXIpKVxuICAgICAgeyByZXR1cm4gdGhpcy5idWlsZEJpbmFyeShzdGFydFBvcywgc3RhcnRMb2MsIGV4cHIsIHRoaXMucGFyc2VNYXliZVVuYXJ5KG51bGwsIGZhbHNlKSwgXCIqKlwiLCBmYWxzZSkgfVxuICAgIGVsc2VcbiAgICAgIHsgcmV0dXJuIGV4cHIgfVxuICB9O1xuXG5cbiAgcHAkMy5wYXJzZUV4cHJTdWJzY3JpcHRzID0gZnVuY3Rpb24ocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICAgIHZhciBzdGFydFBvcyA9IHRoaXMuc3RhcnQsIHN0YXJ0TG9jID0gdGhpcy5zdGFydExvYztcbiAgICB2YXIgZXhwciA9IHRoaXMucGFyc2VFeHByQXRvbShyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgICBpZiAoZXhwci50eXBlID09PSBcIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCIgJiYgdGhpcy5pbnB1dC5zbGljZSh0aGlzLmxhc3RUb2tTdGFydCwgdGhpcy5sYXN0VG9rRW5kKSAhPT0gXCIpXCIpXG4gICAgICB7IHJldHVybiBleHByIH1cbiAgICB2YXIgcmVzdWx0ID0gdGhpcy5wYXJzZVN1YnNjcmlwdHMoZXhwciwgc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyAmJiByZXN1bHQudHlwZSA9PT0gXCJNZW1iZXJFeHByZXNzaW9uXCIpIHtcbiAgICAgIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRBc3NpZ24gPj0gcmVzdWx0LnN0YXJ0KSB7IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEFzc2lnbiA9IC0xOyB9XG4gICAgICBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQmluZCA+PSByZXN1bHQuc3RhcnQpIHsgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQmluZCA9IC0xOyB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRcbiAgfTtcblxuICBwcCQzLnBhcnNlU3Vic2NyaXB0cyA9IGZ1bmN0aW9uKGJhc2UsIHN0YXJ0UG9zLCBzdGFydExvYywgbm9DYWxscykge1xuICAgIHZhciBtYXliZUFzeW5jQXJyb3cgPSB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOCAmJiBiYXNlLnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmIGJhc2UubmFtZSA9PT0gXCJhc3luY1wiICYmXG4gICAgICAgIHRoaXMubGFzdFRva0VuZCA9PT0gYmFzZS5lbmQgJiYgIXRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCkgJiYgYmFzZS5lbmQgLSBiYXNlLnN0YXJ0ID09PSA1ICYmXG4gICAgICAgIHRoaXMucG90ZW50aWFsQXJyb3dBdCA9PT0gYmFzZS5zdGFydDtcbiAgICB2YXIgb3B0aW9uYWxDaGFpbmVkID0gZmFsc2U7XG5cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLnBhcnNlU3Vic2NyaXB0KGJhc2UsIHN0YXJ0UG9zLCBzdGFydExvYywgbm9DYWxscywgbWF5YmVBc3luY0Fycm93LCBvcHRpb25hbENoYWluZWQpO1xuXG4gICAgICBpZiAoZWxlbWVudC5vcHRpb25hbCkgeyBvcHRpb25hbENoYWluZWQgPSB0cnVlOyB9XG4gICAgICBpZiAoZWxlbWVudCA9PT0gYmFzZSB8fCBlbGVtZW50LnR5cGUgPT09IFwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cIikge1xuICAgICAgICBpZiAob3B0aW9uYWxDaGFpbmVkKSB7XG4gICAgICAgICAgdmFyIGNoYWluTm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICAgICAgICBjaGFpbk5vZGUuZXhwcmVzc2lvbiA9IGVsZW1lbnQ7XG4gICAgICAgICAgZWxlbWVudCA9IHRoaXMuZmluaXNoTm9kZShjaGFpbk5vZGUsIFwiQ2hhaW5FeHByZXNzaW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbGVtZW50XG4gICAgICB9XG5cbiAgICAgIGJhc2UgPSBlbGVtZW50O1xuICAgIH1cbiAgfTtcblxuICBwcCQzLnBhcnNlU3Vic2NyaXB0ID0gZnVuY3Rpb24oYmFzZSwgc3RhcnRQb3MsIHN0YXJ0TG9jLCBub0NhbGxzLCBtYXliZUFzeW5jQXJyb3csIG9wdGlvbmFsQ2hhaW5lZCkge1xuICAgIHZhciBvcHRpb25hbFN1cHBvcnRlZCA9IHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSAxMTtcbiAgICB2YXIgb3B0aW9uYWwgPSBvcHRpb25hbFN1cHBvcnRlZCAmJiB0aGlzLmVhdCh0eXBlcy5xdWVzdGlvbkRvdCk7XG4gICAgaWYgKG5vQ2FsbHMgJiYgb3B0aW9uYWwpIHsgdGhpcy5yYWlzZSh0aGlzLmxhc3RUb2tTdGFydCwgXCJPcHRpb25hbCBjaGFpbmluZyBjYW5ub3QgYXBwZWFyIGluIHRoZSBjYWxsZWUgb2YgbmV3IGV4cHJlc3Npb25zXCIpOyB9XG5cbiAgICB2YXIgY29tcHV0ZWQgPSB0aGlzLmVhdCh0eXBlcy5icmFja2V0TCk7XG4gICAgaWYgKGNvbXB1dGVkIHx8IChvcHRpb25hbCAmJiB0aGlzLnR5cGUgIT09IHR5cGVzLnBhcmVuTCAmJiB0aGlzLnR5cGUgIT09IHR5cGVzLmJhY2tRdW90ZSkgfHwgdGhpcy5lYXQodHlwZXMuZG90KSkge1xuICAgICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gICAgICBub2RlLm9iamVjdCA9IGJhc2U7XG4gICAgICBub2RlLnByb3BlcnR5ID0gY29tcHV0ZWQgPyB0aGlzLnBhcnNlRXhwcmVzc2lvbigpIDogdGhpcy5wYXJzZUlkZW50KHRoaXMub3B0aW9ucy5hbGxvd1Jlc2VydmVkICE9PSBcIm5ldmVyXCIpO1xuICAgICAgbm9kZS5jb21wdXRlZCA9ICEhY29tcHV0ZWQ7XG4gICAgICBpZiAoY29tcHV0ZWQpIHsgdGhpcy5leHBlY3QodHlwZXMuYnJhY2tldFIpOyB9XG4gICAgICBpZiAob3B0aW9uYWxTdXBwb3J0ZWQpIHtcbiAgICAgICAgbm9kZS5vcHRpb25hbCA9IG9wdGlvbmFsO1xuICAgICAgfVxuICAgICAgYmFzZSA9IHRoaXMuZmluaXNoTm9kZShub2RlLCBcIk1lbWJlckV4cHJlc3Npb25cIik7XG4gICAgfSBlbHNlIGlmICghbm9DYWxscyAmJiB0aGlzLmVhdCh0eXBlcy5wYXJlbkwpKSB7XG4gICAgICB2YXIgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyA9IG5ldyBEZXN0cnVjdHVyaW5nRXJyb3JzLCBvbGRZaWVsZFBvcyA9IHRoaXMueWllbGRQb3MsIG9sZEF3YWl0UG9zID0gdGhpcy5hd2FpdFBvcywgb2xkQXdhaXRJZGVudFBvcyA9IHRoaXMuYXdhaXRJZGVudFBvcztcbiAgICAgIHRoaXMueWllbGRQb3MgPSAwO1xuICAgICAgdGhpcy5hd2FpdFBvcyA9IDA7XG4gICAgICB0aGlzLmF3YWl0SWRlbnRQb3MgPSAwO1xuICAgICAgdmFyIGV4cHJMaXN0ID0gdGhpcy5wYXJzZUV4cHJMaXN0KHR5cGVzLnBhcmVuUiwgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDgsIGZhbHNlLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgICAgIGlmIChtYXliZUFzeW5jQXJyb3cgJiYgIW9wdGlvbmFsICYmICF0aGlzLmNhbkluc2VydFNlbWljb2xvbigpICYmIHRoaXMuZWF0KHR5cGVzLmFycm93KSkge1xuICAgICAgICB0aGlzLmNoZWNrUGF0dGVybkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCBmYWxzZSk7XG4gICAgICAgIHRoaXMuY2hlY2tZaWVsZEF3YWl0SW5EZWZhdWx0UGFyYW1zKCk7XG4gICAgICAgIGlmICh0aGlzLmF3YWl0SWRlbnRQb3MgPiAwKVxuICAgICAgICAgIHsgdGhpcy5yYWlzZSh0aGlzLmF3YWl0SWRlbnRQb3MsIFwiQ2Fubm90IHVzZSAnYXdhaXQnIGFzIGlkZW50aWZpZXIgaW5zaWRlIGFuIGFzeW5jIGZ1bmN0aW9uXCIpOyB9XG4gICAgICAgIHRoaXMueWllbGRQb3MgPSBvbGRZaWVsZFBvcztcbiAgICAgICAgdGhpcy5hd2FpdFBvcyA9IG9sZEF3YWl0UG9zO1xuICAgICAgICB0aGlzLmF3YWl0SWRlbnRQb3MgPSBvbGRBd2FpdElkZW50UG9zO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUFycm93RXhwcmVzc2lvbih0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyksIGV4cHJMaXN0LCB0cnVlKVxuICAgICAgfVxuICAgICAgdGhpcy5jaGVja0V4cHJlc3Npb25FcnJvcnMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgdHJ1ZSk7XG4gICAgICB0aGlzLnlpZWxkUG9zID0gb2xkWWllbGRQb3MgfHwgdGhpcy55aWVsZFBvcztcbiAgICAgIHRoaXMuYXdhaXRQb3MgPSBvbGRBd2FpdFBvcyB8fCB0aGlzLmF3YWl0UG9zO1xuICAgICAgdGhpcy5hd2FpdElkZW50UG9zID0gb2xkQXdhaXRJZGVudFBvcyB8fCB0aGlzLmF3YWl0SWRlbnRQb3M7XG4gICAgICB2YXIgbm9kZSQxID0gdGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICAgICAgbm9kZSQxLmNhbGxlZSA9IGJhc2U7XG4gICAgICBub2RlJDEuYXJndW1lbnRzID0gZXhwckxpc3Q7XG4gICAgICBpZiAob3B0aW9uYWxTdXBwb3J0ZWQpIHtcbiAgICAgICAgbm9kZSQxLm9wdGlvbmFsID0gb3B0aW9uYWw7XG4gICAgICB9XG4gICAgICBiYXNlID0gdGhpcy5maW5pc2hOb2RlKG5vZGUkMSwgXCJDYWxsRXhwcmVzc2lvblwiKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuYmFja1F1b3RlKSB7XG4gICAgICBpZiAob3B0aW9uYWwgfHwgb3B0aW9uYWxDaGFpbmVkKSB7XG4gICAgICAgIHRoaXMucmFpc2UodGhpcy5zdGFydCwgXCJPcHRpb25hbCBjaGFpbmluZyBjYW5ub3QgYXBwZWFyIGluIHRoZSB0YWcgb2YgdGFnZ2VkIHRlbXBsYXRlIGV4cHJlc3Npb25zXCIpO1xuICAgICAgfVxuICAgICAgdmFyIG5vZGUkMiA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICAgIG5vZGUkMi50YWcgPSBiYXNlO1xuICAgICAgbm9kZSQyLnF1YXNpID0gdGhpcy5wYXJzZVRlbXBsYXRlKHtpc1RhZ2dlZDogdHJ1ZX0pO1xuICAgICAgYmFzZSA9IHRoaXMuZmluaXNoTm9kZShub2RlJDIsIFwiVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uXCIpO1xuICAgIH1cbiAgICByZXR1cm4gYmFzZVxuICB9O1xuXG5cbiAgcHAkMy5wYXJzZUV4cHJBdG9tID0gZnVuY3Rpb24ocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLnNsYXNoKSB7IHRoaXMucmVhZFJlZ2V4cCgpOyB9XG5cbiAgICB2YXIgbm9kZSwgY2FuQmVBcnJvdyA9IHRoaXMucG90ZW50aWFsQXJyb3dBdCA9PT0gdGhpcy5zdGFydDtcbiAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xuICAgIGNhc2UgdHlwZXMuX3N1cGVyOlxuICAgICAgaWYgKCF0aGlzLmFsbG93U3VwZXIpXG4gICAgICAgIHsgdGhpcy5yYWlzZSh0aGlzLnN0YXJ0LCBcIidzdXBlcicga2V5d29yZCBvdXRzaWRlIGEgbWV0aG9kXCIpOyB9XG4gICAgICBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMucGFyZW5MICYmICF0aGlzLmFsbG93RGlyZWN0U3VwZXIpXG4gICAgICAgIHsgdGhpcy5yYWlzZShub2RlLnN0YXJ0LCBcInN1cGVyKCkgY2FsbCBvdXRzaWRlIGNvbnN0cnVjdG9yIG9mIGEgc3ViY2xhc3NcIik7IH1cbiAgICAgIGlmICh0aGlzLnR5cGUgIT09IHR5cGVzLmRvdCAmJiB0aGlzLnR5cGUgIT09IHR5cGVzLmJyYWNrZXRMICYmIHRoaXMudHlwZSAhPT0gdHlwZXMucGFyZW5MKVxuICAgICAgICB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiU3VwZXJcIilcblxuICAgIGNhc2UgdHlwZXMuX3RoaXM6XG4gICAgICBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRoaXNFeHByZXNzaW9uXCIpXG5cbiAgICBjYXNlIHR5cGVzLm5hbWU6XG4gICAgICB2YXIgc3RhcnRQb3MgPSB0aGlzLnN0YXJ0LCBzdGFydExvYyA9IHRoaXMuc3RhcnRMb2MsIGNvbnRhaW5zRXNjID0gdGhpcy5jb250YWluc0VzYztcbiAgICAgIHZhciBpZCA9IHRoaXMucGFyc2VJZGVudChmYWxzZSk7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDggJiYgIWNvbnRhaW5zRXNjICYmIGlkLm5hbWUgPT09IFwiYXN5bmNcIiAmJiAhdGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKSAmJiB0aGlzLmVhdCh0eXBlcy5fZnVuY3Rpb24pKVxuICAgICAgICB7IHJldHVybiB0aGlzLnBhcnNlRnVuY3Rpb24odGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpLCAwLCBmYWxzZSwgdHJ1ZSkgfVxuICAgICAgaWYgKGNhbkJlQXJyb3cgJiYgIXRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCkpIHtcbiAgICAgICAgaWYgKHRoaXMuZWF0KHR5cGVzLmFycm93KSlcbiAgICAgICAgICB7IHJldHVybiB0aGlzLnBhcnNlQXJyb3dFeHByZXNzaW9uKHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKSwgW2lkXSwgZmFsc2UpIH1cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA4ICYmIGlkLm5hbWUgPT09IFwiYXN5bmNcIiAmJiB0aGlzLnR5cGUgPT09IHR5cGVzLm5hbWUgJiYgIWNvbnRhaW5zRXNjKSB7XG4gICAgICAgICAgaWQgPSB0aGlzLnBhcnNlSWRlbnQoZmFsc2UpO1xuICAgICAgICAgIGlmICh0aGlzLmNhbkluc2VydFNlbWljb2xvbigpIHx8ICF0aGlzLmVhdCh0eXBlcy5hcnJvdykpXG4gICAgICAgICAgICB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VBcnJvd0V4cHJlc3Npb24odGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpLCBbaWRdLCB0cnVlKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gaWRcblxuICAgIGNhc2UgdHlwZXMucmVnZXhwOlxuICAgICAgdmFyIHZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICAgIG5vZGUgPSB0aGlzLnBhcnNlTGl0ZXJhbCh2YWx1ZS52YWx1ZSk7XG4gICAgICBub2RlLnJlZ2V4ID0ge3BhdHRlcm46IHZhbHVlLnBhdHRlcm4sIGZsYWdzOiB2YWx1ZS5mbGFnc307XG4gICAgICByZXR1cm4gbm9kZVxuXG4gICAgY2FzZSB0eXBlcy5udW06IGNhc2UgdHlwZXMuc3RyaW5nOlxuICAgICAgcmV0dXJuIHRoaXMucGFyc2VMaXRlcmFsKHRoaXMudmFsdWUpXG5cbiAgICBjYXNlIHR5cGVzLl9udWxsOiBjYXNlIHR5cGVzLl90cnVlOiBjYXNlIHR5cGVzLl9mYWxzZTpcbiAgICAgIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgbm9kZS52YWx1ZSA9IHRoaXMudHlwZSA9PT0gdHlwZXMuX251bGwgPyBudWxsIDogdGhpcy50eXBlID09PSB0eXBlcy5fdHJ1ZTtcbiAgICAgIG5vZGUucmF3ID0gdGhpcy50eXBlLmtleXdvcmQ7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJMaXRlcmFsXCIpXG5cbiAgICBjYXNlIHR5cGVzLnBhcmVuTDpcbiAgICAgIHZhciBzdGFydCA9IHRoaXMuc3RhcnQsIGV4cHIgPSB0aGlzLnBhcnNlUGFyZW5BbmREaXN0aW5ndWlzaEV4cHJlc3Npb24oY2FuQmVBcnJvdyk7XG4gICAgICBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICAgICAgICBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQXNzaWduIDwgMCAmJiAhdGhpcy5pc1NpbXBsZUFzc2lnblRhcmdldChleHByKSlcbiAgICAgICAgICB7IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEFzc2lnbiA9IHN0YXJ0OyB9XG4gICAgICAgIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRCaW5kIDwgMClcbiAgICAgICAgICB7IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEJpbmQgPSBzdGFydDsgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGV4cHJcblxuICAgIGNhc2UgdHlwZXMuYnJhY2tldEw6XG4gICAgICBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgbm9kZS5lbGVtZW50cyA9IHRoaXMucGFyc2VFeHByTGlzdCh0eXBlcy5icmFja2V0UiwgdHJ1ZSwgdHJ1ZSwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQXJyYXlFeHByZXNzaW9uXCIpXG5cbiAgICBjYXNlIHR5cGVzLmJyYWNlTDpcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlT2JqKGZhbHNlLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKVxuXG4gICAgY2FzZSB0eXBlcy5fZnVuY3Rpb246XG4gICAgICBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgcmV0dXJuIHRoaXMucGFyc2VGdW5jdGlvbihub2RlLCAwKVxuXG4gICAgY2FzZSB0eXBlcy5fY2xhc3M6XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUNsYXNzKHRoaXMuc3RhcnROb2RlKCksIGZhbHNlKVxuXG4gICAgY2FzZSB0eXBlcy5fbmV3OlxuICAgICAgcmV0dXJuIHRoaXMucGFyc2VOZXcoKVxuXG4gICAgY2FzZSB0eXBlcy5iYWNrUXVvdGU6XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZVRlbXBsYXRlKClcblxuICAgIGNhc2UgdHlwZXMuX2ltcG9ydDpcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gMTEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VFeHBySW1wb3J0KClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLnVuZXhwZWN0ZWQoKVxuICAgICAgfVxuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRoaXMudW5leHBlY3RlZCgpO1xuICAgIH1cbiAgfTtcblxuICBwcCQzLnBhcnNlRXhwckltcG9ydCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcblxuICAgIGlmICh0aGlzLmNvbnRhaW5zRXNjKSB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZSh0aGlzLnN0YXJ0LCBcIkVzY2FwZSBzZXF1ZW5jZSBpbiBrZXl3b3JkIGltcG9ydFwiKTsgfVxuICAgIHZhciBtZXRhID0gdGhpcy5wYXJzZUlkZW50KHRydWUpO1xuXG4gICAgc3dpdGNoICh0aGlzLnR5cGUpIHtcbiAgICBjYXNlIHR5cGVzLnBhcmVuTDpcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlRHluYW1pY0ltcG9ydChub2RlKVxuICAgIGNhc2UgdHlwZXMuZG90OlxuICAgICAgbm9kZS5tZXRhID0gbWV0YTtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlSW1wb3J0TWV0YShub2RlKVxuICAgIGRlZmF1bHQ6XG4gICAgICB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICB9XG4gIH07XG5cbiAgcHAkMy5wYXJzZUR5bmFtaWNJbXBvcnQgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgdGhpcy5uZXh0KCk7IFxuXG4gICAgbm9kZS5zb3VyY2UgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oKTtcblxuICAgIGlmICghdGhpcy5lYXQodHlwZXMucGFyZW5SKSkge1xuICAgICAgdmFyIGVycm9yUG9zID0gdGhpcy5zdGFydDtcbiAgICAgIGlmICh0aGlzLmVhdCh0eXBlcy5jb21tYSkgJiYgdGhpcy5lYXQodHlwZXMucGFyZW5SKSkge1xuICAgICAgICB0aGlzLnJhaXNlUmVjb3ZlcmFibGUoZXJyb3JQb3MsIFwiVHJhaWxpbmcgY29tbWEgaXMgbm90IGFsbG93ZWQgaW4gaW1wb3J0KClcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnVuZXhwZWN0ZWQoZXJyb3JQb3MpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJJbXBvcnRFeHByZXNzaW9uXCIpXG4gIH07XG5cbiAgcHAkMy5wYXJzZUltcG9ydE1ldGEgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgdGhpcy5uZXh0KCk7IFxuXG4gICAgdmFyIGNvbnRhaW5zRXNjID0gdGhpcy5jb250YWluc0VzYztcbiAgICBub2RlLnByb3BlcnR5ID0gdGhpcy5wYXJzZUlkZW50KHRydWUpO1xuXG4gICAgaWYgKG5vZGUucHJvcGVydHkubmFtZSAhPT0gXCJtZXRhXCIpXG4gICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShub2RlLnByb3BlcnR5LnN0YXJ0LCBcIlRoZSBvbmx5IHZhbGlkIG1ldGEgcHJvcGVydHkgZm9yIGltcG9ydCBpcyAnaW1wb3J0Lm1ldGEnXCIpOyB9XG4gICAgaWYgKGNvbnRhaW5zRXNjKVxuICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUobm9kZS5zdGFydCwgXCInaW1wb3J0Lm1ldGEnIG11c3Qgbm90IGNvbnRhaW4gZXNjYXBlZCBjaGFyYWN0ZXJzXCIpOyB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5zb3VyY2VUeXBlICE9PSBcIm1vZHVsZVwiKVxuICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUobm9kZS5zdGFydCwgXCJDYW5ub3QgdXNlICdpbXBvcnQubWV0YScgb3V0c2lkZSBhIG1vZHVsZVwiKTsgfVxuXG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIk1ldGFQcm9wZXJ0eVwiKVxuICB9O1xuXG4gIHBwJDMucGFyc2VMaXRlcmFsID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgbm9kZS52YWx1ZSA9IHZhbHVlO1xuICAgIG5vZGUucmF3ID0gdGhpcy5pbnB1dC5zbGljZSh0aGlzLnN0YXJ0LCB0aGlzLmVuZCk7XG4gICAgaWYgKG5vZGUucmF3LmNoYXJDb2RlQXQobm9kZS5yYXcubGVuZ3RoIC0gMSkgPT09IDExMCkgeyBub2RlLmJpZ2ludCA9IG5vZGUucmF3LnNsaWNlKDAsIC0xKS5yZXBsYWNlKC9fL2csIFwiXCIpOyB9XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkxpdGVyYWxcIilcbiAgfTtcblxuICBwcCQzLnBhcnNlUGFyZW5FeHByZXNzaW9uID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5leHBlY3QodHlwZXMucGFyZW5MKTtcbiAgICB2YXIgdmFsID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcbiAgICB0aGlzLmV4cGVjdCh0eXBlcy5wYXJlblIpO1xuICAgIHJldHVybiB2YWxcbiAgfTtcblxuICBwcCQzLnBhcnNlUGFyZW5BbmREaXN0aW5ndWlzaEV4cHJlc3Npb24gPSBmdW5jdGlvbihjYW5CZUFycm93KSB7XG4gICAgdmFyIHN0YXJ0UG9zID0gdGhpcy5zdGFydCwgc3RhcnRMb2MgPSB0aGlzLnN0YXJ0TG9jLCB2YWwsIGFsbG93VHJhaWxpbmdDb21tYSA9IHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA4O1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNikge1xuICAgICAgdGhpcy5uZXh0KCk7XG5cbiAgICAgIHZhciBpbm5lclN0YXJ0UG9zID0gdGhpcy5zdGFydCwgaW5uZXJTdGFydExvYyA9IHRoaXMuc3RhcnRMb2M7XG4gICAgICB2YXIgZXhwckxpc3QgPSBbXSwgZmlyc3QgPSB0cnVlLCBsYXN0SXNDb21tYSA9IGZhbHNlO1xuICAgICAgdmFyIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMgPSBuZXcgRGVzdHJ1Y3R1cmluZ0Vycm9ycywgb2xkWWllbGRQb3MgPSB0aGlzLnlpZWxkUG9zLCBvbGRBd2FpdFBvcyA9IHRoaXMuYXdhaXRQb3MsIHNwcmVhZFN0YXJ0O1xuICAgICAgdGhpcy55aWVsZFBvcyA9IDA7XG4gICAgICB0aGlzLmF3YWl0UG9zID0gMDtcbiAgICAgIHdoaWxlICh0aGlzLnR5cGUgIT09IHR5cGVzLnBhcmVuUikge1xuICAgICAgICBmaXJzdCA/IGZpcnN0ID0gZmFsc2UgOiB0aGlzLmV4cGVjdCh0eXBlcy5jb21tYSk7XG4gICAgICAgIGlmIChhbGxvd1RyYWlsaW5nQ29tbWEgJiYgdGhpcy5hZnRlclRyYWlsaW5nQ29tbWEodHlwZXMucGFyZW5SLCB0cnVlKSkge1xuICAgICAgICAgIGxhc3RJc0NvbW1hID0gdHJ1ZTtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuZWxsaXBzaXMpIHtcbiAgICAgICAgICBzcHJlYWRTdGFydCA9IHRoaXMuc3RhcnQ7XG4gICAgICAgICAgZXhwckxpc3QucHVzaCh0aGlzLnBhcnNlUGFyZW5JdGVtKHRoaXMucGFyc2VSZXN0QmluZGluZygpKSk7XG4gICAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuY29tbWEpIHsgdGhpcy5yYWlzZSh0aGlzLnN0YXJ0LCBcIkNvbW1hIGlzIG5vdCBwZXJtaXR0ZWQgYWZ0ZXIgdGhlIHJlc3QgZWxlbWVudFwiKTsgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZXhwckxpc3QucHVzaCh0aGlzLnBhcnNlTWF5YmVBc3NpZ24oZmFsc2UsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIHRoaXMucGFyc2VQYXJlbkl0ZW0pKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIGlubmVyRW5kUG9zID0gdGhpcy5zdGFydCwgaW5uZXJFbmRMb2MgPSB0aGlzLnN0YXJ0TG9jO1xuICAgICAgdGhpcy5leHBlY3QodHlwZXMucGFyZW5SKTtcblxuICAgICAgaWYgKGNhbkJlQXJyb3cgJiYgIXRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCkgJiYgdGhpcy5lYXQodHlwZXMuYXJyb3cpKSB7XG4gICAgICAgIHRoaXMuY2hlY2tQYXR0ZXJuRXJyb3JzKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5jaGVja1lpZWxkQXdhaXRJbkRlZmF1bHRQYXJhbXMoKTtcbiAgICAgICAgdGhpcy55aWVsZFBvcyA9IG9sZFlpZWxkUG9zO1xuICAgICAgICB0aGlzLmF3YWl0UG9zID0gb2xkQXdhaXRQb3M7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlUGFyZW5BcnJvd0xpc3Qoc3RhcnRQb3MsIHN0YXJ0TG9jLCBleHByTGlzdClcbiAgICAgIH1cblxuICAgICAgaWYgKCFleHByTGlzdC5sZW5ndGggfHwgbGFzdElzQ29tbWEpIHsgdGhpcy51bmV4cGVjdGVkKHRoaXMubGFzdFRva1N0YXJ0KTsgfVxuICAgICAgaWYgKHNwcmVhZFN0YXJ0KSB7IHRoaXMudW5leHBlY3RlZChzcHJlYWRTdGFydCk7IH1cbiAgICAgIHRoaXMuY2hlY2tFeHByZXNzaW9uRXJyb3JzKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIHRydWUpO1xuICAgICAgdGhpcy55aWVsZFBvcyA9IG9sZFlpZWxkUG9zIHx8IHRoaXMueWllbGRQb3M7XG4gICAgICB0aGlzLmF3YWl0UG9zID0gb2xkQXdhaXRQb3MgfHwgdGhpcy5hd2FpdFBvcztcblxuICAgICAgaWYgKGV4cHJMaXN0Lmxlbmd0aCA+IDEpIHtcbiAgICAgICAgdmFsID0gdGhpcy5zdGFydE5vZGVBdChpbm5lclN0YXJ0UG9zLCBpbm5lclN0YXJ0TG9jKTtcbiAgICAgICAgdmFsLmV4cHJlc3Npb25zID0gZXhwckxpc3Q7XG4gICAgICAgIHRoaXMuZmluaXNoTm9kZUF0KHZhbCwgXCJTZXF1ZW5jZUV4cHJlc3Npb25cIiwgaW5uZXJFbmRQb3MsIGlubmVyRW5kTG9jKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbCA9IGV4cHJMaXN0WzBdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YWwgPSB0aGlzLnBhcnNlUGFyZW5FeHByZXNzaW9uKCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5wcmVzZXJ2ZVBhcmVucykge1xuICAgICAgdmFyIHBhciA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICAgIHBhci5leHByZXNzaW9uID0gdmFsO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShwYXIsIFwiUGFyZW50aGVzaXplZEV4cHJlc3Npb25cIilcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHZhbFxuICAgIH1cbiAgfTtcblxuICBwcCQzLnBhcnNlUGFyZW5JdGVtID0gZnVuY3Rpb24oaXRlbSkge1xuICAgIHJldHVybiBpdGVtXG4gIH07XG5cbiAgcHAkMy5wYXJzZVBhcmVuQXJyb3dMaXN0ID0gZnVuY3Rpb24oc3RhcnRQb3MsIHN0YXJ0TG9jLCBleHByTGlzdCkge1xuICAgIHJldHVybiB0aGlzLnBhcnNlQXJyb3dFeHByZXNzaW9uKHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKSwgZXhwckxpc3QpXG4gIH07XG5cblxuICB2YXIgZW1wdHkkMSA9IFtdO1xuXG4gIHBwJDMucGFyc2VOZXcgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5jb250YWluc0VzYykgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUodGhpcy5zdGFydCwgXCJFc2NhcGUgc2VxdWVuY2UgaW4ga2V5d29yZCBuZXdcIik7IH1cbiAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdmFyIG1ldGEgPSB0aGlzLnBhcnNlSWRlbnQodHJ1ZSk7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2ICYmIHRoaXMuZWF0KHR5cGVzLmRvdCkpIHtcbiAgICAgIG5vZGUubWV0YSA9IG1ldGE7XG4gICAgICB2YXIgY29udGFpbnNFc2MgPSB0aGlzLmNvbnRhaW5zRXNjO1xuICAgICAgbm9kZS5wcm9wZXJ0eSA9IHRoaXMucGFyc2VJZGVudCh0cnVlKTtcbiAgICAgIGlmIChub2RlLnByb3BlcnR5Lm5hbWUgIT09IFwidGFyZ2V0XCIpXG4gICAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKG5vZGUucHJvcGVydHkuc3RhcnQsIFwiVGhlIG9ubHkgdmFsaWQgbWV0YSBwcm9wZXJ0eSBmb3IgbmV3IGlzICduZXcudGFyZ2V0J1wiKTsgfVxuICAgICAgaWYgKGNvbnRhaW5zRXNjKVxuICAgICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShub2RlLnN0YXJ0LCBcIiduZXcudGFyZ2V0JyBtdXN0IG5vdCBjb250YWluIGVzY2FwZWQgY2hhcmFjdGVyc1wiKTsgfVxuICAgICAgaWYgKCF0aGlzLmluTm9uQXJyb3dGdW5jdGlvbigpKVxuICAgICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShub2RlLnN0YXJ0LCBcIiduZXcudGFyZ2V0JyBjYW4gb25seSBiZSB1c2VkIGluIGZ1bmN0aW9uc1wiKTsgfVxuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIk1ldGFQcm9wZXJ0eVwiKVxuICAgIH1cbiAgICB2YXIgc3RhcnRQb3MgPSB0aGlzLnN0YXJ0LCBzdGFydExvYyA9IHRoaXMuc3RhcnRMb2MsIGlzSW1wb3J0ID0gdGhpcy50eXBlID09PSB0eXBlcy5faW1wb3J0O1xuICAgIG5vZGUuY2FsbGVlID0gdGhpcy5wYXJzZVN1YnNjcmlwdHModGhpcy5wYXJzZUV4cHJBdG9tKCksIHN0YXJ0UG9zLCBzdGFydExvYywgdHJ1ZSk7XG4gICAgaWYgKGlzSW1wb3J0ICYmIG5vZGUuY2FsbGVlLnR5cGUgPT09IFwiSW1wb3J0RXhwcmVzc2lvblwiKSB7XG4gICAgICB0aGlzLnJhaXNlKHN0YXJ0UG9zLCBcIkNhbm5vdCB1c2UgbmV3IHdpdGggaW1wb3J0KClcIik7XG4gICAgfVxuICAgIGlmICh0aGlzLmVhdCh0eXBlcy5wYXJlbkwpKSB7IG5vZGUuYXJndW1lbnRzID0gdGhpcy5wYXJzZUV4cHJMaXN0KHR5cGVzLnBhcmVuUiwgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDgsIGZhbHNlKTsgfVxuICAgIGVsc2UgeyBub2RlLmFyZ3VtZW50cyA9IGVtcHR5JDE7IH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiTmV3RXhwcmVzc2lvblwiKVxuICB9O1xuXG5cbiAgcHAkMy5wYXJzZVRlbXBsYXRlRWxlbWVudCA9IGZ1bmN0aW9uKHJlZikge1xuICAgIHZhciBpc1RhZ2dlZCA9IHJlZi5pc1RhZ2dlZDtcblxuICAgIHZhciBlbGVtID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5pbnZhbGlkVGVtcGxhdGUpIHtcbiAgICAgIGlmICghaXNUYWdnZWQpIHtcbiAgICAgICAgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHRoaXMuc3RhcnQsIFwiQmFkIGVzY2FwZSBzZXF1ZW5jZSBpbiB1bnRhZ2dlZCB0ZW1wbGF0ZSBsaXRlcmFsXCIpO1xuICAgICAgfVxuICAgICAgZWxlbS52YWx1ZSA9IHtcbiAgICAgICAgcmF3OiB0aGlzLnZhbHVlLFxuICAgICAgICBjb29rZWQ6IG51bGxcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW0udmFsdWUgPSB7XG4gICAgICAgIHJhdzogdGhpcy5pbnB1dC5zbGljZSh0aGlzLnN0YXJ0LCB0aGlzLmVuZCkucmVwbGFjZSgvXFxyXFxuPy9nLCBcIlxcblwiKSxcbiAgICAgICAgY29va2VkOiB0aGlzLnZhbHVlXG4gICAgICB9O1xuICAgIH1cbiAgICB0aGlzLm5leHQoKTtcbiAgICBlbGVtLnRhaWwgPSB0aGlzLnR5cGUgPT09IHR5cGVzLmJhY2tRdW90ZTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKGVsZW0sIFwiVGVtcGxhdGVFbGVtZW50XCIpXG4gIH07XG5cbiAgcHAkMy5wYXJzZVRlbXBsYXRlID0gZnVuY3Rpb24ocmVmKSB7XG4gICAgaWYgKCByZWYgPT09IHZvaWQgMCApIHJlZiA9IHt9O1xuICAgIHZhciBpc1RhZ2dlZCA9IHJlZi5pc1RhZ2dlZDsgaWYgKCBpc1RhZ2dlZCA9PT0gdm9pZCAwICkgaXNUYWdnZWQgPSBmYWxzZTtcblxuICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBub2RlLmV4cHJlc3Npb25zID0gW107XG4gICAgdmFyIGN1ckVsdCA9IHRoaXMucGFyc2VUZW1wbGF0ZUVsZW1lbnQoe2lzVGFnZ2VkOiBpc1RhZ2dlZH0pO1xuICAgIG5vZGUucXVhc2lzID0gW2N1ckVsdF07XG4gICAgd2hpbGUgKCFjdXJFbHQudGFpbCkge1xuICAgICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuZW9mKSB7IHRoaXMucmFpc2UodGhpcy5wb3MsIFwiVW50ZXJtaW5hdGVkIHRlbXBsYXRlIGxpdGVyYWxcIik7IH1cbiAgICAgIHRoaXMuZXhwZWN0KHR5cGVzLmRvbGxhckJyYWNlTCk7XG4gICAgICBub2RlLmV4cHJlc3Npb25zLnB1c2godGhpcy5wYXJzZUV4cHJlc3Npb24oKSk7XG4gICAgICB0aGlzLmV4cGVjdCh0eXBlcy5icmFjZVIpO1xuICAgICAgbm9kZS5xdWFzaXMucHVzaChjdXJFbHQgPSB0aGlzLnBhcnNlVGVtcGxhdGVFbGVtZW50KHtpc1RhZ2dlZDogaXNUYWdnZWR9KSk7XG4gICAgfVxuICAgIHRoaXMubmV4dCgpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUZW1wbGF0ZUxpdGVyYWxcIilcbiAgfTtcblxuICBwcCQzLmlzQXN5bmNQcm9wID0gZnVuY3Rpb24ocHJvcCkge1xuICAgIHJldHVybiAhcHJvcC5jb21wdXRlZCAmJiBwcm9wLmtleS50eXBlID09PSBcIklkZW50aWZpZXJcIiAmJiBwcm9wLmtleS5uYW1lID09PSBcImFzeW5jXCIgJiZcbiAgICAgICh0aGlzLnR5cGUgPT09IHR5cGVzLm5hbWUgfHwgdGhpcy50eXBlID09PSB0eXBlcy5udW0gfHwgdGhpcy50eXBlID09PSB0eXBlcy5zdHJpbmcgfHwgdGhpcy50eXBlID09PSB0eXBlcy5icmFja2V0TCB8fCB0aGlzLnR5cGUua2V5d29yZCB8fCAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkgJiYgdGhpcy50eXBlID09PSB0eXBlcy5zdGFyKSkgJiZcbiAgICAgICFsaW5lQnJlYWsudGVzdCh0aGlzLmlucHV0LnNsaWNlKHRoaXMubGFzdFRva0VuZCwgdGhpcy5zdGFydCkpXG4gIH07XG5cblxuICBwcCQzLnBhcnNlT2JqID0gZnVuY3Rpb24oaXNQYXR0ZXJuLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpLCBmaXJzdCA9IHRydWUsIHByb3BIYXNoID0ge307XG4gICAgbm9kZS5wcm9wZXJ0aWVzID0gW107XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgd2hpbGUgKCF0aGlzLmVhdCh0eXBlcy5icmFjZVIpKSB7XG4gICAgICBpZiAoIWZpcnN0KSB7XG4gICAgICAgIHRoaXMuZXhwZWN0KHR5cGVzLmNvbW1hKTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA1ICYmIHRoaXMuYWZ0ZXJUcmFpbGluZ0NvbW1hKHR5cGVzLmJyYWNlUikpIHsgYnJlYWsgfVxuICAgICAgfSBlbHNlIHsgZmlyc3QgPSBmYWxzZTsgfVxuXG4gICAgICB2YXIgcHJvcCA9IHRoaXMucGFyc2VQcm9wZXJ0eShpc1BhdHRlcm4sIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICAgICAgaWYgKCFpc1BhdHRlcm4pIHsgdGhpcy5jaGVja1Byb3BDbGFzaChwcm9wLCBwcm9wSGFzaCwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7IH1cbiAgICAgIG5vZGUucHJvcGVydGllcy5wdXNoKHByb3ApO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIGlzUGF0dGVybiA/IFwiT2JqZWN0UGF0dGVyblwiIDogXCJPYmplY3RFeHByZXNzaW9uXCIpXG4gIH07XG5cbiAgcHAkMy5wYXJzZVByb3BlcnR5ID0gZnVuY3Rpb24oaXNQYXR0ZXJuLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gICAgdmFyIHByb3AgPSB0aGlzLnN0YXJ0Tm9kZSgpLCBpc0dlbmVyYXRvciwgaXNBc3luYywgc3RhcnRQb3MsIHN0YXJ0TG9jO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOSAmJiB0aGlzLmVhdCh0eXBlcy5lbGxpcHNpcykpIHtcbiAgICAgIGlmIChpc1BhdHRlcm4pIHtcbiAgICAgICAgcHJvcC5hcmd1bWVudCA9IHRoaXMucGFyc2VJZGVudChmYWxzZSk7XG4gICAgICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLmNvbW1hKSB7XG4gICAgICAgICAgdGhpcy5yYWlzZSh0aGlzLnN0YXJ0LCBcIkNvbW1hIGlzIG5vdCBwZXJtaXR0ZWQgYWZ0ZXIgdGhlIHJlc3QgZWxlbWVudFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKHByb3AsIFwiUmVzdEVsZW1lbnRcIilcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLnBhcmVuTCAmJiByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gICAgICAgIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRBc3NpZ24gPCAwKSB7XG4gICAgICAgICAgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQXNzaWduID0gdGhpcy5zdGFydDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQmluZCA8IDApIHtcbiAgICAgICAgICByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRCaW5kID0gdGhpcy5zdGFydDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcHJvcC5hcmd1bWVudCA9IHRoaXMucGFyc2VNYXliZUFzc2lnbihmYWxzZSwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gICAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5jb21tYSAmJiByZWZEZXN0cnVjdHVyaW5nRXJyb3JzICYmIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMudHJhaWxpbmdDb21tYSA8IDApIHtcbiAgICAgICAgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy50cmFpbGluZ0NvbW1hID0gdGhpcy5zdGFydDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUocHJvcCwgXCJTcHJlYWRFbGVtZW50XCIpXG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNikge1xuICAgICAgcHJvcC5tZXRob2QgPSBmYWxzZTtcbiAgICAgIHByb3Auc2hvcnRoYW5kID0gZmFsc2U7XG4gICAgICBpZiAoaXNQYXR0ZXJuIHx8IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgICAgICAgc3RhcnRQb3MgPSB0aGlzLnN0YXJ0O1xuICAgICAgICBzdGFydExvYyA9IHRoaXMuc3RhcnRMb2M7XG4gICAgICB9XG4gICAgICBpZiAoIWlzUGF0dGVybilcbiAgICAgICAgeyBpc0dlbmVyYXRvciA9IHRoaXMuZWF0KHR5cGVzLnN0YXIpOyB9XG4gICAgfVxuICAgIHZhciBjb250YWluc0VzYyA9IHRoaXMuY29udGFpbnNFc2M7XG4gICAgdGhpcy5wYXJzZVByb3BlcnR5TmFtZShwcm9wKTtcbiAgICBpZiAoIWlzUGF0dGVybiAmJiAhY29udGFpbnNFc2MgJiYgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDggJiYgIWlzR2VuZXJhdG9yICYmIHRoaXMuaXNBc3luY1Byb3AocHJvcCkpIHtcbiAgICAgIGlzQXN5bmMgPSB0cnVlO1xuICAgICAgaXNHZW5lcmF0b3IgPSB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOSAmJiB0aGlzLmVhdCh0eXBlcy5zdGFyKTtcbiAgICAgIHRoaXMucGFyc2VQcm9wZXJ0eU5hbWUocHJvcCwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlzQXN5bmMgPSBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5wYXJzZVByb3BlcnR5VmFsdWUocHJvcCwgaXNQYXR0ZXJuLCBpc0dlbmVyYXRvciwgaXNBc3luYywgc3RhcnRQb3MsIHN0YXJ0TG9jLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCBjb250YWluc0VzYyk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShwcm9wLCBcIlByb3BlcnR5XCIpXG4gIH07XG5cbiAgcHAkMy5wYXJzZVByb3BlcnR5VmFsdWUgPSBmdW5jdGlvbihwcm9wLCBpc1BhdHRlcm4sIGlzR2VuZXJhdG9yLCBpc0FzeW5jLCBzdGFydFBvcywgc3RhcnRMb2MsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIGNvbnRhaW5zRXNjKSB7XG4gICAgaWYgKChpc0dlbmVyYXRvciB8fCBpc0FzeW5jKSAmJiB0aGlzLnR5cGUgPT09IHR5cGVzLmNvbG9uKVxuICAgICAgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuXG4gICAgaWYgKHRoaXMuZWF0KHR5cGVzLmNvbG9uKSkge1xuICAgICAgcHJvcC52YWx1ZSA9IGlzUGF0dGVybiA/IHRoaXMucGFyc2VNYXliZURlZmF1bHQodGhpcy5zdGFydCwgdGhpcy5zdGFydExvYykgOiB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oZmFsc2UsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICAgICAgcHJvcC5raW5kID0gXCJpbml0XCI7XG4gICAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNiAmJiB0aGlzLnR5cGUgPT09IHR5cGVzLnBhcmVuTCkge1xuICAgICAgaWYgKGlzUGF0dGVybikgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICAgICAgcHJvcC5raW5kID0gXCJpbml0XCI7XG4gICAgICBwcm9wLm1ldGhvZCA9IHRydWU7XG4gICAgICBwcm9wLnZhbHVlID0gdGhpcy5wYXJzZU1ldGhvZChpc0dlbmVyYXRvciwgaXNBc3luYyk7XG4gICAgfSBlbHNlIGlmICghaXNQYXR0ZXJuICYmICFjb250YWluc0VzYyAmJlxuICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDUgJiYgIXByb3AuY29tcHV0ZWQgJiYgcHJvcC5rZXkudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiZcbiAgICAgICAgICAgICAgIChwcm9wLmtleS5uYW1lID09PSBcImdldFwiIHx8IHByb3Aua2V5Lm5hbWUgPT09IFwic2V0XCIpICYmXG4gICAgICAgICAgICAgICAodGhpcy50eXBlICE9PSB0eXBlcy5jb21tYSAmJiB0aGlzLnR5cGUgIT09IHR5cGVzLmJyYWNlUiAmJiB0aGlzLnR5cGUgIT09IHR5cGVzLmVxKSkge1xuICAgICAgaWYgKGlzR2VuZXJhdG9yIHx8IGlzQXN5bmMpIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICAgIHByb3Aua2luZCA9IHByb3Aua2V5Lm5hbWU7XG4gICAgICB0aGlzLnBhcnNlUHJvcGVydHlOYW1lKHByb3ApO1xuICAgICAgcHJvcC52YWx1ZSA9IHRoaXMucGFyc2VNZXRob2QoZmFsc2UpO1xuICAgICAgdmFyIHBhcmFtQ291bnQgPSBwcm9wLmtpbmQgPT09IFwiZ2V0XCIgPyAwIDogMTtcbiAgICAgIGlmIChwcm9wLnZhbHVlLnBhcmFtcy5sZW5ndGggIT09IHBhcmFtQ291bnQpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gcHJvcC52YWx1ZS5zdGFydDtcbiAgICAgICAgaWYgKHByb3Aua2luZCA9PT0gXCJnZXRcIilcbiAgICAgICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShzdGFydCwgXCJnZXR0ZXIgc2hvdWxkIGhhdmUgbm8gcGFyYW1zXCIpOyB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShzdGFydCwgXCJzZXR0ZXIgc2hvdWxkIGhhdmUgZXhhY3RseSBvbmUgcGFyYW1cIik7IH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChwcm9wLmtpbmQgPT09IFwic2V0XCIgJiYgcHJvcC52YWx1ZS5wYXJhbXNbMF0udHlwZSA9PT0gXCJSZXN0RWxlbWVudFwiKVxuICAgICAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHByb3AudmFsdWUucGFyYW1zWzBdLnN0YXJ0LCBcIlNldHRlciBjYW5ub3QgdXNlIHJlc3QgcGFyYW1zXCIpOyB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNiAmJiAhcHJvcC5jb21wdXRlZCAmJiBwcm9wLmtleS50eXBlID09PSBcIklkZW50aWZpZXJcIikge1xuICAgICAgaWYgKGlzR2VuZXJhdG9yIHx8IGlzQXN5bmMpIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICAgIHRoaXMuY2hlY2tVbnJlc2VydmVkKHByb3Aua2V5KTtcbiAgICAgIGlmIChwcm9wLmtleS5uYW1lID09PSBcImF3YWl0XCIgJiYgIXRoaXMuYXdhaXRJZGVudFBvcylcbiAgICAgICAgeyB0aGlzLmF3YWl0SWRlbnRQb3MgPSBzdGFydFBvczsgfVxuICAgICAgcHJvcC5raW5kID0gXCJpbml0XCI7XG4gICAgICBpZiAoaXNQYXR0ZXJuKSB7XG4gICAgICAgIHByb3AudmFsdWUgPSB0aGlzLnBhcnNlTWF5YmVEZWZhdWx0KHN0YXJ0UG9zLCBzdGFydExvYywgcHJvcC5rZXkpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLmVxICYmIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgICAgICAgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMuc2hvcnRoYW5kQXNzaWduIDwgMClcbiAgICAgICAgICB7IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMuc2hvcnRoYW5kQXNzaWduID0gdGhpcy5zdGFydDsgfVxuICAgICAgICBwcm9wLnZhbHVlID0gdGhpcy5wYXJzZU1heWJlRGVmYXVsdChzdGFydFBvcywgc3RhcnRMb2MsIHByb3Aua2V5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb3AudmFsdWUgPSBwcm9wLmtleTtcbiAgICAgIH1cbiAgICAgIHByb3Auc2hvcnRoYW5kID0gdHJ1ZTtcbiAgICB9IGVsc2UgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICB9O1xuXG4gIHBwJDMucGFyc2VQcm9wZXJ0eU5hbWUgPSBmdW5jdGlvbihwcm9wKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KSB7XG4gICAgICBpZiAodGhpcy5lYXQodHlwZXMuYnJhY2tldEwpKSB7XG4gICAgICAgIHByb3AuY29tcHV0ZWQgPSB0cnVlO1xuICAgICAgICBwcm9wLmtleSA9IHRoaXMucGFyc2VNYXliZUFzc2lnbigpO1xuICAgICAgICB0aGlzLmV4cGVjdCh0eXBlcy5icmFja2V0Uik7XG4gICAgICAgIHJldHVybiBwcm9wLmtleVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvcC5jb21wdXRlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcHJvcC5rZXkgPSB0aGlzLnR5cGUgPT09IHR5cGVzLm51bSB8fCB0aGlzLnR5cGUgPT09IHR5cGVzLnN0cmluZyA/IHRoaXMucGFyc2VFeHByQXRvbSgpIDogdGhpcy5wYXJzZUlkZW50KHRoaXMub3B0aW9ucy5hbGxvd1Jlc2VydmVkICE9PSBcIm5ldmVyXCIpXG4gIH07XG5cblxuICBwcCQzLmluaXRGdW5jdGlvbiA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICBub2RlLmlkID0gbnVsbDtcbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYpIHsgbm9kZS5nZW5lcmF0b3IgPSBub2RlLmV4cHJlc3Npb24gPSBmYWxzZTsgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOCkgeyBub2RlLmFzeW5jID0gZmFsc2U7IH1cbiAgfTtcblxuXG4gIHBwJDMucGFyc2VNZXRob2QgPSBmdW5jdGlvbihpc0dlbmVyYXRvciwgaXNBc3luYywgYWxsb3dEaXJlY3RTdXBlcikge1xuICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKSwgb2xkWWllbGRQb3MgPSB0aGlzLnlpZWxkUG9zLCBvbGRBd2FpdFBvcyA9IHRoaXMuYXdhaXRQb3MsIG9sZEF3YWl0SWRlbnRQb3MgPSB0aGlzLmF3YWl0SWRlbnRQb3M7XG5cbiAgICB0aGlzLmluaXRGdW5jdGlvbihub2RlKTtcbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYpXG4gICAgICB7IG5vZGUuZ2VuZXJhdG9yID0gaXNHZW5lcmF0b3I7IH1cbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDgpXG4gICAgICB7IG5vZGUuYXN5bmMgPSAhIWlzQXN5bmM7IH1cblxuICAgIHRoaXMueWllbGRQb3MgPSAwO1xuICAgIHRoaXMuYXdhaXRQb3MgPSAwO1xuICAgIHRoaXMuYXdhaXRJZGVudFBvcyA9IDA7XG4gICAgdGhpcy5lbnRlclNjb3BlKGZ1bmN0aW9uRmxhZ3MoaXNBc3luYywgbm9kZS5nZW5lcmF0b3IpIHwgU0NPUEVfU1VQRVIgfCAoYWxsb3dEaXJlY3RTdXBlciA/IFNDT1BFX0RJUkVDVF9TVVBFUiA6IDApKTtcblxuICAgIHRoaXMuZXhwZWN0KHR5cGVzLnBhcmVuTCk7XG4gICAgbm9kZS5wYXJhbXMgPSB0aGlzLnBhcnNlQmluZGluZ0xpc3QodHlwZXMucGFyZW5SLCBmYWxzZSwgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDgpO1xuICAgIHRoaXMuY2hlY2tZaWVsZEF3YWl0SW5EZWZhdWx0UGFyYW1zKCk7XG4gICAgdGhpcy5wYXJzZUZ1bmN0aW9uQm9keShub2RlLCBmYWxzZSwgdHJ1ZSk7XG5cbiAgICB0aGlzLnlpZWxkUG9zID0gb2xkWWllbGRQb3M7XG4gICAgdGhpcy5hd2FpdFBvcyA9IG9sZEF3YWl0UG9zO1xuICAgIHRoaXMuYXdhaXRJZGVudFBvcyA9IG9sZEF3YWl0SWRlbnRQb3M7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkZ1bmN0aW9uRXhwcmVzc2lvblwiKVxuICB9O1xuXG5cbiAgcHAkMy5wYXJzZUFycm93RXhwcmVzc2lvbiA9IGZ1bmN0aW9uKG5vZGUsIHBhcmFtcywgaXNBc3luYykge1xuICAgIHZhciBvbGRZaWVsZFBvcyA9IHRoaXMueWllbGRQb3MsIG9sZEF3YWl0UG9zID0gdGhpcy5hd2FpdFBvcywgb2xkQXdhaXRJZGVudFBvcyA9IHRoaXMuYXdhaXRJZGVudFBvcztcblxuICAgIHRoaXMuZW50ZXJTY29wZShmdW5jdGlvbkZsYWdzKGlzQXN5bmMsIGZhbHNlKSB8IFNDT1BFX0FSUk9XKTtcbiAgICB0aGlzLmluaXRGdW5jdGlvbihub2RlKTtcbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDgpIHsgbm9kZS5hc3luYyA9ICEhaXNBc3luYzsgfVxuXG4gICAgdGhpcy55aWVsZFBvcyA9IDA7XG4gICAgdGhpcy5hd2FpdFBvcyA9IDA7XG4gICAgdGhpcy5hd2FpdElkZW50UG9zID0gMDtcblxuICAgIG5vZGUucGFyYW1zID0gdGhpcy50b0Fzc2lnbmFibGVMaXN0KHBhcmFtcywgdHJ1ZSk7XG4gICAgdGhpcy5wYXJzZUZ1bmN0aW9uQm9keShub2RlLCB0cnVlLCBmYWxzZSk7XG5cbiAgICB0aGlzLnlpZWxkUG9zID0gb2xkWWllbGRQb3M7XG4gICAgdGhpcy5hd2FpdFBvcyA9IG9sZEF3YWl0UG9zO1xuICAgIHRoaXMuYXdhaXRJZGVudFBvcyA9IG9sZEF3YWl0SWRlbnRQb3M7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCIpXG4gIH07XG5cblxuICBwcCQzLnBhcnNlRnVuY3Rpb25Cb2R5ID0gZnVuY3Rpb24obm9kZSwgaXNBcnJvd0Z1bmN0aW9uLCBpc01ldGhvZCkge1xuICAgIHZhciBpc0V4cHJlc3Npb24gPSBpc0Fycm93RnVuY3Rpb24gJiYgdGhpcy50eXBlICE9PSB0eXBlcy5icmFjZUw7XG4gICAgdmFyIG9sZFN0cmljdCA9IHRoaXMuc3RyaWN0LCB1c2VTdHJpY3QgPSBmYWxzZTtcblxuICAgIGlmIChpc0V4cHJlc3Npb24pIHtcbiAgICAgIG5vZGUuYm9keSA9IHRoaXMucGFyc2VNYXliZUFzc2lnbigpO1xuICAgICAgbm9kZS5leHByZXNzaW9uID0gdHJ1ZTtcbiAgICAgIHRoaXMuY2hlY2tQYXJhbXMobm9kZSwgZmFsc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbm9uU2ltcGxlID0gdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDcgJiYgIXRoaXMuaXNTaW1wbGVQYXJhbUxpc3Qobm9kZS5wYXJhbXMpO1xuICAgICAgaWYgKCFvbGRTdHJpY3QgfHwgbm9uU2ltcGxlKSB7XG4gICAgICAgIHVzZVN0cmljdCA9IHRoaXMuc3RyaWN0RGlyZWN0aXZlKHRoaXMuZW5kKTtcbiAgICAgICAgaWYgKHVzZVN0cmljdCAmJiBub25TaW1wbGUpXG4gICAgICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUobm9kZS5zdGFydCwgXCJJbGxlZ2FsICd1c2Ugc3RyaWN0JyBkaXJlY3RpdmUgaW4gZnVuY3Rpb24gd2l0aCBub24tc2ltcGxlIHBhcmFtZXRlciBsaXN0XCIpOyB9XG4gICAgICB9XG4gICAgICB2YXIgb2xkTGFiZWxzID0gdGhpcy5sYWJlbHM7XG4gICAgICB0aGlzLmxhYmVscyA9IFtdO1xuICAgICAgaWYgKHVzZVN0cmljdCkgeyB0aGlzLnN0cmljdCA9IHRydWU7IH1cblxuICAgICAgdGhpcy5jaGVja1BhcmFtcyhub2RlLCAhb2xkU3RyaWN0ICYmICF1c2VTdHJpY3QgJiYgIWlzQXJyb3dGdW5jdGlvbiAmJiAhaXNNZXRob2QgJiYgdGhpcy5pc1NpbXBsZVBhcmFtTGlzdChub2RlLnBhcmFtcykpO1xuICAgICAgaWYgKHRoaXMuc3RyaWN0ICYmIG5vZGUuaWQpIHsgdGhpcy5jaGVja0xWYWwobm9kZS5pZCwgQklORF9PVVRTSURFKTsgfVxuICAgICAgbm9kZS5ib2R5ID0gdGhpcy5wYXJzZUJsb2NrKGZhbHNlLCB1bmRlZmluZWQsIHVzZVN0cmljdCAmJiAhb2xkU3RyaWN0KTtcbiAgICAgIG5vZGUuZXhwcmVzc2lvbiA9IGZhbHNlO1xuICAgICAgdGhpcy5hZGFwdERpcmVjdGl2ZVByb2xvZ3VlKG5vZGUuYm9keS5ib2R5KTtcbiAgICAgIHRoaXMubGFiZWxzID0gb2xkTGFiZWxzO1xuICAgIH1cbiAgICB0aGlzLmV4aXRTY29wZSgpO1xuICB9O1xuXG4gIHBwJDMuaXNTaW1wbGVQYXJhbUxpc3QgPSBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IHBhcmFtczsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpXG4gICAgICB7XG4gICAgICB2YXIgcGFyYW0gPSBsaXN0W2ldO1xuXG4gICAgICBpZiAocGFyYW0udHlwZSAhPT0gXCJJZGVudGlmaWVyXCIpIHsgcmV0dXJuIGZhbHNlXG4gICAgfSB9XG4gICAgcmV0dXJuIHRydWVcbiAgfTtcblxuXG4gIHBwJDMuY2hlY2tQYXJhbXMgPSBmdW5jdGlvbihub2RlLCBhbGxvd0R1cGxpY2F0ZXMpIHtcbiAgICB2YXIgbmFtZUhhc2ggPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IG5vZGUucGFyYW1zOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSlcbiAgICAgIHtcbiAgICAgIHZhciBwYXJhbSA9IGxpc3RbaV07XG5cbiAgICAgIHRoaXMuY2hlY2tMVmFsKHBhcmFtLCBCSU5EX1ZBUiwgYWxsb3dEdXBsaWNhdGVzID8gbnVsbCA6IG5hbWVIYXNoKTtcbiAgICB9XG4gIH07XG5cblxuICBwcCQzLnBhcnNlRXhwckxpc3QgPSBmdW5jdGlvbihjbG9zZSwgYWxsb3dUcmFpbGluZ0NvbW1hLCBhbGxvd0VtcHR5LCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gICAgdmFyIGVsdHMgPSBbXSwgZmlyc3QgPSB0cnVlO1xuICAgIHdoaWxlICghdGhpcy5lYXQoY2xvc2UpKSB7XG4gICAgICBpZiAoIWZpcnN0KSB7XG4gICAgICAgIHRoaXMuZXhwZWN0KHR5cGVzLmNvbW1hKTtcbiAgICAgICAgaWYgKGFsbG93VHJhaWxpbmdDb21tYSAmJiB0aGlzLmFmdGVyVHJhaWxpbmdDb21tYShjbG9zZSkpIHsgYnJlYWsgfVxuICAgICAgfSBlbHNlIHsgZmlyc3QgPSBmYWxzZTsgfVxuXG4gICAgICB2YXIgZWx0ID0gKHZvaWQgMCk7XG4gICAgICBpZiAoYWxsb3dFbXB0eSAmJiB0aGlzLnR5cGUgPT09IHR5cGVzLmNvbW1hKVxuICAgICAgICB7IGVsdCA9IG51bGw7IH1cbiAgICAgIGVsc2UgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuZWxsaXBzaXMpIHtcbiAgICAgICAgZWx0ID0gdGhpcy5wYXJzZVNwcmVhZChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgICAgICAgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMgJiYgdGhpcy50eXBlID09PSB0eXBlcy5jb21tYSAmJiByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnRyYWlsaW5nQ29tbWEgPCAwKVxuICAgICAgICAgIHsgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy50cmFpbGluZ0NvbW1hID0gdGhpcy5zdGFydDsgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWx0ID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKGZhbHNlLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgICAgIH1cbiAgICAgIGVsdHMucHVzaChlbHQpO1xuICAgIH1cbiAgICByZXR1cm4gZWx0c1xuICB9O1xuXG4gIHBwJDMuY2hlY2tVbnJlc2VydmVkID0gZnVuY3Rpb24ocmVmKSB7XG4gICAgdmFyIHN0YXJ0ID0gcmVmLnN0YXJ0O1xuICAgIHZhciBlbmQgPSByZWYuZW5kO1xuICAgIHZhciBuYW1lID0gcmVmLm5hbWU7XG5cbiAgICBpZiAodGhpcy5pbkdlbmVyYXRvciAmJiBuYW1lID09PSBcInlpZWxkXCIpXG4gICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShzdGFydCwgXCJDYW5ub3QgdXNlICd5aWVsZCcgYXMgaWRlbnRpZmllciBpbnNpZGUgYSBnZW5lcmF0b3JcIik7IH1cbiAgICBpZiAodGhpcy5pbkFzeW5jICYmIG5hbWUgPT09IFwiYXdhaXRcIilcbiAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHN0YXJ0LCBcIkNhbm5vdCB1c2UgJ2F3YWl0JyBhcyBpZGVudGlmaWVyIGluc2lkZSBhbiBhc3luYyBmdW5jdGlvblwiKTsgfVxuICAgIGlmICh0aGlzLmtleXdvcmRzLnRlc3QobmFtZSkpXG4gICAgICB7IHRoaXMucmFpc2Uoc3RhcnQsIChcIlVuZXhwZWN0ZWQga2V5d29yZCAnXCIgKyBuYW1lICsgXCInXCIpKTsgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPCA2ICYmXG4gICAgICB0aGlzLmlucHV0LnNsaWNlKHN0YXJ0LCBlbmQpLmluZGV4T2YoXCJcXFxcXCIpICE9PSAtMSkgeyByZXR1cm4gfVxuICAgIHZhciByZSA9IHRoaXMuc3RyaWN0ID8gdGhpcy5yZXNlcnZlZFdvcmRzU3RyaWN0IDogdGhpcy5yZXNlcnZlZFdvcmRzO1xuICAgIGlmIChyZS50ZXN0KG5hbWUpKSB7XG4gICAgICBpZiAoIXRoaXMuaW5Bc3luYyAmJiBuYW1lID09PSBcImF3YWl0XCIpXG4gICAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHN0YXJ0LCBcIkNhbm5vdCB1c2Uga2V5d29yZCAnYXdhaXQnIG91dHNpZGUgYW4gYXN5bmMgZnVuY3Rpb25cIik7IH1cbiAgICAgIHRoaXMucmFpc2VSZWNvdmVyYWJsZShzdGFydCwgKFwiVGhlIGtleXdvcmQgJ1wiICsgbmFtZSArIFwiJyBpcyByZXNlcnZlZFwiKSk7XG4gICAgfVxuICB9O1xuXG5cbiAgcHAkMy5wYXJzZUlkZW50ID0gZnVuY3Rpb24obGliZXJhbCwgaXNCaW5kaW5nKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLm5hbWUpIHtcbiAgICAgIG5vZGUubmFtZSA9IHRoaXMudmFsdWU7XG4gICAgfSBlbHNlIGlmICh0aGlzLnR5cGUua2V5d29yZCkge1xuICAgICAgbm9kZS5uYW1lID0gdGhpcy50eXBlLmtleXdvcmQ7XG5cbiAgICAgIGlmICgobm9kZS5uYW1lID09PSBcImNsYXNzXCIgfHwgbm9kZS5uYW1lID09PSBcImZ1bmN0aW9uXCIpICYmXG4gICAgICAgICAgKHRoaXMubGFzdFRva0VuZCAhPT0gdGhpcy5sYXN0VG9rU3RhcnQgKyAxIHx8IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLmxhc3RUb2tTdGFydCkgIT09IDQ2KSkge1xuICAgICAgICB0aGlzLmNvbnRleHQucG9wKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudW5leHBlY3RlZCgpO1xuICAgIH1cbiAgICB0aGlzLm5leHQoISFsaWJlcmFsKTtcbiAgICB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJJZGVudGlmaWVyXCIpO1xuICAgIGlmICghbGliZXJhbCkge1xuICAgICAgdGhpcy5jaGVja1VucmVzZXJ2ZWQobm9kZSk7XG4gICAgICBpZiAobm9kZS5uYW1lID09PSBcImF3YWl0XCIgJiYgIXRoaXMuYXdhaXRJZGVudFBvcylcbiAgICAgICAgeyB0aGlzLmF3YWl0SWRlbnRQb3MgPSBub2RlLnN0YXJ0OyB9XG4gICAgfVxuICAgIHJldHVybiBub2RlXG4gIH07XG5cblxuICBwcCQzLnBhcnNlWWllbGQgPSBmdW5jdGlvbihub0luKSB7XG4gICAgaWYgKCF0aGlzLnlpZWxkUG9zKSB7IHRoaXMueWllbGRQb3MgPSB0aGlzLnN0YXJ0OyB9XG5cbiAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuc2VtaSB8fCB0aGlzLmNhbkluc2VydFNlbWljb2xvbigpIHx8ICh0aGlzLnR5cGUgIT09IHR5cGVzLnN0YXIgJiYgIXRoaXMudHlwZS5zdGFydHNFeHByKSkge1xuICAgICAgbm9kZS5kZWxlZ2F0ZSA9IGZhbHNlO1xuICAgICAgbm9kZS5hcmd1bWVudCA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUuZGVsZWdhdGUgPSB0aGlzLmVhdCh0eXBlcy5zdGFyKTtcbiAgICAgIG5vZGUuYXJndW1lbnQgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24obm9Jbik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJZaWVsZEV4cHJlc3Npb25cIilcbiAgfTtcblxuICBwcCQzLnBhcnNlQXdhaXQgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoIXRoaXMuYXdhaXRQb3MpIHsgdGhpcy5hd2FpdFBvcyA9IHRoaXMuc3RhcnQ7IH1cblxuICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBub2RlLmFyZ3VtZW50ID0gdGhpcy5wYXJzZU1heWJlVW5hcnkobnVsbCwgZmFsc2UpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJBd2FpdEV4cHJlc3Npb25cIilcbiAgfTtcblxuICB2YXIgcHAkNCA9IFBhcnNlci5wcm90b3R5cGU7XG5cblxuICBwcCQ0LnJhaXNlID0gZnVuY3Rpb24ocG9zLCBtZXNzYWdlKSB7XG4gICAgdmFyIGxvYyA9IGdldExpbmVJbmZvKHRoaXMuaW5wdXQsIHBvcyk7XG4gICAgbWVzc2FnZSArPSBcIiAoXCIgKyBsb2MubGluZSArIFwiOlwiICsgbG9jLmNvbHVtbiArIFwiKVwiO1xuICAgIHZhciBlcnIgPSBuZXcgU3ludGF4RXJyb3IobWVzc2FnZSk7XG4gICAgZXJyLnBvcyA9IHBvczsgZXJyLmxvYyA9IGxvYzsgZXJyLnJhaXNlZEF0ID0gdGhpcy5wb3M7XG4gICAgdGhyb3cgZXJyXG4gIH07XG5cbiAgcHAkNC5yYWlzZVJlY292ZXJhYmxlID0gcHAkNC5yYWlzZTtcblxuICBwcCQ0LmN1clBvc2l0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5sb2NhdGlvbnMpIHtcbiAgICAgIHJldHVybiBuZXcgUG9zaXRpb24odGhpcy5jdXJMaW5lLCB0aGlzLnBvcyAtIHRoaXMubGluZVN0YXJ0KVxuICAgIH1cbiAgfTtcblxuICB2YXIgcHAkNSA9IFBhcnNlci5wcm90b3R5cGU7XG5cbiAgdmFyIFNjb3BlID0gZnVuY3Rpb24gU2NvcGUoZmxhZ3MpIHtcbiAgICB0aGlzLmZsYWdzID0gZmxhZ3M7XG4gICAgdGhpcy52YXIgPSBbXTtcbiAgICB0aGlzLmxleGljYWwgPSBbXTtcbiAgICB0aGlzLmZ1bmN0aW9ucyA9IFtdO1xuICB9O1xuXG5cbiAgcHAkNS5lbnRlclNjb3BlID0gZnVuY3Rpb24oZmxhZ3MpIHtcbiAgICB0aGlzLnNjb3BlU3RhY2sucHVzaChuZXcgU2NvcGUoZmxhZ3MpKTtcbiAgfTtcblxuICBwcCQ1LmV4aXRTY29wZSA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuc2NvcGVTdGFjay5wb3AoKTtcbiAgfTtcblxuICBwcCQ1LnRyZWF0RnVuY3Rpb25zQXNWYXJJblNjb3BlID0gZnVuY3Rpb24oc2NvcGUpIHtcbiAgICByZXR1cm4gKHNjb3BlLmZsYWdzICYgU0NPUEVfRlVOQ1RJT04pIHx8ICF0aGlzLmluTW9kdWxlICYmIChzY29wZS5mbGFncyAmIFNDT1BFX1RPUClcbiAgfTtcblxuICBwcCQ1LmRlY2xhcmVOYW1lID0gZnVuY3Rpb24obmFtZSwgYmluZGluZ1R5cGUsIHBvcykge1xuICAgIHZhciByZWRlY2xhcmVkID0gZmFsc2U7XG4gICAgaWYgKGJpbmRpbmdUeXBlID09PSBCSU5EX0xFWElDQUwpIHtcbiAgICAgIHZhciBzY29wZSA9IHRoaXMuY3VycmVudFNjb3BlKCk7XG4gICAgICByZWRlY2xhcmVkID0gc2NvcGUubGV4aWNhbC5pbmRleE9mKG5hbWUpID4gLTEgfHwgc2NvcGUuZnVuY3Rpb25zLmluZGV4T2YobmFtZSkgPiAtMSB8fCBzY29wZS52YXIuaW5kZXhPZihuYW1lKSA+IC0xO1xuICAgICAgc2NvcGUubGV4aWNhbC5wdXNoKG5hbWUpO1xuICAgICAgaWYgKHRoaXMuaW5Nb2R1bGUgJiYgKHNjb3BlLmZsYWdzICYgU0NPUEVfVE9QKSlcbiAgICAgICAgeyBkZWxldGUgdGhpcy51bmRlZmluZWRFeHBvcnRzW25hbWVdOyB9XG4gICAgfSBlbHNlIGlmIChiaW5kaW5nVHlwZSA9PT0gQklORF9TSU1QTEVfQ0FUQ0gpIHtcbiAgICAgIHZhciBzY29wZSQxID0gdGhpcy5jdXJyZW50U2NvcGUoKTtcbiAgICAgIHNjb3BlJDEubGV4aWNhbC5wdXNoKG5hbWUpO1xuICAgIH0gZWxzZSBpZiAoYmluZGluZ1R5cGUgPT09IEJJTkRfRlVOQ1RJT04pIHtcbiAgICAgIHZhciBzY29wZSQyID0gdGhpcy5jdXJyZW50U2NvcGUoKTtcbiAgICAgIGlmICh0aGlzLnRyZWF0RnVuY3Rpb25zQXNWYXIpXG4gICAgICAgIHsgcmVkZWNsYXJlZCA9IHNjb3BlJDIubGV4aWNhbC5pbmRleE9mKG5hbWUpID4gLTE7IH1cbiAgICAgIGVsc2VcbiAgICAgICAgeyByZWRlY2xhcmVkID0gc2NvcGUkMi5sZXhpY2FsLmluZGV4T2YobmFtZSkgPiAtMSB8fCBzY29wZSQyLnZhci5pbmRleE9mKG5hbWUpID4gLTE7IH1cbiAgICAgIHNjb3BlJDIuZnVuY3Rpb25zLnB1c2gobmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnNjb3BlU3RhY2subGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIHNjb3BlJDMgPSB0aGlzLnNjb3BlU3RhY2tbaV07XG4gICAgICAgIGlmIChzY29wZSQzLmxleGljYWwuaW5kZXhPZihuYW1lKSA+IC0xICYmICEoKHNjb3BlJDMuZmxhZ3MgJiBTQ09QRV9TSU1QTEVfQ0FUQ0gpICYmIHNjb3BlJDMubGV4aWNhbFswXSA9PT0gbmFtZSkgfHxcbiAgICAgICAgICAgICF0aGlzLnRyZWF0RnVuY3Rpb25zQXNWYXJJblNjb3BlKHNjb3BlJDMpICYmIHNjb3BlJDMuZnVuY3Rpb25zLmluZGV4T2YobmFtZSkgPiAtMSkge1xuICAgICAgICAgIHJlZGVjbGFyZWQgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgc2NvcGUkMy52YXIucHVzaChuYW1lKTtcbiAgICAgICAgaWYgKHRoaXMuaW5Nb2R1bGUgJiYgKHNjb3BlJDMuZmxhZ3MgJiBTQ09QRV9UT1ApKVxuICAgICAgICAgIHsgZGVsZXRlIHRoaXMudW5kZWZpbmVkRXhwb3J0c1tuYW1lXTsgfVxuICAgICAgICBpZiAoc2NvcGUkMy5mbGFncyAmIFNDT1BFX1ZBUikgeyBicmVhayB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChyZWRlY2xhcmVkKSB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShwb3MsIChcIklkZW50aWZpZXIgJ1wiICsgbmFtZSArIFwiJyBoYXMgYWxyZWFkeSBiZWVuIGRlY2xhcmVkXCIpKTsgfVxuICB9O1xuXG4gIHBwJDUuY2hlY2tMb2NhbEV4cG9ydCA9IGZ1bmN0aW9uKGlkKSB7XG4gICAgaWYgKHRoaXMuc2NvcGVTdGFja1swXS5sZXhpY2FsLmluZGV4T2YoaWQubmFtZSkgPT09IC0xICYmXG4gICAgICAgIHRoaXMuc2NvcGVTdGFja1swXS52YXIuaW5kZXhPZihpZC5uYW1lKSA9PT0gLTEpIHtcbiAgICAgIHRoaXMudW5kZWZpbmVkRXhwb3J0c1tpZC5uYW1lXSA9IGlkO1xuICAgIH1cbiAgfTtcblxuICBwcCQ1LmN1cnJlbnRTY29wZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnNjb3BlU3RhY2tbdGhpcy5zY29wZVN0YWNrLmxlbmd0aCAtIDFdXG4gIH07XG5cbiAgcHAkNS5jdXJyZW50VmFyU2NvcGUgPSBmdW5jdGlvbigpIHtcbiAgICBmb3IgKHZhciBpID0gdGhpcy5zY29wZVN0YWNrLmxlbmd0aCAtIDE7OyBpLS0pIHtcbiAgICAgIHZhciBzY29wZSA9IHRoaXMuc2NvcGVTdGFja1tpXTtcbiAgICAgIGlmIChzY29wZS5mbGFncyAmIFNDT1BFX1ZBUikgeyByZXR1cm4gc2NvcGUgfVxuICAgIH1cbiAgfTtcblxuICBwcCQ1LmN1cnJlbnRUaGlzU2NvcGUgPSBmdW5jdGlvbigpIHtcbiAgICBmb3IgKHZhciBpID0gdGhpcy5zY29wZVN0YWNrLmxlbmd0aCAtIDE7OyBpLS0pIHtcbiAgICAgIHZhciBzY29wZSA9IHRoaXMuc2NvcGVTdGFja1tpXTtcbiAgICAgIGlmIChzY29wZS5mbGFncyAmIFNDT1BFX1ZBUiAmJiAhKHNjb3BlLmZsYWdzICYgU0NPUEVfQVJST1cpKSB7IHJldHVybiBzY29wZSB9XG4gICAgfVxuICB9O1xuXG4gIHZhciBOb2RlID0gZnVuY3Rpb24gTm9kZShwYXJzZXIsIHBvcywgbG9jKSB7XG4gICAgdGhpcy50eXBlID0gXCJcIjtcbiAgICB0aGlzLnN0YXJ0ID0gcG9zO1xuICAgIHRoaXMuZW5kID0gMDtcbiAgICBpZiAocGFyc2VyLm9wdGlvbnMubG9jYXRpb25zKVxuICAgICAgeyB0aGlzLmxvYyA9IG5ldyBTb3VyY2VMb2NhdGlvbihwYXJzZXIsIGxvYyk7IH1cbiAgICBpZiAocGFyc2VyLm9wdGlvbnMuZGlyZWN0U291cmNlRmlsZSlcbiAgICAgIHsgdGhpcy5zb3VyY2VGaWxlID0gcGFyc2VyLm9wdGlvbnMuZGlyZWN0U291cmNlRmlsZTsgfVxuICAgIGlmIChwYXJzZXIub3B0aW9ucy5yYW5nZXMpXG4gICAgICB7IHRoaXMucmFuZ2UgPSBbcG9zLCAwXTsgfVxuICB9O1xuXG5cbiAgdmFyIHBwJDYgPSBQYXJzZXIucHJvdG90eXBlO1xuXG4gIHBwJDYuc3RhcnROb2RlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBOb2RlKHRoaXMsIHRoaXMuc3RhcnQsIHRoaXMuc3RhcnRMb2MpXG4gIH07XG5cbiAgcHAkNi5zdGFydE5vZGVBdCA9IGZ1bmN0aW9uKHBvcywgbG9jKSB7XG4gICAgcmV0dXJuIG5ldyBOb2RlKHRoaXMsIHBvcywgbG9jKVxuICB9O1xuXG5cbiAgZnVuY3Rpb24gZmluaXNoTm9kZUF0KG5vZGUsIHR5cGUsIHBvcywgbG9jKSB7XG4gICAgbm9kZS50eXBlID0gdHlwZTtcbiAgICBub2RlLmVuZCA9IHBvcztcbiAgICBpZiAodGhpcy5vcHRpb25zLmxvY2F0aW9ucylcbiAgICAgIHsgbm9kZS5sb2MuZW5kID0gbG9jOyB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5yYW5nZXMpXG4gICAgICB7IG5vZGUucmFuZ2VbMV0gPSBwb3M7IH1cbiAgICByZXR1cm4gbm9kZVxuICB9XG5cbiAgcHAkNi5maW5pc2hOb2RlID0gZnVuY3Rpb24obm9kZSwgdHlwZSkge1xuICAgIHJldHVybiBmaW5pc2hOb2RlQXQuY2FsbCh0aGlzLCBub2RlLCB0eXBlLCB0aGlzLmxhc3RUb2tFbmQsIHRoaXMubGFzdFRva0VuZExvYylcbiAgfTtcblxuXG4gIHBwJDYuZmluaXNoTm9kZUF0ID0gZnVuY3Rpb24obm9kZSwgdHlwZSwgcG9zLCBsb2MpIHtcbiAgICByZXR1cm4gZmluaXNoTm9kZUF0LmNhbGwodGhpcywgbm9kZSwgdHlwZSwgcG9zLCBsb2MpXG4gIH07XG5cblxuICB2YXIgVG9rQ29udGV4dCA9IGZ1bmN0aW9uIFRva0NvbnRleHQodG9rZW4sIGlzRXhwciwgcHJlc2VydmVTcGFjZSwgb3ZlcnJpZGUsIGdlbmVyYXRvcikge1xuICAgIHRoaXMudG9rZW4gPSB0b2tlbjtcbiAgICB0aGlzLmlzRXhwciA9ICEhaXNFeHByO1xuICAgIHRoaXMucHJlc2VydmVTcGFjZSA9ICEhcHJlc2VydmVTcGFjZTtcbiAgICB0aGlzLm92ZXJyaWRlID0gb3ZlcnJpZGU7XG4gICAgdGhpcy5nZW5lcmF0b3IgPSAhIWdlbmVyYXRvcjtcbiAgfTtcblxuICB2YXIgdHlwZXMkMSA9IHtcbiAgICBiX3N0YXQ6IG5ldyBUb2tDb250ZXh0KFwie1wiLCBmYWxzZSksXG4gICAgYl9leHByOiBuZXcgVG9rQ29udGV4dChcIntcIiwgdHJ1ZSksXG4gICAgYl90bXBsOiBuZXcgVG9rQ29udGV4dChcIiR7XCIsIGZhbHNlKSxcbiAgICBwX3N0YXQ6IG5ldyBUb2tDb250ZXh0KFwiKFwiLCBmYWxzZSksXG4gICAgcF9leHByOiBuZXcgVG9rQ29udGV4dChcIihcIiwgdHJ1ZSksXG4gICAgcV90bXBsOiBuZXcgVG9rQ29udGV4dChcImBcIiwgdHJ1ZSwgdHJ1ZSwgZnVuY3Rpb24gKHApIHsgcmV0dXJuIHAudHJ5UmVhZFRlbXBsYXRlVG9rZW4oKTsgfSksXG4gICAgZl9zdGF0OiBuZXcgVG9rQ29udGV4dChcImZ1bmN0aW9uXCIsIGZhbHNlKSxcbiAgICBmX2V4cHI6IG5ldyBUb2tDb250ZXh0KFwiZnVuY3Rpb25cIiwgdHJ1ZSksXG4gICAgZl9leHByX2dlbjogbmV3IFRva0NvbnRleHQoXCJmdW5jdGlvblwiLCB0cnVlLCBmYWxzZSwgbnVsbCwgdHJ1ZSksXG4gICAgZl9nZW46IG5ldyBUb2tDb250ZXh0KFwiZnVuY3Rpb25cIiwgZmFsc2UsIGZhbHNlLCBudWxsLCB0cnVlKVxuICB9O1xuXG4gIHZhciBwcCQ3ID0gUGFyc2VyLnByb3RvdHlwZTtcblxuICBwcCQ3LmluaXRpYWxDb250ZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFt0eXBlcyQxLmJfc3RhdF1cbiAgfTtcblxuICBwcCQ3LmJyYWNlSXNCbG9jayA9IGZ1bmN0aW9uKHByZXZUeXBlKSB7XG4gICAgdmFyIHBhcmVudCA9IHRoaXMuY3VyQ29udGV4dCgpO1xuICAgIGlmIChwYXJlbnQgPT09IHR5cGVzJDEuZl9leHByIHx8IHBhcmVudCA9PT0gdHlwZXMkMS5mX3N0YXQpXG4gICAgICB7IHJldHVybiB0cnVlIH1cbiAgICBpZiAocHJldlR5cGUgPT09IHR5cGVzLmNvbG9uICYmIChwYXJlbnQgPT09IHR5cGVzJDEuYl9zdGF0IHx8IHBhcmVudCA9PT0gdHlwZXMkMS5iX2V4cHIpKVxuICAgICAgeyByZXR1cm4gIXBhcmVudC5pc0V4cHIgfVxuXG4gICAgaWYgKHByZXZUeXBlID09PSB0eXBlcy5fcmV0dXJuIHx8IHByZXZUeXBlID09PSB0eXBlcy5uYW1lICYmIHRoaXMuZXhwckFsbG93ZWQpXG4gICAgICB7IHJldHVybiBsaW5lQnJlYWsudGVzdCh0aGlzLmlucHV0LnNsaWNlKHRoaXMubGFzdFRva0VuZCwgdGhpcy5zdGFydCkpIH1cbiAgICBpZiAocHJldlR5cGUgPT09IHR5cGVzLl9lbHNlIHx8IHByZXZUeXBlID09PSB0eXBlcy5zZW1pIHx8IHByZXZUeXBlID09PSB0eXBlcy5lb2YgfHwgcHJldlR5cGUgPT09IHR5cGVzLnBhcmVuUiB8fCBwcmV2VHlwZSA9PT0gdHlwZXMuYXJyb3cpXG4gICAgICB7IHJldHVybiB0cnVlIH1cbiAgICBpZiAocHJldlR5cGUgPT09IHR5cGVzLmJyYWNlTClcbiAgICAgIHsgcmV0dXJuIHBhcmVudCA9PT0gdHlwZXMkMS5iX3N0YXQgfVxuICAgIGlmIChwcmV2VHlwZSA9PT0gdHlwZXMuX3ZhciB8fCBwcmV2VHlwZSA9PT0gdHlwZXMuX2NvbnN0IHx8IHByZXZUeXBlID09PSB0eXBlcy5uYW1lKVxuICAgICAgeyByZXR1cm4gZmFsc2UgfVxuICAgIHJldHVybiAhdGhpcy5leHByQWxsb3dlZFxuICB9O1xuXG4gIHBwJDcuaW5HZW5lcmF0b3JDb250ZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgZm9yICh2YXIgaSA9IHRoaXMuY29udGV4dC5sZW5ndGggLSAxOyBpID49IDE7IGktLSkge1xuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLmNvbnRleHRbaV07XG4gICAgICBpZiAoY29udGV4dC50b2tlbiA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgICB7IHJldHVybiBjb250ZXh0LmdlbmVyYXRvciB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuXG4gIHBwJDcudXBkYXRlQ29udGV4dCA9IGZ1bmN0aW9uKHByZXZUeXBlKSB7XG4gICAgdmFyIHVwZGF0ZSwgdHlwZSA9IHRoaXMudHlwZTtcbiAgICBpZiAodHlwZS5rZXl3b3JkICYmIHByZXZUeXBlID09PSB0eXBlcy5kb3QpXG4gICAgICB7IHRoaXMuZXhwckFsbG93ZWQgPSBmYWxzZTsgfVxuICAgIGVsc2UgaWYgKHVwZGF0ZSA9IHR5cGUudXBkYXRlQ29udGV4dClcbiAgICAgIHsgdXBkYXRlLmNhbGwodGhpcywgcHJldlR5cGUpOyB9XG4gICAgZWxzZVxuICAgICAgeyB0aGlzLmV4cHJBbGxvd2VkID0gdHlwZS5iZWZvcmVFeHByOyB9XG4gIH07XG5cblxuICB0eXBlcy5wYXJlblIudXBkYXRlQ29udGV4dCA9IHR5cGVzLmJyYWNlUi51cGRhdGVDb250ZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuY29udGV4dC5sZW5ndGggPT09IDEpIHtcbiAgICAgIHRoaXMuZXhwckFsbG93ZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHZhciBvdXQgPSB0aGlzLmNvbnRleHQucG9wKCk7XG4gICAgaWYgKG91dCA9PT0gdHlwZXMkMS5iX3N0YXQgJiYgdGhpcy5jdXJDb250ZXh0KCkudG9rZW4gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgb3V0ID0gdGhpcy5jb250ZXh0LnBvcCgpO1xuICAgIH1cbiAgICB0aGlzLmV4cHJBbGxvd2VkID0gIW91dC5pc0V4cHI7XG4gIH07XG5cbiAgdHlwZXMuYnJhY2VMLnVwZGF0ZUNvbnRleHQgPSBmdW5jdGlvbihwcmV2VHlwZSkge1xuICAgIHRoaXMuY29udGV4dC5wdXNoKHRoaXMuYnJhY2VJc0Jsb2NrKHByZXZUeXBlKSA/IHR5cGVzJDEuYl9zdGF0IDogdHlwZXMkMS5iX2V4cHIpO1xuICAgIHRoaXMuZXhwckFsbG93ZWQgPSB0cnVlO1xuICB9O1xuXG4gIHR5cGVzLmRvbGxhckJyYWNlTC51cGRhdGVDb250ZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5jb250ZXh0LnB1c2godHlwZXMkMS5iX3RtcGwpO1xuICAgIHRoaXMuZXhwckFsbG93ZWQgPSB0cnVlO1xuICB9O1xuXG4gIHR5cGVzLnBhcmVuTC51cGRhdGVDb250ZXh0ID0gZnVuY3Rpb24ocHJldlR5cGUpIHtcbiAgICB2YXIgc3RhdGVtZW50UGFyZW5zID0gcHJldlR5cGUgPT09IHR5cGVzLl9pZiB8fCBwcmV2VHlwZSA9PT0gdHlwZXMuX2ZvciB8fCBwcmV2VHlwZSA9PT0gdHlwZXMuX3dpdGggfHwgcHJldlR5cGUgPT09IHR5cGVzLl93aGlsZTtcbiAgICB0aGlzLmNvbnRleHQucHVzaChzdGF0ZW1lbnRQYXJlbnMgPyB0eXBlcyQxLnBfc3RhdCA6IHR5cGVzJDEucF9leHByKTtcbiAgICB0aGlzLmV4cHJBbGxvd2VkID0gdHJ1ZTtcbiAgfTtcblxuICB0eXBlcy5pbmNEZWMudXBkYXRlQ29udGV4dCA9IGZ1bmN0aW9uKCkge1xuICB9O1xuXG4gIHR5cGVzLl9mdW5jdGlvbi51cGRhdGVDb250ZXh0ID0gdHlwZXMuX2NsYXNzLnVwZGF0ZUNvbnRleHQgPSBmdW5jdGlvbihwcmV2VHlwZSkge1xuICAgIGlmIChwcmV2VHlwZS5iZWZvcmVFeHByICYmIHByZXZUeXBlICE9PSB0eXBlcy5zZW1pICYmIHByZXZUeXBlICE9PSB0eXBlcy5fZWxzZSAmJlxuICAgICAgICAhKHByZXZUeXBlID09PSB0eXBlcy5fcmV0dXJuICYmIGxpbmVCcmVhay50ZXN0KHRoaXMuaW5wdXQuc2xpY2UodGhpcy5sYXN0VG9rRW5kLCB0aGlzLnN0YXJ0KSkpICYmXG4gICAgICAgICEoKHByZXZUeXBlID09PSB0eXBlcy5jb2xvbiB8fCBwcmV2VHlwZSA9PT0gdHlwZXMuYnJhY2VMKSAmJiB0aGlzLmN1ckNvbnRleHQoKSA9PT0gdHlwZXMkMS5iX3N0YXQpKVxuICAgICAgeyB0aGlzLmNvbnRleHQucHVzaCh0eXBlcyQxLmZfZXhwcik7IH1cbiAgICBlbHNlXG4gICAgICB7IHRoaXMuY29udGV4dC5wdXNoKHR5cGVzJDEuZl9zdGF0KTsgfVxuICAgIHRoaXMuZXhwckFsbG93ZWQgPSBmYWxzZTtcbiAgfTtcblxuICB0eXBlcy5iYWNrUXVvdGUudXBkYXRlQ29udGV4dCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLmN1ckNvbnRleHQoKSA9PT0gdHlwZXMkMS5xX3RtcGwpXG4gICAgICB7IHRoaXMuY29udGV4dC5wb3AoKTsgfVxuICAgIGVsc2VcbiAgICAgIHsgdGhpcy5jb250ZXh0LnB1c2godHlwZXMkMS5xX3RtcGwpOyB9XG4gICAgdGhpcy5leHByQWxsb3dlZCA9IGZhbHNlO1xuICB9O1xuXG4gIHR5cGVzLnN0YXIudXBkYXRlQ29udGV4dCA9IGZ1bmN0aW9uKHByZXZUeXBlKSB7XG4gICAgaWYgKHByZXZUeXBlID09PSB0eXBlcy5fZnVuY3Rpb24pIHtcbiAgICAgIHZhciBpbmRleCA9IHRoaXMuY29udGV4dC5sZW5ndGggLSAxO1xuICAgICAgaWYgKHRoaXMuY29udGV4dFtpbmRleF0gPT09IHR5cGVzJDEuZl9leHByKVxuICAgICAgICB7IHRoaXMuY29udGV4dFtpbmRleF0gPSB0eXBlcyQxLmZfZXhwcl9nZW47IH1cbiAgICAgIGVsc2VcbiAgICAgICAgeyB0aGlzLmNvbnRleHRbaW5kZXhdID0gdHlwZXMkMS5mX2dlbjsgfVxuICAgIH1cbiAgICB0aGlzLmV4cHJBbGxvd2VkID0gdHJ1ZTtcbiAgfTtcblxuICB0eXBlcy5uYW1lLnVwZGF0ZUNvbnRleHQgPSBmdW5jdGlvbihwcmV2VHlwZSkge1xuICAgIHZhciBhbGxvd2VkID0gZmFsc2U7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2ICYmIHByZXZUeXBlICE9PSB0eXBlcy5kb3QpIHtcbiAgICAgIGlmICh0aGlzLnZhbHVlID09PSBcIm9mXCIgJiYgIXRoaXMuZXhwckFsbG93ZWQgfHxcbiAgICAgICAgICB0aGlzLnZhbHVlID09PSBcInlpZWxkXCIgJiYgdGhpcy5pbkdlbmVyYXRvckNvbnRleHQoKSlcbiAgICAgICAgeyBhbGxvd2VkID0gdHJ1ZTsgfVxuICAgIH1cbiAgICB0aGlzLmV4cHJBbGxvd2VkID0gYWxsb3dlZDtcbiAgfTtcblxuXG4gIHZhciBlY21hOUJpbmFyeVByb3BlcnRpZXMgPSBcIkFTQ0lJIEFTQ0lJX0hleF9EaWdpdCBBSGV4IEFscGhhYmV0aWMgQWxwaGEgQW55IEFzc2lnbmVkIEJpZGlfQ29udHJvbCBCaWRpX0MgQmlkaV9NaXJyb3JlZCBCaWRpX00gQ2FzZV9JZ25vcmFibGUgQ0kgQ2FzZWQgQ2hhbmdlc19XaGVuX0Nhc2Vmb2xkZWQgQ1dDRiBDaGFuZ2VzX1doZW5fQ2FzZW1hcHBlZCBDV0NNIENoYW5nZXNfV2hlbl9Mb3dlcmNhc2VkIENXTCBDaGFuZ2VzX1doZW5fTkZLQ19DYXNlZm9sZGVkIENXS0NGIENoYW5nZXNfV2hlbl9UaXRsZWNhc2VkIENXVCBDaGFuZ2VzX1doZW5fVXBwZXJjYXNlZCBDV1UgRGFzaCBEZWZhdWx0X0lnbm9yYWJsZV9Db2RlX1BvaW50IERJIERlcHJlY2F0ZWQgRGVwIERpYWNyaXRpYyBEaWEgRW1vamkgRW1vamlfQ29tcG9uZW50IEVtb2ppX01vZGlmaWVyIEVtb2ppX01vZGlmaWVyX0Jhc2UgRW1vamlfUHJlc2VudGF0aW9uIEV4dGVuZGVyIEV4dCBHcmFwaGVtZV9CYXNlIEdyX0Jhc2UgR3JhcGhlbWVfRXh0ZW5kIEdyX0V4dCBIZXhfRGlnaXQgSGV4IElEU19CaW5hcnlfT3BlcmF0b3IgSURTQiBJRFNfVHJpbmFyeV9PcGVyYXRvciBJRFNUIElEX0NvbnRpbnVlIElEQyBJRF9TdGFydCBJRFMgSWRlb2dyYXBoaWMgSWRlbyBKb2luX0NvbnRyb2wgSm9pbl9DIExvZ2ljYWxfT3JkZXJfRXhjZXB0aW9uIExPRSBMb3dlcmNhc2UgTG93ZXIgTWF0aCBOb25jaGFyYWN0ZXJfQ29kZV9Qb2ludCBOQ2hhciBQYXR0ZXJuX1N5bnRheCBQYXRfU3luIFBhdHRlcm5fV2hpdGVfU3BhY2UgUGF0X1dTIFF1b3RhdGlvbl9NYXJrIFFNYXJrIFJhZGljYWwgUmVnaW9uYWxfSW5kaWNhdG9yIFJJIFNlbnRlbmNlX1Rlcm1pbmFsIFNUZXJtIFNvZnRfRG90dGVkIFNEIFRlcm1pbmFsX1B1bmN0dWF0aW9uIFRlcm0gVW5pZmllZF9JZGVvZ3JhcGggVUlkZW8gVXBwZXJjYXNlIFVwcGVyIFZhcmlhdGlvbl9TZWxlY3RvciBWUyBXaGl0ZV9TcGFjZSBzcGFjZSBYSURfQ29udGludWUgWElEQyBYSURfU3RhcnQgWElEU1wiO1xuICB2YXIgZWNtYTEwQmluYXJ5UHJvcGVydGllcyA9IGVjbWE5QmluYXJ5UHJvcGVydGllcyArIFwiIEV4dGVuZGVkX1BpY3RvZ3JhcGhpY1wiO1xuICB2YXIgZWNtYTExQmluYXJ5UHJvcGVydGllcyA9IGVjbWExMEJpbmFyeVByb3BlcnRpZXM7XG4gIHZhciB1bmljb2RlQmluYXJ5UHJvcGVydGllcyA9IHtcbiAgICA5OiBlY21hOUJpbmFyeVByb3BlcnRpZXMsXG4gICAgMTA6IGVjbWExMEJpbmFyeVByb3BlcnRpZXMsXG4gICAgMTE6IGVjbWExMUJpbmFyeVByb3BlcnRpZXNcbiAgfTtcblxuICB2YXIgdW5pY29kZUdlbmVyYWxDYXRlZ29yeVZhbHVlcyA9IFwiQ2FzZWRfTGV0dGVyIExDIENsb3NlX1B1bmN0dWF0aW9uIFBlIENvbm5lY3Rvcl9QdW5jdHVhdGlvbiBQYyBDb250cm9sIENjIGNudHJsIEN1cnJlbmN5X1N5bWJvbCBTYyBEYXNoX1B1bmN0dWF0aW9uIFBkIERlY2ltYWxfTnVtYmVyIE5kIGRpZ2l0IEVuY2xvc2luZ19NYXJrIE1lIEZpbmFsX1B1bmN0dWF0aW9uIFBmIEZvcm1hdCBDZiBJbml0aWFsX1B1bmN0dWF0aW9uIFBpIExldHRlciBMIExldHRlcl9OdW1iZXIgTmwgTGluZV9TZXBhcmF0b3IgWmwgTG93ZXJjYXNlX0xldHRlciBMbCBNYXJrIE0gQ29tYmluaW5nX01hcmsgTWF0aF9TeW1ib2wgU20gTW9kaWZpZXJfTGV0dGVyIExtIE1vZGlmaWVyX1N5bWJvbCBTayBOb25zcGFjaW5nX01hcmsgTW4gTnVtYmVyIE4gT3Blbl9QdW5jdHVhdGlvbiBQcyBPdGhlciBDIE90aGVyX0xldHRlciBMbyBPdGhlcl9OdW1iZXIgTm8gT3RoZXJfUHVuY3R1YXRpb24gUG8gT3RoZXJfU3ltYm9sIFNvIFBhcmFncmFwaF9TZXBhcmF0b3IgWnAgUHJpdmF0ZV9Vc2UgQ28gUHVuY3R1YXRpb24gUCBwdW5jdCBTZXBhcmF0b3IgWiBTcGFjZV9TZXBhcmF0b3IgWnMgU3BhY2luZ19NYXJrIE1jIFN1cnJvZ2F0ZSBDcyBTeW1ib2wgUyBUaXRsZWNhc2VfTGV0dGVyIEx0IFVuYXNzaWduZWQgQ24gVXBwZXJjYXNlX0xldHRlciBMdVwiO1xuXG4gIHZhciBlY21hOVNjcmlwdFZhbHVlcyA9IFwiQWRsYW0gQWRsbSBBaG9tIEFob20gQW5hdG9saWFuX0hpZXJvZ2x5cGhzIEhsdXcgQXJhYmljIEFyYWIgQXJtZW5pYW4gQXJtbiBBdmVzdGFuIEF2c3QgQmFsaW5lc2UgQmFsaSBCYW11bSBCYW11IEJhc3NhX1ZhaCBCYXNzIEJhdGFrIEJhdGsgQmVuZ2FsaSBCZW5nIEJoYWlrc3VraSBCaGtzIEJvcG9tb2ZvIEJvcG8gQnJhaG1pIEJyYWggQnJhaWxsZSBCcmFpIEJ1Z2luZXNlIEJ1Z2kgQnVoaWQgQnVoZCBDYW5hZGlhbl9BYm9yaWdpbmFsIENhbnMgQ2FyaWFuIENhcmkgQ2F1Y2FzaWFuX0FsYmFuaWFuIEFnaGIgQ2hha21hIENha20gQ2hhbSBDaGFtIENoZXJva2VlIENoZXIgQ29tbW9uIFp5eXkgQ29wdGljIENvcHQgUWFhYyBDdW5laWZvcm0gWHN1eCBDeXByaW90IENwcnQgQ3lyaWxsaWMgQ3lybCBEZXNlcmV0IERzcnQgRGV2YW5hZ2FyaSBEZXZhIER1cGxveWFuIER1cGwgRWd5cHRpYW5fSGllcm9nbHlwaHMgRWd5cCBFbGJhc2FuIEVsYmEgRXRoaW9waWMgRXRoaSBHZW9yZ2lhbiBHZW9yIEdsYWdvbGl0aWMgR2xhZyBHb3RoaWMgR290aCBHcmFudGhhIEdyYW4gR3JlZWsgR3JlayBHdWphcmF0aSBHdWpyIEd1cm11a2hpIEd1cnUgSGFuIEhhbmkgSGFuZ3VsIEhhbmcgSGFudW5vbyBIYW5vIEhhdHJhbiBIYXRyIEhlYnJldyBIZWJyIEhpcmFnYW5hIEhpcmEgSW1wZXJpYWxfQXJhbWFpYyBBcm1pIEluaGVyaXRlZCBaaW5oIFFhYWkgSW5zY3JpcHRpb25hbF9QYWhsYXZpIFBobGkgSW5zY3JpcHRpb25hbF9QYXJ0aGlhbiBQcnRpIEphdmFuZXNlIEphdmEgS2FpdGhpIEt0aGkgS2FubmFkYSBLbmRhIEthdGFrYW5hIEthbmEgS2F5YWhfTGkgS2FsaSBLaGFyb3NodGhpIEtoYXIgS2htZXIgS2htciBLaG9qa2kgS2hvaiBLaHVkYXdhZGkgU2luZCBMYW8gTGFvbyBMYXRpbiBMYXRuIExlcGNoYSBMZXBjIExpbWJ1IExpbWIgTGluZWFyX0EgTGluYSBMaW5lYXJfQiBMaW5iIExpc3UgTGlzdSBMeWNpYW4gTHljaSBMeWRpYW4gTHlkaSBNYWhhamFuaSBNYWhqIE1hbGF5YWxhbSBNbHltIE1hbmRhaWMgTWFuZCBNYW5pY2hhZWFuIE1hbmkgTWFyY2hlbiBNYXJjIE1hc2FyYW1fR29uZGkgR29ubSBNZWV0ZWlfTWF5ZWsgTXRlaSBNZW5kZV9LaWtha3VpIE1lbmQgTWVyb2l0aWNfQ3Vyc2l2ZSBNZXJjIE1lcm9pdGljX0hpZXJvZ2x5cGhzIE1lcm8gTWlhbyBQbHJkIE1vZGkgTW9kaSBNb25nb2xpYW4gTW9uZyBNcm8gTXJvbyBNdWx0YW5pIE11bHQgTXlhbm1hciBNeW1yIE5hYmF0YWVhbiBOYmF0IE5ld19UYWlfTHVlIFRhbHUgTmV3YSBOZXdhIE5rbyBOa29vIE51c2h1IE5zaHUgT2doYW0gT2dhbSBPbF9DaGlraSBPbGNrIE9sZF9IdW5nYXJpYW4gSHVuZyBPbGRfSXRhbGljIEl0YWwgT2xkX05vcnRoX0FyYWJpYW4gTmFyYiBPbGRfUGVybWljIFBlcm0gT2xkX1BlcnNpYW4gWHBlbyBPbGRfU291dGhfQXJhYmlhbiBTYXJiIE9sZF9UdXJraWMgT3JraCBPcml5YSBPcnlhIE9zYWdlIE9zZ2UgT3NtYW55YSBPc21hIFBhaGF3aF9IbW9uZyBIbW5nIFBhbG15cmVuZSBQYWxtIFBhdV9DaW5fSGF1IFBhdWMgUGhhZ3NfUGEgUGhhZyBQaG9lbmljaWFuIFBobnggUHNhbHRlcl9QYWhsYXZpIFBobHAgUmVqYW5nIFJqbmcgUnVuaWMgUnVuciBTYW1hcml0YW4gU2FtciBTYXVyYXNodHJhIFNhdXIgU2hhcmFkYSBTaHJkIFNoYXZpYW4gU2hhdyBTaWRkaGFtIFNpZGQgU2lnbldyaXRpbmcgU2dudyBTaW5oYWxhIFNpbmggU29yYV9Tb21wZW5nIFNvcmEgU295b21ibyBTb3lvIFN1bmRhbmVzZSBTdW5kIFN5bG90aV9OYWdyaSBTeWxvIFN5cmlhYyBTeXJjIFRhZ2Fsb2cgVGdsZyBUYWdiYW53YSBUYWdiIFRhaV9MZSBUYWxlIFRhaV9UaGFtIExhbmEgVGFpX1ZpZXQgVGF2dCBUYWtyaSBUYWtyIFRhbWlsIFRhbWwgVGFuZ3V0IFRhbmcgVGVsdWd1IFRlbHUgVGhhYW5hIFRoYWEgVGhhaSBUaGFpIFRpYmV0YW4gVGlidCBUaWZpbmFnaCBUZm5nIFRpcmh1dGEgVGlyaCBVZ2FyaXRpYyBVZ2FyIFZhaSBWYWlpIFdhcmFuZ19DaXRpIFdhcmEgWWkgWWlpaSBaYW5hYmF6YXJfU3F1YXJlIFphbmJcIjtcbiAgdmFyIGVjbWExMFNjcmlwdFZhbHVlcyA9IGVjbWE5U2NyaXB0VmFsdWVzICsgXCIgRG9ncmEgRG9nciBHdW5qYWxhX0dvbmRpIEdvbmcgSGFuaWZpX1JvaGluZ3lhIFJvaGcgTWFrYXNhciBNYWthIE1lZGVmYWlkcmluIE1lZGYgT2xkX1NvZ2RpYW4gU29nbyBTb2dkaWFuIFNvZ2RcIjtcbiAgdmFyIGVjbWExMVNjcmlwdFZhbHVlcyA9IGVjbWExMFNjcmlwdFZhbHVlcyArIFwiIEVseW1haWMgRWx5bSBOYW5kaW5hZ2FyaSBOYW5kIE55aWFrZW5nX1B1YWNodWVfSG1vbmcgSG1ucCBXYW5jaG8gV2Nob1wiO1xuICB2YXIgdW5pY29kZVNjcmlwdFZhbHVlcyA9IHtcbiAgICA5OiBlY21hOVNjcmlwdFZhbHVlcyxcbiAgICAxMDogZWNtYTEwU2NyaXB0VmFsdWVzLFxuICAgIDExOiBlY21hMTFTY3JpcHRWYWx1ZXNcbiAgfTtcblxuICB2YXIgZGF0YSA9IHt9O1xuICBmdW5jdGlvbiBidWlsZFVuaWNvZGVEYXRhKGVjbWFWZXJzaW9uKSB7XG4gICAgdmFyIGQgPSBkYXRhW2VjbWFWZXJzaW9uXSA9IHtcbiAgICAgIGJpbmFyeTogd29yZHNSZWdleHAodW5pY29kZUJpbmFyeVByb3BlcnRpZXNbZWNtYVZlcnNpb25dICsgXCIgXCIgKyB1bmljb2RlR2VuZXJhbENhdGVnb3J5VmFsdWVzKSxcbiAgICAgIG5vbkJpbmFyeToge1xuICAgICAgICBHZW5lcmFsX0NhdGVnb3J5OiB3b3Jkc1JlZ2V4cCh1bmljb2RlR2VuZXJhbENhdGVnb3J5VmFsdWVzKSxcbiAgICAgICAgU2NyaXB0OiB3b3Jkc1JlZ2V4cCh1bmljb2RlU2NyaXB0VmFsdWVzW2VjbWFWZXJzaW9uXSlcbiAgICAgIH1cbiAgICB9O1xuICAgIGQubm9uQmluYXJ5LlNjcmlwdF9FeHRlbnNpb25zID0gZC5ub25CaW5hcnkuU2NyaXB0O1xuXG4gICAgZC5ub25CaW5hcnkuZ2MgPSBkLm5vbkJpbmFyeS5HZW5lcmFsX0NhdGVnb3J5O1xuICAgIGQubm9uQmluYXJ5LnNjID0gZC5ub25CaW5hcnkuU2NyaXB0O1xuICAgIGQubm9uQmluYXJ5LnNjeCA9IGQubm9uQmluYXJ5LlNjcmlwdF9FeHRlbnNpb25zO1xuICB9XG4gIGJ1aWxkVW5pY29kZURhdGEoOSk7XG4gIGJ1aWxkVW5pY29kZURhdGEoMTApO1xuICBidWlsZFVuaWNvZGVEYXRhKDExKTtcblxuICB2YXIgcHAkOCA9IFBhcnNlci5wcm90b3R5cGU7XG5cbiAgdmFyIFJlZ0V4cFZhbGlkYXRpb25TdGF0ZSA9IGZ1bmN0aW9uIFJlZ0V4cFZhbGlkYXRpb25TdGF0ZShwYXJzZXIpIHtcbiAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICB0aGlzLnZhbGlkRmxhZ3MgPSBcImdpbVwiICsgKHBhcnNlci5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYgPyBcInV5XCIgOiBcIlwiKSArIChwYXJzZXIub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA5ID8gXCJzXCIgOiBcIlwiKTtcbiAgICB0aGlzLnVuaWNvZGVQcm9wZXJ0aWVzID0gZGF0YVtwYXJzZXIub3B0aW9ucy5lY21hVmVyc2lvbiA+PSAxMSA/IDExIDogcGFyc2VyLm9wdGlvbnMuZWNtYVZlcnNpb25dO1xuICAgIHRoaXMuc291cmNlID0gXCJcIjtcbiAgICB0aGlzLmZsYWdzID0gXCJcIjtcbiAgICB0aGlzLnN0YXJ0ID0gMDtcbiAgICB0aGlzLnN3aXRjaFUgPSBmYWxzZTtcbiAgICB0aGlzLnN3aXRjaE4gPSBmYWxzZTtcbiAgICB0aGlzLnBvcyA9IDA7XG4gICAgdGhpcy5sYXN0SW50VmFsdWUgPSAwO1xuICAgIHRoaXMubGFzdFN0cmluZ1ZhbHVlID0gXCJcIjtcbiAgICB0aGlzLmxhc3RBc3NlcnRpb25Jc1F1YW50aWZpYWJsZSA9IGZhbHNlO1xuICAgIHRoaXMubnVtQ2FwdHVyaW5nUGFyZW5zID0gMDtcbiAgICB0aGlzLm1heEJhY2tSZWZlcmVuY2UgPSAwO1xuICAgIHRoaXMuZ3JvdXBOYW1lcyA9IFtdO1xuICAgIHRoaXMuYmFja1JlZmVyZW5jZU5hbWVzID0gW107XG4gIH07XG5cbiAgUmVnRXhwVmFsaWRhdGlvblN0YXRlLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uIHJlc2V0IChzdGFydCwgcGF0dGVybiwgZmxhZ3MpIHtcbiAgICB2YXIgdW5pY29kZSA9IGZsYWdzLmluZGV4T2YoXCJ1XCIpICE9PSAtMTtcbiAgICB0aGlzLnN0YXJ0ID0gc3RhcnQgfCAwO1xuICAgIHRoaXMuc291cmNlID0gcGF0dGVybiArIFwiXCI7XG4gICAgdGhpcy5mbGFncyA9IGZsYWdzO1xuICAgIHRoaXMuc3dpdGNoVSA9IHVuaWNvZGUgJiYgdGhpcy5wYXJzZXIub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2O1xuICAgIHRoaXMuc3dpdGNoTiA9IHVuaWNvZGUgJiYgdGhpcy5wYXJzZXIub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA5O1xuICB9O1xuXG4gIFJlZ0V4cFZhbGlkYXRpb25TdGF0ZS5wcm90b3R5cGUucmFpc2UgPSBmdW5jdGlvbiByYWlzZSAobWVzc2FnZSkge1xuICAgIHRoaXMucGFyc2VyLnJhaXNlUmVjb3ZlcmFibGUodGhpcy5zdGFydCwgKFwiSW52YWxpZCByZWd1bGFyIGV4cHJlc3Npb246IC9cIiArICh0aGlzLnNvdXJjZSkgKyBcIi86IFwiICsgbWVzc2FnZSkpO1xuICB9O1xuXG4gIFJlZ0V4cFZhbGlkYXRpb25TdGF0ZS5wcm90b3R5cGUuYXQgPSBmdW5jdGlvbiBhdCAoaSwgZm9yY2VVKSB7XG4gICAgICBpZiAoIGZvcmNlVSA9PT0gdm9pZCAwICkgZm9yY2VVID0gZmFsc2U7XG5cbiAgICB2YXIgcyA9IHRoaXMuc291cmNlO1xuICAgIHZhciBsID0gcy5sZW5ndGg7XG4gICAgaWYgKGkgPj0gbCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuICAgIHZhciBjID0gcy5jaGFyQ29kZUF0KGkpO1xuICAgIGlmICghKGZvcmNlVSB8fCB0aGlzLnN3aXRjaFUpIHx8IGMgPD0gMHhEN0ZGIHx8IGMgPj0gMHhFMDAwIHx8IGkgKyAxID49IGwpIHtcbiAgICAgIHJldHVybiBjXG4gICAgfVxuICAgIHZhciBuZXh0ID0gcy5jaGFyQ29kZUF0KGkgKyAxKTtcbiAgICByZXR1cm4gbmV4dCA+PSAweERDMDAgJiYgbmV4dCA8PSAweERGRkYgPyAoYyA8PCAxMCkgKyBuZXh0IC0gMHgzNUZEQzAwIDogY1xuICB9O1xuXG4gIFJlZ0V4cFZhbGlkYXRpb25TdGF0ZS5wcm90b3R5cGUubmV4dEluZGV4ID0gZnVuY3Rpb24gbmV4dEluZGV4IChpLCBmb3JjZVUpIHtcbiAgICAgIGlmICggZm9yY2VVID09PSB2b2lkIDAgKSBmb3JjZVUgPSBmYWxzZTtcblxuICAgIHZhciBzID0gdGhpcy5zb3VyY2U7XG4gICAgdmFyIGwgPSBzLmxlbmd0aDtcbiAgICBpZiAoaSA+PSBsKSB7XG4gICAgICByZXR1cm4gbFxuICAgIH1cbiAgICB2YXIgYyA9IHMuY2hhckNvZGVBdChpKSwgbmV4dDtcbiAgICBpZiAoIShmb3JjZVUgfHwgdGhpcy5zd2l0Y2hVKSB8fCBjIDw9IDB4RDdGRiB8fCBjID49IDB4RTAwMCB8fCBpICsgMSA+PSBsIHx8XG4gICAgICAgIChuZXh0ID0gcy5jaGFyQ29kZUF0KGkgKyAxKSkgPCAweERDMDAgfHwgbmV4dCA+IDB4REZGRikge1xuICAgICAgcmV0dXJuIGkgKyAxXG4gICAgfVxuICAgIHJldHVybiBpICsgMlxuICB9O1xuXG4gIFJlZ0V4cFZhbGlkYXRpb25TdGF0ZS5wcm90b3R5cGUuY3VycmVudCA9IGZ1bmN0aW9uIGN1cnJlbnQgKGZvcmNlVSkge1xuICAgICAgaWYgKCBmb3JjZVUgPT09IHZvaWQgMCApIGZvcmNlVSA9IGZhbHNlO1xuXG4gICAgcmV0dXJuIHRoaXMuYXQodGhpcy5wb3MsIGZvcmNlVSlcbiAgfTtcblxuICBSZWdFeHBWYWxpZGF0aW9uU3RhdGUucHJvdG90eXBlLmxvb2thaGVhZCA9IGZ1bmN0aW9uIGxvb2thaGVhZCAoZm9yY2VVKSB7XG4gICAgICBpZiAoIGZvcmNlVSA9PT0gdm9pZCAwICkgZm9yY2VVID0gZmFsc2U7XG5cbiAgICByZXR1cm4gdGhpcy5hdCh0aGlzLm5leHRJbmRleCh0aGlzLnBvcywgZm9yY2VVKSwgZm9yY2VVKVxuICB9O1xuXG4gIFJlZ0V4cFZhbGlkYXRpb25TdGF0ZS5wcm90b3R5cGUuYWR2YW5jZSA9IGZ1bmN0aW9uIGFkdmFuY2UgKGZvcmNlVSkge1xuICAgICAgaWYgKCBmb3JjZVUgPT09IHZvaWQgMCApIGZvcmNlVSA9IGZhbHNlO1xuXG4gICAgdGhpcy5wb3MgPSB0aGlzLm5leHRJbmRleCh0aGlzLnBvcywgZm9yY2VVKTtcbiAgfTtcblxuICBSZWdFeHBWYWxpZGF0aW9uU3RhdGUucHJvdG90eXBlLmVhdCA9IGZ1bmN0aW9uIGVhdCAoY2gsIGZvcmNlVSkge1xuICAgICAgaWYgKCBmb3JjZVUgPT09IHZvaWQgMCApIGZvcmNlVSA9IGZhbHNlO1xuXG4gICAgaWYgKHRoaXMuY3VycmVudChmb3JjZVUpID09PSBjaCkge1xuICAgICAgdGhpcy5hZHZhbmNlKGZvcmNlVSk7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcblxuICBmdW5jdGlvbiBjb2RlUG9pbnRUb1N0cmluZyhjaCkge1xuICAgIGlmIChjaCA8PSAweEZGRkYpIHsgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY2gpIH1cbiAgICBjaCAtPSAweDEwMDAwO1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKChjaCA+PiAxMCkgKyAweEQ4MDAsIChjaCAmIDB4MDNGRikgKyAweERDMDApXG4gIH1cblxuICBwcCQ4LnZhbGlkYXRlUmVnRXhwRmxhZ3MgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHZhciB2YWxpZEZsYWdzID0gc3RhdGUudmFsaWRGbGFncztcbiAgICB2YXIgZmxhZ3MgPSBzdGF0ZS5mbGFncztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmxhZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBmbGFnID0gZmxhZ3MuY2hhckF0KGkpO1xuICAgICAgaWYgKHZhbGlkRmxhZ3MuaW5kZXhPZihmbGFnKSA9PT0gLTEpIHtcbiAgICAgICAgdGhpcy5yYWlzZShzdGF0ZS5zdGFydCwgXCJJbnZhbGlkIHJlZ3VsYXIgZXhwcmVzc2lvbiBmbGFnXCIpO1xuICAgICAgfVxuICAgICAgaWYgKGZsYWdzLmluZGV4T2YoZmxhZywgaSArIDEpID4gLTEpIHtcbiAgICAgICAgdGhpcy5yYWlzZShzdGF0ZS5zdGFydCwgXCJEdXBsaWNhdGUgcmVndWxhciBleHByZXNzaW9uIGZsYWdcIik7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHBwJDgudmFsaWRhdGVSZWdFeHBQYXR0ZXJuID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB0aGlzLnJlZ2V4cF9wYXR0ZXJuKHN0YXRlKTtcblxuICAgIGlmICghc3RhdGUuc3dpdGNoTiAmJiB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOSAmJiBzdGF0ZS5ncm91cE5hbWVzLmxlbmd0aCA+IDApIHtcbiAgICAgIHN0YXRlLnN3aXRjaE4gPSB0cnVlO1xuICAgICAgdGhpcy5yZWdleHBfcGF0dGVybihzdGF0ZSk7XG4gICAgfVxuICB9O1xuXG4gIHBwJDgucmVnZXhwX3BhdHRlcm4gPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHN0YXRlLnBvcyA9IDA7XG4gICAgc3RhdGUubGFzdEludFZhbHVlID0gMDtcbiAgICBzdGF0ZS5sYXN0U3RyaW5nVmFsdWUgPSBcIlwiO1xuICAgIHN0YXRlLmxhc3RBc3NlcnRpb25Jc1F1YW50aWZpYWJsZSA9IGZhbHNlO1xuICAgIHN0YXRlLm51bUNhcHR1cmluZ1BhcmVucyA9IDA7XG4gICAgc3RhdGUubWF4QmFja1JlZmVyZW5jZSA9IDA7XG4gICAgc3RhdGUuZ3JvdXBOYW1lcy5sZW5ndGggPSAwO1xuICAgIHN0YXRlLmJhY2tSZWZlcmVuY2VOYW1lcy5sZW5ndGggPSAwO1xuXG4gICAgdGhpcy5yZWdleHBfZGlzanVuY3Rpb24oc3RhdGUpO1xuXG4gICAgaWYgKHN0YXRlLnBvcyAhPT0gc3RhdGUuc291cmNlLmxlbmd0aCkge1xuICAgICAgaWYgKHN0YXRlLmVhdCgweDI5ICkpIHtcbiAgICAgICAgc3RhdGUucmFpc2UoXCJVbm1hdGNoZWQgJyknXCIpO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXRlLmVhdCgweDVEICkgfHwgc3RhdGUuZWF0KDB4N0QgKSkge1xuICAgICAgICBzdGF0ZS5yYWlzZShcIkxvbmUgcXVhbnRpZmllciBicmFja2V0c1wiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHN0YXRlLm1heEJhY2tSZWZlcmVuY2UgPiBzdGF0ZS5udW1DYXB0dXJpbmdQYXJlbnMpIHtcbiAgICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCBlc2NhcGVcIik7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gc3RhdGUuYmFja1JlZmVyZW5jZU5hbWVzOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgdmFyIG5hbWUgPSBsaXN0W2ldO1xuXG4gICAgICBpZiAoc3RhdGUuZ3JvdXBOYW1lcy5pbmRleE9mKG5hbWUpID09PSAtMSkge1xuICAgICAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgbmFtZWQgY2FwdHVyZSByZWZlcmVuY2VkXCIpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBwcCQ4LnJlZ2V4cF9kaXNqdW5jdGlvbiA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgdGhpcy5yZWdleHBfYWx0ZXJuYXRpdmUoc3RhdGUpO1xuICAgIHdoaWxlIChzdGF0ZS5lYXQoMHg3QyApKSB7XG4gICAgICB0aGlzLnJlZ2V4cF9hbHRlcm5hdGl2ZShzdGF0ZSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucmVnZXhwX2VhdFF1YW50aWZpZXIoc3RhdGUsIHRydWUpKSB7XG4gICAgICBzdGF0ZS5yYWlzZShcIk5vdGhpbmcgdG8gcmVwZWF0XCIpO1xuICAgIH1cbiAgICBpZiAoc3RhdGUuZWF0KDB4N0IgKSkge1xuICAgICAgc3RhdGUucmFpc2UoXCJMb25lIHF1YW50aWZpZXIgYnJhY2tldHNcIik7XG4gICAgfVxuICB9O1xuXG4gIHBwJDgucmVnZXhwX2FsdGVybmF0aXZlID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB3aGlsZSAoc3RhdGUucG9zIDwgc3RhdGUuc291cmNlLmxlbmd0aCAmJiB0aGlzLnJlZ2V4cF9lYXRUZXJtKHN0YXRlKSlcbiAgICAgIHsgfVxuICB9O1xuXG4gIHBwJDgucmVnZXhwX2VhdFRlcm0gPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIGlmICh0aGlzLnJlZ2V4cF9lYXRBc3NlcnRpb24oc3RhdGUpKSB7XG4gICAgICBpZiAoc3RhdGUubGFzdEFzc2VydGlvbklzUXVhbnRpZmlhYmxlICYmIHRoaXMucmVnZXhwX2VhdFF1YW50aWZpZXIoc3RhdGUpKSB7XG4gICAgICAgIGlmIChzdGF0ZS5zd2l0Y2hVKSB7XG4gICAgICAgICAgc3RhdGUucmFpc2UoXCJJbnZhbGlkIHF1YW50aWZpZXJcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgaWYgKHN0YXRlLnN3aXRjaFUgPyB0aGlzLnJlZ2V4cF9lYXRBdG9tKHN0YXRlKSA6IHRoaXMucmVnZXhwX2VhdEV4dGVuZGVkQXRvbShzdGF0ZSkpIHtcbiAgICAgIHRoaXMucmVnZXhwX2VhdFF1YW50aWZpZXIoc3RhdGUpO1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcblxuICBwcCQ4LnJlZ2V4cF9lYXRBc3NlcnRpb24gPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHZhciBzdGFydCA9IHN0YXRlLnBvcztcbiAgICBzdGF0ZS5sYXN0QXNzZXJ0aW9uSXNRdWFudGlmaWFibGUgPSBmYWxzZTtcblxuICAgIGlmIChzdGF0ZS5lYXQoMHg1RSApIHx8IHN0YXRlLmVhdCgweDI0ICkpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgaWYgKHN0YXRlLmVhdCgweDVDICkpIHtcbiAgICAgIGlmIChzdGF0ZS5lYXQoMHg0MiApIHx8IHN0YXRlLmVhdCgweDYyICkpIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICAgIH1cblxuICAgIGlmIChzdGF0ZS5lYXQoMHgyOCApICYmIHN0YXRlLmVhdCgweDNGICkpIHtcbiAgICAgIHZhciBsb29rYmVoaW5kID0gZmFsc2U7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkpIHtcbiAgICAgICAgbG9va2JlaGluZCA9IHN0YXRlLmVhdCgweDNDICk7XG4gICAgICB9XG4gICAgICBpZiAoc3RhdGUuZWF0KDB4M0QgKSB8fCBzdGF0ZS5lYXQoMHgyMSApKSB7XG4gICAgICAgIHRoaXMucmVnZXhwX2Rpc2p1bmN0aW9uKHN0YXRlKTtcbiAgICAgICAgaWYgKCFzdGF0ZS5lYXQoMHgyOSApKSB7XG4gICAgICAgICAgc3RhdGUucmFpc2UoXCJVbnRlcm1pbmF0ZWQgZ3JvdXBcIik7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUubGFzdEFzc2VydGlvbklzUXVhbnRpZmlhYmxlID0gIWxvb2tiZWhpbmQ7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGUucG9zID0gc3RhcnQ7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG5cbiAgcHAkOC5yZWdleHBfZWF0UXVhbnRpZmllciA9IGZ1bmN0aW9uKHN0YXRlLCBub0Vycm9yKSB7XG4gICAgaWYgKCBub0Vycm9yID09PSB2b2lkIDAgKSBub0Vycm9yID0gZmFsc2U7XG5cbiAgICBpZiAodGhpcy5yZWdleHBfZWF0UXVhbnRpZmllclByZWZpeChzdGF0ZSwgbm9FcnJvcikpIHtcbiAgICAgIHN0YXRlLmVhdCgweDNGICk7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcblxuICBwcCQ4LnJlZ2V4cF9lYXRRdWFudGlmaWVyUHJlZml4ID0gZnVuY3Rpb24oc3RhdGUsIG5vRXJyb3IpIHtcbiAgICByZXR1cm4gKFxuICAgICAgc3RhdGUuZWF0KDB4MkEgKSB8fFxuICAgICAgc3RhdGUuZWF0KDB4MkIgKSB8fFxuICAgICAgc3RhdGUuZWF0KDB4M0YgKSB8fFxuICAgICAgdGhpcy5yZWdleHBfZWF0QnJhY2VkUXVhbnRpZmllcihzdGF0ZSwgbm9FcnJvcilcbiAgICApXG4gIH07XG4gIHBwJDgucmVnZXhwX2VhdEJyYWNlZFF1YW50aWZpZXIgPSBmdW5jdGlvbihzdGF0ZSwgbm9FcnJvcikge1xuICAgIHZhciBzdGFydCA9IHN0YXRlLnBvcztcbiAgICBpZiAoc3RhdGUuZWF0KDB4N0IgKSkge1xuICAgICAgdmFyIG1pbiA9IDAsIG1heCA9IC0xO1xuICAgICAgaWYgKHRoaXMucmVnZXhwX2VhdERlY2ltYWxEaWdpdHMoc3RhdGUpKSB7XG4gICAgICAgIG1pbiA9IHN0YXRlLmxhc3RJbnRWYWx1ZTtcbiAgICAgICAgaWYgKHN0YXRlLmVhdCgweDJDICkgJiYgdGhpcy5yZWdleHBfZWF0RGVjaW1hbERpZ2l0cyhzdGF0ZSkpIHtcbiAgICAgICAgICBtYXggPSBzdGF0ZS5sYXN0SW50VmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLmVhdCgweDdEICkpIHtcbiAgICAgICAgICBpZiAobWF4ICE9PSAtMSAmJiBtYXggPCBtaW4gJiYgIW5vRXJyb3IpIHtcbiAgICAgICAgICAgIHN0YXRlLnJhaXNlKFwibnVtYmVycyBvdXQgb2Ygb3JkZXIgaW4ge30gcXVhbnRpZmllclwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHN0YXRlLnN3aXRjaFUgJiYgIW5vRXJyb3IpIHtcbiAgICAgICAgc3RhdGUucmFpc2UoXCJJbmNvbXBsZXRlIHF1YW50aWZpZXJcIik7XG4gICAgICB9XG4gICAgICBzdGF0ZS5wb3MgPSBzdGFydDtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG5cbiAgcHAkOC5yZWdleHBfZWF0QXRvbSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIHRoaXMucmVnZXhwX2VhdFBhdHRlcm5DaGFyYWN0ZXJzKHN0YXRlKSB8fFxuICAgICAgc3RhdGUuZWF0KDB4MkUgKSB8fFxuICAgICAgdGhpcy5yZWdleHBfZWF0UmV2ZXJzZVNvbGlkdXNBdG9tRXNjYXBlKHN0YXRlKSB8fFxuICAgICAgdGhpcy5yZWdleHBfZWF0Q2hhcmFjdGVyQ2xhc3Moc3RhdGUpIHx8XG4gICAgICB0aGlzLnJlZ2V4cF9lYXRVbmNhcHR1cmluZ0dyb3VwKHN0YXRlKSB8fFxuICAgICAgdGhpcy5yZWdleHBfZWF0Q2FwdHVyaW5nR3JvdXAoc3RhdGUpXG4gICAgKVxuICB9O1xuICBwcCQ4LnJlZ2V4cF9lYXRSZXZlcnNlU29saWR1c0F0b21Fc2NhcGUgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHZhciBzdGFydCA9IHN0YXRlLnBvcztcbiAgICBpZiAoc3RhdGUuZWF0KDB4NUMgKSkge1xuICAgICAgaWYgKHRoaXMucmVnZXhwX2VhdEF0b21Fc2NhcGUoc3RhdGUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgICBzdGF0ZS5wb3MgPSBzdGFydDtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG4gIHBwJDgucmVnZXhwX2VhdFVuY2FwdHVyaW5nR3JvdXAgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHZhciBzdGFydCA9IHN0YXRlLnBvcztcbiAgICBpZiAoc3RhdGUuZWF0KDB4MjggKSkge1xuICAgICAgaWYgKHN0YXRlLmVhdCgweDNGICkgJiYgc3RhdGUuZWF0KDB4M0EgKSkge1xuICAgICAgICB0aGlzLnJlZ2V4cF9kaXNqdW5jdGlvbihzdGF0ZSk7XG4gICAgICAgIGlmIChzdGF0ZS5lYXQoMHgyOSApKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5yYWlzZShcIlVudGVybWluYXRlZCBncm91cFwiKTtcbiAgICAgIH1cbiAgICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcbiAgcHAkOC5yZWdleHBfZWF0Q2FwdHVyaW5nR3JvdXAgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIGlmIChzdGF0ZS5lYXQoMHgyOCApKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkpIHtcbiAgICAgICAgdGhpcy5yZWdleHBfZ3JvdXBTcGVjaWZpZXIoc3RhdGUpO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5jdXJyZW50KCkgPT09IDB4M0YgKSB7XG4gICAgICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCBncm91cFwiKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucmVnZXhwX2Rpc2p1bmN0aW9uKHN0YXRlKTtcbiAgICAgIGlmIChzdGF0ZS5lYXQoMHgyOSApKSB7XG4gICAgICAgIHN0YXRlLm51bUNhcHR1cmluZ1BhcmVucyArPSAxO1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgc3RhdGUucmFpc2UoXCJVbnRlcm1pbmF0ZWQgZ3JvdXBcIik7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuXG4gIHBwJDgucmVnZXhwX2VhdEV4dGVuZGVkQXRvbSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIHN0YXRlLmVhdCgweDJFICkgfHxcbiAgICAgIHRoaXMucmVnZXhwX2VhdFJldmVyc2VTb2xpZHVzQXRvbUVzY2FwZShzdGF0ZSkgfHxcbiAgICAgIHRoaXMucmVnZXhwX2VhdENoYXJhY3RlckNsYXNzKHN0YXRlKSB8fFxuICAgICAgdGhpcy5yZWdleHBfZWF0VW5jYXB0dXJpbmdHcm91cChzdGF0ZSkgfHxcbiAgICAgIHRoaXMucmVnZXhwX2VhdENhcHR1cmluZ0dyb3VwKHN0YXRlKSB8fFxuICAgICAgdGhpcy5yZWdleHBfZWF0SW52YWxpZEJyYWNlZFF1YW50aWZpZXIoc3RhdGUpIHx8XG4gICAgICB0aGlzLnJlZ2V4cF9lYXRFeHRlbmRlZFBhdHRlcm5DaGFyYWN0ZXIoc3RhdGUpXG4gICAgKVxuICB9O1xuXG4gIHBwJDgucmVnZXhwX2VhdEludmFsaWRCcmFjZWRRdWFudGlmaWVyID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICBpZiAodGhpcy5yZWdleHBfZWF0QnJhY2VkUXVhbnRpZmllcihzdGF0ZSwgdHJ1ZSkpIHtcbiAgICAgIHN0YXRlLnJhaXNlKFwiTm90aGluZyB0byByZXBlYXRcIik7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuXG4gIHBwJDgucmVnZXhwX2VhdFN5bnRheENoYXJhY3RlciA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgdmFyIGNoID0gc3RhdGUuY3VycmVudCgpO1xuICAgIGlmIChpc1N5bnRheENoYXJhY3RlcihjaCkpIHtcbiAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IGNoO1xuICAgICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG4gIGZ1bmN0aW9uIGlzU3ludGF4Q2hhcmFjdGVyKGNoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIGNoID09PSAweDI0ICB8fFxuICAgICAgY2ggPj0gMHgyOCAgJiYgY2ggPD0gMHgyQiAgfHxcbiAgICAgIGNoID09PSAweDJFICB8fFxuICAgICAgY2ggPT09IDB4M0YgIHx8XG4gICAgICBjaCA+PSAweDVCICAmJiBjaCA8PSAweDVFICB8fFxuICAgICAgY2ggPj0gMHg3QiAgJiYgY2ggPD0gMHg3RCBcbiAgICApXG4gIH1cblxuICBwcCQ4LnJlZ2V4cF9lYXRQYXR0ZXJuQ2hhcmFjdGVycyA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICAgIHZhciBjaCA9IDA7XG4gICAgd2hpbGUgKChjaCA9IHN0YXRlLmN1cnJlbnQoKSkgIT09IC0xICYmICFpc1N5bnRheENoYXJhY3RlcihjaCkpIHtcbiAgICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0YXRlLnBvcyAhPT0gc3RhcnRcbiAgfTtcblxuICBwcCQ4LnJlZ2V4cF9lYXRFeHRlbmRlZFBhdHRlcm5DaGFyYWN0ZXIgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHZhciBjaCA9IHN0YXRlLmN1cnJlbnQoKTtcbiAgICBpZiAoXG4gICAgICBjaCAhPT0gLTEgJiZcbiAgICAgIGNoICE9PSAweDI0ICAmJlxuICAgICAgIShjaCA+PSAweDI4ICAmJiBjaCA8PSAweDJCICkgJiZcbiAgICAgIGNoICE9PSAweDJFICAmJlxuICAgICAgY2ggIT09IDB4M0YgICYmXG4gICAgICBjaCAhPT0gMHg1QiAgJiZcbiAgICAgIGNoICE9PSAweDVFICAmJlxuICAgICAgY2ggIT09IDB4N0MgXG4gICAgKSB7XG4gICAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcblxuICBwcCQ4LnJlZ2V4cF9ncm91cFNwZWNpZmllciA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgaWYgKHN0YXRlLmVhdCgweDNGICkpIHtcbiAgICAgIGlmICh0aGlzLnJlZ2V4cF9lYXRHcm91cE5hbWUoc3RhdGUpKSB7XG4gICAgICAgIGlmIChzdGF0ZS5ncm91cE5hbWVzLmluZGV4T2Yoc3RhdGUubGFzdFN0cmluZ1ZhbHVlKSAhPT0gLTEpIHtcbiAgICAgICAgICBzdGF0ZS5yYWlzZShcIkR1cGxpY2F0ZSBjYXB0dXJlIGdyb3VwIG5hbWVcIik7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUuZ3JvdXBOYW1lcy5wdXNoKHN0YXRlLmxhc3RTdHJpbmdWYWx1ZSk7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgc3RhdGUucmFpc2UoXCJJbnZhbGlkIGdyb3VwXCIpO1xuICAgIH1cbiAgfTtcblxuICBwcCQ4LnJlZ2V4cF9lYXRHcm91cE5hbWUgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHN0YXRlLmxhc3RTdHJpbmdWYWx1ZSA9IFwiXCI7XG4gICAgaWYgKHN0YXRlLmVhdCgweDNDICkpIHtcbiAgICAgIGlmICh0aGlzLnJlZ2V4cF9lYXRSZWdFeHBJZGVudGlmaWVyTmFtZShzdGF0ZSkgJiYgc3RhdGUuZWF0KDB4M0UgKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgc3RhdGUucmFpc2UoXCJJbnZhbGlkIGNhcHR1cmUgZ3JvdXAgbmFtZVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG5cbiAgcHAkOC5yZWdleHBfZWF0UmVnRXhwSWRlbnRpZmllck5hbWUgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHN0YXRlLmxhc3RTdHJpbmdWYWx1ZSA9IFwiXCI7XG4gICAgaWYgKHRoaXMucmVnZXhwX2VhdFJlZ0V4cElkZW50aWZpZXJTdGFydChzdGF0ZSkpIHtcbiAgICAgIHN0YXRlLmxhc3RTdHJpbmdWYWx1ZSArPSBjb2RlUG9pbnRUb1N0cmluZyhzdGF0ZS5sYXN0SW50VmFsdWUpO1xuICAgICAgd2hpbGUgKHRoaXMucmVnZXhwX2VhdFJlZ0V4cElkZW50aWZpZXJQYXJ0KHN0YXRlKSkge1xuICAgICAgICBzdGF0ZS5sYXN0U3RyaW5nVmFsdWUgKz0gY29kZVBvaW50VG9TdHJpbmcoc3RhdGUubGFzdEludFZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuXG4gIHBwJDgucmVnZXhwX2VhdFJlZ0V4cElkZW50aWZpZXJTdGFydCA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICAgIHZhciBmb3JjZVUgPSB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gMTE7XG4gICAgdmFyIGNoID0gc3RhdGUuY3VycmVudChmb3JjZVUpO1xuICAgIHN0YXRlLmFkdmFuY2UoZm9yY2VVKTtcblxuICAgIGlmIChjaCA9PT0gMHg1QyAgJiYgdGhpcy5yZWdleHBfZWF0UmVnRXhwVW5pY29kZUVzY2FwZVNlcXVlbmNlKHN0YXRlLCBmb3JjZVUpKSB7XG4gICAgICBjaCA9IHN0YXRlLmxhc3RJbnRWYWx1ZTtcbiAgICB9XG4gICAgaWYgKGlzUmVnRXhwSWRlbnRpZmllclN0YXJ0KGNoKSkge1xuICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gY2g7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICAgIHJldHVybiBmYWxzZVxuICB9O1xuICBmdW5jdGlvbiBpc1JlZ0V4cElkZW50aWZpZXJTdGFydChjaCkge1xuICAgIHJldHVybiBpc0lkZW50aWZpZXJTdGFydChjaCwgdHJ1ZSkgfHwgY2ggPT09IDB4MjQgIHx8IGNoID09PSAweDVGIFxuICB9XG5cbiAgcHAkOC5yZWdleHBfZWF0UmVnRXhwSWRlbnRpZmllclBhcnQgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHZhciBzdGFydCA9IHN0YXRlLnBvcztcbiAgICB2YXIgZm9yY2VVID0gdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDExO1xuICAgIHZhciBjaCA9IHN0YXRlLmN1cnJlbnQoZm9yY2VVKTtcbiAgICBzdGF0ZS5hZHZhbmNlKGZvcmNlVSk7XG5cbiAgICBpZiAoY2ggPT09IDB4NUMgICYmIHRoaXMucmVnZXhwX2VhdFJlZ0V4cFVuaWNvZGVFc2NhcGVTZXF1ZW5jZShzdGF0ZSwgZm9yY2VVKSkge1xuICAgICAgY2ggPSBzdGF0ZS5sYXN0SW50VmFsdWU7XG4gICAgfVxuICAgIGlmIChpc1JlZ0V4cElkZW50aWZpZXJQYXJ0KGNoKSkge1xuICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gY2g7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICAgIHJldHVybiBmYWxzZVxuICB9O1xuICBmdW5jdGlvbiBpc1JlZ0V4cElkZW50aWZpZXJQYXJ0KGNoKSB7XG4gICAgcmV0dXJuIGlzSWRlbnRpZmllckNoYXIoY2gsIHRydWUpIHx8IGNoID09PSAweDI0ICB8fCBjaCA9PT0gMHg1RiAgfHwgY2ggPT09IDB4MjAwQyAgfHwgY2ggPT09IDB4MjAwRCBcbiAgfVxuXG4gIHBwJDgucmVnZXhwX2VhdEF0b21Fc2NhcGUgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIGlmIChcbiAgICAgIHRoaXMucmVnZXhwX2VhdEJhY2tSZWZlcmVuY2Uoc3RhdGUpIHx8XG4gICAgICB0aGlzLnJlZ2V4cF9lYXRDaGFyYWN0ZXJDbGFzc0VzY2FwZShzdGF0ZSkgfHxcbiAgICAgIHRoaXMucmVnZXhwX2VhdENoYXJhY3RlckVzY2FwZShzdGF0ZSkgfHxcbiAgICAgIChzdGF0ZS5zd2l0Y2hOICYmIHRoaXMucmVnZXhwX2VhdEtHcm91cE5hbWUoc3RhdGUpKVxuICAgICkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgaWYgKHN0YXRlLnN3aXRjaFUpIHtcbiAgICAgIGlmIChzdGF0ZS5jdXJyZW50KCkgPT09IDB4NjMgKSB7XG4gICAgICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCB1bmljb2RlIGVzY2FwZVwiKTtcbiAgICAgIH1cbiAgICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCBlc2NhcGVcIik7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuICBwcCQ4LnJlZ2V4cF9lYXRCYWNrUmVmZXJlbmNlID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG4gICAgaWYgKHRoaXMucmVnZXhwX2VhdERlY2ltYWxFc2NhcGUoc3RhdGUpKSB7XG4gICAgICB2YXIgbiA9IHN0YXRlLmxhc3RJbnRWYWx1ZTtcbiAgICAgIGlmIChzdGF0ZS5zd2l0Y2hVKSB7XG4gICAgICAgIGlmIChuID4gc3RhdGUubWF4QmFja1JlZmVyZW5jZSkge1xuICAgICAgICAgIHN0YXRlLm1heEJhY2tSZWZlcmVuY2UgPSBuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgICBpZiAobiA8PSBzdGF0ZS5udW1DYXB0dXJpbmdQYXJlbnMpIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcbiAgcHAkOC5yZWdleHBfZWF0S0dyb3VwTmFtZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgaWYgKHN0YXRlLmVhdCgweDZCICkpIHtcbiAgICAgIGlmICh0aGlzLnJlZ2V4cF9lYXRHcm91cE5hbWUoc3RhdGUpKSB7XG4gICAgICAgIHN0YXRlLmJhY2tSZWZlcmVuY2VOYW1lcy5wdXNoKHN0YXRlLmxhc3RTdHJpbmdWYWx1ZSk7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgbmFtZWQgcmVmZXJlbmNlXCIpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcblxuICBwcCQ4LnJlZ2V4cF9lYXRDaGFyYWN0ZXJFc2NhcGUgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHJldHVybiAoXG4gICAgICB0aGlzLnJlZ2V4cF9lYXRDb250cm9sRXNjYXBlKHN0YXRlKSB8fFxuICAgICAgdGhpcy5yZWdleHBfZWF0Q0NvbnRyb2xMZXR0ZXIoc3RhdGUpIHx8XG4gICAgICB0aGlzLnJlZ2V4cF9lYXRaZXJvKHN0YXRlKSB8fFxuICAgICAgdGhpcy5yZWdleHBfZWF0SGV4RXNjYXBlU2VxdWVuY2Uoc3RhdGUpIHx8XG4gICAgICB0aGlzLnJlZ2V4cF9lYXRSZWdFeHBVbmljb2RlRXNjYXBlU2VxdWVuY2Uoc3RhdGUsIGZhbHNlKSB8fFxuICAgICAgKCFzdGF0ZS5zd2l0Y2hVICYmIHRoaXMucmVnZXhwX2VhdExlZ2FjeU9jdGFsRXNjYXBlU2VxdWVuY2Uoc3RhdGUpKSB8fFxuICAgICAgdGhpcy5yZWdleHBfZWF0SWRlbnRpdHlFc2NhcGUoc3RhdGUpXG4gICAgKVxuICB9O1xuICBwcCQ4LnJlZ2V4cF9lYXRDQ29udHJvbExldHRlciA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICAgIGlmIChzdGF0ZS5lYXQoMHg2MyApKSB7XG4gICAgICBpZiAodGhpcy5yZWdleHBfZWF0Q29udHJvbExldHRlcihzdGF0ZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcbiAgcHAkOC5yZWdleHBfZWF0WmVybyA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgaWYgKHN0YXRlLmN1cnJlbnQoKSA9PT0gMHgzMCAgJiYgIWlzRGVjaW1hbERpZ2l0KHN0YXRlLmxvb2thaGVhZCgpKSkge1xuICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gMDtcbiAgICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuXG4gIHBwJDgucmVnZXhwX2VhdENvbnRyb2xFc2NhcGUgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHZhciBjaCA9IHN0YXRlLmN1cnJlbnQoKTtcbiAgICBpZiAoY2ggPT09IDB4NzQgKSB7XG4gICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAweDA5OyBcbiAgICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIGlmIChjaCA9PT0gMHg2RSApIHtcbiAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDB4MEE7IFxuICAgICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgaWYgKGNoID09PSAweDc2ICkge1xuICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gMHgwQjsgXG4gICAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBpZiAoY2ggPT09IDB4NjYgKSB7XG4gICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAweDBDOyBcbiAgICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIGlmIChjaCA9PT0gMHg3MiApIHtcbiAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDB4MEQ7IFxuICAgICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG5cbiAgcHAkOC5yZWdleHBfZWF0Q29udHJvbExldHRlciA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgdmFyIGNoID0gc3RhdGUuY3VycmVudCgpO1xuICAgIGlmIChpc0NvbnRyb2xMZXR0ZXIoY2gpKSB7XG4gICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSBjaCAlIDB4MjA7XG4gICAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcbiAgZnVuY3Rpb24gaXNDb250cm9sTGV0dGVyKGNoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIChjaCA+PSAweDQxICAmJiBjaCA8PSAweDVBICkgfHxcbiAgICAgIChjaCA+PSAweDYxICAmJiBjaCA8PSAweDdBIClcbiAgICApXG4gIH1cblxuICBwcCQ4LnJlZ2V4cF9lYXRSZWdFeHBVbmljb2RlRXNjYXBlU2VxdWVuY2UgPSBmdW5jdGlvbihzdGF0ZSwgZm9yY2VVKSB7XG4gICAgaWYgKCBmb3JjZVUgPT09IHZvaWQgMCApIGZvcmNlVSA9IGZhbHNlO1xuXG4gICAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICAgIHZhciBzd2l0Y2hVID0gZm9yY2VVIHx8IHN0YXRlLnN3aXRjaFU7XG5cbiAgICBpZiAoc3RhdGUuZWF0KDB4NzUgKSkge1xuICAgICAgaWYgKHRoaXMucmVnZXhwX2VhdEZpeGVkSGV4RGlnaXRzKHN0YXRlLCA0KSkge1xuICAgICAgICB2YXIgbGVhZCA9IHN0YXRlLmxhc3RJbnRWYWx1ZTtcbiAgICAgICAgaWYgKHN3aXRjaFUgJiYgbGVhZCA+PSAweEQ4MDAgJiYgbGVhZCA8PSAweERCRkYpIHtcbiAgICAgICAgICB2YXIgbGVhZFN1cnJvZ2F0ZUVuZCA9IHN0YXRlLnBvcztcbiAgICAgICAgICBpZiAoc3RhdGUuZWF0KDB4NUMgKSAmJiBzdGF0ZS5lYXQoMHg3NSApICYmIHRoaXMucmVnZXhwX2VhdEZpeGVkSGV4RGlnaXRzKHN0YXRlLCA0KSkge1xuICAgICAgICAgICAgdmFyIHRyYWlsID0gc3RhdGUubGFzdEludFZhbHVlO1xuICAgICAgICAgICAgaWYgKHRyYWlsID49IDB4REMwMCAmJiB0cmFpbCA8PSAweERGRkYpIHtcbiAgICAgICAgICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gKGxlYWQgLSAweEQ4MDApICogMHg0MDAgKyAodHJhaWwgLSAweERDMDApICsgMHgxMDAwMDtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgc3RhdGUucG9zID0gbGVhZFN1cnJvZ2F0ZUVuZDtcbiAgICAgICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSBsZWFkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgICBpZiAoXG4gICAgICAgIHN3aXRjaFUgJiZcbiAgICAgICAgc3RhdGUuZWF0KDB4N0IgKSAmJlxuICAgICAgICB0aGlzLnJlZ2V4cF9lYXRIZXhEaWdpdHMoc3RhdGUpICYmXG4gICAgICAgIHN0YXRlLmVhdCgweDdEICkgJiZcbiAgICAgICAgaXNWYWxpZFVuaWNvZGUoc3RhdGUubGFzdEludFZhbHVlKVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgICBpZiAoc3dpdGNoVSkge1xuICAgICAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgdW5pY29kZSBlc2NhcGVcIik7XG4gICAgICB9XG4gICAgICBzdGF0ZS5wb3MgPSBzdGFydDtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcbiAgZnVuY3Rpb24gaXNWYWxpZFVuaWNvZGUoY2gpIHtcbiAgICByZXR1cm4gY2ggPj0gMCAmJiBjaCA8PSAweDEwRkZGRlxuICB9XG5cbiAgcHAkOC5yZWdleHBfZWF0SWRlbnRpdHlFc2NhcGUgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIGlmIChzdGF0ZS5zd2l0Y2hVKSB7XG4gICAgICBpZiAodGhpcy5yZWdleHBfZWF0U3ludGF4Q2hhcmFjdGVyKHN0YXRlKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgaWYgKHN0YXRlLmVhdCgweDJGICkpIHtcbiAgICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gMHgyRjsgXG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICB2YXIgY2ggPSBzdGF0ZS5jdXJyZW50KCk7XG4gICAgaWYgKGNoICE9PSAweDYzICAmJiAoIXN0YXRlLnN3aXRjaE4gfHwgY2ggIT09IDB4NkIgKSkge1xuICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gY2g7XG4gICAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuXG4gIHBwJDgucmVnZXhwX2VhdERlY2ltYWxFc2NhcGUgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDA7XG4gICAgdmFyIGNoID0gc3RhdGUuY3VycmVudCgpO1xuICAgIGlmIChjaCA+PSAweDMxICAmJiBjaCA8PSAweDM5ICkge1xuICAgICAgZG8ge1xuICAgICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAxMCAqIHN0YXRlLmxhc3RJbnRWYWx1ZSArIChjaCAtIDB4MzAgKTtcbiAgICAgICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgICAgfSB3aGlsZSAoKGNoID0gc3RhdGUuY3VycmVudCgpKSA+PSAweDMwICAmJiBjaCA8PSAweDM5IClcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuXG4gIHBwJDgucmVnZXhwX2VhdENoYXJhY3RlckNsYXNzRXNjYXBlID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB2YXIgY2ggPSBzdGF0ZS5jdXJyZW50KCk7XG5cbiAgICBpZiAoaXNDaGFyYWN0ZXJDbGFzc0VzY2FwZShjaCkpIHtcbiAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IC0xO1xuICAgICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICBzdGF0ZS5zd2l0Y2hVICYmXG4gICAgICB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOSAmJlxuICAgICAgKGNoID09PSAweDUwICB8fCBjaCA9PT0gMHg3MCApXG4gICAgKSB7XG4gICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAtMTtcbiAgICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICAgIGlmIChcbiAgICAgICAgc3RhdGUuZWF0KDB4N0IgKSAmJlxuICAgICAgICB0aGlzLnJlZ2V4cF9lYXRVbmljb2RlUHJvcGVydHlWYWx1ZUV4cHJlc3Npb24oc3RhdGUpICYmXG4gICAgICAgIHN0YXRlLmVhdCgweDdEIClcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgc3RhdGUucmFpc2UoXCJJbnZhbGlkIHByb3BlcnR5IG5hbWVcIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG4gIGZ1bmN0aW9uIGlzQ2hhcmFjdGVyQ2xhc3NFc2NhcGUoY2gpIHtcbiAgICByZXR1cm4gKFxuICAgICAgY2ggPT09IDB4NjQgIHx8XG4gICAgICBjaCA9PT0gMHg0NCAgfHxcbiAgICAgIGNoID09PSAweDczICB8fFxuICAgICAgY2ggPT09IDB4NTMgIHx8XG4gICAgICBjaCA9PT0gMHg3NyAgfHxcbiAgICAgIGNoID09PSAweDU3IFxuICAgIClcbiAgfVxuXG4gIHBwJDgucmVnZXhwX2VhdFVuaWNvZGVQcm9wZXJ0eVZhbHVlRXhwcmVzc2lvbiA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuXG4gICAgaWYgKHRoaXMucmVnZXhwX2VhdFVuaWNvZGVQcm9wZXJ0eU5hbWUoc3RhdGUpICYmIHN0YXRlLmVhdCgweDNEICkpIHtcbiAgICAgIHZhciBuYW1lID0gc3RhdGUubGFzdFN0cmluZ1ZhbHVlO1xuICAgICAgaWYgKHRoaXMucmVnZXhwX2VhdFVuaWNvZGVQcm9wZXJ0eVZhbHVlKHN0YXRlKSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBzdGF0ZS5sYXN0U3RyaW5nVmFsdWU7XG4gICAgICAgIHRoaXMucmVnZXhwX3ZhbGlkYXRlVW5pY29kZVByb3BlcnR5TmFtZUFuZFZhbHVlKHN0YXRlLCBuYW1lLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuXG4gICAgaWYgKHRoaXMucmVnZXhwX2VhdExvbmVVbmljb2RlUHJvcGVydHlOYW1lT3JWYWx1ZShzdGF0ZSkpIHtcbiAgICAgIHZhciBuYW1lT3JWYWx1ZSA9IHN0YXRlLmxhc3RTdHJpbmdWYWx1ZTtcbiAgICAgIHRoaXMucmVnZXhwX3ZhbGlkYXRlVW5pY29kZVByb3BlcnR5TmFtZU9yVmFsdWUoc3RhdGUsIG5hbWVPclZhbHVlKTtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuICBwcCQ4LnJlZ2V4cF92YWxpZGF0ZVVuaWNvZGVQcm9wZXJ0eU5hbWVBbmRWYWx1ZSA9IGZ1bmN0aW9uKHN0YXRlLCBuYW1lLCB2YWx1ZSkge1xuICAgIGlmICghaGFzKHN0YXRlLnVuaWNvZGVQcm9wZXJ0aWVzLm5vbkJpbmFyeSwgbmFtZSkpXG4gICAgICB7IHN0YXRlLnJhaXNlKFwiSW52YWxpZCBwcm9wZXJ0eSBuYW1lXCIpOyB9XG4gICAgaWYgKCFzdGF0ZS51bmljb2RlUHJvcGVydGllcy5ub25CaW5hcnlbbmFtZV0udGVzdCh2YWx1ZSkpXG4gICAgICB7IHN0YXRlLnJhaXNlKFwiSW52YWxpZCBwcm9wZXJ0eSB2YWx1ZVwiKTsgfVxuICB9O1xuICBwcCQ4LnJlZ2V4cF92YWxpZGF0ZVVuaWNvZGVQcm9wZXJ0eU5hbWVPclZhbHVlID0gZnVuY3Rpb24oc3RhdGUsIG5hbWVPclZhbHVlKSB7XG4gICAgaWYgKCFzdGF0ZS51bmljb2RlUHJvcGVydGllcy5iaW5hcnkudGVzdChuYW1lT3JWYWx1ZSkpXG4gICAgICB7IHN0YXRlLnJhaXNlKFwiSW52YWxpZCBwcm9wZXJ0eSBuYW1lXCIpOyB9XG4gIH07XG5cbiAgcHAkOC5yZWdleHBfZWF0VW5pY29kZVByb3BlcnR5TmFtZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgdmFyIGNoID0gMDtcbiAgICBzdGF0ZS5sYXN0U3RyaW5nVmFsdWUgPSBcIlwiO1xuICAgIHdoaWxlIChpc1VuaWNvZGVQcm9wZXJ0eU5hbWVDaGFyYWN0ZXIoY2ggPSBzdGF0ZS5jdXJyZW50KCkpKSB7XG4gICAgICBzdGF0ZS5sYXN0U3RyaW5nVmFsdWUgKz0gY29kZVBvaW50VG9TdHJpbmcoY2gpO1xuICAgICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgIH1cbiAgICByZXR1cm4gc3RhdGUubGFzdFN0cmluZ1ZhbHVlICE9PSBcIlwiXG4gIH07XG4gIGZ1bmN0aW9uIGlzVW5pY29kZVByb3BlcnR5TmFtZUNoYXJhY3RlcihjaCkge1xuICAgIHJldHVybiBpc0NvbnRyb2xMZXR0ZXIoY2gpIHx8IGNoID09PSAweDVGIFxuICB9XG5cbiAgcHAkOC5yZWdleHBfZWF0VW5pY29kZVByb3BlcnR5VmFsdWUgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHZhciBjaCA9IDA7XG4gICAgc3RhdGUubGFzdFN0cmluZ1ZhbHVlID0gXCJcIjtcbiAgICB3aGlsZSAoaXNVbmljb2RlUHJvcGVydHlWYWx1ZUNoYXJhY3RlcihjaCA9IHN0YXRlLmN1cnJlbnQoKSkpIHtcbiAgICAgIHN0YXRlLmxhc3RTdHJpbmdWYWx1ZSArPSBjb2RlUG9pbnRUb1N0cmluZyhjaCk7XG4gICAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgfVxuICAgIHJldHVybiBzdGF0ZS5sYXN0U3RyaW5nVmFsdWUgIT09IFwiXCJcbiAgfTtcbiAgZnVuY3Rpb24gaXNVbmljb2RlUHJvcGVydHlWYWx1ZUNoYXJhY3RlcihjaCkge1xuICAgIHJldHVybiBpc1VuaWNvZGVQcm9wZXJ0eU5hbWVDaGFyYWN0ZXIoY2gpIHx8IGlzRGVjaW1hbERpZ2l0KGNoKVxuICB9XG5cbiAgcHAkOC5yZWdleHBfZWF0TG9uZVVuaWNvZGVQcm9wZXJ0eU5hbWVPclZhbHVlID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5yZWdleHBfZWF0VW5pY29kZVByb3BlcnR5VmFsdWUoc3RhdGUpXG4gIH07XG5cbiAgcHAkOC5yZWdleHBfZWF0Q2hhcmFjdGVyQ2xhc3MgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIGlmIChzdGF0ZS5lYXQoMHg1QiApKSB7XG4gICAgICBzdGF0ZS5lYXQoMHg1RSApO1xuICAgICAgdGhpcy5yZWdleHBfY2xhc3NSYW5nZXMoc3RhdGUpO1xuICAgICAgaWYgKHN0YXRlLmVhdCgweDVEICkpIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICAgIHN0YXRlLnJhaXNlKFwiVW50ZXJtaW5hdGVkIGNoYXJhY3RlciBjbGFzc1wiKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG5cbiAgcHAkOC5yZWdleHBfY2xhc3NSYW5nZXMgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHdoaWxlICh0aGlzLnJlZ2V4cF9lYXRDbGFzc0F0b20oc3RhdGUpKSB7XG4gICAgICB2YXIgbGVmdCA9IHN0YXRlLmxhc3RJbnRWYWx1ZTtcbiAgICAgIGlmIChzdGF0ZS5lYXQoMHgyRCApICYmIHRoaXMucmVnZXhwX2VhdENsYXNzQXRvbShzdGF0ZSkpIHtcbiAgICAgICAgdmFyIHJpZ2h0ID0gc3RhdGUubGFzdEludFZhbHVlO1xuICAgICAgICBpZiAoc3RhdGUuc3dpdGNoVSAmJiAobGVmdCA9PT0gLTEgfHwgcmlnaHQgPT09IC0xKSkge1xuICAgICAgICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCBjaGFyYWN0ZXIgY2xhc3NcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlZnQgIT09IC0xICYmIHJpZ2h0ICE9PSAtMSAmJiBsZWZ0ID4gcmlnaHQpIHtcbiAgICAgICAgICBzdGF0ZS5yYWlzZShcIlJhbmdlIG91dCBvZiBvcmRlciBpbiBjaGFyYWN0ZXIgY2xhc3NcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgcHAkOC5yZWdleHBfZWF0Q2xhc3NBdG9tID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG5cbiAgICBpZiAoc3RhdGUuZWF0KDB4NUMgKSkge1xuICAgICAgaWYgKHRoaXMucmVnZXhwX2VhdENsYXNzRXNjYXBlKHN0YXRlKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgaWYgKHN0YXRlLnN3aXRjaFUpIHtcbiAgICAgICAgdmFyIGNoJDEgPSBzdGF0ZS5jdXJyZW50KCk7XG4gICAgICAgIGlmIChjaCQxID09PSAweDYzICB8fCBpc09jdGFsRGlnaXQoY2gkMSkpIHtcbiAgICAgICAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgY2xhc3MgZXNjYXBlXCIpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCBlc2NhcGVcIik7XG4gICAgICB9XG4gICAgICBzdGF0ZS5wb3MgPSBzdGFydDtcbiAgICB9XG5cbiAgICB2YXIgY2ggPSBzdGF0ZS5jdXJyZW50KCk7XG4gICAgaWYgKGNoICE9PSAweDVEICkge1xuICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gY2g7XG4gICAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuXG4gIHBwJDgucmVnZXhwX2VhdENsYXNzRXNjYXBlID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG5cbiAgICBpZiAoc3RhdGUuZWF0KDB4NjIgKSkge1xuICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gMHgwODsgXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIGlmIChzdGF0ZS5zd2l0Y2hVICYmIHN0YXRlLmVhdCgweDJEICkpIHtcbiAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDB4MkQ7IFxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICBpZiAoIXN0YXRlLnN3aXRjaFUgJiYgc3RhdGUuZWF0KDB4NjMgKSkge1xuICAgICAgaWYgKHRoaXMucmVnZXhwX2VhdENsYXNzQ29udHJvbExldHRlcihzdGF0ZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICB0aGlzLnJlZ2V4cF9lYXRDaGFyYWN0ZXJDbGFzc0VzY2FwZShzdGF0ZSkgfHxcbiAgICAgIHRoaXMucmVnZXhwX2VhdENoYXJhY3RlckVzY2FwZShzdGF0ZSlcbiAgICApXG4gIH07XG5cbiAgcHAkOC5yZWdleHBfZWF0Q2xhc3NDb250cm9sTGV0dGVyID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB2YXIgY2ggPSBzdGF0ZS5jdXJyZW50KCk7XG4gICAgaWYgKGlzRGVjaW1hbERpZ2l0KGNoKSB8fCBjaCA9PT0gMHg1RiApIHtcbiAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IGNoICUgMHgyMDtcbiAgICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuXG4gIHBwJDgucmVnZXhwX2VhdEhleEVzY2FwZVNlcXVlbmNlID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG4gICAgaWYgKHN0YXRlLmVhdCgweDc4ICkpIHtcbiAgICAgIGlmICh0aGlzLnJlZ2V4cF9lYXRGaXhlZEhleERpZ2l0cyhzdGF0ZSwgMikpIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICAgIGlmIChzdGF0ZS5zd2l0Y2hVKSB7XG4gICAgICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCBlc2NhcGVcIik7XG4gICAgICB9XG4gICAgICBzdGF0ZS5wb3MgPSBzdGFydDtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG5cbiAgcHAkOC5yZWdleHBfZWF0RGVjaW1hbERpZ2l0cyA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICAgIHZhciBjaCA9IDA7XG4gICAgc3RhdGUubGFzdEludFZhbHVlID0gMDtcbiAgICB3aGlsZSAoaXNEZWNpbWFsRGlnaXQoY2ggPSBzdGF0ZS5jdXJyZW50KCkpKSB7XG4gICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAxMCAqIHN0YXRlLmxhc3RJbnRWYWx1ZSArIChjaCAtIDB4MzAgKTtcbiAgICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0YXRlLnBvcyAhPT0gc3RhcnRcbiAgfTtcbiAgZnVuY3Rpb24gaXNEZWNpbWFsRGlnaXQoY2gpIHtcbiAgICByZXR1cm4gY2ggPj0gMHgzMCAgJiYgY2ggPD0gMHgzOSBcbiAgfVxuXG4gIHBwJDgucmVnZXhwX2VhdEhleERpZ2l0cyA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICAgIHZhciBjaCA9IDA7XG4gICAgc3RhdGUubGFzdEludFZhbHVlID0gMDtcbiAgICB3aGlsZSAoaXNIZXhEaWdpdChjaCA9IHN0YXRlLmN1cnJlbnQoKSkpIHtcbiAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDE2ICogc3RhdGUubGFzdEludFZhbHVlICsgaGV4VG9JbnQoY2gpO1xuICAgICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgIH1cbiAgICByZXR1cm4gc3RhdGUucG9zICE9PSBzdGFydFxuICB9O1xuICBmdW5jdGlvbiBpc0hleERpZ2l0KGNoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIChjaCA+PSAweDMwICAmJiBjaCA8PSAweDM5ICkgfHxcbiAgICAgIChjaCA+PSAweDQxICAmJiBjaCA8PSAweDQ2ICkgfHxcbiAgICAgIChjaCA+PSAweDYxICAmJiBjaCA8PSAweDY2IClcbiAgICApXG4gIH1cbiAgZnVuY3Rpb24gaGV4VG9JbnQoY2gpIHtcbiAgICBpZiAoY2ggPj0gMHg0MSAgJiYgY2ggPD0gMHg0NiApIHtcbiAgICAgIHJldHVybiAxMCArIChjaCAtIDB4NDEgKVxuICAgIH1cbiAgICBpZiAoY2ggPj0gMHg2MSAgJiYgY2ggPD0gMHg2NiApIHtcbiAgICAgIHJldHVybiAxMCArIChjaCAtIDB4NjEgKVxuICAgIH1cbiAgICByZXR1cm4gY2ggLSAweDMwIFxuICB9XG5cbiAgcHAkOC5yZWdleHBfZWF0TGVnYWN5T2N0YWxFc2NhcGVTZXF1ZW5jZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgaWYgKHRoaXMucmVnZXhwX2VhdE9jdGFsRGlnaXQoc3RhdGUpKSB7XG4gICAgICB2YXIgbjEgPSBzdGF0ZS5sYXN0SW50VmFsdWU7XG4gICAgICBpZiAodGhpcy5yZWdleHBfZWF0T2N0YWxEaWdpdChzdGF0ZSkpIHtcbiAgICAgICAgdmFyIG4yID0gc3RhdGUubGFzdEludFZhbHVlO1xuICAgICAgICBpZiAobjEgPD0gMyAmJiB0aGlzLnJlZ2V4cF9lYXRPY3RhbERpZ2l0KHN0YXRlKSkge1xuICAgICAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IG4xICogNjQgKyBuMiAqIDggKyBzdGF0ZS5sYXN0SW50VmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gbjEgKiA4ICsgbjI7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IG4xO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG5cbiAgcHAkOC5yZWdleHBfZWF0T2N0YWxEaWdpdCA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgdmFyIGNoID0gc3RhdGUuY3VycmVudCgpO1xuICAgIGlmIChpc09jdGFsRGlnaXQoY2gpKSB7XG4gICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSBjaCAtIDB4MzA7IFxuICAgICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgc3RhdGUubGFzdEludFZhbHVlID0gMDtcbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcbiAgZnVuY3Rpb24gaXNPY3RhbERpZ2l0KGNoKSB7XG4gICAgcmV0dXJuIGNoID49IDB4MzAgICYmIGNoIDw9IDB4MzcgXG4gIH1cblxuICBwcCQ4LnJlZ2V4cF9lYXRGaXhlZEhleERpZ2l0cyA9IGZ1bmN0aW9uKHN0YXRlLCBsZW5ndGgpIHtcbiAgICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG4gICAgc3RhdGUubGFzdEludFZhbHVlID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgY2ggPSBzdGF0ZS5jdXJyZW50KCk7XG4gICAgICBpZiAoIWlzSGV4RGlnaXQoY2gpKSB7XG4gICAgICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDE2ICogc3RhdGUubGFzdEludFZhbHVlICsgaGV4VG9JbnQoY2gpO1xuICAgICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZVxuICB9O1xuXG5cbiAgdmFyIFRva2VuID0gZnVuY3Rpb24gVG9rZW4ocCkge1xuICAgIHRoaXMudHlwZSA9IHAudHlwZTtcbiAgICB0aGlzLnZhbHVlID0gcC52YWx1ZTtcbiAgICB0aGlzLnN0YXJ0ID0gcC5zdGFydDtcbiAgICB0aGlzLmVuZCA9IHAuZW5kO1xuICAgIGlmIChwLm9wdGlvbnMubG9jYXRpb25zKVxuICAgICAgeyB0aGlzLmxvYyA9IG5ldyBTb3VyY2VMb2NhdGlvbihwLCBwLnN0YXJ0TG9jLCBwLmVuZExvYyk7IH1cbiAgICBpZiAocC5vcHRpb25zLnJhbmdlcylcbiAgICAgIHsgdGhpcy5yYW5nZSA9IFtwLnN0YXJ0LCBwLmVuZF07IH1cbiAgfTtcblxuXG4gIHZhciBwcCQ5ID0gUGFyc2VyLnByb3RvdHlwZTtcblxuXG4gIHBwJDkubmV4dCA9IGZ1bmN0aW9uKGlnbm9yZUVzY2FwZVNlcXVlbmNlSW5LZXl3b3JkKSB7XG4gICAgaWYgKCFpZ25vcmVFc2NhcGVTZXF1ZW5jZUluS2V5d29yZCAmJiB0aGlzLnR5cGUua2V5d29yZCAmJiB0aGlzLmNvbnRhaW5zRXNjKVxuICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUodGhpcy5zdGFydCwgXCJFc2NhcGUgc2VxdWVuY2UgaW4ga2V5d29yZCBcIiArIHRoaXMudHlwZS5rZXl3b3JkKTsgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMub25Ub2tlbilcbiAgICAgIHsgdGhpcy5vcHRpb25zLm9uVG9rZW4obmV3IFRva2VuKHRoaXMpKTsgfVxuXG4gICAgdGhpcy5sYXN0VG9rRW5kID0gdGhpcy5lbmQ7XG4gICAgdGhpcy5sYXN0VG9rU3RhcnQgPSB0aGlzLnN0YXJ0O1xuICAgIHRoaXMubGFzdFRva0VuZExvYyA9IHRoaXMuZW5kTG9jO1xuICAgIHRoaXMubGFzdFRva1N0YXJ0TG9jID0gdGhpcy5zdGFydExvYztcbiAgICB0aGlzLm5leHRUb2tlbigpO1xuICB9O1xuXG4gIHBwJDkuZ2V0VG9rZW4gPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLm5leHQoKTtcbiAgICByZXR1cm4gbmV3IFRva2VuKHRoaXMpXG4gIH07XG5cbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIpXG4gICAgeyBwcCQ5W1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIHRva2VuID0gdGhpcyQxLmdldFRva2VuKCk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRvbmU6IHRva2VuLnR5cGUgPT09IHR5cGVzLmVvZixcbiAgICAgICAgICAgIHZhbHVlOiB0b2tlblxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07IH1cblxuXG4gIHBwJDkuY3VyQ29udGV4dCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRleHRbdGhpcy5jb250ZXh0Lmxlbmd0aCAtIDFdXG4gIH07XG5cblxuICBwcCQ5Lm5leHRUb2tlbiA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBjdXJDb250ZXh0ID0gdGhpcy5jdXJDb250ZXh0KCk7XG4gICAgaWYgKCFjdXJDb250ZXh0IHx8ICFjdXJDb250ZXh0LnByZXNlcnZlU3BhY2UpIHsgdGhpcy5za2lwU3BhY2UoKTsgfVxuXG4gICAgdGhpcy5zdGFydCA9IHRoaXMucG9zO1xuICAgIGlmICh0aGlzLm9wdGlvbnMubG9jYXRpb25zKSB7IHRoaXMuc3RhcnRMb2MgPSB0aGlzLmN1clBvc2l0aW9uKCk7IH1cbiAgICBpZiAodGhpcy5wb3MgPj0gdGhpcy5pbnB1dC5sZW5ndGgpIHsgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMuZW9mKSB9XG5cbiAgICBpZiAoY3VyQ29udGV4dC5vdmVycmlkZSkgeyByZXR1cm4gY3VyQ29udGV4dC5vdmVycmlkZSh0aGlzKSB9XG4gICAgZWxzZSB7IHRoaXMucmVhZFRva2VuKHRoaXMuZnVsbENoYXJDb2RlQXRQb3MoKSk7IH1cbiAgfTtcblxuICBwcCQ5LnJlYWRUb2tlbiA9IGZ1bmN0aW9uKGNvZGUpIHtcbiAgICBpZiAoaXNJZGVudGlmaWVyU3RhcnQoY29kZSwgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYpIHx8IGNvZGUgPT09IDkyIClcbiAgICAgIHsgcmV0dXJuIHRoaXMucmVhZFdvcmQoKSB9XG5cbiAgICByZXR1cm4gdGhpcy5nZXRUb2tlbkZyb21Db2RlKGNvZGUpXG4gIH07XG5cbiAgcHAkOS5mdWxsQ2hhckNvZGVBdFBvcyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBjb2RlID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKTtcbiAgICBpZiAoY29kZSA8PSAweGQ3ZmYgfHwgY29kZSA+PSAweGUwMDApIHsgcmV0dXJuIGNvZGUgfVxuICAgIHZhciBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMSk7XG4gICAgcmV0dXJuIChjb2RlIDw8IDEwKSArIG5leHQgLSAweDM1ZmRjMDBcbiAgfTtcblxuICBwcCQ5LnNraXBCbG9ja0NvbW1lbnQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgc3RhcnRMb2MgPSB0aGlzLm9wdGlvbnMub25Db21tZW50ICYmIHRoaXMuY3VyUG9zaXRpb24oKTtcbiAgICB2YXIgc3RhcnQgPSB0aGlzLnBvcywgZW5kID0gdGhpcy5pbnB1dC5pbmRleE9mKFwiKi9cIiwgdGhpcy5wb3MgKz0gMik7XG4gICAgaWYgKGVuZCA9PT0gLTEpIHsgdGhpcy5yYWlzZSh0aGlzLnBvcyAtIDIsIFwiVW50ZXJtaW5hdGVkIGNvbW1lbnRcIik7IH1cbiAgICB0aGlzLnBvcyA9IGVuZCArIDI7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5sb2NhdGlvbnMpIHtcbiAgICAgIGxpbmVCcmVha0cubGFzdEluZGV4ID0gc3RhcnQ7XG4gICAgICB2YXIgbWF0Y2g7XG4gICAgICB3aGlsZSAoKG1hdGNoID0gbGluZUJyZWFrRy5leGVjKHRoaXMuaW5wdXQpKSAmJiBtYXRjaC5pbmRleCA8IHRoaXMucG9zKSB7XG4gICAgICAgICsrdGhpcy5jdXJMaW5lO1xuICAgICAgICB0aGlzLmxpbmVTdGFydCA9IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLm9uQ29tbWVudClcbiAgICAgIHsgdGhpcy5vcHRpb25zLm9uQ29tbWVudCh0cnVlLCB0aGlzLmlucHV0LnNsaWNlKHN0YXJ0ICsgMiwgZW5kKSwgc3RhcnQsIHRoaXMucG9zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydExvYywgdGhpcy5jdXJQb3NpdGlvbigpKTsgfVxuICB9O1xuXG4gIHBwJDkuc2tpcExpbmVDb21tZW50ID0gZnVuY3Rpb24oc3RhcnRTa2lwKSB7XG4gICAgdmFyIHN0YXJ0ID0gdGhpcy5wb3M7XG4gICAgdmFyIHN0YXJ0TG9jID0gdGhpcy5vcHRpb25zLm9uQ29tbWVudCAmJiB0aGlzLmN1clBvc2l0aW9uKCk7XG4gICAgdmFyIGNoID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICs9IHN0YXJ0U2tpcCk7XG4gICAgd2hpbGUgKHRoaXMucG9zIDwgdGhpcy5pbnB1dC5sZW5ndGggJiYgIWlzTmV3TGluZShjaCkpIHtcbiAgICAgIGNoID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KCsrdGhpcy5wb3MpO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLm9uQ29tbWVudClcbiAgICAgIHsgdGhpcy5vcHRpb25zLm9uQ29tbWVudChmYWxzZSwgdGhpcy5pbnB1dC5zbGljZShzdGFydCArIHN0YXJ0U2tpcCwgdGhpcy5wb3MpLCBzdGFydCwgdGhpcy5wb3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0TG9jLCB0aGlzLmN1clBvc2l0aW9uKCkpOyB9XG4gIH07XG5cblxuICBwcCQ5LnNraXBTcGFjZSA9IGZ1bmN0aW9uKCkge1xuICAgIGxvb3A6IHdoaWxlICh0aGlzLnBvcyA8IHRoaXMuaW5wdXQubGVuZ3RoKSB7XG4gICAgICB2YXIgY2ggPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MpO1xuICAgICAgc3dpdGNoIChjaCkge1xuICAgICAgY2FzZSAzMjogY2FzZSAxNjA6IFxuICAgICAgICArK3RoaXMucG9zO1xuICAgICAgICBicmVha1xuICAgICAgY2FzZSAxMzpcbiAgICAgICAgaWYgKHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDEpID09PSAxMCkge1xuICAgICAgICAgICsrdGhpcy5wb3M7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgMTA6IGNhc2UgODIzMjogY2FzZSA4MjMzOlxuICAgICAgICArK3RoaXMucG9zO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmxvY2F0aW9ucykge1xuICAgICAgICAgICsrdGhpcy5jdXJMaW5lO1xuICAgICAgICAgIHRoaXMubGluZVN0YXJ0ID0gdGhpcy5wb3M7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgNDc6IFxuICAgICAgICBzd2l0Y2ggKHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDEpKSB7XG4gICAgICAgIGNhc2UgNDI6IFxuICAgICAgICAgIHRoaXMuc2tpcEJsb2NrQ29tbWVudCgpO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgNDc6XG4gICAgICAgICAgdGhpcy5za2lwTGluZUNvbW1lbnQoMik7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBicmVhayBsb29wXG4gICAgICAgIH1cbiAgICAgICAgYnJlYWtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChjaCA+IDggJiYgY2ggPCAxNCB8fCBjaCA+PSA1NzYwICYmIG5vbkFTQ0lJd2hpdGVzcGFjZS50ZXN0KFN0cmluZy5mcm9tQ2hhckNvZGUoY2gpKSkge1xuICAgICAgICAgICsrdGhpcy5wb3M7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnJlYWsgbG9vcFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG5cbiAgcHAkOS5maW5pc2hUb2tlbiA9IGZ1bmN0aW9uKHR5cGUsIHZhbCkge1xuICAgIHRoaXMuZW5kID0gdGhpcy5wb3M7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5sb2NhdGlvbnMpIHsgdGhpcy5lbmRMb2MgPSB0aGlzLmN1clBvc2l0aW9uKCk7IH1cbiAgICB2YXIgcHJldlR5cGUgPSB0aGlzLnR5cGU7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLnZhbHVlID0gdmFsO1xuXG4gICAgdGhpcy51cGRhdGVDb250ZXh0KHByZXZUeXBlKTtcbiAgfTtcblxuXG4gIHBwJDkucmVhZFRva2VuX2RvdCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMSk7XG4gICAgaWYgKG5leHQgPj0gNDggJiYgbmV4dCA8PSA1NykgeyByZXR1cm4gdGhpcy5yZWFkTnVtYmVyKHRydWUpIH1cbiAgICB2YXIgbmV4dDIgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAyKTtcbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYgJiYgbmV4dCA9PT0gNDYgJiYgbmV4dDIgPT09IDQ2KSB7IFxuICAgICAgdGhpcy5wb3MgKz0gMztcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLmVsbGlwc2lzKVxuICAgIH0gZWxzZSB7XG4gICAgICArK3RoaXMucG9zO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMuZG90KVxuICAgIH1cbiAgfTtcblxuICBwcCQ5LnJlYWRUb2tlbl9zbGFzaCA9IGZ1bmN0aW9uKCkgeyBcbiAgICB2YXIgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDEpO1xuICAgIGlmICh0aGlzLmV4cHJBbGxvd2VkKSB7ICsrdGhpcy5wb3M7IHJldHVybiB0aGlzLnJlYWRSZWdleHAoKSB9XG4gICAgaWYgKG5leHQgPT09IDYxKSB7IHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzLmFzc2lnbiwgMikgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzLnNsYXNoLCAxKVxuICB9O1xuXG4gIHBwJDkucmVhZFRva2VuX211bHRfbW9kdWxvX2V4cCA9IGZ1bmN0aW9uKGNvZGUpIHsgXG4gICAgdmFyIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAxKTtcbiAgICB2YXIgc2l6ZSA9IDE7XG4gICAgdmFyIHRva2VudHlwZSA9IGNvZGUgPT09IDQyID8gdHlwZXMuc3RhciA6IHR5cGVzLm1vZHVsbztcblxuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNyAmJiBjb2RlID09PSA0MiAmJiBuZXh0ID09PSA0Mikge1xuICAgICAgKytzaXplO1xuICAgICAgdG9rZW50eXBlID0gdHlwZXMuc3RhcnN0YXI7XG4gICAgICBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMik7XG4gICAgfVxuXG4gICAgaWYgKG5leHQgPT09IDYxKSB7IHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzLmFzc2lnbiwgc2l6ZSArIDEpIH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hPcCh0b2tlbnR5cGUsIHNpemUpXG4gIH07XG5cbiAgcHAkOS5yZWFkVG9rZW5fcGlwZV9hbXAgPSBmdW5jdGlvbihjb2RlKSB7IFxuICAgIHZhciBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMSk7XG4gICAgaWYgKG5leHQgPT09IGNvZGUpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gMTIpIHtcbiAgICAgICAgdmFyIG5leHQyID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMik7XG4gICAgICAgIGlmIChuZXh0MiA9PT0gNjEpIHsgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMuYXNzaWduLCAzKSB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hPcChjb2RlID09PSAxMjQgPyB0eXBlcy5sb2dpY2FsT1IgOiB0eXBlcy5sb2dpY2FsQU5ELCAyKVxuICAgIH1cbiAgICBpZiAobmV4dCA9PT0gNjEpIHsgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMuYXNzaWduLCAyKSB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoT3AoY29kZSA9PT0gMTI0ID8gdHlwZXMuYml0d2lzZU9SIDogdHlwZXMuYml0d2lzZUFORCwgMSlcbiAgfTtcblxuICBwcCQ5LnJlYWRUb2tlbl9jYXJldCA9IGZ1bmN0aW9uKCkgeyBcbiAgICB2YXIgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDEpO1xuICAgIGlmIChuZXh0ID09PSA2MSkgeyByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcy5hc3NpZ24sIDIpIH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcy5iaXR3aXNlWE9SLCAxKVxuICB9O1xuXG4gIHBwJDkucmVhZFRva2VuX3BsdXNfbWluID0gZnVuY3Rpb24oY29kZSkgeyBcbiAgICB2YXIgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDEpO1xuICAgIGlmIChuZXh0ID09PSBjb2RlKSB7XG4gICAgICBpZiAobmV4dCA9PT0gNDUgJiYgIXRoaXMuaW5Nb2R1bGUgJiYgdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMikgPT09IDYyICYmXG4gICAgICAgICAgKHRoaXMubGFzdFRva0VuZCA9PT0gMCB8fCBsaW5lQnJlYWsudGVzdCh0aGlzLmlucHV0LnNsaWNlKHRoaXMubGFzdFRva0VuZCwgdGhpcy5wb3MpKSkpIHtcbiAgICAgICAgdGhpcy5za2lwTGluZUNvbW1lbnQoMyk7XG4gICAgICAgIHRoaXMuc2tpcFNwYWNlKCk7XG4gICAgICAgIHJldHVybiB0aGlzLm5leHRUb2tlbigpXG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcy5pbmNEZWMsIDIpXG4gICAgfVxuICAgIGlmIChuZXh0ID09PSA2MSkgeyByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcy5hc3NpZ24sIDIpIH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcy5wbHVzTWluLCAxKVxuICB9O1xuXG4gIHBwJDkucmVhZFRva2VuX2x0X2d0ID0gZnVuY3Rpb24oY29kZSkgeyBcbiAgICB2YXIgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDEpO1xuICAgIHZhciBzaXplID0gMTtcbiAgICBpZiAobmV4dCA9PT0gY29kZSkge1xuICAgICAgc2l6ZSA9IGNvZGUgPT09IDYyICYmIHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDIpID09PSA2MiA/IDMgOiAyO1xuICAgICAgaWYgKHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIHNpemUpID09PSA2MSkgeyByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcy5hc3NpZ24sIHNpemUgKyAxKSB9XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcy5iaXRTaGlmdCwgc2l6ZSlcbiAgICB9XG4gICAgaWYgKG5leHQgPT09IDMzICYmIGNvZGUgPT09IDYwICYmICF0aGlzLmluTW9kdWxlICYmIHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDIpID09PSA0NSAmJlxuICAgICAgICB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAzKSA9PT0gNDUpIHtcbiAgICAgIHRoaXMuc2tpcExpbmVDb21tZW50KDQpO1xuICAgICAgdGhpcy5za2lwU3BhY2UoKTtcbiAgICAgIHJldHVybiB0aGlzLm5leHRUb2tlbigpXG4gICAgfVxuICAgIGlmIChuZXh0ID09PSA2MSkgeyBzaXplID0gMjsgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzLnJlbGF0aW9uYWwsIHNpemUpXG4gIH07XG5cbiAgcHAkOS5yZWFkVG9rZW5fZXFfZXhjbCA9IGZ1bmN0aW9uKGNvZGUpIHsgXG4gICAgdmFyIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAxKTtcbiAgICBpZiAobmV4dCA9PT0gNjEpIHsgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMuZXF1YWxpdHksIHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDIpID09PSA2MSA/IDMgOiAyKSB9XG4gICAgaWYgKGNvZGUgPT09IDYxICYmIG5leHQgPT09IDYyICYmIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KSB7IFxuICAgICAgdGhpcy5wb3MgKz0gMjtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLmFycm93KVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hPcChjb2RlID09PSA2MSA/IHR5cGVzLmVxIDogdHlwZXMucHJlZml4LCAxKVxuICB9O1xuXG4gIHBwJDkucmVhZFRva2VuX3F1ZXN0aW9uID0gZnVuY3Rpb24oKSB7IFxuICAgIHZhciBlY21hVmVyc2lvbiA9IHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbjtcbiAgICBpZiAoZWNtYVZlcnNpb24gPj0gMTEpIHtcbiAgICAgIHZhciBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMSk7XG4gICAgICBpZiAobmV4dCA9PT0gNDYpIHtcbiAgICAgICAgdmFyIG5leHQyID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMik7XG4gICAgICAgIGlmIChuZXh0MiA8IDQ4IHx8IG5leHQyID4gNTcpIHsgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMucXVlc3Rpb25Eb3QsIDIpIH1cbiAgICAgIH1cbiAgICAgIGlmIChuZXh0ID09PSA2Mykge1xuICAgICAgICBpZiAoZWNtYVZlcnNpb24gPj0gMTIpIHtcbiAgICAgICAgICB2YXIgbmV4dDIkMSA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDIpO1xuICAgICAgICAgIGlmIChuZXh0MiQxID09PSA2MSkgeyByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcy5hc3NpZ24sIDMpIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcy5jb2FsZXNjZSwgMilcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMucXVlc3Rpb24sIDEpXG4gIH07XG5cbiAgcHAkOS5nZXRUb2tlbkZyb21Db2RlID0gZnVuY3Rpb24oY29kZSkge1xuICAgIHN3aXRjaCAoY29kZSkge1xuICAgIGNhc2UgNDY6IFxuICAgICAgcmV0dXJuIHRoaXMucmVhZFRva2VuX2RvdCgpXG5cbiAgICBjYXNlIDQwOiArK3RoaXMucG9zOyByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5wYXJlbkwpXG4gICAgY2FzZSA0MTogKyt0aGlzLnBvczsgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMucGFyZW5SKVxuICAgIGNhc2UgNTk6ICsrdGhpcy5wb3M7IHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLnNlbWkpXG4gICAgY2FzZSA0NDogKyt0aGlzLnBvczsgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMuY29tbWEpXG4gICAgY2FzZSA5MTogKyt0aGlzLnBvczsgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMuYnJhY2tldEwpXG4gICAgY2FzZSA5MzogKyt0aGlzLnBvczsgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMuYnJhY2tldFIpXG4gICAgY2FzZSAxMjM6ICsrdGhpcy5wb3M7IHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLmJyYWNlTClcbiAgICBjYXNlIDEyNTogKyt0aGlzLnBvczsgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMuYnJhY2VSKVxuICAgIGNhc2UgNTg6ICsrdGhpcy5wb3M7IHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLmNvbG9uKVxuXG4gICAgY2FzZSA5NjogXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uIDwgNikgeyBicmVhayB9XG4gICAgICArK3RoaXMucG9zO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMuYmFja1F1b3RlKVxuXG4gICAgY2FzZSA0ODogXG4gICAgICB2YXIgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDEpO1xuICAgICAgaWYgKG5leHQgPT09IDEyMCB8fCBuZXh0ID09PSA4OCkgeyByZXR1cm4gdGhpcy5yZWFkUmFkaXhOdW1iZXIoMTYpIH0gXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYpIHtcbiAgICAgICAgaWYgKG5leHQgPT09IDExMSB8fCBuZXh0ID09PSA3OSkgeyByZXR1cm4gdGhpcy5yZWFkUmFkaXhOdW1iZXIoOCkgfSBcbiAgICAgICAgaWYgKG5leHQgPT09IDk4IHx8IG5leHQgPT09IDY2KSB7IHJldHVybiB0aGlzLnJlYWRSYWRpeE51bWJlcigyKSB9IFxuICAgICAgfVxuXG4gICAgY2FzZSA0OTogY2FzZSA1MDogY2FzZSA1MTogY2FzZSA1MjogY2FzZSA1MzogY2FzZSA1NDogY2FzZSA1NTogY2FzZSA1NjogY2FzZSA1NzogXG4gICAgICByZXR1cm4gdGhpcy5yZWFkTnVtYmVyKGZhbHNlKVxuXG4gICAgY2FzZSAzNDogY2FzZSAzOTogXG4gICAgICByZXR1cm4gdGhpcy5yZWFkU3RyaW5nKGNvZGUpXG5cblxuICAgIGNhc2UgNDc6IFxuICAgICAgcmV0dXJuIHRoaXMucmVhZFRva2VuX3NsYXNoKClcblxuICAgIGNhc2UgMzc6IGNhc2UgNDI6IFxuICAgICAgcmV0dXJuIHRoaXMucmVhZFRva2VuX211bHRfbW9kdWxvX2V4cChjb2RlKVxuXG4gICAgY2FzZSAxMjQ6IGNhc2UgMzg6IFxuICAgICAgcmV0dXJuIHRoaXMucmVhZFRva2VuX3BpcGVfYW1wKGNvZGUpXG5cbiAgICBjYXNlIDk0OiBcbiAgICAgIHJldHVybiB0aGlzLnJlYWRUb2tlbl9jYXJldCgpXG5cbiAgICBjYXNlIDQzOiBjYXNlIDQ1OiBcbiAgICAgIHJldHVybiB0aGlzLnJlYWRUb2tlbl9wbHVzX21pbihjb2RlKVxuXG4gICAgY2FzZSA2MDogY2FzZSA2MjogXG4gICAgICByZXR1cm4gdGhpcy5yZWFkVG9rZW5fbHRfZ3QoY29kZSlcblxuICAgIGNhc2UgNjE6IGNhc2UgMzM6IFxuICAgICAgcmV0dXJuIHRoaXMucmVhZFRva2VuX2VxX2V4Y2woY29kZSlcblxuICAgIGNhc2UgNjM6IFxuICAgICAgcmV0dXJuIHRoaXMucmVhZFRva2VuX3F1ZXN0aW9uKClcblxuICAgIGNhc2UgMTI2OiBcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzLnByZWZpeCwgMSlcbiAgICB9XG5cbiAgICB0aGlzLnJhaXNlKHRoaXMucG9zLCBcIlVuZXhwZWN0ZWQgY2hhcmFjdGVyICdcIiArIGNvZGVQb2ludFRvU3RyaW5nJDEoY29kZSkgKyBcIidcIik7XG4gIH07XG5cbiAgcHAkOS5maW5pc2hPcCA9IGZ1bmN0aW9uKHR5cGUsIHNpemUpIHtcbiAgICB2YXIgc3RyID0gdGhpcy5pbnB1dC5zbGljZSh0aGlzLnBvcywgdGhpcy5wb3MgKyBzaXplKTtcbiAgICB0aGlzLnBvcyArPSBzaXplO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGUsIHN0cilcbiAgfTtcblxuICBwcCQ5LnJlYWRSZWdleHAgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZXNjYXBlZCwgaW5DbGFzcywgc3RhcnQgPSB0aGlzLnBvcztcbiAgICBmb3IgKDs7KSB7XG4gICAgICBpZiAodGhpcy5wb3MgPj0gdGhpcy5pbnB1dC5sZW5ndGgpIHsgdGhpcy5yYWlzZShzdGFydCwgXCJVbnRlcm1pbmF0ZWQgcmVndWxhciBleHByZXNzaW9uXCIpOyB9XG4gICAgICB2YXIgY2ggPSB0aGlzLmlucHV0LmNoYXJBdCh0aGlzLnBvcyk7XG4gICAgICBpZiAobGluZUJyZWFrLnRlc3QoY2gpKSB7IHRoaXMucmFpc2Uoc3RhcnQsIFwiVW50ZXJtaW5hdGVkIHJlZ3VsYXIgZXhwcmVzc2lvblwiKTsgfVxuICAgICAgaWYgKCFlc2NhcGVkKSB7XG4gICAgICAgIGlmIChjaCA9PT0gXCJbXCIpIHsgaW5DbGFzcyA9IHRydWU7IH1cbiAgICAgICAgZWxzZSBpZiAoY2ggPT09IFwiXVwiICYmIGluQ2xhc3MpIHsgaW5DbGFzcyA9IGZhbHNlOyB9XG4gICAgICAgIGVsc2UgaWYgKGNoID09PSBcIi9cIiAmJiAhaW5DbGFzcykgeyBicmVhayB9XG4gICAgICAgIGVzY2FwZWQgPSBjaCA9PT0gXCJcXFxcXCI7XG4gICAgICB9IGVsc2UgeyBlc2NhcGVkID0gZmFsc2U7IH1cbiAgICAgICsrdGhpcy5wb3M7XG4gICAgfVxuICAgIHZhciBwYXR0ZXJuID0gdGhpcy5pbnB1dC5zbGljZShzdGFydCwgdGhpcy5wb3MpO1xuICAgICsrdGhpcy5wb3M7XG4gICAgdmFyIGZsYWdzU3RhcnQgPSB0aGlzLnBvcztcbiAgICB2YXIgZmxhZ3MgPSB0aGlzLnJlYWRXb3JkMSgpO1xuICAgIGlmICh0aGlzLmNvbnRhaW5zRXNjKSB7IHRoaXMudW5leHBlY3RlZChmbGFnc1N0YXJ0KTsgfVxuXG4gICAgdmFyIHN0YXRlID0gdGhpcy5yZWdleHBTdGF0ZSB8fCAodGhpcy5yZWdleHBTdGF0ZSA9IG5ldyBSZWdFeHBWYWxpZGF0aW9uU3RhdGUodGhpcykpO1xuICAgIHN0YXRlLnJlc2V0KHN0YXJ0LCBwYXR0ZXJuLCBmbGFncyk7XG4gICAgdGhpcy52YWxpZGF0ZVJlZ0V4cEZsYWdzKHN0YXRlKTtcbiAgICB0aGlzLnZhbGlkYXRlUmVnRXhwUGF0dGVybihzdGF0ZSk7XG5cbiAgICB2YXIgdmFsdWUgPSBudWxsO1xuICAgIHRyeSB7XG4gICAgICB2YWx1ZSA9IG5ldyBSZWdFeHAocGF0dGVybiwgZmxhZ3MpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5yZWdleHAsIHtwYXR0ZXJuOiBwYXR0ZXJuLCBmbGFnczogZmxhZ3MsIHZhbHVlOiB2YWx1ZX0pXG4gIH07XG5cblxuICBwcCQ5LnJlYWRJbnQgPSBmdW5jdGlvbihyYWRpeCwgbGVuLCBtYXliZUxlZ2FjeU9jdGFsTnVtZXJpY0xpdGVyYWwpIHtcbiAgICB2YXIgYWxsb3dTZXBhcmF0b3JzID0gdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDEyICYmIGxlbiA9PT0gdW5kZWZpbmVkO1xuXG4gICAgdmFyIGlzTGVnYWN5T2N0YWxOdW1lcmljTGl0ZXJhbCA9IG1heWJlTGVnYWN5T2N0YWxOdW1lcmljTGl0ZXJhbCAmJiB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MpID09PSA0ODtcblxuICAgIHZhciBzdGFydCA9IHRoaXMucG9zLCB0b3RhbCA9IDAsIGxhc3RDb2RlID0gMDtcbiAgICBmb3IgKHZhciBpID0gMCwgZSA9IGxlbiA9PSBudWxsID8gSW5maW5pdHkgOiBsZW47IGkgPCBlOyArK2ksICsrdGhpcy5wb3MpIHtcbiAgICAgIHZhciBjb2RlID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKSwgdmFsID0gKHZvaWQgMCk7XG5cbiAgICAgIGlmIChhbGxvd1NlcGFyYXRvcnMgJiYgY29kZSA9PT0gOTUpIHtcbiAgICAgICAgaWYgKGlzTGVnYWN5T2N0YWxOdW1lcmljTGl0ZXJhbCkgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUodGhpcy5wb3MsIFwiTnVtZXJpYyBzZXBhcmF0b3IgaXMgbm90IGFsbG93ZWQgaW4gbGVnYWN5IG9jdGFsIG51bWVyaWMgbGl0ZXJhbHNcIik7IH1cbiAgICAgICAgaWYgKGxhc3RDb2RlID09PSA5NSkgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUodGhpcy5wb3MsIFwiTnVtZXJpYyBzZXBhcmF0b3IgbXVzdCBiZSBleGFjdGx5IG9uZSB1bmRlcnNjb3JlXCIpOyB9XG4gICAgICAgIGlmIChpID09PSAwKSB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZSh0aGlzLnBvcywgXCJOdW1lcmljIHNlcGFyYXRvciBpcyBub3QgYWxsb3dlZCBhdCB0aGUgZmlyc3Qgb2YgZGlnaXRzXCIpOyB9XG4gICAgICAgIGxhc3RDb2RlID0gY29kZTtcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgaWYgKGNvZGUgPj0gOTcpIHsgdmFsID0gY29kZSAtIDk3ICsgMTA7IH0gXG4gICAgICBlbHNlIGlmIChjb2RlID49IDY1KSB7IHZhbCA9IGNvZGUgLSA2NSArIDEwOyB9IFxuICAgICAgZWxzZSBpZiAoY29kZSA+PSA0OCAmJiBjb2RlIDw9IDU3KSB7IHZhbCA9IGNvZGUgLSA0ODsgfSBcbiAgICAgIGVsc2UgeyB2YWwgPSBJbmZpbml0eTsgfVxuICAgICAgaWYgKHZhbCA+PSByYWRpeCkgeyBicmVhayB9XG4gICAgICBsYXN0Q29kZSA9IGNvZGU7XG4gICAgICB0b3RhbCA9IHRvdGFsICogcmFkaXggKyB2YWw7XG4gICAgfVxuXG4gICAgaWYgKGFsbG93U2VwYXJhdG9ycyAmJiBsYXN0Q29kZSA9PT0gOTUpIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHRoaXMucG9zIC0gMSwgXCJOdW1lcmljIHNlcGFyYXRvciBpcyBub3QgYWxsb3dlZCBhdCB0aGUgbGFzdCBvZiBkaWdpdHNcIik7IH1cbiAgICBpZiAodGhpcy5wb3MgPT09IHN0YXJ0IHx8IGxlbiAhPSBudWxsICYmIHRoaXMucG9zIC0gc3RhcnQgIT09IGxlbikgeyByZXR1cm4gbnVsbCB9XG5cbiAgICByZXR1cm4gdG90YWxcbiAgfTtcblxuICBmdW5jdGlvbiBzdHJpbmdUb051bWJlcihzdHIsIGlzTGVnYWN5T2N0YWxOdW1lcmljTGl0ZXJhbCkge1xuICAgIGlmIChpc0xlZ2FjeU9jdGFsTnVtZXJpY0xpdGVyYWwpIHtcbiAgICAgIHJldHVybiBwYXJzZUludChzdHIsIDgpXG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcnNlRmxvYXQoc3RyLnJlcGxhY2UoL18vZywgXCJcIikpXG4gIH1cblxuICBmdW5jdGlvbiBzdHJpbmdUb0JpZ0ludChzdHIpIHtcbiAgICBpZiAodHlwZW9mIEJpZ0ludCAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIHJldHVybiBCaWdJbnQoc3RyLnJlcGxhY2UoL18vZywgXCJcIikpXG4gIH1cblxuICBwcCQ5LnJlYWRSYWRpeE51bWJlciA9IGZ1bmN0aW9uKHJhZGl4KSB7XG4gICAgdmFyIHN0YXJ0ID0gdGhpcy5wb3M7XG4gICAgdGhpcy5wb3MgKz0gMjsgXG4gICAgdmFyIHZhbCA9IHRoaXMucmVhZEludChyYWRpeCk7XG4gICAgaWYgKHZhbCA9PSBudWxsKSB7IHRoaXMucmFpc2UodGhpcy5zdGFydCArIDIsIFwiRXhwZWN0ZWQgbnVtYmVyIGluIHJhZGl4IFwiICsgcmFkaXgpOyB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSAxMSAmJiB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MpID09PSAxMTApIHtcbiAgICAgIHZhbCA9IHN0cmluZ1RvQmlnSW50KHRoaXMuaW5wdXQuc2xpY2Uoc3RhcnQsIHRoaXMucG9zKSk7XG4gICAgICArK3RoaXMucG9zO1xuICAgIH0gZWxzZSBpZiAoaXNJZGVudGlmaWVyU3RhcnQodGhpcy5mdWxsQ2hhckNvZGVBdFBvcygpKSkgeyB0aGlzLnJhaXNlKHRoaXMucG9zLCBcIklkZW50aWZpZXIgZGlyZWN0bHkgYWZ0ZXIgbnVtYmVyXCIpOyB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMubnVtLCB2YWwpXG4gIH07XG5cblxuICBwcCQ5LnJlYWROdW1iZXIgPSBmdW5jdGlvbihzdGFydHNXaXRoRG90KSB7XG4gICAgdmFyIHN0YXJ0ID0gdGhpcy5wb3M7XG4gICAgaWYgKCFzdGFydHNXaXRoRG90ICYmIHRoaXMucmVhZEludCgxMCwgdW5kZWZpbmVkLCB0cnVlKSA9PT0gbnVsbCkgeyB0aGlzLnJhaXNlKHN0YXJ0LCBcIkludmFsaWQgbnVtYmVyXCIpOyB9XG4gICAgdmFyIG9jdGFsID0gdGhpcy5wb3MgLSBzdGFydCA+PSAyICYmIHRoaXMuaW5wdXQuY2hhckNvZGVBdChzdGFydCkgPT09IDQ4O1xuICAgIGlmIChvY3RhbCAmJiB0aGlzLnN0cmljdCkgeyB0aGlzLnJhaXNlKHN0YXJ0LCBcIkludmFsaWQgbnVtYmVyXCIpOyB9XG4gICAgdmFyIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MpO1xuICAgIGlmICghb2N0YWwgJiYgIXN0YXJ0c1dpdGhEb3QgJiYgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDExICYmIG5leHQgPT09IDExMCkge1xuICAgICAgdmFyIHZhbCQxID0gc3RyaW5nVG9CaWdJbnQodGhpcy5pbnB1dC5zbGljZShzdGFydCwgdGhpcy5wb3MpKTtcbiAgICAgICsrdGhpcy5wb3M7XG4gICAgICBpZiAoaXNJZGVudGlmaWVyU3RhcnQodGhpcy5mdWxsQ2hhckNvZGVBdFBvcygpKSkgeyB0aGlzLnJhaXNlKHRoaXMucG9zLCBcIklkZW50aWZpZXIgZGlyZWN0bHkgYWZ0ZXIgbnVtYmVyXCIpOyB9XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5udW0sIHZhbCQxKVxuICAgIH1cbiAgICBpZiAob2N0YWwgJiYgL1s4OV0vLnRlc3QodGhpcy5pbnB1dC5zbGljZShzdGFydCwgdGhpcy5wb3MpKSkgeyBvY3RhbCA9IGZhbHNlOyB9XG4gICAgaWYgKG5leHQgPT09IDQ2ICYmICFvY3RhbCkgeyBcbiAgICAgICsrdGhpcy5wb3M7XG4gICAgICB0aGlzLnJlYWRJbnQoMTApO1xuICAgICAgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyk7XG4gICAgfVxuICAgIGlmICgobmV4dCA9PT0gNjkgfHwgbmV4dCA9PT0gMTAxKSAmJiAhb2N0YWwpIHsgXG4gICAgICBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KCsrdGhpcy5wb3MpO1xuICAgICAgaWYgKG5leHQgPT09IDQzIHx8IG5leHQgPT09IDQ1KSB7ICsrdGhpcy5wb3M7IH0gXG4gICAgICBpZiAodGhpcy5yZWFkSW50KDEwKSA9PT0gbnVsbCkgeyB0aGlzLnJhaXNlKHN0YXJ0LCBcIkludmFsaWQgbnVtYmVyXCIpOyB9XG4gICAgfVxuICAgIGlmIChpc0lkZW50aWZpZXJTdGFydCh0aGlzLmZ1bGxDaGFyQ29kZUF0UG9zKCkpKSB7IHRoaXMucmFpc2UodGhpcy5wb3MsIFwiSWRlbnRpZmllciBkaXJlY3RseSBhZnRlciBudW1iZXJcIik7IH1cblxuICAgIHZhciB2YWwgPSBzdHJpbmdUb051bWJlcih0aGlzLmlucHV0LnNsaWNlKHN0YXJ0LCB0aGlzLnBvcyksIG9jdGFsKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5udW0sIHZhbClcbiAgfTtcblxuXG4gIHBwJDkucmVhZENvZGVQb2ludCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBjaCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyksIGNvZGU7XG5cbiAgICBpZiAoY2ggPT09IDEyMykgeyBcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPCA2KSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgICB2YXIgY29kZVBvcyA9ICsrdGhpcy5wb3M7XG4gICAgICBjb2RlID0gdGhpcy5yZWFkSGV4Q2hhcih0aGlzLmlucHV0LmluZGV4T2YoXCJ9XCIsIHRoaXMucG9zKSAtIHRoaXMucG9zKTtcbiAgICAgICsrdGhpcy5wb3M7XG4gICAgICBpZiAoY29kZSA+IDB4MTBGRkZGKSB7IHRoaXMuaW52YWxpZFN0cmluZ1Rva2VuKGNvZGVQb3MsIFwiQ29kZSBwb2ludCBvdXQgb2YgYm91bmRzXCIpOyB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvZGUgPSB0aGlzLnJlYWRIZXhDaGFyKDQpO1xuICAgIH1cbiAgICByZXR1cm4gY29kZVxuICB9O1xuXG4gIGZ1bmN0aW9uIGNvZGVQb2ludFRvU3RyaW5nJDEoY29kZSkge1xuICAgIGlmIChjb2RlIDw9IDB4RkZGRikgeyByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKSB9XG4gICAgY29kZSAtPSAweDEwMDAwO1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKChjb2RlID4+IDEwKSArIDB4RDgwMCwgKGNvZGUgJiAxMDIzKSArIDB4REMwMClcbiAgfVxuXG4gIHBwJDkucmVhZFN0cmluZyA9IGZ1bmN0aW9uKHF1b3RlKSB7XG4gICAgdmFyIG91dCA9IFwiXCIsIGNodW5rU3RhcnQgPSArK3RoaXMucG9zO1xuICAgIGZvciAoOzspIHtcbiAgICAgIGlmICh0aGlzLnBvcyA+PSB0aGlzLmlucHV0Lmxlbmd0aCkgeyB0aGlzLnJhaXNlKHRoaXMuc3RhcnQsIFwiVW50ZXJtaW5hdGVkIHN0cmluZyBjb25zdGFudFwiKTsgfVxuICAgICAgdmFyIGNoID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKTtcbiAgICAgIGlmIChjaCA9PT0gcXVvdGUpIHsgYnJlYWsgfVxuICAgICAgaWYgKGNoID09PSA5MikgeyBcbiAgICAgICAgb3V0ICs9IHRoaXMuaW5wdXQuc2xpY2UoY2h1bmtTdGFydCwgdGhpcy5wb3MpO1xuICAgICAgICBvdXQgKz0gdGhpcy5yZWFkRXNjYXBlZENoYXIoZmFsc2UpO1xuICAgICAgICBjaHVua1N0YXJ0ID0gdGhpcy5wb3M7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaXNOZXdMaW5lKGNoLCB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gMTApKSB7IHRoaXMucmFpc2UodGhpcy5zdGFydCwgXCJVbnRlcm1pbmF0ZWQgc3RyaW5nIGNvbnN0YW50XCIpOyB9XG4gICAgICAgICsrdGhpcy5wb3M7XG4gICAgICB9XG4gICAgfVxuICAgIG91dCArPSB0aGlzLmlucHV0LnNsaWNlKGNodW5rU3RhcnQsIHRoaXMucG9zKyspO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLnN0cmluZywgb3V0KVxuICB9O1xuXG5cbiAgdmFyIElOVkFMSURfVEVNUExBVEVfRVNDQVBFX0VSUk9SID0ge307XG5cbiAgcHAkOS50cnlSZWFkVGVtcGxhdGVUb2tlbiA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuaW5UZW1wbGF0ZUVsZW1lbnQgPSB0cnVlO1xuICAgIHRyeSB7XG4gICAgICB0aGlzLnJlYWRUbXBsVG9rZW4oKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmIChlcnIgPT09IElOVkFMSURfVEVNUExBVEVfRVNDQVBFX0VSUk9SKSB7XG4gICAgICAgIHRoaXMucmVhZEludmFsaWRUZW1wbGF0ZVRva2VuKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBlcnJcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmluVGVtcGxhdGVFbGVtZW50ID0gZmFsc2U7XG4gIH07XG5cbiAgcHAkOS5pbnZhbGlkU3RyaW5nVG9rZW4gPSBmdW5jdGlvbihwb3NpdGlvbiwgbWVzc2FnZSkge1xuICAgIGlmICh0aGlzLmluVGVtcGxhdGVFbGVtZW50ICYmIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA5KSB7XG4gICAgICB0aHJvdyBJTlZBTElEX1RFTVBMQVRFX0VTQ0FQRV9FUlJPUlxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJhaXNlKHBvc2l0aW9uLCBtZXNzYWdlKTtcbiAgICB9XG4gIH07XG5cbiAgcHAkOS5yZWFkVG1wbFRva2VuID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG91dCA9IFwiXCIsIGNodW5rU3RhcnQgPSB0aGlzLnBvcztcbiAgICBmb3IgKDs7KSB7XG4gICAgICBpZiAodGhpcy5wb3MgPj0gdGhpcy5pbnB1dC5sZW5ndGgpIHsgdGhpcy5yYWlzZSh0aGlzLnN0YXJ0LCBcIlVudGVybWluYXRlZCB0ZW1wbGF0ZVwiKTsgfVxuICAgICAgdmFyIGNoID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKTtcbiAgICAgIGlmIChjaCA9PT0gOTYgfHwgY2ggPT09IDM2ICYmIHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDEpID09PSAxMjMpIHsgXG4gICAgICAgIGlmICh0aGlzLnBvcyA9PT0gdGhpcy5zdGFydCAmJiAodGhpcy50eXBlID09PSB0eXBlcy50ZW1wbGF0ZSB8fCB0aGlzLnR5cGUgPT09IHR5cGVzLmludmFsaWRUZW1wbGF0ZSkpIHtcbiAgICAgICAgICBpZiAoY2ggPT09IDM2KSB7XG4gICAgICAgICAgICB0aGlzLnBvcyArPSAyO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMuZG9sbGFyQnJhY2VMKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICArK3RoaXMucG9zO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMuYmFja1F1b3RlKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBvdXQgKz0gdGhpcy5pbnB1dC5zbGljZShjaHVua1N0YXJ0LCB0aGlzLnBvcyk7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLnRlbXBsYXRlLCBvdXQpXG4gICAgICB9XG4gICAgICBpZiAoY2ggPT09IDkyKSB7IFxuICAgICAgICBvdXQgKz0gdGhpcy5pbnB1dC5zbGljZShjaHVua1N0YXJ0LCB0aGlzLnBvcyk7XG4gICAgICAgIG91dCArPSB0aGlzLnJlYWRFc2NhcGVkQ2hhcih0cnVlKTtcbiAgICAgICAgY2h1bmtTdGFydCA9IHRoaXMucG9zO1xuICAgICAgfSBlbHNlIGlmIChpc05ld0xpbmUoY2gpKSB7XG4gICAgICAgIG91dCArPSB0aGlzLmlucHV0LnNsaWNlKGNodW5rU3RhcnQsIHRoaXMucG9zKTtcbiAgICAgICAgKyt0aGlzLnBvcztcbiAgICAgICAgc3dpdGNoIChjaCkge1xuICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgIGlmICh0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MpID09PSAxMCkgeyArK3RoaXMucG9zOyB9XG4gICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgb3V0ICs9IFwiXFxuXCI7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBvdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjaCk7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmxvY2F0aW9ucykge1xuICAgICAgICAgICsrdGhpcy5jdXJMaW5lO1xuICAgICAgICAgIHRoaXMubGluZVN0YXJ0ID0gdGhpcy5wb3M7XG4gICAgICAgIH1cbiAgICAgICAgY2h1bmtTdGFydCA9IHRoaXMucG9zO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgKyt0aGlzLnBvcztcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgcHAkOS5yZWFkSW52YWxpZFRlbXBsYXRlVG9rZW4gPSBmdW5jdGlvbigpIHtcbiAgICBmb3IgKDsgdGhpcy5wb3MgPCB0aGlzLmlucHV0Lmxlbmd0aDsgdGhpcy5wb3MrKykge1xuICAgICAgc3dpdGNoICh0aGlzLmlucHV0W3RoaXMucG9zXSkge1xuICAgICAgY2FzZSBcIlxcXFxcIjpcbiAgICAgICAgKyt0aGlzLnBvcztcbiAgICAgICAgYnJlYWtcblxuICAgICAgY2FzZSBcIiRcIjpcbiAgICAgICAgaWYgKHRoaXMuaW5wdXRbdGhpcy5wb3MgKyAxXSAhPT0gXCJ7XCIpIHtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJgXCI6XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLmludmFsaWRUZW1wbGF0ZSwgdGhpcy5pbnB1dC5zbGljZSh0aGlzLnN0YXJ0LCB0aGlzLnBvcykpXG5cbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5yYWlzZSh0aGlzLnN0YXJ0LCBcIlVudGVybWluYXRlZCB0ZW1wbGF0ZVwiKTtcbiAgfTtcblxuXG4gIHBwJDkucmVhZEVzY2FwZWRDaGFyID0gZnVuY3Rpb24oaW5UZW1wbGF0ZSkge1xuICAgIHZhciBjaCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCgrK3RoaXMucG9zKTtcbiAgICArK3RoaXMucG9zO1xuICAgIHN3aXRjaCAoY2gpIHtcbiAgICBjYXNlIDExMDogcmV0dXJuIFwiXFxuXCIgXG4gICAgY2FzZSAxMTQ6IHJldHVybiBcIlxcclwiIFxuICAgIGNhc2UgMTIwOiByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSh0aGlzLnJlYWRIZXhDaGFyKDIpKSBcbiAgICBjYXNlIDExNzogcmV0dXJuIGNvZGVQb2ludFRvU3RyaW5nJDEodGhpcy5yZWFkQ29kZVBvaW50KCkpIFxuICAgIGNhc2UgMTE2OiByZXR1cm4gXCJcXHRcIiBcbiAgICBjYXNlIDk4OiByZXR1cm4gXCJcXGJcIiBcbiAgICBjYXNlIDExODogcmV0dXJuIFwiXFx1MDAwYlwiIFxuICAgIGNhc2UgMTAyOiByZXR1cm4gXCJcXGZcIiBcbiAgICBjYXNlIDEzOiBpZiAodGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKSA9PT0gMTApIHsgKyt0aGlzLnBvczsgfSBcbiAgICBjYXNlIDEwOiBcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMubG9jYXRpb25zKSB7IHRoaXMubGluZVN0YXJ0ID0gdGhpcy5wb3M7ICsrdGhpcy5jdXJMaW5lOyB9XG4gICAgICByZXR1cm4gXCJcIlxuICAgIGNhc2UgNTY6XG4gICAgY2FzZSA1NzpcbiAgICAgIGlmIChpblRlbXBsYXRlKSB7XG4gICAgICAgIHZhciBjb2RlUG9zID0gdGhpcy5wb3MgLSAxO1xuXG4gICAgICAgIHRoaXMuaW52YWxpZFN0cmluZ1Rva2VuKFxuICAgICAgICAgIGNvZGVQb3MsXG4gICAgICAgICAgXCJJbnZhbGlkIGVzY2FwZSBzZXF1ZW5jZSBpbiB0ZW1wbGF0ZSBzdHJpbmdcIlxuICAgICAgICApO1xuXG4gICAgICAgIHJldHVybiBudWxsXG4gICAgICB9XG4gICAgZGVmYXVsdDpcbiAgICAgIGlmIChjaCA+PSA0OCAmJiBjaCA8PSA1NSkge1xuICAgICAgICB2YXIgb2N0YWxTdHIgPSB0aGlzLmlucHV0LnN1YnN0cih0aGlzLnBvcyAtIDEsIDMpLm1hdGNoKC9eWzAtN10rLylbMF07XG4gICAgICAgIHZhciBvY3RhbCA9IHBhcnNlSW50KG9jdGFsU3RyLCA4KTtcbiAgICAgICAgaWYgKG9jdGFsID4gMjU1KSB7XG4gICAgICAgICAgb2N0YWxTdHIgPSBvY3RhbFN0ci5zbGljZSgwLCAtMSk7XG4gICAgICAgICAgb2N0YWwgPSBwYXJzZUludChvY3RhbFN0ciwgOCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wb3MgKz0gb2N0YWxTdHIubGVuZ3RoIC0gMTtcbiAgICAgICAgY2ggPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MpO1xuICAgICAgICBpZiAoKG9jdGFsU3RyICE9PSBcIjBcIiB8fCBjaCA9PT0gNTYgfHwgY2ggPT09IDU3KSAmJiAodGhpcy5zdHJpY3QgfHwgaW5UZW1wbGF0ZSkpIHtcbiAgICAgICAgICB0aGlzLmludmFsaWRTdHJpbmdUb2tlbihcbiAgICAgICAgICAgIHRoaXMucG9zIC0gMSAtIG9jdGFsU3RyLmxlbmd0aCxcbiAgICAgICAgICAgIGluVGVtcGxhdGVcbiAgICAgICAgICAgICAgPyBcIk9jdGFsIGxpdGVyYWwgaW4gdGVtcGxhdGUgc3RyaW5nXCJcbiAgICAgICAgICAgICAgOiBcIk9jdGFsIGxpdGVyYWwgaW4gc3RyaWN0IG1vZGVcIlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUob2N0YWwpXG4gICAgICB9XG4gICAgICBpZiAoaXNOZXdMaW5lKGNoKSkge1xuICAgICAgICByZXR1cm4gXCJcIlxuICAgICAgfVxuICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY2gpXG4gICAgfVxuICB9O1xuXG5cbiAgcHAkOS5yZWFkSGV4Q2hhciA9IGZ1bmN0aW9uKGxlbikge1xuICAgIHZhciBjb2RlUG9zID0gdGhpcy5wb3M7XG4gICAgdmFyIG4gPSB0aGlzLnJlYWRJbnQoMTYsIGxlbik7XG4gICAgaWYgKG4gPT09IG51bGwpIHsgdGhpcy5pbnZhbGlkU3RyaW5nVG9rZW4oY29kZVBvcywgXCJCYWQgY2hhcmFjdGVyIGVzY2FwZSBzZXF1ZW5jZVwiKTsgfVxuICAgIHJldHVybiBuXG4gIH07XG5cblxuICBwcCQ5LnJlYWRXb3JkMSA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuY29udGFpbnNFc2MgPSBmYWxzZTtcbiAgICB2YXIgd29yZCA9IFwiXCIsIGZpcnN0ID0gdHJ1ZSwgY2h1bmtTdGFydCA9IHRoaXMucG9zO1xuICAgIHZhciBhc3RyYWwgPSB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNjtcbiAgICB3aGlsZSAodGhpcy5wb3MgPCB0aGlzLmlucHV0Lmxlbmd0aCkge1xuICAgICAgdmFyIGNoID0gdGhpcy5mdWxsQ2hhckNvZGVBdFBvcygpO1xuICAgICAgaWYgKGlzSWRlbnRpZmllckNoYXIoY2gsIGFzdHJhbCkpIHtcbiAgICAgICAgdGhpcy5wb3MgKz0gY2ggPD0gMHhmZmZmID8gMSA6IDI7XG4gICAgICB9IGVsc2UgaWYgKGNoID09PSA5MikgeyBcbiAgICAgICAgdGhpcy5jb250YWluc0VzYyA9IHRydWU7XG4gICAgICAgIHdvcmQgKz0gdGhpcy5pbnB1dC5zbGljZShjaHVua1N0YXJ0LCB0aGlzLnBvcyk7XG4gICAgICAgIHZhciBlc2NTdGFydCA9IHRoaXMucG9zO1xuICAgICAgICBpZiAodGhpcy5pbnB1dC5jaGFyQ29kZUF0KCsrdGhpcy5wb3MpICE9PSAxMTcpIFxuICAgICAgICAgIHsgdGhpcy5pbnZhbGlkU3RyaW5nVG9rZW4odGhpcy5wb3MsIFwiRXhwZWN0aW5nIFVuaWNvZGUgZXNjYXBlIHNlcXVlbmNlIFxcXFx1WFhYWFwiKTsgfVxuICAgICAgICArK3RoaXMucG9zO1xuICAgICAgICB2YXIgZXNjID0gdGhpcy5yZWFkQ29kZVBvaW50KCk7XG4gICAgICAgIGlmICghKGZpcnN0ID8gaXNJZGVudGlmaWVyU3RhcnQgOiBpc0lkZW50aWZpZXJDaGFyKShlc2MsIGFzdHJhbCkpXG4gICAgICAgICAgeyB0aGlzLmludmFsaWRTdHJpbmdUb2tlbihlc2NTdGFydCwgXCJJbnZhbGlkIFVuaWNvZGUgZXNjYXBlXCIpOyB9XG4gICAgICAgIHdvcmQgKz0gY29kZVBvaW50VG9TdHJpbmckMShlc2MpO1xuICAgICAgICBjaHVua1N0YXJ0ID0gdGhpcy5wb3M7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgZmlyc3QgPSBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHdvcmQgKyB0aGlzLmlucHV0LnNsaWNlKGNodW5rU3RhcnQsIHRoaXMucG9zKVxuICB9O1xuXG5cbiAgcHAkOS5yZWFkV29yZCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB3b3JkID0gdGhpcy5yZWFkV29yZDEoKTtcbiAgICB2YXIgdHlwZSA9IHR5cGVzLm5hbWU7XG4gICAgaWYgKHRoaXMua2V5d29yZHMudGVzdCh3b3JkKSkge1xuICAgICAgdHlwZSA9IGtleXdvcmRzJDFbd29yZF07XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGUsIHdvcmQpXG4gIH07XG5cblxuICB2YXIgdmVyc2lvbiA9IFwiNy40LjBcIjtcblxuICBQYXJzZXIuYWNvcm4gPSB7XG4gICAgUGFyc2VyOiBQYXJzZXIsXG4gICAgdmVyc2lvbjogdmVyc2lvbixcbiAgICBkZWZhdWx0T3B0aW9uczogZGVmYXVsdE9wdGlvbnMsXG4gICAgUG9zaXRpb246IFBvc2l0aW9uLFxuICAgIFNvdXJjZUxvY2F0aW9uOiBTb3VyY2VMb2NhdGlvbixcbiAgICBnZXRMaW5lSW5mbzogZ2V0TGluZUluZm8sXG4gICAgTm9kZTogTm9kZSxcbiAgICBUb2tlblR5cGU6IFRva2VuVHlwZSxcbiAgICB0b2tUeXBlczogdHlwZXMsXG4gICAga2V5d29yZFR5cGVzOiBrZXl3b3JkcyQxLFxuICAgIFRva0NvbnRleHQ6IFRva0NvbnRleHQsXG4gICAgdG9rQ29udGV4dHM6IHR5cGVzJDEsXG4gICAgaXNJZGVudGlmaWVyQ2hhcjogaXNJZGVudGlmaWVyQ2hhcixcbiAgICBpc0lkZW50aWZpZXJTdGFydDogaXNJZGVudGlmaWVyU3RhcnQsXG4gICAgVG9rZW46IFRva2VuLFxuICAgIGlzTmV3TGluZTogaXNOZXdMaW5lLFxuICAgIGxpbmVCcmVhazogbGluZUJyZWFrLFxuICAgIGxpbmVCcmVha0c6IGxpbmVCcmVha0csXG4gICAgbm9uQVNDSUl3aGl0ZXNwYWNlOiBub25BU0NJSXdoaXRlc3BhY2VcbiAgfTtcblxuXG4gIGZ1bmN0aW9uIHBhcnNlKGlucHV0LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIFBhcnNlci5wYXJzZShpbnB1dCwgb3B0aW9ucylcbiAgfVxuXG5cbiAgZnVuY3Rpb24gcGFyc2VFeHByZXNzaW9uQXQoaW5wdXQsIHBvcywgb3B0aW9ucykge1xuICAgIHJldHVybiBQYXJzZXIucGFyc2VFeHByZXNzaW9uQXQoaW5wdXQsIHBvcywgb3B0aW9ucylcbiAgfVxuXG5cbiAgZnVuY3Rpb24gdG9rZW5pemVyKGlucHV0LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIFBhcnNlci50b2tlbml6ZXIoaW5wdXQsIG9wdGlvbnMpXG4gIH1cblxuICBleHBvcnRzLk5vZGUgPSBOb2RlO1xuICBleHBvcnRzLlBhcnNlciA9IFBhcnNlcjtcbiAgZXhwb3J0cy5Qb3NpdGlvbiA9IFBvc2l0aW9uO1xuICBleHBvcnRzLlNvdXJjZUxvY2F0aW9uID0gU291cmNlTG9jYXRpb247XG4gIGV4cG9ydHMuVG9rQ29udGV4dCA9IFRva0NvbnRleHQ7XG4gIGV4cG9ydHMuVG9rZW4gPSBUb2tlbjtcbiAgZXhwb3J0cy5Ub2tlblR5cGUgPSBUb2tlblR5cGU7XG4gIGV4cG9ydHMuZGVmYXVsdE9wdGlvbnMgPSBkZWZhdWx0T3B0aW9ucztcbiAgZXhwb3J0cy5nZXRMaW5lSW5mbyA9IGdldExpbmVJbmZvO1xuICBleHBvcnRzLmlzSWRlbnRpZmllckNoYXIgPSBpc0lkZW50aWZpZXJDaGFyO1xuICBleHBvcnRzLmlzSWRlbnRpZmllclN0YXJ0ID0gaXNJZGVudGlmaWVyU3RhcnQ7XG4gIGV4cG9ydHMuaXNOZXdMaW5lID0gaXNOZXdMaW5lO1xuICBleHBvcnRzLmtleXdvcmRUeXBlcyA9IGtleXdvcmRzJDE7XG4gIGV4cG9ydHMubGluZUJyZWFrID0gbGluZUJyZWFrO1xuICBleHBvcnRzLmxpbmVCcmVha0cgPSBsaW5lQnJlYWtHO1xuICBleHBvcnRzLm5vbkFTQ0lJd2hpdGVzcGFjZSA9IG5vbkFTQ0lJd2hpdGVzcGFjZTtcbiAgZXhwb3J0cy5wYXJzZSA9IHBhcnNlO1xuICBleHBvcnRzLnBhcnNlRXhwcmVzc2lvbkF0ID0gcGFyc2VFeHByZXNzaW9uQXQ7XG4gIGV4cG9ydHMudG9rQ29udGV4dHMgPSB0eXBlcyQxO1xuICBleHBvcnRzLnRva1R5cGVzID0gdHlwZXM7XG4gIGV4cG9ydHMudG9rZW5pemVyID0gdG9rZW5pemVyO1xuICBleHBvcnRzLnZlcnNpb24gPSB2ZXJzaW9uO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbn0pKSk7XG5cbn0se31dLDI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuXG59LHt9XSwzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmZ1bmN0aW9uIGdsV2lyZXRhcChnbCwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHtcbiAgICBjb250ZXh0TmFtZSA9ICdnbCcsXG4gICAgdGhyb3dHZXRFcnJvcixcbiAgICB1c2VUcmFja2FibGVQcmltaXRpdmVzLFxuICAgIHJlYWRQaXhlbHNGaWxlLFxuICAgIHJlY29yZGluZyA9IFtdLFxuICAgIHZhcmlhYmxlcyA9IHt9LFxuICAgIG9uUmVhZFBpeGVscyxcbiAgICBvblVucmVjb2duaXplZEFyZ3VtZW50TG9va3VwLFxuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgcHJveHkgPSBuZXcgUHJveHkoZ2wsIHsgZ2V0OiBsaXN0ZW4gfSk7XG4gIGNvbnN0IGNvbnRleHRWYXJpYWJsZXMgPSBbXTtcbiAgY29uc3QgZW50aXR5TmFtZXMgPSB7fTtcbiAgbGV0IGltYWdlQ291bnQgPSAwO1xuICBsZXQgaW5kZW50ID0gJyc7XG4gIGxldCByZWFkUGl4ZWxzVmFyaWFibGVOYW1lO1xuICByZXR1cm4gcHJveHk7XG4gIGZ1bmN0aW9uIGxpc3RlbihvYmosIHByb3BlcnR5KSB7XG4gICAgc3dpdGNoIChwcm9wZXJ0eSkge1xuICAgICAgY2FzZSAnYWRkQ29tbWVudCc6IHJldHVybiBhZGRDb21tZW50O1xuICAgICAgY2FzZSAnY2hlY2tUaHJvd0Vycm9yJzogcmV0dXJuIGNoZWNrVGhyb3dFcnJvcjtcbiAgICAgIGNhc2UgJ2dldFJlYWRQaXhlbHNWYXJpYWJsZU5hbWUnOiByZXR1cm4gcmVhZFBpeGVsc1ZhcmlhYmxlTmFtZTtcbiAgICAgIGNhc2UgJ2luc2VydFZhcmlhYmxlJzogcmV0dXJuIGluc2VydFZhcmlhYmxlO1xuICAgICAgY2FzZSAncmVzZXQnOiByZXR1cm4gcmVzZXQ7XG4gICAgICBjYXNlICdzZXRJbmRlbnQnOiByZXR1cm4gc2V0SW5kZW50O1xuICAgICAgY2FzZSAndG9TdHJpbmcnOiByZXR1cm4gdG9TdHJpbmc7XG4gICAgICBjYXNlICdnZXRDb250ZXh0VmFyaWFibGVOYW1lJzogcmV0dXJuIGdldENvbnRleHRWYXJpYWJsZU5hbWU7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZ2xbcHJvcGVydHldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7IFxuICAgICAgICBzd2l0Y2ggKHByb3BlcnR5KSB7XG4gICAgICAgICAgY2FzZSAnZ2V0RXJyb3InOlxuICAgICAgICAgICAgaWYgKHRocm93R2V0RXJyb3IpIHtcbiAgICAgICAgICAgICAgcmVjb3JkaW5nLnB1c2goYCR7aW5kZW50fWlmICgke2NvbnRleHROYW1lfS5nZXRFcnJvcigpICE9PSAke2NvbnRleHROYW1lfS5OT05FKSB0aHJvdyBuZXcgRXJyb3IoJ2Vycm9yJyk7YCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZWNvcmRpbmcucHVzaChgJHtpbmRlbnR9JHtjb250ZXh0TmFtZX0uZ2V0RXJyb3IoKTtgKTsgXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZ2wuZ2V0RXJyb3IoKTtcbiAgICAgICAgICBjYXNlICdnZXRFeHRlbnNpb24nOiB7XG4gICAgICAgICAgICBjb25zdCB2YXJpYWJsZU5hbWUgPSBgJHtjb250ZXh0TmFtZX1WYXJpYWJsZXMke2NvbnRleHRWYXJpYWJsZXMubGVuZ3RofWA7XG4gICAgICAgICAgICByZWNvcmRpbmcucHVzaChgJHtpbmRlbnR9Y29uc3QgJHt2YXJpYWJsZU5hbWV9ID0gJHtjb250ZXh0TmFtZX0uZ2V0RXh0ZW5zaW9uKCcke2FyZ3VtZW50c1swXX0nKTtgKTtcbiAgICAgICAgICAgIGNvbnN0IGV4dGVuc2lvbiA9IGdsLmdldEV4dGVuc2lvbihhcmd1bWVudHNbMF0pO1xuICAgICAgICAgICAgaWYgKGV4dGVuc2lvbiAmJiB0eXBlb2YgZXh0ZW5zaW9uID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICBjb25zdCB0YXBwZWRFeHRlbnNpb24gPSBnbEV4dGVuc2lvbldpcmV0YXAoZXh0ZW5zaW9uLCB7XG4gICAgICAgICAgICAgICAgZ2V0RW50aXR5LFxuICAgICAgICAgICAgICAgIHVzZVRyYWNrYWJsZVByaW1pdGl2ZXMsXG4gICAgICAgICAgICAgICAgcmVjb3JkaW5nLFxuICAgICAgICAgICAgICAgIGNvbnRleHROYW1lOiB2YXJpYWJsZU5hbWUsXG4gICAgICAgICAgICAgICAgY29udGV4dFZhcmlhYmxlcyxcbiAgICAgICAgICAgICAgICB2YXJpYWJsZXMsXG4gICAgICAgICAgICAgICAgaW5kZW50LFxuICAgICAgICAgICAgICAgIG9uVW5yZWNvZ25pemVkQXJndW1lbnRMb29rdXAsXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBjb250ZXh0VmFyaWFibGVzLnB1c2godGFwcGVkRXh0ZW5zaW9uKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRhcHBlZEV4dGVuc2lvbjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNvbnRleHRWYXJpYWJsZXMucHVzaChudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBleHRlbnNpb247XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgJ3JlYWRQaXhlbHMnOlxuICAgICAgICAgICAgY29uc3QgaSA9IGNvbnRleHRWYXJpYWJsZXMuaW5kZXhPZihhcmd1bWVudHNbNl0pO1xuICAgICAgICAgICAgbGV0IHRhcmdldFZhcmlhYmxlTmFtZTtcbiAgICAgICAgICAgIGlmIChpID09PSAtMSkge1xuICAgICAgICAgICAgICBjb25zdCB2YXJpYWJsZU5hbWUgPSBnZXRWYXJpYWJsZU5hbWUoYXJndW1lbnRzWzZdKTtcbiAgICAgICAgICAgICAgaWYgKHZhcmlhYmxlTmFtZSkge1xuICAgICAgICAgICAgICAgIHRhcmdldFZhcmlhYmxlTmFtZSA9IHZhcmlhYmxlTmFtZTtcbiAgICAgICAgICAgICAgICByZWNvcmRpbmcucHVzaChgJHtpbmRlbnR9JHt2YXJpYWJsZU5hbWV9YCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0VmFyaWFibGVOYW1lID0gYCR7Y29udGV4dE5hbWV9VmFyaWFibGUke2NvbnRleHRWYXJpYWJsZXMubGVuZ3RofWA7XG4gICAgICAgICAgICAgICAgY29udGV4dFZhcmlhYmxlcy5wdXNoKGFyZ3VtZW50c1s2XSk7XG4gICAgICAgICAgICAgICAgcmVjb3JkaW5nLnB1c2goYCR7aW5kZW50fWNvbnN0ICR7dGFyZ2V0VmFyaWFibGVOYW1lfSA9IG5ldyAke2FyZ3VtZW50c1s2XS5jb25zdHJ1Y3Rvci5uYW1lfSgke2FyZ3VtZW50c1s2XS5sZW5ndGh9KTtgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGFyZ2V0VmFyaWFibGVOYW1lID0gYCR7Y29udGV4dE5hbWV9VmFyaWFibGUke2l9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlYWRQaXhlbHNWYXJpYWJsZU5hbWUgPSB0YXJnZXRWYXJpYWJsZU5hbWU7XG4gICAgICAgICAgICBjb25zdCBhcmd1bWVudEFzU3RyaW5ncyA9IFtcbiAgICAgICAgICAgICAgYXJndW1lbnRzWzBdLFxuICAgICAgICAgICAgICBhcmd1bWVudHNbMV0sXG4gICAgICAgICAgICAgIGFyZ3VtZW50c1syXSxcbiAgICAgICAgICAgICAgYXJndW1lbnRzWzNdLFxuICAgICAgICAgICAgICBnZXRFbnRpdHkoYXJndW1lbnRzWzRdKSxcbiAgICAgICAgICAgICAgZ2V0RW50aXR5KGFyZ3VtZW50c1s1XSksXG4gICAgICAgICAgICAgIHRhcmdldFZhcmlhYmxlTmFtZVxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIHJlY29yZGluZy5wdXNoKGAke2luZGVudH0ke2NvbnRleHROYW1lfS5yZWFkUGl4ZWxzKCR7YXJndW1lbnRBc1N0cmluZ3Muam9pbignLCAnKX0pO2ApO1xuICAgICAgICAgICAgaWYgKHJlYWRQaXhlbHNGaWxlKSB7XG4gICAgICAgICAgICAgIHdyaXRlUFBNKGFyZ3VtZW50c1syXSwgYXJndW1lbnRzWzNdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvblJlYWRQaXhlbHMpIHtcbiAgICAgICAgICAgICAgb25SZWFkUGl4ZWxzKHRhcmdldFZhcmlhYmxlTmFtZSwgYXJndW1lbnRBc1N0cmluZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGdsLnJlYWRQaXhlbHMuYXBwbHkoZ2wsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgY2FzZSAnZHJhd0J1ZmZlcnMnOlxuICAgICAgICAgICAgcmVjb3JkaW5nLnB1c2goYCR7aW5kZW50fSR7Y29udGV4dE5hbWV9LmRyYXdCdWZmZXJzKFske2FyZ3VtZW50c1RvU3RyaW5nKGFyZ3VtZW50c1swXSwgeyBjb250ZXh0TmFtZSwgY29udGV4dFZhcmlhYmxlcywgZ2V0RW50aXR5LCBhZGRWYXJpYWJsZSwgdmFyaWFibGVzLCBvblVucmVjb2duaXplZEFyZ3VtZW50TG9va3VwIH0gKX1dKTtgKTtcbiAgICAgICAgICAgIHJldHVybiBnbC5kcmF3QnVmZmVycyhhcmd1bWVudHNbMF0pO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXN1bHQgPSBnbFtwcm9wZXJ0eV0uYXBwbHkoZ2wsIGFyZ3VtZW50cyk7XG4gICAgICAgIHN3aXRjaCAodHlwZW9mIHJlc3VsdCkge1xuICAgICAgICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICAgICAgICByZWNvcmRpbmcucHVzaChgJHtpbmRlbnR9JHttZXRob2RDYWxsVG9TdHJpbmcocHJvcGVydHksIGFyZ3VtZW50cyl9O2ApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICBpZiAodXNlVHJhY2thYmxlUHJpbWl0aXZlcyAmJiBjb250ZXh0VmFyaWFibGVzLmluZGV4T2YodHJhY2thYmxlUHJpbWl0aXZlKHJlc3VsdCkpID09PSAtMSkge1xuICAgICAgICAgICAgICByZWNvcmRpbmcucHVzaChgJHtpbmRlbnR9Y29uc3QgJHtjb250ZXh0TmFtZX1WYXJpYWJsZSR7Y29udGV4dFZhcmlhYmxlcy5sZW5ndGh9ID0gJHttZXRob2RDYWxsVG9TdHJpbmcocHJvcGVydHksIGFyZ3VtZW50cyl9O2ApO1xuICAgICAgICAgICAgICBjb250ZXh0VmFyaWFibGVzLnB1c2gocmVzdWx0ID0gdHJhY2thYmxlUHJpbWl0aXZlKHJlc3VsdCkpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICByZWNvcmRpbmcucHVzaChgJHttZXRob2RDYWxsVG9TdHJpbmcocHJvcGVydHksIGFyZ3VtZW50cyl9O2ApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVjb3JkaW5nLnB1c2goYCR7aW5kZW50fWNvbnN0ICR7Y29udGV4dE5hbWV9VmFyaWFibGUke2NvbnRleHRWYXJpYWJsZXMubGVuZ3RofSA9ICR7bWV0aG9kQ2FsbFRvU3RyaW5nKHByb3BlcnR5LCBhcmd1bWVudHMpfTtgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29udGV4dFZhcmlhYmxlcy5wdXNoKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICB9XG4gICAgZW50aXR5TmFtZXNbZ2xbcHJvcGVydHldXSA9IHByb3BlcnR5O1xuICAgIHJldHVybiBnbFtwcm9wZXJ0eV07XG4gIH1cbiAgZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHJlY29yZGluZy5qb2luKCdcXG4nKTtcbiAgfVxuICBmdW5jdGlvbiByZXNldCgpIHtcbiAgICB3aGlsZSAocmVjb3JkaW5nLmxlbmd0aCA+IDApIHtcbiAgICAgIHJlY29yZGluZy5wb3AoKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gaW5zZXJ0VmFyaWFibGUobmFtZSwgdmFsdWUpIHtcbiAgICB2YXJpYWJsZXNbbmFtZV0gPSB2YWx1ZTtcbiAgfVxuICBmdW5jdGlvbiBnZXRFbnRpdHkodmFsdWUpIHtcbiAgICBjb25zdCBuYW1lID0gZW50aXR5TmFtZXNbdmFsdWVdO1xuICAgIGlmIChuYW1lKSB7XG4gICAgICByZXR1cm4gY29udGV4dE5hbWUgKyAnLicgKyBuYW1lO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgZnVuY3Rpb24gc2V0SW5kZW50KHNwYWNlcykge1xuICAgIGluZGVudCA9ICcgJy5yZXBlYXQoc3BhY2VzKTtcbiAgfVxuICBmdW5jdGlvbiBhZGRWYXJpYWJsZSh2YWx1ZSwgc291cmNlKSB7XG4gICAgY29uc3QgdmFyaWFibGVOYW1lID0gYCR7Y29udGV4dE5hbWV9VmFyaWFibGUke2NvbnRleHRWYXJpYWJsZXMubGVuZ3RofWA7XG4gICAgcmVjb3JkaW5nLnB1c2goYCR7aW5kZW50fWNvbnN0ICR7dmFyaWFibGVOYW1lfSA9ICR7c291cmNlfTtgKTtcbiAgICBjb250ZXh0VmFyaWFibGVzLnB1c2godmFsdWUpO1xuICAgIHJldHVybiB2YXJpYWJsZU5hbWU7XG4gIH1cbiAgZnVuY3Rpb24gd3JpdGVQUE0od2lkdGgsIGhlaWdodCkge1xuICAgIGNvbnN0IHNvdXJjZVZhcmlhYmxlID0gYCR7Y29udGV4dE5hbWV9VmFyaWFibGUke2NvbnRleHRWYXJpYWJsZXMubGVuZ3RofWA7XG4gICAgY29uc3QgaW1hZ2VWYXJpYWJsZSA9IGBpbWFnZURhdHVtJHtpbWFnZUNvdW50fWA7XG4gICAgcmVjb3JkaW5nLnB1c2goYCR7aW5kZW50fWxldCAke2ltYWdlVmFyaWFibGV9ID0gW1wiUDNcXFxcbiMgJHtyZWFkUGl4ZWxzRmlsZX0ucHBtXFxcXG5cIiwgJHt3aWR0aH0sICcgJywgJHtoZWlnaHR9LCBcIlxcXFxuMjU1XFxcXG5cIl0uam9pbihcIlwiKTtgKTtcbiAgICByZWNvcmRpbmcucHVzaChgJHtpbmRlbnR9Zm9yIChsZXQgaSA9IDA7IGkgPCAke2ltYWdlVmFyaWFibGV9Lmxlbmd0aDsgaSArPSA0KSB7YCk7XG4gICAgcmVjb3JkaW5nLnB1c2goYCR7aW5kZW50fSAgJHtpbWFnZVZhcmlhYmxlfSArPSAke3NvdXJjZVZhcmlhYmxlfVtpXSArICcgJyArICR7c291cmNlVmFyaWFibGV9W2kgKyAxXSArICcgJyArICR7c291cmNlVmFyaWFibGV9W2kgKyAyXSArICcgJztgKTtcbiAgICByZWNvcmRpbmcucHVzaChgJHtpbmRlbnR9fWApO1xuICAgIHJlY29yZGluZy5wdXNoKGAke2luZGVudH1pZiAodHlwZW9mIHJlcXVpcmUgIT09IFwidW5kZWZpbmVkXCIpIHtgKTtcbiAgICByZWNvcmRpbmcucHVzaChgJHtpbmRlbnR9ICByZXF1aXJlKCdmcycpLndyaXRlRmlsZVN5bmMoJy4vJHtyZWFkUGl4ZWxzRmlsZX0ucHBtJywgJHtpbWFnZVZhcmlhYmxlfSk7YCk7XG4gICAgcmVjb3JkaW5nLnB1c2goYCR7aW5kZW50fX1gKTtcbiAgICBpbWFnZUNvdW50Kys7XG4gIH1cbiAgZnVuY3Rpb24gYWRkQ29tbWVudCh2YWx1ZSkge1xuICAgIHJlY29yZGluZy5wdXNoKGAke2luZGVudH0vLyAke3ZhbHVlfWApO1xuICB9XG4gIGZ1bmN0aW9uIGNoZWNrVGhyb3dFcnJvcigpIHtcbiAgICByZWNvcmRpbmcucHVzaChgJHtpbmRlbnR9KCgpID0+IHtcbiR7aW5kZW50fWNvbnN0IGVycm9yID0gJHtjb250ZXh0TmFtZX0uZ2V0RXJyb3IoKTtcbiR7aW5kZW50fWlmIChlcnJvciAhPT0gJHtjb250ZXh0TmFtZX0uTk9ORSkge1xuJHtpbmRlbnR9ICBjb25zdCBuYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGdsKTtcbiR7aW5kZW50fSAgZm9yIChsZXQgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7IGkrKykge1xuJHtpbmRlbnR9ICAgIGNvbnN0IG5hbWUgPSBuYW1lc1tpXTtcbiR7aW5kZW50fSAgICBpZiAoJHtjb250ZXh0TmFtZX1bbmFtZV0gPT09IGVycm9yKSB7XG4ke2luZGVudH0gICAgICB0aHJvdyBuZXcgRXJyb3IoJyR7Y29udGV4dE5hbWV9IHRocmV3ICcgKyBuYW1lKTtcbiR7aW5kZW50fSAgICB9XG4ke2luZGVudH0gIH1cbiR7aW5kZW50fX1cbiR7aW5kZW50fX0pKCk7YCk7XG4gIH1cbiAgZnVuY3Rpb24gbWV0aG9kQ2FsbFRvU3RyaW5nKG1ldGhvZCwgYXJncykge1xuICAgIHJldHVybiBgJHtjb250ZXh0TmFtZX0uJHttZXRob2R9KCR7YXJndW1lbnRzVG9TdHJpbmcoYXJncywgeyBjb250ZXh0TmFtZSwgY29udGV4dFZhcmlhYmxlcywgZ2V0RW50aXR5LCBhZGRWYXJpYWJsZSwgdmFyaWFibGVzLCBvblVucmVjb2duaXplZEFyZ3VtZW50TG9va3VwIH0pfSlgO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0VmFyaWFibGVOYW1lKHZhbHVlKSB7XG4gICAgaWYgKHZhcmlhYmxlcykge1xuICAgICAgZm9yIChjb25zdCBuYW1lIGluIHZhcmlhYmxlcykge1xuICAgICAgICBpZiAodmFyaWFibGVzW25hbWVdID09PSB2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0Q29udGV4dFZhcmlhYmxlTmFtZSh2YWx1ZSkge1xuICAgIGNvbnN0IGkgPSBjb250ZXh0VmFyaWFibGVzLmluZGV4T2YodmFsdWUpO1xuICAgIGlmIChpICE9PSAtMSkge1xuICAgICAgcmV0dXJuIGAke2NvbnRleHROYW1lfVZhcmlhYmxlJHtpfWA7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdsRXh0ZW5zaW9uV2lyZXRhcChleHRlbnNpb24sIG9wdGlvbnMpIHtcbiAgY29uc3QgcHJveHkgPSBuZXcgUHJveHkoZXh0ZW5zaW9uLCB7IGdldDogbGlzdGVuIH0pO1xuICBjb25zdCBleHRlbnNpb25FbnRpdHlOYW1lcyA9IHt9O1xuICBjb25zdCB7XG4gICAgY29udGV4dE5hbWUsXG4gICAgY29udGV4dFZhcmlhYmxlcyxcbiAgICBnZXRFbnRpdHksXG4gICAgdXNlVHJhY2thYmxlUHJpbWl0aXZlcyxcbiAgICByZWNvcmRpbmcsXG4gICAgdmFyaWFibGVzLFxuICAgIGluZGVudCxcbiAgICBvblVucmVjb2duaXplZEFyZ3VtZW50TG9va3VwLFxuICB9ID0gb3B0aW9ucztcbiAgcmV0dXJuIHByb3h5O1xuICBmdW5jdGlvbiBsaXN0ZW4ob2JqLCBwcm9wZXJ0eSkge1xuICAgIGlmICh0eXBlb2Ygb2JqW3Byb3BlcnR5XSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICBzd2l0Y2ggKHByb3BlcnR5KSB7XG4gICAgICAgICAgY2FzZSAnZHJhd0J1ZmZlcnNXRUJHTCc6XG4gICAgICAgICAgICByZWNvcmRpbmcucHVzaChgJHtpbmRlbnR9JHtjb250ZXh0TmFtZX0uZHJhd0J1ZmZlcnNXRUJHTChbJHthcmd1bWVudHNUb1N0cmluZyhhcmd1bWVudHNbMF0sIHsgY29udGV4dE5hbWUsIGNvbnRleHRWYXJpYWJsZXMsIGdldEVudGl0eTogZ2V0RXh0ZW5zaW9uRW50aXR5LCBhZGRWYXJpYWJsZSwgdmFyaWFibGVzLCBvblVucmVjb2duaXplZEFyZ3VtZW50TG9va3VwIH0pfV0pO2ApO1xuICAgICAgICAgICAgcmV0dXJuIGV4dGVuc2lvbi5kcmF3QnVmZmVyc1dFQkdMKGFyZ3VtZW50c1swXSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3VsdCA9IGV4dGVuc2lvbltwcm9wZXJ0eV0uYXBwbHkoZXh0ZW5zaW9uLCBhcmd1bWVudHMpO1xuICAgICAgICBzd2l0Y2ggKHR5cGVvZiByZXN1bHQpIHtcbiAgICAgICAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgICAgICAgcmVjb3JkaW5nLnB1c2goYCR7aW5kZW50fSR7bWV0aG9kQ2FsbFRvU3RyaW5nKHByb3BlcnR5LCBhcmd1bWVudHMpfTtgKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgaWYgKHVzZVRyYWNrYWJsZVByaW1pdGl2ZXMgJiYgY29udGV4dFZhcmlhYmxlcy5pbmRleE9mKHRyYWNrYWJsZVByaW1pdGl2ZShyZXN1bHQpKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgcmVjb3JkaW5nLnB1c2goYCR7aW5kZW50fWNvbnN0ICR7Y29udGV4dE5hbWV9VmFyaWFibGUke2NvbnRleHRWYXJpYWJsZXMubGVuZ3RofSA9ICR7bWV0aG9kQ2FsbFRvU3RyaW5nKHByb3BlcnR5LCBhcmd1bWVudHMpfTtgKTtcbiAgICAgICAgICAgICAgY29udGV4dFZhcmlhYmxlcy5wdXNoKHJlc3VsdCA9IHRyYWNrYWJsZVByaW1pdGl2ZShyZXN1bHQpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlY29yZGluZy5wdXNoKGAke2luZGVudH1jb25zdCAke2NvbnRleHROYW1lfVZhcmlhYmxlJHtjb250ZXh0VmFyaWFibGVzLmxlbmd0aH0gPSAke21ldGhvZENhbGxUb1N0cmluZyhwcm9wZXJ0eSwgYXJndW1lbnRzKX07YCk7XG4gICAgICAgICAgICAgIGNvbnRleHRWYXJpYWJsZXMucHVzaChyZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgcmVjb3JkaW5nLnB1c2goYCR7bWV0aG9kQ2FsbFRvU3RyaW5nKHByb3BlcnR5LCBhcmd1bWVudHMpfTtgKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlY29yZGluZy5wdXNoKGAke2luZGVudH1jb25zdCAke2NvbnRleHROYW1lfVZhcmlhYmxlJHtjb250ZXh0VmFyaWFibGVzLmxlbmd0aH0gPSAke21ldGhvZENhbGxUb1N0cmluZyhwcm9wZXJ0eSwgYXJndW1lbnRzKX07YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250ZXh0VmFyaWFibGVzLnB1c2gocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICB9XG4gICAgZXh0ZW5zaW9uRW50aXR5TmFtZXNbZXh0ZW5zaW9uW3Byb3BlcnR5XV0gPSBwcm9wZXJ0eTtcbiAgICByZXR1cm4gZXh0ZW5zaW9uW3Byb3BlcnR5XTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEV4dGVuc2lvbkVudGl0eSh2YWx1ZSkge1xuICAgIGlmIChleHRlbnNpb25FbnRpdHlOYW1lcy5oYXNPd25Qcm9wZXJ0eSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBgJHtjb250ZXh0TmFtZX0uJHtleHRlbnNpb25FbnRpdHlOYW1lc1t2YWx1ZV19YDtcbiAgICB9XG4gICAgcmV0dXJuIGdldEVudGl0eSh2YWx1ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBtZXRob2RDYWxsVG9TdHJpbmcobWV0aG9kLCBhcmdzKSB7XG4gICAgcmV0dXJuIGAke2NvbnRleHROYW1lfS4ke21ldGhvZH0oJHthcmd1bWVudHNUb1N0cmluZyhhcmdzLCB7IGNvbnRleHROYW1lLCBjb250ZXh0VmFyaWFibGVzLCBnZXRFbnRpdHk6IGdldEV4dGVuc2lvbkVudGl0eSwgYWRkVmFyaWFibGUsIHZhcmlhYmxlcywgb25VbnJlY29nbml6ZWRBcmd1bWVudExvb2t1cCB9KX0pYDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZFZhcmlhYmxlKHZhbHVlLCBzb3VyY2UpIHtcbiAgICBjb25zdCB2YXJpYWJsZU5hbWUgPSBgJHtjb250ZXh0TmFtZX1WYXJpYWJsZSR7Y29udGV4dFZhcmlhYmxlcy5sZW5ndGh9YDtcbiAgICBjb250ZXh0VmFyaWFibGVzLnB1c2godmFsdWUpO1xuICAgIHJlY29yZGluZy5wdXNoKGAke2luZGVudH1jb25zdCAke3ZhcmlhYmxlTmFtZX0gPSAke3NvdXJjZX07YCk7XG4gICAgcmV0dXJuIHZhcmlhYmxlTmFtZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhcmd1bWVudHNUb1N0cmluZyhhcmdzLCBvcHRpb25zKSB7XG4gIGNvbnN0IHsgdmFyaWFibGVzLCBvblVucmVjb2duaXplZEFyZ3VtZW50TG9va3VwIH0gPSBvcHRpb25zO1xuICByZXR1cm4gKEFycmF5LmZyb20oYXJncykubWFwKChhcmcpID0+IHtcbiAgICBjb25zdCB2YXJpYWJsZU5hbWUgPSBnZXRWYXJpYWJsZU5hbWUoYXJnKTtcbiAgICBpZiAodmFyaWFibGVOYW1lKSB7XG4gICAgICByZXR1cm4gdmFyaWFibGVOYW1lO1xuICAgIH1cbiAgICByZXR1cm4gYXJndW1lbnRUb1N0cmluZyhhcmcsIG9wdGlvbnMpO1xuICB9KS5qb2luKCcsICcpKTtcblxuICBmdW5jdGlvbiBnZXRWYXJpYWJsZU5hbWUodmFsdWUpIHtcbiAgICBpZiAodmFyaWFibGVzKSB7XG4gICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gdmFyaWFibGVzKSB7XG4gICAgICAgIGlmICghdmFyaWFibGVzLmhhc093blByb3BlcnR5KG5hbWUpKSBjb250aW51ZTtcbiAgICAgICAgaWYgKHZhcmlhYmxlc1tuYW1lXSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAob25VbnJlY29nbml6ZWRBcmd1bWVudExvb2t1cCkge1xuICAgICAgcmV0dXJuIG9uVW5yZWNvZ25pemVkQXJndW1lbnRMb29rdXAodmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5mdW5jdGlvbiBhcmd1bWVudFRvU3RyaW5nKGFyZywgb3B0aW9ucykge1xuICBjb25zdCB7IGNvbnRleHROYW1lLCBjb250ZXh0VmFyaWFibGVzLCBnZXRFbnRpdHksIGFkZFZhcmlhYmxlLCBvblVucmVjb2duaXplZEFyZ3VtZW50TG9va3VwIH0gPSBvcHRpb25zO1xuICBpZiAodHlwZW9mIGFyZyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gJ3VuZGVmaW5lZCc7XG4gIH1cbiAgaWYgKGFyZyA9PT0gbnVsbCkge1xuICAgIHJldHVybiAnbnVsbCc7XG4gIH1cbiAgY29uc3QgaSA9IGNvbnRleHRWYXJpYWJsZXMuaW5kZXhPZihhcmcpO1xuICBpZiAoaSA+IC0xKSB7XG4gICAgcmV0dXJuIGAke2NvbnRleHROYW1lfVZhcmlhYmxlJHtpfWA7XG4gIH1cbiAgc3dpdGNoIChhcmcuY29uc3RydWN0b3IubmFtZSkge1xuICAgIGNhc2UgJ1N0cmluZyc6XG4gICAgICBjb25zdCBoYXNMaW5lcyA9IC9cXG4vLnRlc3QoYXJnKTtcbiAgICAgIGNvbnN0IGhhc1NpbmdsZVF1b3RlcyA9IC8nLy50ZXN0KGFyZyk7XG4gICAgICBjb25zdCBoYXNEb3VibGVRdW90ZXMgPSAvXCIvLnRlc3QoYXJnKTtcbiAgICAgIGlmIChoYXNMaW5lcykge1xuICAgICAgICByZXR1cm4gJ2AnICsgYXJnICsgJ2AnO1xuICAgICAgfSBlbHNlIGlmIChoYXNTaW5nbGVRdW90ZXMgJiYgIWhhc0RvdWJsZVF1b3Rlcykge1xuICAgICAgICByZXR1cm4gJ1wiJyArIGFyZyArICdcIic7XG4gICAgICB9IGVsc2UgaWYgKCFoYXNTaW5nbGVRdW90ZXMgJiYgaGFzRG91YmxlUXVvdGVzKSB7XG4gICAgICAgIHJldHVybiBcIidcIiArIGFyZyArIFwiJ1wiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuICdcXCcnICsgYXJnICsgJ1xcJyc7XG4gICAgICB9XG4gICAgY2FzZSAnTnVtYmVyJzogcmV0dXJuIGdldEVudGl0eShhcmcpO1xuICAgIGNhc2UgJ0Jvb2xlYW4nOiByZXR1cm4gZ2V0RW50aXR5KGFyZyk7XG4gICAgY2FzZSAnQXJyYXknOlxuICAgICAgcmV0dXJuIGFkZFZhcmlhYmxlKGFyZywgYG5ldyAke2FyZy5jb25zdHJ1Y3Rvci5uYW1lfShbJHtBcnJheS5mcm9tKGFyZykuam9pbignLCcpfV0pYCk7XG4gICAgY2FzZSAnRmxvYXQzMkFycmF5JzpcbiAgICBjYXNlICdVaW50OEFycmF5JzpcbiAgICBjYXNlICdVaW50MTZBcnJheSc6XG4gICAgY2FzZSAnSW50MzJBcnJheSc6XG4gICAgICByZXR1cm4gYWRkVmFyaWFibGUoYXJnLCBgbmV3ICR7YXJnLmNvbnN0cnVjdG9yLm5hbWV9KCR7SlNPTi5zdHJpbmdpZnkoQXJyYXkuZnJvbShhcmcpKX0pYCk7XG4gICAgZGVmYXVsdDpcbiAgICAgIGlmIChvblVucmVjb2duaXplZEFyZ3VtZW50TG9va3VwKSB7XG4gICAgICAgIGNvbnN0IGluc3RhbnRpYXRpb25TdHJpbmcgPSBvblVucmVjb2duaXplZEFyZ3VtZW50TG9va3VwKGFyZyk7XG4gICAgICAgIGlmIChpbnN0YW50aWF0aW9uU3RyaW5nKSB7XG4gICAgICAgICAgcmV0dXJuIGluc3RhbnRpYXRpb25TdHJpbmc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcihgdW5yZWNvZ25pemVkIGFyZ3VtZW50IHR5cGUgJHthcmcuY29uc3RydWN0b3IubmFtZX1gKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB0cmFja2FibGVQcmltaXRpdmUodmFsdWUpIHtcbiAgcmV0dXJuIG5ldyB2YWx1ZS5jb25zdHJ1Y3Rvcih2YWx1ZSk7XG59XG5cbmlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHsgZ2xXaXJldGFwLCBnbEV4dGVuc2lvbldpcmV0YXAgfTtcbn1cblxuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gIGdsV2lyZXRhcC5nbEV4dGVuc2lvbldpcmV0YXAgPSBnbEV4dGVuc2lvbldpcmV0YXA7XG4gIHdpbmRvdy5nbFdpcmV0YXAgPSBnbFdpcmV0YXA7XG59XG5cbn0se31dLDQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuZnVuY3Rpb24gc2V0dXBBcmd1bWVudHMoYXJncykge1xuICBjb25zdCBuZXdBcmd1bWVudHMgPSBuZXcgQXJyYXkoYXJncy5sZW5ndGgpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBhcmcgPSBhcmdzW2ldO1xuICAgIGlmIChhcmcudG9BcnJheSkge1xuICAgICAgbmV3QXJndW1lbnRzW2ldID0gYXJnLnRvQXJyYXkoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV3QXJndW1lbnRzW2ldID0gYXJnO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmV3QXJndW1lbnRzO1xufVxuXG5mdW5jdGlvbiBtb2NrMUQoKSB7XG4gIGNvbnN0IGFyZ3MgPSBzZXR1cEFyZ3VtZW50cyhhcmd1bWVudHMpO1xuICBjb25zdCByb3cgPSBuZXcgRmxvYXQzMkFycmF5KHRoaXMub3V0cHV0LngpO1xuICBmb3IgKGxldCB4ID0gMDsgeCA8IHRoaXMub3V0cHV0Lng7IHgrKykge1xuICAgIHRoaXMudGhyZWFkLnggPSB4O1xuICAgIHRoaXMudGhyZWFkLnkgPSAwO1xuICAgIHRoaXMudGhyZWFkLnogPSAwO1xuICAgIHJvd1t4XSA9IHRoaXMuX2ZuLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICB9XG4gIHJldHVybiByb3c7XG59XG5cbmZ1bmN0aW9uIG1vY2syRCgpIHtcbiAgY29uc3QgYXJncyA9IHNldHVwQXJndW1lbnRzKGFyZ3VtZW50cyk7XG4gIGNvbnN0IG1hdHJpeCA9IG5ldyBBcnJheSh0aGlzLm91dHB1dC55KTtcbiAgZm9yIChsZXQgeSA9IDA7IHkgPCB0aGlzLm91dHB1dC55OyB5KyspIHtcbiAgICBjb25zdCByb3cgPSBuZXcgRmxvYXQzMkFycmF5KHRoaXMub3V0cHV0LngpO1xuICAgIGZvciAobGV0IHggPSAwOyB4IDwgdGhpcy5vdXRwdXQueDsgeCsrKSB7XG4gICAgICB0aGlzLnRocmVhZC54ID0geDtcbiAgICAgIHRoaXMudGhyZWFkLnkgPSB5O1xuICAgICAgdGhpcy50aHJlYWQueiA9IDA7XG4gICAgICByb3dbeF0gPSB0aGlzLl9mbi5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gICAgbWF0cml4W3ldID0gcm93O1xuICB9XG4gIHJldHVybiBtYXRyaXg7XG59XG5cbmZ1bmN0aW9uIG1vY2syREdyYXBoaWNhbCgpIHtcbiAgY29uc3QgYXJncyA9IHNldHVwQXJndW1lbnRzKGFyZ3VtZW50cyk7XG4gIGZvciAobGV0IHkgPSAwOyB5IDwgdGhpcy5vdXRwdXQueTsgeSsrKSB7XG4gICAgZm9yIChsZXQgeCA9IDA7IHggPCB0aGlzLm91dHB1dC54OyB4KyspIHtcbiAgICAgIHRoaXMudGhyZWFkLnggPSB4O1xuICAgICAgdGhpcy50aHJlYWQueSA9IHk7XG4gICAgICB0aGlzLnRocmVhZC56ID0gMDtcbiAgICAgIHRoaXMuX2ZuLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBtb2NrM0QoKSB7XG4gIGNvbnN0IGFyZ3MgPSBzZXR1cEFyZ3VtZW50cyhhcmd1bWVudHMpO1xuICBjb25zdCBjdWJlID0gbmV3IEFycmF5KHRoaXMub3V0cHV0LnopO1xuICBmb3IgKGxldCB6ID0gMDsgeiA8IHRoaXMub3V0cHV0Lno7IHorKykge1xuICAgIGNvbnN0IG1hdHJpeCA9IG5ldyBBcnJheSh0aGlzLm91dHB1dC55KTtcbiAgICBmb3IgKGxldCB5ID0gMDsgeSA8IHRoaXMub3V0cHV0Lnk7IHkrKykge1xuICAgICAgY29uc3Qgcm93ID0gbmV3IEZsb2F0MzJBcnJheSh0aGlzLm91dHB1dC54KTtcbiAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgdGhpcy5vdXRwdXQueDsgeCsrKSB7XG4gICAgICAgIHRoaXMudGhyZWFkLnggPSB4O1xuICAgICAgICB0aGlzLnRocmVhZC55ID0geTtcbiAgICAgICAgdGhpcy50aHJlYWQueiA9IHo7XG4gICAgICAgIHJvd1t4XSA9IHRoaXMuX2ZuLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgfVxuICAgICAgbWF0cml4W3ldID0gcm93O1xuICAgIH1cbiAgICBjdWJlW3pdID0gbWF0cml4O1xuICB9XG4gIHJldHVybiBjdWJlO1xufVxuXG5mdW5jdGlvbiBhcGlEZWNvcmF0ZShrZXJuZWwpIHtcbiAga2VybmVsLnNldE91dHB1dCA9IChvdXRwdXQpID0+IHtcbiAgICBrZXJuZWwub3V0cHV0ID0gc2V0dXBPdXRwdXQob3V0cHV0KTtcbiAgICBpZiAoa2VybmVsLmdyYXBoaWNhbCkge1xuICAgICAgc2V0dXBHcmFwaGljYWwoa2VybmVsKTtcbiAgICB9XG4gIH07XG4gIGtlcm5lbC50b0pTT04gPSAoKSA9PiB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgdXNhYmxlIHdpdGggZ3B1TW9jaycpO1xuICB9O1xuICBrZXJuZWwuc2V0Q29uc3RhbnRzID0gKGZsYWcpID0+IHtcbiAgICBrZXJuZWwuY29uc3RhbnRzID0gZmxhZztcbiAgICByZXR1cm4ga2VybmVsO1xuICB9O1xuICBrZXJuZWwuc2V0R3JhcGhpY2FsID0gKGZsYWcpID0+IHtcbiAgICBrZXJuZWwuZ3JhcGhpY2FsID0gZmxhZztcbiAgICByZXR1cm4ga2VybmVsO1xuICB9O1xuICBrZXJuZWwuc2V0Q2FudmFzID0gKGZsYWcpID0+IHtcbiAgICBrZXJuZWwuY2FudmFzID0gZmxhZztcbiAgICByZXR1cm4ga2VybmVsO1xuICB9O1xuICBrZXJuZWwuc2V0Q29udGV4dCA9IChmbGFnKSA9PiB7XG4gICAga2VybmVsLmNvbnRleHQgPSBmbGFnO1xuICAgIHJldHVybiBrZXJuZWw7XG4gIH07XG4gIGtlcm5lbC5kZXN0cm95ID0gKCkgPT4ge307XG4gIGtlcm5lbC52YWxpZGF0ZVNldHRpbmdzID0gKCkgPT4ge307XG4gIGlmIChrZXJuZWwuZ3JhcGhpY2FsICYmIGtlcm5lbC5vdXRwdXQpIHtcbiAgICBzZXR1cEdyYXBoaWNhbChrZXJuZWwpO1xuICB9XG4gIGtlcm5lbC5leGVjID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJlc29sdmUoa2VybmVsLmFwcGx5KGtlcm5lbCwgYXJndW1lbnRzKSk7XG4gICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuICBrZXJuZWwuZ2V0UGl4ZWxzID0gKGZsaXApID0+IHtcbiAgICBjb25zdCB7eCwgeX0gPSBrZXJuZWwub3V0cHV0O1xuICAgIHJldHVybiBmbGlwID8gZmxpcFBpeGVscyhrZXJuZWwuX2ltYWdlRGF0YS5kYXRhLCB4LCB5KSA6IGtlcm5lbC5faW1hZ2VEYXRhLmRhdGEuc2xpY2UoMCk7XG4gIH07XG4gIGtlcm5lbC5jb2xvciA9IGZ1bmN0aW9uKHIsIGcsIGIsIGEpIHtcbiAgICBpZiAodHlwZW9mIGEgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBhID0gMTtcbiAgICB9XG5cbiAgICByID0gTWF0aC5mbG9vcihyICogMjU1KTtcbiAgICBnID0gTWF0aC5mbG9vcihnICogMjU1KTtcbiAgICBiID0gTWF0aC5mbG9vcihiICogMjU1KTtcbiAgICBhID0gTWF0aC5mbG9vcihhICogMjU1KTtcblxuICAgIGNvbnN0IHdpZHRoID0ga2VybmVsLm91dHB1dC54O1xuICAgIGNvbnN0IGhlaWdodCA9IGtlcm5lbC5vdXRwdXQueTtcblxuICAgIGNvbnN0IHggPSBrZXJuZWwudGhyZWFkLng7XG4gICAgY29uc3QgeSA9IGhlaWdodCAtIGtlcm5lbC50aHJlYWQueSAtIDE7XG5cbiAgICBjb25zdCBpbmRleCA9IHggKyB5ICogd2lkdGg7XG5cbiAgICBrZXJuZWwuX2NvbG9yRGF0YVtpbmRleCAqIDQgKyAwXSA9IHI7XG4gICAga2VybmVsLl9jb2xvckRhdGFbaW5kZXggKiA0ICsgMV0gPSBnO1xuICAgIGtlcm5lbC5fY29sb3JEYXRhW2luZGV4ICogNCArIDJdID0gYjtcbiAgICBrZXJuZWwuX2NvbG9yRGF0YVtpbmRleCAqIDQgKyAzXSA9IGE7XG4gIH07XG5cbiAgY29uc3QgbW9ja01ldGhvZCA9ICgpID0+IGtlcm5lbDtcbiAgY29uc3QgbWV0aG9kcyA9IFtcbiAgICAnc2V0V2FyblZhclVzYWdlJyxcbiAgICAnc2V0QXJndW1lbnRUeXBlcycsXG4gICAgJ3NldFRhY3RpYycsXG4gICAgJ3NldE9wdGltaXplRmxvYXRNZW1vcnknLFxuICAgICdzZXREZWJ1ZycsXG4gICAgJ3NldExvb3BNYXhJdGVyYXRpb25zJyxcbiAgICAnc2V0Q29uc3RhbnRUeXBlcycsXG4gICAgJ3NldEZ1bmN0aW9ucycsXG4gICAgJ3NldE5hdGl2ZUZ1bmN0aW9ucycsXG4gICAgJ3NldEluamVjdGVkTmF0aXZlJyxcbiAgICAnc2V0UGlwZWxpbmUnLFxuICAgICdzZXRQcmVjaXNpb24nLFxuICAgICdzZXRPdXRwdXRUb1RleHR1cmUnLFxuICAgICdzZXRJbW11dGFibGUnLFxuICAgICdzZXRTdHJpY3RJbnRlZ2VycycsXG4gICAgJ3NldER5bmFtaWNPdXRwdXQnLFxuICAgICdzZXRIYXJkY29kZUNvbnN0YW50cycsXG4gICAgJ3NldER5bmFtaWNBcmd1bWVudHMnLFxuICAgICdzZXRVc2VMZWdhY3lFbmNvZGVyJyxcbiAgICAnc2V0V2FyblZhclVzYWdlJyxcbiAgICAnYWRkU3ViS2VybmVsJyxcbiAgXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBtZXRob2RzLmxlbmd0aDsgaSsrKSB7XG4gICAga2VybmVsW21ldGhvZHNbaV1dID0gbW9ja01ldGhvZDtcbiAgfVxuICByZXR1cm4ga2VybmVsO1xufVxuXG5mdW5jdGlvbiBzZXR1cEdyYXBoaWNhbChrZXJuZWwpIHtcbiAgY29uc3Qge3gsIHl9ID0ga2VybmVsLm91dHB1dDtcbiAgaWYgKGtlcm5lbC5jb250ZXh0ICYmIGtlcm5lbC5jb250ZXh0LmNyZWF0ZUltYWdlRGF0YSkge1xuICAgIGNvbnN0IGRhdGEgPSBuZXcgVWludDhDbGFtcGVkQXJyYXkoeCAqIHkgKiA0KTtcbiAgICBrZXJuZWwuX2ltYWdlRGF0YSA9IGtlcm5lbC5jb250ZXh0LmNyZWF0ZUltYWdlRGF0YSh4LCB5KTtcbiAgICBrZXJuZWwuX2NvbG9yRGF0YSA9IGRhdGE7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgZGF0YSA9IG5ldyBVaW50OENsYW1wZWRBcnJheSh4ICogeSAqIDQpO1xuICAgIGtlcm5lbC5faW1hZ2VEYXRhID0geyBkYXRhIH07XG4gICAga2VybmVsLl9jb2xvckRhdGEgPSBkYXRhO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNldHVwT3V0cHV0KG91dHB1dCkge1xuICBsZXQgcmVzdWx0ID0gbnVsbDtcbiAgaWYgKG91dHB1dC5sZW5ndGgpIHtcbiAgICBpZiAob3V0cHV0Lmxlbmd0aCA9PT0gMykge1xuICAgICAgY29uc3QgW3gseSx6XSA9IG91dHB1dDtcbiAgICAgIHJlc3VsdCA9IHsgeCwgeSwgeiB9O1xuICAgIH0gZWxzZSBpZiAob3V0cHV0Lmxlbmd0aCA9PT0gMikge1xuICAgICAgY29uc3QgW3gseV0gPSBvdXRwdXQ7XG4gICAgICByZXN1bHQgPSB7IHgsIHkgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgW3hdID0gb3V0cHV0O1xuICAgICAgcmVzdWx0ID0geyB4IH07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJlc3VsdCA9IG91dHB1dDtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBncHVNb2NrKGZuLCBzZXR0aW5ncyA9IHt9KSB7XG4gIGNvbnN0IG91dHB1dCA9IHNldHRpbmdzLm91dHB1dCA/IHNldHVwT3V0cHV0KHNldHRpbmdzLm91dHB1dCkgOiBudWxsO1xuICBmdW5jdGlvbiBrZXJuZWwoKSB7XG4gICAgaWYgKGtlcm5lbC5vdXRwdXQueikge1xuICAgICAgcmV0dXJuIG1vY2szRC5hcHBseShrZXJuZWwsIGFyZ3VtZW50cyk7XG4gICAgfSBlbHNlIGlmIChrZXJuZWwub3V0cHV0LnkpIHtcbiAgICAgIGlmIChrZXJuZWwuZ3JhcGhpY2FsKSB7XG4gICAgICAgIHJldHVybiBtb2NrMkRHcmFwaGljYWwuYXBwbHkoa2VybmVsLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1vY2syRC5hcHBseShrZXJuZWwsIGFyZ3VtZW50cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBtb2NrMUQuYXBwbHkoa2VybmVsLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfVxuICBrZXJuZWwuX2ZuID0gZm47XG4gIGtlcm5lbC5jb25zdGFudHMgPSBzZXR0aW5ncy5jb25zdGFudHMgfHwgbnVsbDtcbiAga2VybmVsLmNvbnRleHQgPSBzZXR0aW5ncy5jb250ZXh0IHx8IG51bGw7XG4gIGtlcm5lbC5jYW52YXMgPSBzZXR0aW5ncy5jYW52YXMgfHwgbnVsbDtcbiAga2VybmVsLmdyYXBoaWNhbCA9IHNldHRpbmdzLmdyYXBoaWNhbCB8fCBmYWxzZTtcbiAga2VybmVsLl9pbWFnZURhdGEgPSBudWxsO1xuICBrZXJuZWwuX2NvbG9yRGF0YSA9IG51bGw7XG4gIGtlcm5lbC5vdXRwdXQgPSBvdXRwdXQ7XG4gIGtlcm5lbC50aHJlYWQgPSB7XG4gICAgeDogMCxcbiAgICB5OiAwLFxuICAgIHo6IDBcbiAgfTtcbiAgcmV0dXJuIGFwaURlY29yYXRlKGtlcm5lbCk7XG59XG5cbmZ1bmN0aW9uIGZsaXBQaXhlbHMocGl4ZWxzLCB3aWR0aCwgaGVpZ2h0KSB7XG4gIGNvbnN0IGhhbGZIZWlnaHQgPSBoZWlnaHQgLyAyIHwgMDsgXG4gIGNvbnN0IGJ5dGVzUGVyUm93ID0gd2lkdGggKiA0O1xuICBjb25zdCB0ZW1wID0gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KHdpZHRoICogNCk7XG4gIGNvbnN0IHJlc3VsdCA9IHBpeGVscy5zbGljZSgwKTtcbiAgZm9yIChsZXQgeSA9IDA7IHkgPCBoYWxmSGVpZ2h0OyArK3kpIHtcbiAgICBjb25zdCB0b3BPZmZzZXQgPSB5ICogYnl0ZXNQZXJSb3c7XG4gICAgY29uc3QgYm90dG9tT2Zmc2V0ID0gKGhlaWdodCAtIHkgLSAxKSAqIGJ5dGVzUGVyUm93O1xuXG4gICAgdGVtcC5zZXQocmVzdWx0LnN1YmFycmF5KHRvcE9mZnNldCwgdG9wT2Zmc2V0ICsgYnl0ZXNQZXJSb3cpKTtcblxuICAgIHJlc3VsdC5jb3B5V2l0aGluKHRvcE9mZnNldCwgYm90dG9tT2Zmc2V0LCBib3R0b21PZmZzZXQgKyBieXRlc1BlclJvdyk7XG5cbiAgICByZXN1bHQuc2V0KHRlbXAsIGJvdHRvbU9mZnNldCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGdwdU1vY2tcbn07XG5cbn0se31dLDU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi91dGlscycpO1xuXG5mdW5jdGlvbiBhbGlhcyhuYW1lLCBzb3VyY2UpIHtcbiAgY29uc3QgZm5TdHJpbmcgPSBzb3VyY2UudG9TdHJpbmcoKTtcbiAgcmV0dXJuIG5ldyBGdW5jdGlvbihgcmV0dXJuIGZ1bmN0aW9uICR7IG5hbWUgfSAoJHsgdXRpbHMuZ2V0QXJndW1lbnROYW1lc0Zyb21TdHJpbmcoZm5TdHJpbmcpLmpvaW4oJywgJykgfSkge1xuICAkeyB1dGlscy5nZXRGdW5jdGlvbkJvZHlGcm9tU3RyaW5nKGZuU3RyaW5nKSB9XG59YCkoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGFsaWFzXG59O1xufSx7XCIuL3V0aWxzXCI6MTE0fV0sNjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IEZ1bmN0aW9uTm9kZSB9ID0gcmVxdWlyZSgnLi4vZnVuY3Rpb24tbm9kZScpO1xuXG5jbGFzcyBDUFVGdW5jdGlvbk5vZGUgZXh0ZW5kcyBGdW5jdGlvbk5vZGUge1xuICBhc3RGdW5jdGlvbihhc3QsIHJldEFycikge1xuXG4gICAgaWYgKCF0aGlzLmlzUm9vdEtlcm5lbCkge1xuICAgICAgcmV0QXJyLnB1c2goJ2Z1bmN0aW9uJyk7XG4gICAgICByZXRBcnIucHVzaCgnICcpO1xuICAgICAgcmV0QXJyLnB1c2godGhpcy5uYW1lKTtcbiAgICAgIHJldEFyci5wdXNoKCcoJyk7XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5hcmd1bWVudE5hbWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IGFyZ3VtZW50TmFtZSA9IHRoaXMuYXJndW1lbnROYW1lc1tpXTtcblxuICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICByZXRBcnIucHVzaCgnLCAnKTtcbiAgICAgICAgfVxuICAgICAgICByZXRBcnIucHVzaCgndXNlcl8nKTtcbiAgICAgICAgcmV0QXJyLnB1c2goYXJndW1lbnROYW1lKTtcbiAgICAgIH1cblxuICAgICAgcmV0QXJyLnB1c2goJykge1xcbicpO1xuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXN0LmJvZHkuYm9keS5sZW5ndGg7ICsraSkge1xuICAgICAgdGhpcy5hc3RHZW5lcmljKGFzdC5ib2R5LmJvZHlbaV0sIHJldEFycik7XG4gICAgICByZXRBcnIucHVzaCgnXFxuJyk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmlzUm9vdEtlcm5lbCkge1xuICAgICAgcmV0QXJyLnB1c2goJ31cXG4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldEFycjtcbiAgfVxuXG4gIGFzdFJldHVyblN0YXRlbWVudChhc3QsIHJldEFycikge1xuICAgIGNvbnN0IHR5cGUgPSB0aGlzLnJldHVyblR5cGUgfHwgdGhpcy5nZXRUeXBlKGFzdC5hcmd1bWVudCk7XG5cbiAgICBpZiAoIXRoaXMucmV0dXJuVHlwZSkge1xuICAgICAgdGhpcy5yZXR1cm5UeXBlID0gdHlwZTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5pc1Jvb3RLZXJuZWwpIHtcbiAgICAgIHJldEFyci5wdXNoKHRoaXMubGVhZGluZ1JldHVyblN0YXRlbWVudCk7XG4gICAgICB0aGlzLmFzdEdlbmVyaWMoYXN0LmFyZ3VtZW50LCByZXRBcnIpO1xuICAgICAgcmV0QXJyLnB1c2goJztcXG4nKTtcbiAgICAgIHJldEFyci5wdXNoKHRoaXMuZm9sbG93aW5nUmV0dXJuU3RhdGVtZW50KTtcbiAgICAgIHJldEFyci5wdXNoKCdjb250aW51ZTtcXG4nKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNTdWJLZXJuZWwpIHtcbiAgICAgIHJldEFyci5wdXNoKGBzdWJLZXJuZWxSZXN1bHRfJHsgdGhpcy5uYW1lIH0gPSBgKTtcbiAgICAgIHRoaXMuYXN0R2VuZXJpYyhhc3QuYXJndW1lbnQsIHJldEFycik7XG4gICAgICByZXRBcnIucHVzaCgnOycpO1xuICAgICAgcmV0QXJyLnB1c2goYHJldHVybiBzdWJLZXJuZWxSZXN1bHRfJHsgdGhpcy5uYW1lIH07YCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldEFyci5wdXNoKCdyZXR1cm4gJyk7XG4gICAgICB0aGlzLmFzdEdlbmVyaWMoYXN0LmFyZ3VtZW50LCByZXRBcnIpO1xuICAgICAgcmV0QXJyLnB1c2goJzsnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldEFycjtcbiAgfVxuXG4gIGFzdExpdGVyYWwoYXN0LCByZXRBcnIpIHtcblxuICAgIGlmIChpc05hTihhc3QudmFsdWUpKSB7XG4gICAgICB0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KFxuICAgICAgICAnTm9uLW51bWVyaWMgbGl0ZXJhbCBub3Qgc3VwcG9ydGVkIDogJyArIGFzdC52YWx1ZSxcbiAgICAgICAgYXN0XG4gICAgICApO1xuICAgIH1cblxuICAgIHJldEFyci5wdXNoKGFzdC52YWx1ZSk7XG5cbiAgICByZXR1cm4gcmV0QXJyO1xuICB9XG5cbiAgYXN0QmluYXJ5RXhwcmVzc2lvbihhc3QsIHJldEFycikge1xuICAgIHJldEFyci5wdXNoKCcoJyk7XG4gICAgdGhpcy5hc3RHZW5lcmljKGFzdC5sZWZ0LCByZXRBcnIpO1xuICAgIHJldEFyci5wdXNoKGFzdC5vcGVyYXRvcik7XG4gICAgdGhpcy5hc3RHZW5lcmljKGFzdC5yaWdodCwgcmV0QXJyKTtcbiAgICByZXRBcnIucHVzaCgnKScpO1xuICAgIHJldHVybiByZXRBcnI7XG4gIH1cblxuICBhc3RJZGVudGlmaWVyRXhwcmVzc2lvbihpZHROb2RlLCByZXRBcnIpIHtcbiAgICBpZiAoaWR0Tm9kZS50eXBlICE9PSAnSWRlbnRpZmllcicpIHtcbiAgICAgIHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoXG4gICAgICAgICdJZGVudGlmaWVyRXhwcmVzc2lvbiAtIG5vdCBhbiBJZGVudGlmaWVyJyxcbiAgICAgICAgaWR0Tm9kZVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKGlkdE5vZGUubmFtZSkge1xuICAgICAgY2FzZSAnSW5maW5pdHknOlxuICAgICAgICByZXRBcnIucHVzaCgnSW5maW5pdHknKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAodGhpcy5jb25zdGFudHMgJiYgdGhpcy5jb25zdGFudHMuaGFzT3duUHJvcGVydHkoaWR0Tm9kZS5uYW1lKSkge1xuICAgICAgICAgIHJldEFyci5wdXNoKCdjb25zdGFudHNfJyArIGlkdE5vZGUubmFtZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0QXJyLnB1c2goJ3VzZXJfJyArIGlkdE5vZGUubmFtZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmV0QXJyO1xuICB9XG5cbiAgYXN0Rm9yU3RhdGVtZW50KGZvck5vZGUsIHJldEFycikge1xuICAgIGlmIChmb3JOb2RlLnR5cGUgIT09ICdGb3JTdGF0ZW1lbnQnKSB7XG4gICAgICB0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KCdJbnZhbGlkIGZvciBzdGF0ZW1lbnQnLCBmb3JOb2RlKTtcbiAgICB9XG5cbiAgICBjb25zdCBpbml0QXJyID0gW107XG4gICAgY29uc3QgdGVzdEFyciA9IFtdO1xuICAgIGNvbnN0IHVwZGF0ZUFyciA9IFtdO1xuICAgIGNvbnN0IGJvZHlBcnIgPSBbXTtcbiAgICBsZXQgaXNTYWZlID0gbnVsbDtcblxuICAgIGlmIChmb3JOb2RlLmluaXQpIHtcbiAgICAgIHRoaXMucHVzaFN0YXRlKCdpbi1mb3ItbG9vcC1pbml0Jyk7XG4gICAgICB0aGlzLmFzdEdlbmVyaWMoZm9yTm9kZS5pbml0LCBpbml0QXJyKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5pdEFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaW5pdEFycltpXS5pbmNsdWRlcyAmJiBpbml0QXJyW2ldLmluY2x1ZGVzKCcsJykpIHtcbiAgICAgICAgICBpc1NhZmUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5wb3BTdGF0ZSgnaW4tZm9yLWxvb3AtaW5pdCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpc1NhZmUgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoZm9yTm9kZS50ZXN0KSB7XG4gICAgICB0aGlzLmFzdEdlbmVyaWMoZm9yTm9kZS50ZXN0LCB0ZXN0QXJyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaXNTYWZlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGZvck5vZGUudXBkYXRlKSB7XG4gICAgICB0aGlzLmFzdEdlbmVyaWMoZm9yTm9kZS51cGRhdGUsIHVwZGF0ZUFycik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlzU2FmZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChmb3JOb2RlLmJvZHkpIHtcbiAgICAgIHRoaXMucHVzaFN0YXRlKCdsb29wLWJvZHknKTtcbiAgICAgIHRoaXMuYXN0R2VuZXJpYyhmb3JOb2RlLmJvZHksIGJvZHlBcnIpO1xuICAgICAgdGhpcy5wb3BTdGF0ZSgnbG9vcC1ib2R5Jyk7XG4gICAgfVxuXG4gICAgaWYgKGlzU2FmZSA9PT0gbnVsbCkge1xuICAgICAgaXNTYWZlID0gdGhpcy5pc1NhZmUoZm9yTm9kZS5pbml0KSAmJiB0aGlzLmlzU2FmZShmb3JOb2RlLnRlc3QpO1xuICAgIH1cblxuICAgIGlmIChpc1NhZmUpIHtcbiAgICAgIHJldEFyci5wdXNoKGBmb3IgKCR7aW5pdEFyci5qb2luKCcnKX07JHt0ZXN0QXJyLmpvaW4oJycpfTske3VwZGF0ZUFyci5qb2luKCcnKX0pe1xcbmApO1xuICAgICAgcmV0QXJyLnB1c2goYm9keUFyci5qb2luKCcnKSk7XG4gICAgICByZXRBcnIucHVzaCgnfVxcbicpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBpVmFyaWFibGVOYW1lID0gdGhpcy5nZXRJbnRlcm5hbFZhcmlhYmxlTmFtZSgnc2FmZUknKTtcbiAgICAgIGlmIChpbml0QXJyLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0QXJyLnB1c2goaW5pdEFyci5qb2luKCcnKSwgJztcXG4nKTtcbiAgICAgIH1cbiAgICAgIHJldEFyci5wdXNoKGBmb3IgKGxldCAke2lWYXJpYWJsZU5hbWV9PTA7JHtpVmFyaWFibGVOYW1lfTxMT09QX01BWDske2lWYXJpYWJsZU5hbWV9Kyspe1xcbmApO1xuICAgICAgaWYgKHRlc3RBcnIubGVuZ3RoID4gMCkge1xuICAgICAgICByZXRBcnIucHVzaChgaWYgKCEke3Rlc3RBcnIuam9pbignJyl9KSBicmVhaztcXG5gKTtcbiAgICAgIH1cbiAgICAgIHJldEFyci5wdXNoKGJvZHlBcnIuam9pbignJykpO1xuICAgICAgcmV0QXJyLnB1c2goYFxcbiR7dXBkYXRlQXJyLmpvaW4oJycpfTtgKTtcbiAgICAgIHJldEFyci5wdXNoKCd9XFxuJyk7XG4gICAgfVxuICAgIHJldHVybiByZXRBcnI7XG4gIH1cblxuICBhc3RXaGlsZVN0YXRlbWVudCh3aGlsZU5vZGUsIHJldEFycikge1xuICAgIGlmICh3aGlsZU5vZGUudHlwZSAhPT0gJ1doaWxlU3RhdGVtZW50Jykge1xuICAgICAgdGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dChcbiAgICAgICAgJ0ludmFsaWQgd2hpbGUgc3RhdGVtZW50JyxcbiAgICAgICAgd2hpbGVOb2RlXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldEFyci5wdXNoKCdmb3IgKGxldCBpID0gMDsgaSA8IExPT1BfTUFYOyBpKyspIHsnKTtcbiAgICByZXRBcnIucHVzaCgnaWYgKCcpO1xuICAgIHRoaXMuYXN0R2VuZXJpYyh3aGlsZU5vZGUudGVzdCwgcmV0QXJyKTtcbiAgICByZXRBcnIucHVzaCgnKSB7XFxuJyk7XG4gICAgdGhpcy5hc3RHZW5lcmljKHdoaWxlTm9kZS5ib2R5LCByZXRBcnIpO1xuICAgIHJldEFyci5wdXNoKCd9IGVsc2Uge1xcbicpO1xuICAgIHJldEFyci5wdXNoKCdicmVhaztcXG4nKTtcbiAgICByZXRBcnIucHVzaCgnfVxcbicpO1xuICAgIHJldEFyci5wdXNoKCd9XFxuJyk7XG5cbiAgICByZXR1cm4gcmV0QXJyO1xuICB9XG5cbiAgYXN0RG9XaGlsZVN0YXRlbWVudChkb1doaWxlTm9kZSwgcmV0QXJyKSB7XG4gICAgaWYgKGRvV2hpbGVOb2RlLnR5cGUgIT09ICdEb1doaWxlU3RhdGVtZW50Jykge1xuICAgICAgdGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dChcbiAgICAgICAgJ0ludmFsaWQgd2hpbGUgc3RhdGVtZW50JyxcbiAgICAgICAgZG9XaGlsZU5vZGVcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0QXJyLnB1c2goJ2ZvciAobGV0IGkgPSAwOyBpIDwgTE9PUF9NQVg7IGkrKykgeycpO1xuICAgIHRoaXMuYXN0R2VuZXJpYyhkb1doaWxlTm9kZS5ib2R5LCByZXRBcnIpO1xuICAgIHJldEFyci5wdXNoKCdpZiAoIScpO1xuICAgIHRoaXMuYXN0R2VuZXJpYyhkb1doaWxlTm9kZS50ZXN0LCByZXRBcnIpO1xuICAgIHJldEFyci5wdXNoKCcpIHtcXG4nKTtcbiAgICByZXRBcnIucHVzaCgnYnJlYWs7XFxuJyk7XG4gICAgcmV0QXJyLnB1c2goJ31cXG4nKTtcbiAgICByZXRBcnIucHVzaCgnfVxcbicpO1xuXG4gICAgcmV0dXJuIHJldEFycjtcblxuICB9XG5cbiAgYXN0QXNzaWdubWVudEV4cHJlc3Npb24oYXNzTm9kZSwgcmV0QXJyKSB7XG4gICAgY29uc3QgZGVjbGFyYXRpb24gPSB0aGlzLmdldERlY2xhcmF0aW9uKGFzc05vZGUubGVmdCk7XG4gICAgaWYgKGRlY2xhcmF0aW9uICYmICFkZWNsYXJhdGlvbi5hc3NpZ25hYmxlKSB7XG4gICAgICB0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KGBWYXJpYWJsZSAke2Fzc05vZGUubGVmdC5uYW1lfSBpcyBub3QgYXNzaWduYWJsZSBoZXJlYCwgYXNzTm9kZSk7XG4gICAgfVxuICAgIHRoaXMuYXN0R2VuZXJpYyhhc3NOb2RlLmxlZnQsIHJldEFycik7XG4gICAgcmV0QXJyLnB1c2goYXNzTm9kZS5vcGVyYXRvcik7XG4gICAgdGhpcy5hc3RHZW5lcmljKGFzc05vZGUucmlnaHQsIHJldEFycik7XG4gICAgcmV0dXJuIHJldEFycjtcbiAgfVxuXG4gIGFzdEJsb2NrU3RhdGVtZW50KGJOb2RlLCByZXRBcnIpIHtcbiAgICBpZiAodGhpcy5pc1N0YXRlKCdsb29wLWJvZHknKSkge1xuICAgICAgdGhpcy5wdXNoU3RhdGUoJ2Jsb2NrLWJvZHknKTsgXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJOb2RlLmJvZHkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5hc3RHZW5lcmljKGJOb2RlLmJvZHlbaV0sIHJldEFycik7XG4gICAgICB9XG4gICAgICB0aGlzLnBvcFN0YXRlKCdibG9jay1ib2R5Jyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldEFyci5wdXNoKCd7XFxuJyk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJOb2RlLmJvZHkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5hc3RHZW5lcmljKGJOb2RlLmJvZHlbaV0sIHJldEFycik7XG4gICAgICB9XG4gICAgICByZXRBcnIucHVzaCgnfVxcbicpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0QXJyO1xuICB9XG5cbiAgYXN0VmFyaWFibGVEZWNsYXJhdGlvbih2YXJEZWNOb2RlLCByZXRBcnIpIHtcbiAgICByZXRBcnIucHVzaChgJHt2YXJEZWNOb2RlLmtpbmR9IGApO1xuICAgIGNvbnN0IHsgZGVjbGFyYXRpb25zIH0gPSB2YXJEZWNOb2RlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGVjbGFyYXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgcmV0QXJyLnB1c2goJywnKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRlY2xhcmF0aW9uID0gZGVjbGFyYXRpb25zW2ldO1xuICAgICAgY29uc3QgaW5mbyA9IHRoaXMuZ2V0RGVjbGFyYXRpb24oZGVjbGFyYXRpb24uaWQpO1xuICAgICAgaWYgKCFpbmZvLnZhbHVlVHlwZSkge1xuICAgICAgICBpbmZvLnZhbHVlVHlwZSA9IHRoaXMuZ2V0VHlwZShkZWNsYXJhdGlvbi5pbml0KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuYXN0R2VuZXJpYyhkZWNsYXJhdGlvbiwgcmV0QXJyKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmlzU3RhdGUoJ2luLWZvci1sb29wLWluaXQnKSkge1xuICAgICAgcmV0QXJyLnB1c2goJzsnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldEFycjtcbiAgfVxuXG4gIGFzdElmU3RhdGVtZW50KGlmTm9kZSwgcmV0QXJyKSB7XG4gICAgcmV0QXJyLnB1c2goJ2lmICgnKTtcbiAgICB0aGlzLmFzdEdlbmVyaWMoaWZOb2RlLnRlc3QsIHJldEFycik7XG4gICAgcmV0QXJyLnB1c2goJyknKTtcbiAgICBpZiAoaWZOb2RlLmNvbnNlcXVlbnQudHlwZSA9PT0gJ0Jsb2NrU3RhdGVtZW50Jykge1xuICAgICAgdGhpcy5hc3RHZW5lcmljKGlmTm9kZS5jb25zZXF1ZW50LCByZXRBcnIpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXRBcnIucHVzaCgnIHtcXG4nKTtcbiAgICAgIHRoaXMuYXN0R2VuZXJpYyhpZk5vZGUuY29uc2VxdWVudCwgcmV0QXJyKTtcbiAgICAgIHJldEFyci5wdXNoKCdcXG59XFxuJyk7XG4gICAgfVxuXG4gICAgaWYgKGlmTm9kZS5hbHRlcm5hdGUpIHtcbiAgICAgIHJldEFyci5wdXNoKCdlbHNlICcpO1xuICAgICAgaWYgKGlmTm9kZS5hbHRlcm5hdGUudHlwZSA9PT0gJ0Jsb2NrU3RhdGVtZW50JyB8fCBpZk5vZGUuYWx0ZXJuYXRlLnR5cGUgPT09ICdJZlN0YXRlbWVudCcpIHtcbiAgICAgICAgdGhpcy5hc3RHZW5lcmljKGlmTm9kZS5hbHRlcm5hdGUsIHJldEFycik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXRBcnIucHVzaCgnIHtcXG4nKTtcbiAgICAgICAgdGhpcy5hc3RHZW5lcmljKGlmTm9kZS5hbHRlcm5hdGUsIHJldEFycik7XG4gICAgICAgIHJldEFyci5wdXNoKCdcXG59XFxuJyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXRBcnI7XG5cbiAgfVxuXG4gIGFzdFN3aXRjaFN0YXRlbWVudChhc3QsIHJldEFycikge1xuICAgIGNvbnN0IHsgZGlzY3JpbWluYW50LCBjYXNlcyB9ID0gYXN0O1xuICAgIHJldEFyci5wdXNoKCdzd2l0Y2ggKCcpO1xuICAgIHRoaXMuYXN0R2VuZXJpYyhkaXNjcmltaW5hbnQsIHJldEFycik7XG4gICAgcmV0QXJyLnB1c2goJykge1xcbicpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2FzZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChjYXNlc1tpXS50ZXN0ID09PSBudWxsKSB7XG4gICAgICAgIHJldEFyci5wdXNoKCdkZWZhdWx0OlxcbicpO1xuICAgICAgICB0aGlzLmFzdEdlbmVyaWMoY2FzZXNbaV0uY29uc2VxdWVudCwgcmV0QXJyKTtcbiAgICAgICAgaWYgKGNhc2VzW2ldLmNvbnNlcXVlbnQgJiYgY2FzZXNbaV0uY29uc2VxdWVudC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgcmV0QXJyLnB1c2goJ2JyZWFrO1xcbicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgcmV0QXJyLnB1c2goJ2Nhc2UgJyk7XG4gICAgICB0aGlzLmFzdEdlbmVyaWMoY2FzZXNbaV0udGVzdCwgcmV0QXJyKTtcbiAgICAgIHJldEFyci5wdXNoKCc6XFxuJyk7XG4gICAgICBpZiAoY2FzZXNbaV0uY29uc2VxdWVudCAmJiBjYXNlc1tpXS5jb25zZXF1ZW50Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhpcy5hc3RHZW5lcmljKGNhc2VzW2ldLmNvbnNlcXVlbnQsIHJldEFycik7XG4gICAgICAgIHJldEFyci5wdXNoKCdicmVhaztcXG4nKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0QXJyLnB1c2goJ1xcbn0nKTtcbiAgfVxuXG4gIGFzdFRoaXNFeHByZXNzaW9uKHROb2RlLCByZXRBcnIpIHtcbiAgICByZXRBcnIucHVzaCgnX3RoaXMnKTtcbiAgICByZXR1cm4gcmV0QXJyO1xuICB9XG5cbiAgYXN0TWVtYmVyRXhwcmVzc2lvbihtTm9kZSwgcmV0QXJyKSB7XG4gICAgY29uc3Qge1xuICAgICAgc2lnbmF0dXJlLFxuICAgICAgdHlwZSxcbiAgICAgIHByb3BlcnR5LFxuICAgICAgeFByb3BlcnR5LFxuICAgICAgeVByb3BlcnR5LFxuICAgICAgelByb3BlcnR5LFxuICAgICAgbmFtZSxcbiAgICAgIG9yaWdpblxuICAgIH0gPSB0aGlzLmdldE1lbWJlckV4cHJlc3Npb25EZXRhaWxzKG1Ob2RlKTtcbiAgICBzd2l0Y2ggKHNpZ25hdHVyZSkge1xuICAgICAgY2FzZSAndGhpcy50aHJlYWQudmFsdWUnOlxuICAgICAgICByZXRBcnIucHVzaChgX3RoaXMudGhyZWFkLiR7IG5hbWUgfWApO1xuICAgICAgICByZXR1cm4gcmV0QXJyO1xuICAgICAgY2FzZSAndGhpcy5vdXRwdXQudmFsdWUnOlxuICAgICAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgICAgICBjYXNlICd4JzpcbiAgICAgICAgICAgIHJldEFyci5wdXNoKCdvdXRwdXRYJyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICd5JzpcbiAgICAgICAgICAgIHJldEFyci5wdXNoKCdvdXRwdXRZJyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICd6JzpcbiAgICAgICAgICAgIHJldEFyci5wdXNoKCdvdXRwdXRaJyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dCgnVW5leHBlY3RlZCBleHByZXNzaW9uJywgbU5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXRBcnI7XG4gICAgICBjYXNlICd2YWx1ZSc6XG4gICAgICAgIHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoJ1VuZXhwZWN0ZWQgZXhwcmVzc2lvbicsIG1Ob2RlKTtcbiAgICAgIGNhc2UgJ3ZhbHVlW10nOlxuICAgICAgY2FzZSAndmFsdWVbXVtdJzpcbiAgICAgIGNhc2UgJ3ZhbHVlW11bXVtdJzpcbiAgICAgIGNhc2UgJ3ZhbHVlLnZhbHVlJzpcbiAgICAgICAgaWYgKG9yaWdpbiA9PT0gJ01hdGgnKSB7XG4gICAgICAgICAgcmV0QXJyLnB1c2goTWF0aFtuYW1lXSk7XG4gICAgICAgICAgcmV0dXJuIHJldEFycjtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKHByb3BlcnR5KSB7XG4gICAgICAgICAgY2FzZSAncic6XG4gICAgICAgICAgICByZXRBcnIucHVzaChgdXNlcl8keyBuYW1lIH1bMF1gKTtcbiAgICAgICAgICAgIHJldHVybiByZXRBcnI7XG4gICAgICAgICAgY2FzZSAnZyc6XG4gICAgICAgICAgICByZXRBcnIucHVzaChgdXNlcl8keyBuYW1lIH1bMV1gKTtcbiAgICAgICAgICAgIHJldHVybiByZXRBcnI7XG4gICAgICAgICAgY2FzZSAnYic6XG4gICAgICAgICAgICByZXRBcnIucHVzaChgdXNlcl8keyBuYW1lIH1bMl1gKTtcbiAgICAgICAgICAgIHJldHVybiByZXRBcnI7XG4gICAgICAgICAgY2FzZSAnYSc6XG4gICAgICAgICAgICByZXRBcnIucHVzaChgdXNlcl8keyBuYW1lIH1bM11gKTtcbiAgICAgICAgICAgIHJldHVybiByZXRBcnI7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0aGlzLmNvbnN0YW50cy52YWx1ZSc6XG4gICAgICBjYXNlICd0aGlzLmNvbnN0YW50cy52YWx1ZVtdJzpcbiAgICAgIGNhc2UgJ3RoaXMuY29uc3RhbnRzLnZhbHVlW11bXSc6XG4gICAgICBjYXNlICd0aGlzLmNvbnN0YW50cy52YWx1ZVtdW11bXSc6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnZm4oKVtdJzpcbiAgICAgICAgdGhpcy5hc3RHZW5lcmljKG1Ob2RlLm9iamVjdCwgcmV0QXJyKTtcbiAgICAgICAgcmV0QXJyLnB1c2goJ1snKTtcbiAgICAgICAgdGhpcy5hc3RHZW5lcmljKG1Ob2RlLnByb3BlcnR5LCByZXRBcnIpO1xuICAgICAgICByZXRBcnIucHVzaCgnXScpO1xuICAgICAgICByZXR1cm4gcmV0QXJyO1xuICAgICAgY2FzZSAnZm4oKVtdW10nOlxuICAgICAgICB0aGlzLmFzdEdlbmVyaWMobU5vZGUub2JqZWN0Lm9iamVjdCwgcmV0QXJyKTtcbiAgICAgICAgcmV0QXJyLnB1c2goJ1snKTtcbiAgICAgICAgdGhpcy5hc3RHZW5lcmljKG1Ob2RlLm9iamVjdC5wcm9wZXJ0eSwgcmV0QXJyKTtcbiAgICAgICAgcmV0QXJyLnB1c2goJ10nKTtcbiAgICAgICAgcmV0QXJyLnB1c2goJ1snKTtcbiAgICAgICAgdGhpcy5hc3RHZW5lcmljKG1Ob2RlLnByb3BlcnR5LCByZXRBcnIpO1xuICAgICAgICByZXRBcnIucHVzaCgnXScpO1xuICAgICAgICByZXR1cm4gcmV0QXJyO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dCgnVW5leHBlY3RlZCBleHByZXNzaW9uJywgbU5vZGUpO1xuICAgIH1cblxuICAgIGlmICghbU5vZGUuY29tcHV0ZWQpIHtcbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlICdOdW1iZXInOlxuICAgICAgICBjYXNlICdJbnRlZ2VyJzpcbiAgICAgICAgY2FzZSAnRmxvYXQnOlxuICAgICAgICBjYXNlICdCb29sZWFuJzpcbiAgICAgICAgICByZXRBcnIucHVzaChgJHtvcmlnaW59XyR7bmFtZX1gKTtcbiAgICAgICAgICByZXR1cm4gcmV0QXJyO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IG1hcmt1cE5hbWUgPSBgJHtvcmlnaW59XyR7bmFtZX1gO1xuXG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlICdBcnJheSgyKSc6XG4gICAgICBjYXNlICdBcnJheSgzKSc6XG4gICAgICBjYXNlICdBcnJheSg0KSc6XG4gICAgICBjYXNlICdNYXRyaXgoMiknOlxuICAgICAgY2FzZSAnTWF0cml4KDMpJzpcbiAgICAgIGNhc2UgJ01hdHJpeCg0KSc6XG4gICAgICBjYXNlICdIVE1MSW1hZ2VBcnJheSc6XG4gICAgICBjYXNlICdBcnJheVRleHR1cmUoMSknOlxuICAgICAgY2FzZSAnQXJyYXlUZXh0dXJlKDIpJzpcbiAgICAgIGNhc2UgJ0FycmF5VGV4dHVyZSgzKSc6XG4gICAgICBjYXNlICdBcnJheVRleHR1cmUoNCknOlxuICAgICAgY2FzZSAnSFRNTEltYWdlJzpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGxldCBzaXplO1xuICAgICAgICBsZXQgaXNJbnB1dDtcbiAgICAgICAgaWYgKG9yaWdpbiA9PT0gJ2NvbnN0YW50cycpIHtcbiAgICAgICAgICBjb25zdCBjb25zdGFudCA9IHRoaXMuY29uc3RhbnRzW25hbWVdO1xuICAgICAgICAgIGlzSW5wdXQgPSB0aGlzLmNvbnN0YW50VHlwZXNbbmFtZV0gPT09ICdJbnB1dCc7XG4gICAgICAgICAgc2l6ZSA9IGlzSW5wdXQgPyBjb25zdGFudC5zaXplIDogbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpc0lucHV0ID0gdGhpcy5pc0lucHV0KG5hbWUpO1xuICAgICAgICAgIHNpemUgPSBpc0lucHV0ID8gdGhpcy5hcmd1bWVudFNpemVzW3RoaXMuYXJndW1lbnROYW1lcy5pbmRleE9mKG5hbWUpXSA6IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0QXJyLnB1c2goYCR7IG1hcmt1cE5hbWUgfWApO1xuICAgICAgICBpZiAoelByb3BlcnR5ICYmIHlQcm9wZXJ0eSkge1xuICAgICAgICAgIGlmIChpc0lucHV0KSB7XG4gICAgICAgICAgICByZXRBcnIucHVzaCgnWygnKTtcbiAgICAgICAgICAgIHRoaXMuYXN0R2VuZXJpYyh6UHJvcGVydHksIHJldEFycik7XG4gICAgICAgICAgICByZXRBcnIucHVzaChgKiR7IHRoaXMuZHluYW1pY0FyZ3VtZW50cyA/ICcob3V0cHV0WSAqIG91dHB1dFgpJyA6IHNpemVbMV0gKiBzaXplWzBdIH0pKyhgKTtcbiAgICAgICAgICAgIHRoaXMuYXN0R2VuZXJpYyh5UHJvcGVydHksIHJldEFycik7XG4gICAgICAgICAgICByZXRBcnIucHVzaChgKiR7IHRoaXMuZHluYW1pY0FyZ3VtZW50cyA/ICdvdXRwdXRYJyA6IHNpemVbMF0gfSkrYCk7XG4gICAgICAgICAgICB0aGlzLmFzdEdlbmVyaWMoeFByb3BlcnR5LCByZXRBcnIpO1xuICAgICAgICAgICAgcmV0QXJyLnB1c2goJ10nKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0QXJyLnB1c2goJ1snKTtcbiAgICAgICAgICAgIHRoaXMuYXN0R2VuZXJpYyh6UHJvcGVydHksIHJldEFycik7XG4gICAgICAgICAgICByZXRBcnIucHVzaCgnXScpO1xuICAgICAgICAgICAgcmV0QXJyLnB1c2goJ1snKTtcbiAgICAgICAgICAgIHRoaXMuYXN0R2VuZXJpYyh5UHJvcGVydHksIHJldEFycik7XG4gICAgICAgICAgICByZXRBcnIucHVzaCgnXScpO1xuICAgICAgICAgICAgcmV0QXJyLnB1c2goJ1snKTtcbiAgICAgICAgICAgIHRoaXMuYXN0R2VuZXJpYyh4UHJvcGVydHksIHJldEFycik7XG4gICAgICAgICAgICByZXRBcnIucHVzaCgnXScpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh5UHJvcGVydHkpIHtcbiAgICAgICAgICBpZiAoaXNJbnB1dCkge1xuICAgICAgICAgICAgcmV0QXJyLnB1c2goJ1soJyk7XG4gICAgICAgICAgICB0aGlzLmFzdEdlbmVyaWMoeVByb3BlcnR5LCByZXRBcnIpO1xuICAgICAgICAgICAgcmV0QXJyLnB1c2goYCokeyB0aGlzLmR5bmFtaWNBcmd1bWVudHMgPyAnb3V0cHV0WCcgOiBzaXplWzBdIH0pK2ApO1xuICAgICAgICAgICAgdGhpcy5hc3RHZW5lcmljKHhQcm9wZXJ0eSwgcmV0QXJyKTtcbiAgICAgICAgICAgIHJldEFyci5wdXNoKCddJyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldEFyci5wdXNoKCdbJyk7XG4gICAgICAgICAgICB0aGlzLmFzdEdlbmVyaWMoeVByb3BlcnR5LCByZXRBcnIpO1xuICAgICAgICAgICAgcmV0QXJyLnB1c2goJ10nKTtcbiAgICAgICAgICAgIHJldEFyci5wdXNoKCdbJyk7XG4gICAgICAgICAgICB0aGlzLmFzdEdlbmVyaWMoeFByb3BlcnR5LCByZXRBcnIpO1xuICAgICAgICAgICAgcmV0QXJyLnB1c2goJ10nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHhQcm9wZXJ0eSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICByZXRBcnIucHVzaCgnWycpO1xuICAgICAgICAgIHRoaXMuYXN0R2VuZXJpYyh4UHJvcGVydHksIHJldEFycik7XG4gICAgICAgICAgcmV0QXJyLnB1c2goJ10nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmV0QXJyO1xuICB9XG5cbiAgYXN0Q2FsbEV4cHJlc3Npb24oYXN0LCByZXRBcnIpIHtcbiAgICBpZiAoYXN0LnR5cGUgIT09ICdDYWxsRXhwcmVzc2lvbicpIHtcbiAgICAgIHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoJ1Vua25vd24gQ2FsbEV4cHJlc3Npb24nLCBhc3QpO1xuICAgIH1cbiAgICBsZXQgZnVuY3Rpb25OYW1lID0gdGhpcy5hc3RNZW1iZXJFeHByZXNzaW9uVW5yb2xsKGFzdC5jYWxsZWUpO1xuXG4gICAgaWYgKHRoaXMuY2FsbGVkRnVuY3Rpb25zLmluZGV4T2YoZnVuY3Rpb25OYW1lKSA8IDApIHtcbiAgICAgIHRoaXMuY2FsbGVkRnVuY3Rpb25zLnB1c2goZnVuY3Rpb25OYW1lKTtcbiAgICB9XG5cbiAgICBjb25zdCBpc01hdGhGdW5jdGlvbiA9IHRoaXMuaXNBc3RNYXRoRnVuY3Rpb24oYXN0KTtcblxuICAgIGlmICh0aGlzLm9uRnVuY3Rpb25DYWxsKSB7XG4gICAgICB0aGlzLm9uRnVuY3Rpb25DYWxsKHRoaXMubmFtZSwgZnVuY3Rpb25OYW1lLCBhc3QuYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICByZXRBcnIucHVzaChmdW5jdGlvbk5hbWUpO1xuXG4gICAgcmV0QXJyLnB1c2goJygnKTtcbiAgICBjb25zdCB0YXJnZXRUeXBlcyA9IHRoaXMubG9va3VwRnVuY3Rpb25Bcmd1bWVudFR5cGVzKGZ1bmN0aW9uTmFtZSkgfHwgW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhc3QuYXJndW1lbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICBjb25zdCBhcmd1bWVudCA9IGFzdC5hcmd1bWVudHNbaV07XG5cbiAgICAgIGxldCBhcmd1bWVudFR5cGUgPSB0aGlzLmdldFR5cGUoYXJndW1lbnQpO1xuICAgICAgaWYgKCF0YXJnZXRUeXBlc1tpXSkge1xuICAgICAgICB0aGlzLnRyaWdnZXJJbXBseUFyZ3VtZW50VHlwZShmdW5jdGlvbk5hbWUsIGksIGFyZ3VtZW50VHlwZSwgdGhpcyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpID4gMCkge1xuICAgICAgICByZXRBcnIucHVzaCgnLCAnKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuYXN0R2VuZXJpYyhhcmd1bWVudCwgcmV0QXJyKTtcbiAgICB9XG4gICAgcmV0QXJyLnB1c2goJyknKTtcblxuICAgIHJldHVybiByZXRBcnI7XG4gIH1cblxuICBhc3RBcnJheUV4cHJlc3Npb24oYXJyTm9kZSwgcmV0QXJyKSB7XG4gICAgY29uc3QgcmV0dXJuVHlwZSA9IHRoaXMuZ2V0VHlwZShhcnJOb2RlKTtcbiAgICBjb25zdCBhcnJMZW4gPSBhcnJOb2RlLmVsZW1lbnRzLmxlbmd0aDtcbiAgICBjb25zdCBlbGVtZW50cyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyTGVuOyArK2kpIHtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSBbXTtcbiAgICAgIHRoaXMuYXN0R2VuZXJpYyhhcnJOb2RlLmVsZW1lbnRzW2ldLCBlbGVtZW50KTtcbiAgICAgIGVsZW1lbnRzLnB1c2goZWxlbWVudC5qb2luKCcnKSk7XG4gICAgfVxuICAgIHN3aXRjaCAocmV0dXJuVHlwZSkge1xuICAgICAgY2FzZSAnTWF0cml4KDIpJzpcbiAgICAgIGNhc2UgJ01hdHJpeCgzKSc6XG4gICAgICBjYXNlICdNYXRyaXgoNCknOlxuICAgICAgICByZXRBcnIucHVzaChgWyR7ZWxlbWVudHMuam9pbignLCAnKX1dYCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0QXJyLnB1c2goYG5ldyBGbG9hdDMyQXJyYXkoWyR7ZWxlbWVudHMuam9pbignLCAnKX1dKWApO1xuICAgIH1cbiAgICByZXR1cm4gcmV0QXJyO1xuICB9XG5cbiAgYXN0RGVidWdnZXJTdGF0ZW1lbnQoYXJyTm9kZSwgcmV0QXJyKSB7XG4gICAgcmV0QXJyLnB1c2goJ2RlYnVnZ2VyOycpO1xuICAgIHJldHVybiByZXRBcnI7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIENQVUZ1bmN0aW9uTm9kZVxufTtcbn0se1wiLi4vZnVuY3Rpb24tbm9kZVwiOjEwfV0sNzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi8uLi91dGlscycpO1xuXG5mdW5jdGlvbiBjb25zdGFudHNUb1N0cmluZyhjb25zdGFudHMsIHR5cGVzKSB7XG4gIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgZm9yIChjb25zdCBuYW1lIGluIHR5cGVzKSB7XG4gICAgaWYgKCF0eXBlcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkgY29udGludWU7XG4gICAgY29uc3QgdHlwZSA9IHR5cGVzW25hbWVdO1xuICAgIGNvbnN0IGNvbnN0YW50ID0gY29uc3RhbnRzW25hbWVdO1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAnTnVtYmVyJzpcbiAgICAgIGNhc2UgJ0ludGVnZXInOlxuICAgICAgY2FzZSAnRmxvYXQnOlxuICAgICAgY2FzZSAnQm9vbGVhbic6XG4gICAgICAgIHJlc3VsdHMucHVzaChgJHtuYW1lfToke2NvbnN0YW50fWApO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0FycmF5KDIpJzpcbiAgICAgIGNhc2UgJ0FycmF5KDMpJzpcbiAgICAgIGNhc2UgJ0FycmF5KDQpJzpcbiAgICAgIGNhc2UgJ01hdHJpeCgyKSc6XG4gICAgICBjYXNlICdNYXRyaXgoMyknOlxuICAgICAgY2FzZSAnTWF0cml4KDQpJzpcbiAgICAgICAgcmVzdWx0cy5wdXNoKGAke25hbWV9Om5ldyAke2NvbnN0YW50LmNvbnN0cnVjdG9yLm5hbWV9KCR7SlNPTi5zdHJpbmdpZnkoQXJyYXkuZnJvbShjb25zdGFudCkpfSlgKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBgeyAkeyByZXN1bHRzLmpvaW4oKSB9IH1gO1xufVxuXG5mdW5jdGlvbiBjcHVLZXJuZWxTdHJpbmcoY3B1S2VybmVsLCBuYW1lKSB7XG4gIGNvbnN0IGhlYWRlciA9IFtdO1xuICBjb25zdCB0aGlzUHJvcGVydGllcyA9IFtdO1xuICBjb25zdCBiZWZvcmVSZXR1cm4gPSBbXTtcblxuICBjb25zdCB1c2VGdW5jdGlvbktleXdvcmQgPSAhL15mdW5jdGlvbi8udGVzdChjcHVLZXJuZWwuY29sb3IudG9TdHJpbmcoKSk7XG5cbiAgaGVhZGVyLnB1c2goXG4gICAgJyAgY29uc3QgeyBjb250ZXh0LCBjYW52YXMsIGNvbnN0YW50czogaW5jb21pbmdDb25zdGFudHMgfSA9IHNldHRpbmdzOycsXG4gICAgYCAgY29uc3Qgb3V0cHV0ID0gbmV3IEludDMyQXJyYXkoJHtKU09OLnN0cmluZ2lmeShBcnJheS5mcm9tKGNwdUtlcm5lbC5vdXRwdXQpKX0pO2AsXG4gICAgYCAgY29uc3QgX2NvbnN0YW50VHlwZXMgPSAke0pTT04uc3RyaW5naWZ5KGNwdUtlcm5lbC5jb25zdGFudFR5cGVzKX07YCxcbiAgICBgICBjb25zdCBfY29uc3RhbnRzID0gJHtjb25zdGFudHNUb1N0cmluZyhjcHVLZXJuZWwuY29uc3RhbnRzLCBjcHVLZXJuZWwuY29uc3RhbnRUeXBlcyl9O2BcbiAgKTtcblxuICB0aGlzUHJvcGVydGllcy5wdXNoKFxuICAgICcgICAgY29uc3RhbnRzOiBfY29uc3RhbnRzLCcsXG4gICAgJyAgICBjb250ZXh0LCcsXG4gICAgJyAgICBvdXRwdXQsJyxcbiAgICAnICAgIHRocmVhZDoge3g6IDAsIHk6IDAsIHo6IDB9LCdcbiAgKTtcblxuICBpZiAoY3B1S2VybmVsLmdyYXBoaWNhbCkge1xuICAgIGhlYWRlci5wdXNoKGAgIGNvbnN0IF9pbWFnZURhdGEgPSBjb250ZXh0LmNyZWF0ZUltYWdlRGF0YSgke2NwdUtlcm5lbC5vdXRwdXRbMF19LCAke2NwdUtlcm5lbC5vdXRwdXRbMV19KTtgKTtcbiAgICBoZWFkZXIucHVzaChgICBjb25zdCBfY29sb3JEYXRhID0gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KCR7Y3B1S2VybmVsLm91dHB1dFswXX0gKiAke2NwdUtlcm5lbC5vdXRwdXRbMV19ICogNCk7YCk7XG5cbiAgICBjb25zdCBjb2xvckZuID0gdXRpbHMuZmxhdHRlbkZ1bmN0aW9uVG9TdHJpbmcoKHVzZUZ1bmN0aW9uS2V5d29yZCA/ICdmdW5jdGlvbiAnIDogJycpICsgY3B1S2VybmVsLmNvbG9yLnRvU3RyaW5nKCksIHtcbiAgICAgIHRoaXNMb29rdXA6IChwcm9wZXJ0eU5hbWUpID0+IHtcbiAgICAgICAgc3dpdGNoIChwcm9wZXJ0eU5hbWUpIHtcbiAgICAgICAgICBjYXNlICdfY29sb3JEYXRhJzpcbiAgICAgICAgICAgIHJldHVybiAnX2NvbG9yRGF0YSc7XG4gICAgICAgICAgY2FzZSAnX2ltYWdlRGF0YSc6XG4gICAgICAgICAgICByZXR1cm4gJ19pbWFnZURhdGEnO1xuICAgICAgICAgIGNhc2UgJ291dHB1dCc6XG4gICAgICAgICAgICByZXR1cm4gJ291dHB1dCc7XG4gICAgICAgICAgY2FzZSAndGhyZWFkJzpcbiAgICAgICAgICAgIHJldHVybiAndGhpcy50aHJlYWQnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShjcHVLZXJuZWxbcHJvcGVydHlOYW1lXSk7XG4gICAgICB9LFxuICAgICAgZmluZERlcGVuZGVuY3k6IChvYmplY3QsIG5hbWUpID0+IHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBjb25zdCBnZXRQaXhlbHNGbiA9IHV0aWxzLmZsYXR0ZW5GdW5jdGlvblRvU3RyaW5nKCh1c2VGdW5jdGlvbktleXdvcmQgPyAnZnVuY3Rpb24gJyA6ICcnKSArIGNwdUtlcm5lbC5nZXRQaXhlbHMudG9TdHJpbmcoKSwge1xuICAgICAgdGhpc0xvb2t1cDogKHByb3BlcnR5TmFtZSkgPT4ge1xuICAgICAgICBzd2l0Y2ggKHByb3BlcnR5TmFtZSkge1xuICAgICAgICAgIGNhc2UgJ19jb2xvckRhdGEnOlxuICAgICAgICAgICAgcmV0dXJuICdfY29sb3JEYXRhJztcbiAgICAgICAgICBjYXNlICdfaW1hZ2VEYXRhJzpcbiAgICAgICAgICAgIHJldHVybiAnX2ltYWdlRGF0YSc7XG4gICAgICAgICAgY2FzZSAnb3V0cHV0JzpcbiAgICAgICAgICAgIHJldHVybiAnb3V0cHV0JztcbiAgICAgICAgICBjYXNlICd0aHJlYWQnOlxuICAgICAgICAgICAgcmV0dXJuICd0aGlzLnRocmVhZCc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGNwdUtlcm5lbFtwcm9wZXJ0eU5hbWVdKTtcbiAgICAgIH0sXG4gICAgICBmaW5kRGVwZW5kZW5jeTogKCkgPT4ge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRoaXNQcm9wZXJ0aWVzLnB1c2goXG4gICAgICAnICAgIF9pbWFnZURhdGEsJyxcbiAgICAgICcgICAgX2NvbG9yRGF0YSwnLFxuICAgICAgYCAgICBjb2xvcjogJHtjb2xvckZufSxgXG4gICAgKTtcblxuICAgIGJlZm9yZVJldHVybi5wdXNoKFxuICAgICAgYCAga2VybmVsLmdldFBpeGVscyA9ICR7Z2V0UGl4ZWxzRm59O2BcbiAgICApO1xuICB9XG5cbiAgY29uc3QgY29uc3RhbnRUeXBlcyA9IFtdO1xuICBjb25zdCBjb25zdGFudEtleXMgPSBPYmplY3Qua2V5cyhjcHVLZXJuZWwuY29uc3RhbnRUeXBlcyk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY29uc3RhbnRLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3RhbnRUeXBlcy5wdXNoKGNwdUtlcm5lbC5jb25zdGFudFR5cGVzW2NvbnN0YW50S2V5c10pO1xuICB9XG4gIGlmIChjcHVLZXJuZWwuYXJndW1lbnRUeXBlcy5pbmRleE9mKCdIVE1MSW1hZ2VBcnJheScpICE9PSAtMSB8fCBjb25zdGFudFR5cGVzLmluZGV4T2YoJ0hUTUxJbWFnZUFycmF5JykgIT09IC0xKSB7XG4gICAgY29uc3QgZmxhdHRlbmVkSW1hZ2VUbzNEQXJyYXkgPSB1dGlscy5mbGF0dGVuRnVuY3Rpb25Ub1N0cmluZygodXNlRnVuY3Rpb25LZXl3b3JkID8gJ2Z1bmN0aW9uICcgOiAnJykgKyBjcHVLZXJuZWwuX2ltYWdlVG8zREFycmF5LnRvU3RyaW5nKCksIHtcbiAgICAgIGRvTm90RGVmaW5lOiBbJ2NhbnZhcyddLFxuICAgICAgZmluZERlcGVuZGVuY3k6IChvYmplY3QsIG5hbWUpID0+IHtcbiAgICAgICAgaWYgKG9iamVjdCA9PT0gJ3RoaXMnKSB7XG4gICAgICAgICAgcmV0dXJuICh1c2VGdW5jdGlvbktleXdvcmQgPyAnZnVuY3Rpb24gJyA6ICcnKSArIGNwdUtlcm5lbFtuYW1lXS50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSxcbiAgICAgIHRoaXNMb29rdXA6IChwcm9wZXJ0eU5hbWUpID0+IHtcbiAgICAgICAgc3dpdGNoIChwcm9wZXJ0eU5hbWUpIHtcbiAgICAgICAgICBjYXNlICdjYW52YXMnOlxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIGNhc2UgJ2NvbnRleHQnOlxuICAgICAgICAgICAgcmV0dXJuICdjb250ZXh0JztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIGJlZm9yZVJldHVybi5wdXNoKGZsYXR0ZW5lZEltYWdlVG8zREFycmF5KTtcbiAgICB0aGlzUHJvcGVydGllcy5wdXNoKGAgICAgX21lZGlhVG8yREFycmF5LGApO1xuICAgIHRoaXNQcm9wZXJ0aWVzLnB1c2goYCAgICBfaW1hZ2VUbzNEQXJyYXksYCk7XG4gIH0gZWxzZSBpZiAoY3B1S2VybmVsLmFyZ3VtZW50VHlwZXMuaW5kZXhPZignSFRNTEltYWdlJykgIT09IC0xIHx8IGNvbnN0YW50VHlwZXMuaW5kZXhPZignSFRNTEltYWdlJykgIT09IC0xKSB7XG4gICAgY29uc3QgZmxhdHRlbmVkSW1hZ2VUbzJEQXJyYXkgPSB1dGlscy5mbGF0dGVuRnVuY3Rpb25Ub1N0cmluZygodXNlRnVuY3Rpb25LZXl3b3JkID8gJ2Z1bmN0aW9uICcgOiAnJykgKyBjcHVLZXJuZWwuX21lZGlhVG8yREFycmF5LnRvU3RyaW5nKCksIHtcbiAgICAgIGZpbmREZXBlbmRlbmN5OiAob2JqZWN0LCBuYW1lKSA9PiB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSxcbiAgICAgIHRoaXNMb29rdXA6IChwcm9wZXJ0eU5hbWUpID0+IHtcbiAgICAgICAgc3dpdGNoIChwcm9wZXJ0eU5hbWUpIHtcbiAgICAgICAgICBjYXNlICdjYW52YXMnOlxuICAgICAgICAgICAgcmV0dXJuICdzZXR0aW5ncy5jYW52YXMnO1xuICAgICAgICAgIGNhc2UgJ2NvbnRleHQnOlxuICAgICAgICAgICAgcmV0dXJuICdzZXR0aW5ncy5jb250ZXh0JztcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VuaGFuZGxlZCB0aGlzTG9va3VwJyk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgYmVmb3JlUmV0dXJuLnB1c2goZmxhdHRlbmVkSW1hZ2VUbzJEQXJyYXkpO1xuICAgIHRoaXNQcm9wZXJ0aWVzLnB1c2goYCAgICBfbWVkaWFUbzJEQXJyYXksYCk7XG4gIH1cblxuICByZXR1cm4gYGZ1bmN0aW9uKHNldHRpbmdzKSB7XG4keyBoZWFkZXIuam9pbignXFxuJykgfVxuICBmb3IgKGNvbnN0IHAgaW4gX2NvbnN0YW50VHlwZXMpIHtcbiAgICBpZiAoIV9jb25zdGFudFR5cGVzLmhhc093blByb3BlcnR5KHApKSBjb250aW51ZTtcbiAgICBjb25zdCB0eXBlID0gX2NvbnN0YW50VHlwZXNbcF07XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlICdOdW1iZXInOlxuICAgICAgY2FzZSAnSW50ZWdlcic6XG4gICAgICBjYXNlICdGbG9hdCc6XG4gICAgICBjYXNlICdCb29sZWFuJzpcbiAgICAgIGNhc2UgJ0FycmF5KDIpJzpcbiAgICAgIGNhc2UgJ0FycmF5KDMpJzpcbiAgICAgIGNhc2UgJ0FycmF5KDQpJzpcbiAgICAgIGNhc2UgJ01hdHJpeCgyKSc6XG4gICAgICBjYXNlICdNYXRyaXgoMyknOlxuICAgICAgY2FzZSAnTWF0cml4KDQpJzpcbiAgICAgICAgaWYgKGluY29taW5nQ29uc3RhbnRzLmhhc093blByb3BlcnR5KHApKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKCdjb25zdGFudCAnICsgcCArICcgb2YgdHlwZSAnICsgdHlwZSArICcgY2Fubm90IGJlIHJlc2lnbmVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmICghaW5jb21pbmdDb25zdGFudHMuaGFzT3duUHJvcGVydHkocCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY29uc3RhbnQgJyArIHAgKyAnIG5vdCBmb3VuZCcpO1xuICAgIH1cbiAgICBfY29uc3RhbnRzW3BdID0gaW5jb21pbmdDb25zdGFudHNbcF07XG4gIH1cbiAgY29uc3Qga2VybmVsID0gKGZ1bmN0aW9uKCkge1xuJHtjcHVLZXJuZWwuX2tlcm5lbFN0cmluZ31cbiAgfSlcbiAgICAuYXBwbHkoeyAke3RoaXNQcm9wZXJ0aWVzLmpvaW4oJ1xcbicpfSB9KTtcbiAgJHsgYmVmb3JlUmV0dXJuLmpvaW4oJ1xcbicpIH1cbiAgcmV0dXJuIGtlcm5lbDtcbn1gO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgY3B1S2VybmVsU3RyaW5nXG59O1xufSx7XCIuLi8uLi91dGlsc1wiOjExNH1dLDg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyBLZXJuZWwgfSA9IHJlcXVpcmUoJy4uL2tlcm5lbCcpO1xuY29uc3QgeyBGdW5jdGlvbkJ1aWxkZXIgfSA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9uLWJ1aWxkZXInKTtcbmNvbnN0IHsgQ1BVRnVuY3Rpb25Ob2RlIH0gPSByZXF1aXJlKCcuL2Z1bmN0aW9uLW5vZGUnKTtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzJyk7XG5jb25zdCB7IGNwdUtlcm5lbFN0cmluZyB9ID0gcmVxdWlyZSgnLi9rZXJuZWwtc3RyaW5nJyk7XG5cbmNsYXNzIENQVUtlcm5lbCBleHRlbmRzIEtlcm5lbCB7XG4gIHN0YXRpYyBnZXRGZWF0dXJlcygpIHtcbiAgICByZXR1cm4gdGhpcy5mZWF0dXJlcztcbiAgfVxuICBzdGF0aWMgZ2V0IGZlYXR1cmVzKCkge1xuICAgIHJldHVybiBPYmplY3QuZnJlZXplKHtcbiAgICAgIGtlcm5lbE1hcDogdHJ1ZSxcbiAgICAgIGlzSW50ZWdlckRpdmlzaW9uQWNjdXJhdGU6IHRydWVcbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgZ2V0IGlzU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHN0YXRpYyBpc0NvbnRleHRNYXRjaChjb250ZXh0KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHN0YXRpYyBnZXQgbW9kZSgpIHtcbiAgICByZXR1cm4gJ2NwdSc7XG4gIH1cblxuICBzdGF0aWMgbmF0aXZlRnVuY3Rpb25Bcmd1bWVudHMoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBzdGF0aWMgbmF0aXZlRnVuY3Rpb25SZXR1cm5UeXBlKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgTG9va2luZyB1cCBuYXRpdmUgZnVuY3Rpb24gcmV0dXJuIHR5cGUgbm90IHN1cHBvcnRlZCBvbiAke3RoaXMubmFtZX1gKTtcbiAgfVxuXG4gIHN0YXRpYyBjb21iaW5lS2VybmVscyhjb21iaW5lZEtlcm5lbCkge1xuICAgIHJldHVybiBjb21iaW5lZEtlcm5lbDtcbiAgfVxuXG4gIHN0YXRpYyBnZXRTaWduYXR1cmUoa2VybmVsLCBhcmd1bWVudFR5cGVzKSB7XG4gICAgcmV0dXJuICdjcHUnICsgKGFyZ3VtZW50VHlwZXMubGVuZ3RoID4gMCA/ICc6JyArIGFyZ3VtZW50VHlwZXMuam9pbignLCcpIDogJycpO1xuICB9XG5cbiAgY29uc3RydWN0b3Ioc291cmNlLCBzZXR0aW5ncykge1xuICAgIHN1cGVyKHNvdXJjZSwgc2V0dGluZ3MpO1xuICAgIHRoaXMubWVyZ2VTZXR0aW5ncyhzb3VyY2Uuc2V0dGluZ3MgfHwgc2V0dGluZ3MpO1xuXG4gICAgdGhpcy5faW1hZ2VEYXRhID0gbnVsbDtcbiAgICB0aGlzLl9jb2xvckRhdGEgPSBudWxsO1xuICAgIHRoaXMuX2tlcm5lbFN0cmluZyA9IG51bGw7XG4gICAgdGhpcy5fcHJlcGVuZGVkU3RyaW5nID0gW107XG4gICAgdGhpcy50aHJlYWQgPSB7XG4gICAgICB4OiAwLFxuICAgICAgeTogMCxcbiAgICAgIHo6IDBcbiAgICB9O1xuICAgIHRoaXMudHJhbnNsYXRlZFNvdXJjZXMgPSBudWxsO1xuICB9XG5cbiAgaW5pdENhbnZhcygpIHtcbiAgICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIE9mZnNjcmVlbkNhbnZhcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiBuZXcgT2Zmc2NyZWVuQ2FudmFzKDAsIDApO1xuICAgIH1cbiAgfVxuXG4gIGluaXRDb250ZXh0KCkge1xuICAgIGlmICghdGhpcy5jYW52YXMpIHJldHVybiBudWxsO1xuICAgIHJldHVybiB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICB9XG5cbiAgaW5pdFBsdWdpbnMoc2V0dGluZ3MpIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICB2YWxpZGF0ZVNldHRpbmdzKGFyZ3MpIHtcbiAgICBpZiAoIXRoaXMub3V0cHV0IHx8IHRoaXMub3V0cHV0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgaWYgKGFyZ3MubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQXV0byBvdXRwdXQgb25seSBzdXBwb3J0ZWQgZm9yIGtlcm5lbHMgd2l0aCBvbmx5IG9uZSBpbnB1dCcpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBhcmdUeXBlID0gdXRpbHMuZ2V0VmFyaWFibGVUeXBlKGFyZ3NbMF0sIHRoaXMuc3RyaWN0SW50ZWdlcnMpO1xuICAgICAgaWYgKGFyZ1R5cGUgPT09ICdBcnJheScpIHtcbiAgICAgICAgdGhpcy5vdXRwdXQgPSB1dGlscy5nZXREaW1lbnNpb25zKGFyZ1R5cGUpO1xuICAgICAgfSBlbHNlIGlmIChhcmdUeXBlID09PSAnTnVtYmVyVGV4dHVyZScgfHwgYXJnVHlwZSA9PT0gJ0FycmF5VGV4dHVyZSg0KScpIHtcbiAgICAgICAgdGhpcy5vdXRwdXQgPSBhcmdzWzBdLm91dHB1dDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQXV0byBvdXRwdXQgbm90IHN1cHBvcnRlZCBmb3IgaW5wdXQgdHlwZTogJyArIGFyZ1R5cGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLmdyYXBoaWNhbCkge1xuICAgICAgaWYgKHRoaXMub3V0cHV0Lmxlbmd0aCAhPT0gMikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ091dHB1dCBtdXN0IGhhdmUgMiBkaW1lbnNpb25zIG9uIGdyYXBoaWNhbCBtb2RlJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5jaGVja091dHB1dCgpO1xuICB9XG5cbiAgdHJhbnNsYXRlU291cmNlKCkge1xuICAgIHRoaXMubGVhZGluZ1JldHVyblN0YXRlbWVudCA9IHRoaXMub3V0cHV0Lmxlbmd0aCA+IDEgPyAncmVzdWx0WFt4XSA9ICcgOiAncmVzdWx0W3hdID0gJztcbiAgICBpZiAodGhpcy5zdWJLZXJuZWxzKSB7XG4gICAgICBjb25zdCBmb2xsb3dpbmdSZXR1cm5TdGF0ZW1lbnQgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zdWJLZXJuZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBuYW1lXG4gICAgICAgIH0gPSB0aGlzLnN1Yktlcm5lbHNbaV07XG4gICAgICAgIGZvbGxvd2luZ1JldHVyblN0YXRlbWVudC5wdXNoKHRoaXMub3V0cHV0Lmxlbmd0aCA+IDEgPyBgcmVzdWx0WF8keyBuYW1lIH1beF0gPSBzdWJLZXJuZWxSZXN1bHRfJHsgbmFtZSB9O1xcbmAgOiBgcmVzdWx0XyR7IG5hbWUgfVt4XSA9IHN1Yktlcm5lbFJlc3VsdF8keyBuYW1lIH07XFxuYCk7XG4gICAgICB9XG4gICAgICB0aGlzLmZvbGxvd2luZ1JldHVyblN0YXRlbWVudCA9IGZvbGxvd2luZ1JldHVyblN0YXRlbWVudC5qb2luKCcnKTtcbiAgICB9XG4gICAgY29uc3QgZnVuY3Rpb25CdWlsZGVyID0gRnVuY3Rpb25CdWlsZGVyLmZyb21LZXJuZWwodGhpcywgQ1BVRnVuY3Rpb25Ob2RlKTtcbiAgICB0aGlzLnRyYW5zbGF0ZWRTb3VyY2VzID0gZnVuY3Rpb25CdWlsZGVyLmdldFByb3RvdHlwZXMoJ2tlcm5lbCcpO1xuICAgIGlmICghdGhpcy5ncmFwaGljYWwgJiYgIXRoaXMucmV0dXJuVHlwZSkge1xuICAgICAgdGhpcy5yZXR1cm5UeXBlID0gZnVuY3Rpb25CdWlsZGVyLmdldEtlcm5lbFJlc3VsdFR5cGUoKTtcbiAgICB9XG4gIH1cblxuICBidWlsZCgpIHtcbiAgICBpZiAodGhpcy5idWlsdCkgcmV0dXJuO1xuICAgIHRoaXMuc2V0dXBDb25zdGFudHMoKTtcbiAgICB0aGlzLnNldHVwQXJndW1lbnRzKGFyZ3VtZW50cyk7XG4gICAgdGhpcy52YWxpZGF0ZVNldHRpbmdzKGFyZ3VtZW50cyk7XG4gICAgdGhpcy50cmFuc2xhdGVTb3VyY2UoKTtcblxuICAgIGlmICh0aGlzLmdyYXBoaWNhbCkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBjYW52YXMsXG4gICAgICAgIG91dHB1dFxuICAgICAgfSA9IHRoaXM7XG4gICAgICBpZiAoIWNhbnZhcykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vIGNhbnZhcyBhdmFpbGFibGUgZm9yIHVzaW5nIGdyYXBoaWNhbCBvdXRwdXQnKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHdpZHRoID0gb3V0cHV0WzBdO1xuICAgICAgY29uc3QgaGVpZ2h0ID0gb3V0cHV0WzFdIHx8IDE7XG4gICAgICBjYW52YXMud2lkdGggPSB3aWR0aDtcbiAgICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICB0aGlzLl9pbWFnZURhdGEgPSB0aGlzLmNvbnRleHQuY3JlYXRlSW1hZ2VEYXRhKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgdGhpcy5fY29sb3JEYXRhID0gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KHdpZHRoICogaGVpZ2h0ICogNCk7XG4gICAgfVxuXG4gICAgY29uc3Qga2VybmVsU3RyaW5nID0gdGhpcy5nZXRLZXJuZWxTdHJpbmcoKTtcbiAgICB0aGlzLmtlcm5lbFN0cmluZyA9IGtlcm5lbFN0cmluZztcblxuICAgIGlmICh0aGlzLmRlYnVnKSB7XG4gICAgICBjb25zb2xlLmxvZygnRnVuY3Rpb24gb3V0cHV0OicpO1xuICAgICAgY29uc29sZS5sb2coa2VybmVsU3RyaW5nKTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgdGhpcy5ydW4gPSBuZXcgRnVuY3Rpb24oW10sIGtlcm5lbFN0cmluZykuYmluZCh0aGlzKSgpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0FuIGVycm9yIG9jY3VycmVkIGNvbXBpbGluZyB0aGUgamF2YXNjcmlwdDogJywgZSk7XG4gICAgfVxuICAgIHRoaXMuYnVpbGRTaWduYXR1cmUoYXJndW1lbnRzKTtcbiAgICB0aGlzLmJ1aWx0ID0gdHJ1ZTtcbiAgfVxuXG4gIGNvbG9yKHIsIGcsIGIsIGEpIHtcbiAgICBpZiAodHlwZW9mIGEgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBhID0gMTtcbiAgICB9XG5cbiAgICByID0gTWF0aC5mbG9vcihyICogMjU1KTtcbiAgICBnID0gTWF0aC5mbG9vcihnICogMjU1KTtcbiAgICBiID0gTWF0aC5mbG9vcihiICogMjU1KTtcbiAgICBhID0gTWF0aC5mbG9vcihhICogMjU1KTtcblxuICAgIGNvbnN0IHdpZHRoID0gdGhpcy5vdXRwdXRbMF07XG4gICAgY29uc3QgaGVpZ2h0ID0gdGhpcy5vdXRwdXRbMV07XG5cbiAgICBjb25zdCB4ID0gdGhpcy50aHJlYWQueDtcbiAgICBjb25zdCB5ID0gaGVpZ2h0IC0gdGhpcy50aHJlYWQueSAtIDE7XG5cbiAgICBjb25zdCBpbmRleCA9IHggKyB5ICogd2lkdGg7XG5cbiAgICB0aGlzLl9jb2xvckRhdGFbaW5kZXggKiA0ICsgMF0gPSByO1xuICAgIHRoaXMuX2NvbG9yRGF0YVtpbmRleCAqIDQgKyAxXSA9IGc7XG4gICAgdGhpcy5fY29sb3JEYXRhW2luZGV4ICogNCArIDJdID0gYjtcbiAgICB0aGlzLl9jb2xvckRhdGFbaW5kZXggKiA0ICsgM10gPSBhO1xuICB9XG5cbiAgZ2V0S2VybmVsU3RyaW5nKCkge1xuICAgIGlmICh0aGlzLl9rZXJuZWxTdHJpbmcgIT09IG51bGwpIHJldHVybiB0aGlzLl9rZXJuZWxTdHJpbmc7XG5cbiAgICBsZXQga2VybmVsVGhyZWFkU3RyaW5nID0gbnVsbDtcbiAgICBsZXQge1xuICAgICAgdHJhbnNsYXRlZFNvdXJjZXNcbiAgICB9ID0gdGhpcztcbiAgICBpZiAodHJhbnNsYXRlZFNvdXJjZXMubGVuZ3RoID4gMSkge1xuICAgICAgdHJhbnNsYXRlZFNvdXJjZXMgPSB0cmFuc2xhdGVkU291cmNlcy5maWx0ZXIoZm4gPT4ge1xuICAgICAgICBpZiAoL15mdW5jdGlvbi8udGVzdChmbikpIHJldHVybiBmbjtcbiAgICAgICAga2VybmVsVGhyZWFkU3RyaW5nID0gZm47XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBrZXJuZWxUaHJlYWRTdHJpbmcgPSB0cmFuc2xhdGVkU291cmNlcy5zaGlmdCgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fa2VybmVsU3RyaW5nID0gYCAgY29uc3QgTE9PUF9NQVggPSAkeyB0aGlzLl9nZXRMb29wTWF4U3RyaW5nKCkgfTtcbiAgJHsgdGhpcy5pbmplY3RlZE5hdGl2ZSB8fCAnJyB9XG4gIGNvbnN0IF90aGlzID0gdGhpcztcbiAgJHsgdGhpcy5fcmVzdWx0S2VybmVsSGVhZGVyKCkgfVxuICAkeyB0aGlzLl9wcm9jZXNzQ29uc3RhbnRzKCkgfVxuICByZXR1cm4gKCR7IHRoaXMuYXJndW1lbnROYW1lcy5tYXAoYXJndW1lbnROYW1lID0+ICd1c2VyXycgKyBhcmd1bWVudE5hbWUpLmpvaW4oJywgJykgfSkgPT4ge1xuICAgICR7IHRoaXMuX3ByZXBlbmRlZFN0cmluZy5qb2luKCcnKSB9XG4gICAgJHsgdGhpcy5fZWFybHlUaHJvd3MoKSB9XG4gICAgJHsgdGhpcy5fcHJvY2Vzc0FyZ3VtZW50cygpIH1cbiAgICAkeyB0aGlzLmdyYXBoaWNhbCA/IHRoaXMuX2dyYXBoaWNhbEtlcm5lbEJvZHkoa2VybmVsVGhyZWFkU3RyaW5nKSA6IHRoaXMuX3Jlc3VsdEtlcm5lbEJvZHkoa2VybmVsVGhyZWFkU3RyaW5nKSB9XG4gICAgJHsgdHJhbnNsYXRlZFNvdXJjZXMubGVuZ3RoID4gMCA/IHRyYW5zbGF0ZWRTb3VyY2VzLmpvaW4oJ1xcbicpIDogJycgfVxuICB9O2A7XG4gIH1cblxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gY3B1S2VybmVsU3RyaW5nKHRoaXMpO1xuICB9XG5cbiAgX2dldExvb3BNYXhTdHJpbmcoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIHRoaXMubG9vcE1heEl0ZXJhdGlvbnMgP1xuICAgICAgYCAkeyBwYXJzZUludCh0aGlzLmxvb3BNYXhJdGVyYXRpb25zKSB9O2AgOlxuICAgICAgJyAxMDAwOydcbiAgICApO1xuICB9XG5cbiAgX3Byb2Nlc3NDb25zdGFudHMoKSB7XG4gICAgaWYgKCF0aGlzLmNvbnN0YW50cykgcmV0dXJuICcnO1xuXG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgZm9yIChsZXQgcCBpbiB0aGlzLmNvbnN0YW50cykge1xuICAgICAgY29uc3QgdHlwZSA9IHRoaXMuY29uc3RhbnRUeXBlc1twXTtcbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlICdIVE1MQ2FudmFzJzpcbiAgICAgICAgY2FzZSAnT2Zmc2NyZWVuQ2FudmFzJzpcbiAgICAgICAgY2FzZSAnSFRNTEltYWdlJzpcbiAgICAgICAgY2FzZSAnSW1hZ2VCaXRtYXAnOlxuICAgICAgICBjYXNlICdJbWFnZURhdGEnOlxuICAgICAgICBjYXNlICdIVE1MVmlkZW8nOlxuICAgICAgICAgIHJlc3VsdC5wdXNoKGAgICAgY29uc3QgY29uc3RhbnRzXyR7cH0gPSB0aGlzLl9tZWRpYVRvMkRBcnJheSh0aGlzLmNvbnN0YW50cy4ke3B9KTtcXG5gKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnSFRNTEltYWdlQXJyYXknOlxuICAgICAgICAgIHJlc3VsdC5wdXNoKGAgICAgY29uc3QgY29uc3RhbnRzXyR7cH0gPSB0aGlzLl9pbWFnZVRvM0RBcnJheSh0aGlzLmNvbnN0YW50cy4ke3B9KTtcXG5gKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnSW5wdXQnOlxuICAgICAgICAgIHJlc3VsdC5wdXNoKGAgICAgY29uc3QgY29uc3RhbnRzXyR7cH0gPSB0aGlzLmNvbnN0YW50cy4ke3B9LnZhbHVlO1xcbmApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJlc3VsdC5wdXNoKGAgICAgY29uc3QgY29uc3RhbnRzXyR7cH0gPSB0aGlzLmNvbnN0YW50cy4ke3B9O1xcbmApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0LmpvaW4oJycpO1xuICB9XG5cbiAgX2Vhcmx5VGhyb3dzKCkge1xuICAgIGlmICh0aGlzLmdyYXBoaWNhbCkgcmV0dXJuICcnO1xuICAgIGlmICh0aGlzLmltbXV0YWJsZSkgcmV0dXJuICcnO1xuICAgIGlmICghdGhpcy5waXBlbGluZSkgcmV0dXJuICcnO1xuICAgIGNvbnN0IGFycmF5QXJndW1lbnRzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmFyZ3VtZW50VHlwZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0aGlzLmFyZ3VtZW50VHlwZXNbaV0gPT09ICdBcnJheScpIHtcbiAgICAgICAgYXJyYXlBcmd1bWVudHMucHVzaCh0aGlzLmFyZ3VtZW50TmFtZXNbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoYXJyYXlBcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gJyc7XG4gICAgY29uc3QgY2hlY2tzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheUFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgYXJndW1lbnROYW1lID0gYXJyYXlBcmd1bWVudHNbaV07XG4gICAgICBjb25zdCBjaGVja1N1Yktlcm5lbHMgPSB0aGlzLl9tYXBTdWJLZXJuZWxzKHN1Yktlcm5lbCA9PiBgdXNlcl8ke2FyZ3VtZW50TmFtZX0gPT09IHJlc3VsdF8ke3N1Yktlcm5lbC5uYW1lfWApLmpvaW4oJyB8fCAnKTtcbiAgICAgIGNoZWNrcy5wdXNoKGB1c2VyXyR7YXJndW1lbnROYW1lfSA9PT0gcmVzdWx0JHtjaGVja1N1Yktlcm5lbHMgPyBgIHx8ICR7Y2hlY2tTdWJLZXJuZWxzfWAgOiAnJ31gKTtcbiAgICB9XG4gICAgcmV0dXJuIGBpZiAoJHtjaGVja3Muam9pbignIHx8ICcpfSkgdGhyb3cgbmV3IEVycm9yKCdTb3VyY2UgYW5kIGRlc3RpbmF0aW9uIGFycmF5cyBhcmUgdGhlIHNhbWUuICBVc2UgaW1tdXRhYmxlID0gdHJ1ZScpO2A7XG4gIH1cblxuICBfcHJvY2Vzc0FyZ3VtZW50cygpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuYXJndW1lbnRUeXBlcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgdmFyaWFibGVOYW1lID0gYHVzZXJfJHt0aGlzLmFyZ3VtZW50TmFtZXNbaV19YDtcbiAgICAgIHN3aXRjaCAodGhpcy5hcmd1bWVudFR5cGVzW2ldKSB7XG4gICAgICAgIGNhc2UgJ0hUTUxDYW52YXMnOlxuICAgICAgICBjYXNlICdPZmZzY3JlZW5DYW52YXMnOlxuICAgICAgICBjYXNlICdIVE1MSW1hZ2UnOlxuICAgICAgICBjYXNlICdJbWFnZUJpdG1hcCc6XG4gICAgICAgIGNhc2UgJ0ltYWdlRGF0YSc6XG4gICAgICAgIGNhc2UgJ0hUTUxWaWRlbyc6XG4gICAgICAgICAgcmVzdWx0LnB1c2goYCAgICAke3ZhcmlhYmxlTmFtZX0gPSB0aGlzLl9tZWRpYVRvMkRBcnJheSgke3ZhcmlhYmxlTmFtZX0pO1xcbmApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdIVE1MSW1hZ2VBcnJheSc6XG4gICAgICAgICAgcmVzdWx0LnB1c2goYCAgICAke3ZhcmlhYmxlTmFtZX0gPSB0aGlzLl9pbWFnZVRvM0RBcnJheSgke3ZhcmlhYmxlTmFtZX0pO1xcbmApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdJbnB1dCc6XG4gICAgICAgICAgcmVzdWx0LnB1c2goYCAgICAke3ZhcmlhYmxlTmFtZX0gPSAke3ZhcmlhYmxlTmFtZX0udmFsdWU7XFxuYCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ0FycmF5VGV4dHVyZSgxKSc6XG4gICAgICAgIGNhc2UgJ0FycmF5VGV4dHVyZSgyKSc6XG4gICAgICAgIGNhc2UgJ0FycmF5VGV4dHVyZSgzKSc6XG4gICAgICAgIGNhc2UgJ0FycmF5VGV4dHVyZSg0KSc6XG4gICAgICAgIGNhc2UgJ051bWJlclRleHR1cmUnOlxuICAgICAgICBjYXNlICdNZW1vcnlPcHRpbWl6ZWROdW1iZXJUZXh0dXJlJzpcbiAgICAgICAgICByZXN1bHQucHVzaChgXG4gICAgaWYgKCR7dmFyaWFibGVOYW1lfS50b0FycmF5KSB7XG4gICAgICBpZiAoIV90aGlzLnRleHR1cmVDYWNoZSkge1xuICAgICAgICBfdGhpcy50ZXh0dXJlQ2FjaGUgPSBbXTtcbiAgICAgICAgX3RoaXMuYXJyYXlDYWNoZSA9IFtdO1xuICAgICAgfVxuICAgICAgY29uc3QgdGV4dHVyZUluZGV4ID0gX3RoaXMudGV4dHVyZUNhY2hlLmluZGV4T2YoJHt2YXJpYWJsZU5hbWV9KTtcbiAgICAgIGlmICh0ZXh0dXJlSW5kZXggIT09IC0xKSB7XG4gICAgICAgICR7dmFyaWFibGVOYW1lfSA9IF90aGlzLmFycmF5Q2FjaGVbdGV4dHVyZUluZGV4XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF90aGlzLnRleHR1cmVDYWNoZS5wdXNoKCR7dmFyaWFibGVOYW1lfSk7XG4gICAgICAgICR7dmFyaWFibGVOYW1lfSA9ICR7dmFyaWFibGVOYW1lfS50b0FycmF5KCk7XG4gICAgICAgIF90aGlzLmFycmF5Q2FjaGUucHVzaCgke3ZhcmlhYmxlTmFtZX0pO1xuICAgICAgfVxuICAgIH1gKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdC5qb2luKCcnKTtcbiAgfVxuXG4gIF9tZWRpYVRvMkRBcnJheShtZWRpYSkge1xuICAgIGNvbnN0IGNhbnZhcyA9IHRoaXMuY2FudmFzO1xuICAgIGNvbnN0IHdpZHRoID0gbWVkaWEud2lkdGggPiAwID8gbWVkaWEud2lkdGggOiBtZWRpYS52aWRlb1dpZHRoO1xuICAgIGNvbnN0IGhlaWdodCA9IG1lZGlhLmhlaWdodCA+IDAgPyBtZWRpYS5oZWlnaHQgOiBtZWRpYS52aWRlb0hlaWdodDtcbiAgICBpZiAoY2FudmFzLndpZHRoIDwgd2lkdGgpIHtcbiAgICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgIH1cbiAgICBpZiAoY2FudmFzLmhlaWdodCA8IGhlaWdodCkge1xuICAgICAgY2FudmFzLmhlaWdodCA9IGhlaWdodDtcbiAgICB9XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jb250ZXh0O1xuICAgIGxldCBwaXhlbHNEYXRhO1xuICAgIGlmIChtZWRpYS5jb25zdHJ1Y3RvciA9PT0gSW1hZ2VEYXRhKSB7XG4gICAgICBwaXhlbHNEYXRhID0gbWVkaWEuZGF0YTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3R4LmRyYXdJbWFnZShtZWRpYSwgMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICBwaXhlbHNEYXRhID0gY3R4LmdldEltYWdlRGF0YSgwLCAwLCB3aWR0aCwgaGVpZ2h0KS5kYXRhO1xuICAgIH1cbiAgICBjb25zdCBpbWFnZUFycmF5ID0gbmV3IEFycmF5KGhlaWdodCk7XG4gICAgbGV0IGluZGV4ID0gMDtcbiAgICBmb3IgKGxldCB5ID0gaGVpZ2h0IC0gMTsgeSA+PSAwOyB5LS0pIHtcbiAgICAgIGNvbnN0IHJvdyA9IGltYWdlQXJyYXlbeV0gPSBuZXcgQXJyYXkod2lkdGgpO1xuICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCB3aWR0aDsgeCsrKSB7XG4gICAgICAgIGNvbnN0IHBpeGVsID0gbmV3IEZsb2F0MzJBcnJheSg0KTtcbiAgICAgICAgcGl4ZWxbMF0gPSBwaXhlbHNEYXRhW2luZGV4KytdIC8gMjU1OyBcbiAgICAgICAgcGl4ZWxbMV0gPSBwaXhlbHNEYXRhW2luZGV4KytdIC8gMjU1OyBcbiAgICAgICAgcGl4ZWxbMl0gPSBwaXhlbHNEYXRhW2luZGV4KytdIC8gMjU1OyBcbiAgICAgICAgcGl4ZWxbM10gPSBwaXhlbHNEYXRhW2luZGV4KytdIC8gMjU1OyBcbiAgICAgICAgcm93W3hdID0gcGl4ZWw7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpbWFnZUFycmF5O1xuICB9XG5cbiAgZ2V0UGl4ZWxzKGZsaXApIHtcbiAgICBjb25zdCBbd2lkdGgsIGhlaWdodF0gPSB0aGlzLm91dHB1dDtcbiAgICByZXR1cm4gZmxpcCA/IHV0aWxzLmZsaXBQaXhlbHModGhpcy5faW1hZ2VEYXRhLmRhdGEsIHdpZHRoLCBoZWlnaHQpIDogdGhpcy5faW1hZ2VEYXRhLmRhdGEuc2xpY2UoMCk7XG4gIH1cblxuICBfaW1hZ2VUbzNEQXJyYXkoaW1hZ2VzKSB7XG4gICAgY29uc3QgaW1hZ2VzQXJyYXkgPSBuZXcgQXJyYXkoaW1hZ2VzLmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbWFnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGltYWdlc0FycmF5W2ldID0gdGhpcy5fbWVkaWFUbzJEQXJyYXkoaW1hZ2VzW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIGltYWdlc0FycmF5O1xuICB9XG5cbiAgX3Jlc3VsdEtlcm5lbEhlYWRlcigpIHtcbiAgICBpZiAodGhpcy5ncmFwaGljYWwpIHJldHVybiAnJztcbiAgICBpZiAodGhpcy5pbW11dGFibGUpIHJldHVybiAnJztcbiAgICBpZiAoIXRoaXMucGlwZWxpbmUpIHJldHVybiAnJztcbiAgICBzd2l0Y2ggKHRoaXMub3V0cHV0Lmxlbmd0aCkge1xuICAgICAgY2FzZSAxOlxuICAgICAgICByZXR1cm4gdGhpcy5fbXV0YWJsZUtlcm5lbDFEUmVzdWx0cygpO1xuICAgICAgY2FzZSAyOlxuICAgICAgICByZXR1cm4gdGhpcy5fbXV0YWJsZUtlcm5lbDJEUmVzdWx0cygpO1xuICAgICAgY2FzZSAzOlxuICAgICAgICByZXR1cm4gdGhpcy5fbXV0YWJsZUtlcm5lbDNEUmVzdWx0cygpO1xuICAgIH1cbiAgfVxuXG4gIF9yZXN1bHRLZXJuZWxCb2R5KGtlcm5lbFN0cmluZykge1xuICAgIHN3aXRjaCAodGhpcy5vdXRwdXQubGVuZ3RoKSB7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIHJldHVybiAoIXRoaXMuaW1tdXRhYmxlICYmIHRoaXMucGlwZWxpbmUgPyB0aGlzLl9yZXN1bHRNdXRhYmxlS2VybmVsMURMb29wKGtlcm5lbFN0cmluZykgOiB0aGlzLl9yZXN1bHRJbW11dGFibGVLZXJuZWwxRExvb3Aoa2VybmVsU3RyaW5nKSkgKyB0aGlzLl9rZXJuZWxPdXRwdXQoKTtcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgcmV0dXJuICghdGhpcy5pbW11dGFibGUgJiYgdGhpcy5waXBlbGluZSA/IHRoaXMuX3Jlc3VsdE11dGFibGVLZXJuZWwyRExvb3Aoa2VybmVsU3RyaW5nKSA6IHRoaXMuX3Jlc3VsdEltbXV0YWJsZUtlcm5lbDJETG9vcChrZXJuZWxTdHJpbmcpKSArIHRoaXMuX2tlcm5lbE91dHB1dCgpO1xuICAgICAgY2FzZSAzOlxuICAgICAgICByZXR1cm4gKCF0aGlzLmltbXV0YWJsZSAmJiB0aGlzLnBpcGVsaW5lID8gdGhpcy5fcmVzdWx0TXV0YWJsZUtlcm5lbDNETG9vcChrZXJuZWxTdHJpbmcpIDogdGhpcy5fcmVzdWx0SW1tdXRhYmxlS2VybmVsM0RMb29wKGtlcm5lbFN0cmluZykpICsgdGhpcy5fa2VybmVsT3V0cHV0KCk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vuc3VwcG9ydGVkIHNpemUga2VybmVsJyk7XG4gICAgfVxuICB9XG5cbiAgX2dyYXBoaWNhbEtlcm5lbEJvZHkoa2VybmVsVGhyZWFkU3RyaW5nKSB7XG4gICAgc3dpdGNoICh0aGlzLm91dHB1dC5sZW5ndGgpIHtcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dyYXBoaWNhbEtlcm5lbDJETG9vcChrZXJuZWxUaHJlYWRTdHJpbmcpICsgdGhpcy5fZ3JhcGhpY2FsT3V0cHV0KCk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vuc3VwcG9ydGVkIHNpemUga2VybmVsJyk7XG4gICAgfVxuICB9XG5cbiAgX2dyYXBoaWNhbE91dHB1dCgpIHtcbiAgICByZXR1cm4gYFxuICAgIHRoaXMuX2ltYWdlRGF0YS5kYXRhLnNldCh0aGlzLl9jb2xvckRhdGEpO1xuICAgIHRoaXMuY29udGV4dC5wdXRJbWFnZURhdGEodGhpcy5faW1hZ2VEYXRhLCAwLCAwKTtcbiAgICByZXR1cm47YFxuICB9XG5cbiAgX2dldEtlcm5lbFJlc3VsdFR5cGVDb25zdHJ1Y3RvclN0cmluZygpIHtcbiAgICBzd2l0Y2ggKHRoaXMucmV0dXJuVHlwZSkge1xuICAgICAgY2FzZSAnTGl0ZXJhbEludGVnZXInOlxuICAgICAgY2FzZSAnTnVtYmVyJzpcbiAgICAgIGNhc2UgJ0ludGVnZXInOlxuICAgICAgY2FzZSAnRmxvYXQnOlxuICAgICAgICByZXR1cm4gJ0Zsb2F0MzJBcnJheSc7XG4gICAgICBjYXNlICdBcnJheSgyKSc6XG4gICAgICBjYXNlICdBcnJheSgzKSc6XG4gICAgICBjYXNlICdBcnJheSg0KSc6XG4gICAgICAgIHJldHVybiAnQXJyYXknO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKHRoaXMuZ3JhcGhpY2FsKSB7XG4gICAgICAgICAgcmV0dXJuICdGbG9hdDMyQXJyYXknO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgdW5oYW5kbGVkIHJldHVyblR5cGUgJHsgdGhpcy5yZXR1cm5UeXBlIH1gKTtcbiAgICB9XG4gIH1cblxuICBfcmVzdWx0SW1tdXRhYmxlS2VybmVsMURMb29wKGtlcm5lbFN0cmluZykge1xuICAgIGNvbnN0IGNvbnN0cnVjdG9yU3RyaW5nID0gdGhpcy5fZ2V0S2VybmVsUmVzdWx0VHlwZUNvbnN0cnVjdG9yU3RyaW5nKCk7XG4gICAgcmV0dXJuIGAgIGNvbnN0IG91dHB1dFggPSBfdGhpcy5vdXRwdXRbMF07XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3ICR7Y29uc3RydWN0b3JTdHJpbmd9KG91dHB1dFgpO1xuICAgICR7IHRoaXMuX21hcFN1Yktlcm5lbHMoc3ViS2VybmVsID0+IGBjb25zdCByZXN1bHRfJHsgc3ViS2VybmVsLm5hbWUgfSA9IG5ldyAke2NvbnN0cnVjdG9yU3RyaW5nfShvdXRwdXRYKTtcXG5gKS5qb2luKCcgICAgJykgfVxuICAgICR7IHRoaXMuX21hcFN1Yktlcm5lbHMoc3ViS2VybmVsID0+IGBsZXQgc3ViS2VybmVsUmVzdWx0XyR7IHN1Yktlcm5lbC5uYW1lIH07XFxuYCkuam9pbignICAgICcpIH1cbiAgICBmb3IgKGxldCB4ID0gMDsgeCA8IG91dHB1dFg7IHgrKykge1xuICAgICAgdGhpcy50aHJlYWQueCA9IHg7XG4gICAgICB0aGlzLnRocmVhZC55ID0gMDtcbiAgICAgIHRoaXMudGhyZWFkLnogPSAwO1xuICAgICAgJHsga2VybmVsU3RyaW5nIH1cbiAgICB9YDtcbiAgfVxuXG4gIF9tdXRhYmxlS2VybmVsMURSZXN1bHRzKCkge1xuICAgIGNvbnN0IGNvbnN0cnVjdG9yU3RyaW5nID0gdGhpcy5fZ2V0S2VybmVsUmVzdWx0VHlwZUNvbnN0cnVjdG9yU3RyaW5nKCk7XG4gICAgcmV0dXJuIGAgIGNvbnN0IG91dHB1dFggPSBfdGhpcy5vdXRwdXRbMF07XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3ICR7Y29uc3RydWN0b3JTdHJpbmd9KG91dHB1dFgpO1xuICAgICR7IHRoaXMuX21hcFN1Yktlcm5lbHMoc3ViS2VybmVsID0+IGBjb25zdCByZXN1bHRfJHsgc3ViS2VybmVsLm5hbWUgfSA9IG5ldyAke2NvbnN0cnVjdG9yU3RyaW5nfShvdXRwdXRYKTtcXG5gKS5qb2luKCcgICAgJykgfVxuICAgICR7IHRoaXMuX21hcFN1Yktlcm5lbHMoc3ViS2VybmVsID0+IGBsZXQgc3ViS2VybmVsUmVzdWx0XyR7IHN1Yktlcm5lbC5uYW1lIH07XFxuYCkuam9pbignICAgICcpIH1gO1xuICB9XG5cbiAgX3Jlc3VsdE11dGFibGVLZXJuZWwxRExvb3Aoa2VybmVsU3RyaW5nKSB7XG4gICAgcmV0dXJuIGAgIGNvbnN0IG91dHB1dFggPSBfdGhpcy5vdXRwdXRbMF07XG4gICAgZm9yIChsZXQgeCA9IDA7IHggPCBvdXRwdXRYOyB4KyspIHtcbiAgICAgIHRoaXMudGhyZWFkLnggPSB4O1xuICAgICAgdGhpcy50aHJlYWQueSA9IDA7XG4gICAgICB0aGlzLnRocmVhZC56ID0gMDtcbiAgICAgICR7IGtlcm5lbFN0cmluZyB9XG4gICAgfWA7XG4gIH1cblxuICBfcmVzdWx0SW1tdXRhYmxlS2VybmVsMkRMb29wKGtlcm5lbFN0cmluZykge1xuICAgIGNvbnN0IGNvbnN0cnVjdG9yU3RyaW5nID0gdGhpcy5fZ2V0S2VybmVsUmVzdWx0VHlwZUNvbnN0cnVjdG9yU3RyaW5nKCk7XG4gICAgcmV0dXJuIGAgIGNvbnN0IG91dHB1dFggPSBfdGhpcy5vdXRwdXRbMF07XG4gICAgY29uc3Qgb3V0cHV0WSA9IF90aGlzLm91dHB1dFsxXTtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgQXJyYXkob3V0cHV0WSk7XG4gICAgJHsgdGhpcy5fbWFwU3ViS2VybmVscyhzdWJLZXJuZWwgPT4gYGNvbnN0IHJlc3VsdF8keyBzdWJLZXJuZWwubmFtZSB9ID0gbmV3IEFycmF5KG91dHB1dFkpO1xcbmApLmpvaW4oJyAgICAnKSB9XG4gICAgJHsgdGhpcy5fbWFwU3ViS2VybmVscyhzdWJLZXJuZWwgPT4gYGxldCBzdWJLZXJuZWxSZXN1bHRfJHsgc3ViS2VybmVsLm5hbWUgfTtcXG5gKS5qb2luKCcgICAgJykgfVxuICAgIGZvciAobGV0IHkgPSAwOyB5IDwgb3V0cHV0WTsgeSsrKSB7XG4gICAgICB0aGlzLnRocmVhZC56ID0gMDtcbiAgICAgIHRoaXMudGhyZWFkLnkgPSB5O1xuICAgICAgY29uc3QgcmVzdWx0WCA9IHJlc3VsdFt5XSA9IG5ldyAke2NvbnN0cnVjdG9yU3RyaW5nfShvdXRwdXRYKTtcbiAgICAgICR7IHRoaXMuX21hcFN1Yktlcm5lbHMoc3ViS2VybmVsID0+IGBjb25zdCByZXN1bHRYXyR7IHN1Yktlcm5lbC5uYW1lIH0gPSByZXN1bHRfJHtzdWJLZXJuZWwubmFtZX1beV0gPSBuZXcgJHtjb25zdHJ1Y3RvclN0cmluZ30ob3V0cHV0WCk7XFxuYCkuam9pbignJykgfVxuICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCBvdXRwdXRYOyB4KyspIHtcbiAgICAgICAgdGhpcy50aHJlYWQueCA9IHg7XG4gICAgICAgICR7IGtlcm5lbFN0cmluZyB9XG4gICAgICB9XG4gICAgfWA7XG4gIH1cblxuICBfbXV0YWJsZUtlcm5lbDJEUmVzdWx0cygpIHtcbiAgICBjb25zdCBjb25zdHJ1Y3RvclN0cmluZyA9IHRoaXMuX2dldEtlcm5lbFJlc3VsdFR5cGVDb25zdHJ1Y3RvclN0cmluZygpO1xuICAgIHJldHVybiBgICBjb25zdCBvdXRwdXRYID0gX3RoaXMub3V0cHV0WzBdO1xuICAgIGNvbnN0IG91dHB1dFkgPSBfdGhpcy5vdXRwdXRbMV07XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IEFycmF5KG91dHB1dFkpO1xuICAgICR7IHRoaXMuX21hcFN1Yktlcm5lbHMoc3ViS2VybmVsID0+IGBjb25zdCByZXN1bHRfJHsgc3ViS2VybmVsLm5hbWUgfSA9IG5ldyBBcnJheShvdXRwdXRZKTtcXG5gKS5qb2luKCcgICAgJykgfVxuICAgICR7IHRoaXMuX21hcFN1Yktlcm5lbHMoc3ViS2VybmVsID0+IGBsZXQgc3ViS2VybmVsUmVzdWx0XyR7IHN1Yktlcm5lbC5uYW1lIH07XFxuYCkuam9pbignICAgICcpIH1cbiAgICBmb3IgKGxldCB5ID0gMDsgeSA8IG91dHB1dFk7IHkrKykge1xuICAgICAgY29uc3QgcmVzdWx0WCA9IHJlc3VsdFt5XSA9IG5ldyAke2NvbnN0cnVjdG9yU3RyaW5nfShvdXRwdXRYKTtcbiAgICAgICR7IHRoaXMuX21hcFN1Yktlcm5lbHMoc3ViS2VybmVsID0+IGBjb25zdCByZXN1bHRYXyR7IHN1Yktlcm5lbC5uYW1lIH0gPSByZXN1bHRfJHtzdWJLZXJuZWwubmFtZX1beV0gPSBuZXcgJHtjb25zdHJ1Y3RvclN0cmluZ30ob3V0cHV0WCk7XFxuYCkuam9pbignJykgfVxuICAgIH1gO1xuICB9XG5cbiAgX3Jlc3VsdE11dGFibGVLZXJuZWwyRExvb3Aoa2VybmVsU3RyaW5nKSB7XG4gICAgY29uc3QgY29uc3RydWN0b3JTdHJpbmcgPSB0aGlzLl9nZXRLZXJuZWxSZXN1bHRUeXBlQ29uc3RydWN0b3JTdHJpbmcoKTtcbiAgICByZXR1cm4gYCAgY29uc3Qgb3V0cHV0WCA9IF90aGlzLm91dHB1dFswXTtcbiAgICBjb25zdCBvdXRwdXRZID0gX3RoaXMub3V0cHV0WzFdO1xuICAgIGZvciAobGV0IHkgPSAwOyB5IDwgb3V0cHV0WTsgeSsrKSB7XG4gICAgICB0aGlzLnRocmVhZC56ID0gMDtcbiAgICAgIHRoaXMudGhyZWFkLnkgPSB5O1xuICAgICAgY29uc3QgcmVzdWx0WCA9IHJlc3VsdFt5XTtcbiAgICAgICR7IHRoaXMuX21hcFN1Yktlcm5lbHMoc3ViS2VybmVsID0+IGBjb25zdCByZXN1bHRYXyR7IHN1Yktlcm5lbC5uYW1lIH0gPSByZXN1bHRfJHtzdWJLZXJuZWwubmFtZX1beV0gPSBuZXcgJHtjb25zdHJ1Y3RvclN0cmluZ30ob3V0cHV0WCk7XFxuYCkuam9pbignJykgfVxuICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCBvdXRwdXRYOyB4KyspIHtcbiAgICAgICAgdGhpcy50aHJlYWQueCA9IHg7XG4gICAgICAgICR7IGtlcm5lbFN0cmluZyB9XG4gICAgICB9XG4gICAgfWA7XG4gIH1cblxuICBfZ3JhcGhpY2FsS2VybmVsMkRMb29wKGtlcm5lbFN0cmluZykge1xuICAgIHJldHVybiBgICBjb25zdCBvdXRwdXRYID0gX3RoaXMub3V0cHV0WzBdO1xuICAgIGNvbnN0IG91dHB1dFkgPSBfdGhpcy5vdXRwdXRbMV07XG4gICAgZm9yIChsZXQgeSA9IDA7IHkgPCBvdXRwdXRZOyB5KyspIHtcbiAgICAgIHRoaXMudGhyZWFkLnogPSAwO1xuICAgICAgdGhpcy50aHJlYWQueSA9IHk7XG4gICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IG91dHB1dFg7IHgrKykge1xuICAgICAgICB0aGlzLnRocmVhZC54ID0geDtcbiAgICAgICAgJHsga2VybmVsU3RyaW5nIH1cbiAgICAgIH1cbiAgICB9YDtcbiAgfVxuXG4gIF9yZXN1bHRJbW11dGFibGVLZXJuZWwzRExvb3Aoa2VybmVsU3RyaW5nKSB7XG4gICAgY29uc3QgY29uc3RydWN0b3JTdHJpbmcgPSB0aGlzLl9nZXRLZXJuZWxSZXN1bHRUeXBlQ29uc3RydWN0b3JTdHJpbmcoKTtcbiAgICByZXR1cm4gYCAgY29uc3Qgb3V0cHV0WCA9IF90aGlzLm91dHB1dFswXTtcbiAgICBjb25zdCBvdXRwdXRZID0gX3RoaXMub3V0cHV0WzFdO1xuICAgIGNvbnN0IG91dHB1dFogPSBfdGhpcy5vdXRwdXRbMl07XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IEFycmF5KG91dHB1dFopO1xuICAgICR7IHRoaXMuX21hcFN1Yktlcm5lbHMoc3ViS2VybmVsID0+IGBjb25zdCByZXN1bHRfJHsgc3ViS2VybmVsLm5hbWUgfSA9IG5ldyBBcnJheShvdXRwdXRaKTtcXG5gKS5qb2luKCcgICAgJykgfVxuICAgICR7IHRoaXMuX21hcFN1Yktlcm5lbHMoc3ViS2VybmVsID0+IGBsZXQgc3ViS2VybmVsUmVzdWx0XyR7IHN1Yktlcm5lbC5uYW1lIH07XFxuYCkuam9pbignICAgICcpIH1cbiAgICBmb3IgKGxldCB6ID0gMDsgeiA8IG91dHB1dFo7IHorKykge1xuICAgICAgdGhpcy50aHJlYWQueiA9IHo7XG4gICAgICBjb25zdCByZXN1bHRZID0gcmVzdWx0W3pdID0gbmV3IEFycmF5KG91dHB1dFkpO1xuICAgICAgJHsgdGhpcy5fbWFwU3ViS2VybmVscyhzdWJLZXJuZWwgPT4gYGNvbnN0IHJlc3VsdFlfJHsgc3ViS2VybmVsLm5hbWUgfSA9IHJlc3VsdF8ke3N1Yktlcm5lbC5uYW1lfVt6XSA9IG5ldyBBcnJheShvdXRwdXRZKTtcXG5gKS5qb2luKCcgICAgICAnKSB9XG4gICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IG91dHB1dFk7IHkrKykge1xuICAgICAgICB0aGlzLnRocmVhZC55ID0geTtcbiAgICAgICAgY29uc3QgcmVzdWx0WCA9IHJlc3VsdFlbeV0gPSBuZXcgJHtjb25zdHJ1Y3RvclN0cmluZ30ob3V0cHV0WCk7XG4gICAgICAgICR7IHRoaXMuX21hcFN1Yktlcm5lbHMoc3ViS2VybmVsID0+IGBjb25zdCByZXN1bHRYXyR7IHN1Yktlcm5lbC5uYW1lIH0gPSByZXN1bHRZXyR7c3ViS2VybmVsLm5hbWV9W3ldID0gbmV3ICR7Y29uc3RydWN0b3JTdHJpbmd9KG91dHB1dFgpO1xcbmApLmpvaW4oJyAgICAgICAgJykgfVxuICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IG91dHB1dFg7IHgrKykge1xuICAgICAgICAgIHRoaXMudGhyZWFkLnggPSB4O1xuICAgICAgICAgICR7IGtlcm5lbFN0cmluZyB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9YDtcbiAgfVxuXG4gIF9tdXRhYmxlS2VybmVsM0RSZXN1bHRzKCkge1xuICAgIGNvbnN0IGNvbnN0cnVjdG9yU3RyaW5nID0gdGhpcy5fZ2V0S2VybmVsUmVzdWx0VHlwZUNvbnN0cnVjdG9yU3RyaW5nKCk7XG4gICAgcmV0dXJuIGAgIGNvbnN0IG91dHB1dFggPSBfdGhpcy5vdXRwdXRbMF07XG4gICAgY29uc3Qgb3V0cHV0WSA9IF90aGlzLm91dHB1dFsxXTtcbiAgICBjb25zdCBvdXRwdXRaID0gX3RoaXMub3V0cHV0WzJdO1xuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBBcnJheShvdXRwdXRaKTtcbiAgICAkeyB0aGlzLl9tYXBTdWJLZXJuZWxzKHN1Yktlcm5lbCA9PiBgY29uc3QgcmVzdWx0XyR7IHN1Yktlcm5lbC5uYW1lIH0gPSBuZXcgQXJyYXkob3V0cHV0Wik7XFxuYCkuam9pbignICAgICcpIH1cbiAgICAkeyB0aGlzLl9tYXBTdWJLZXJuZWxzKHN1Yktlcm5lbCA9PiBgbGV0IHN1Yktlcm5lbFJlc3VsdF8keyBzdWJLZXJuZWwubmFtZSB9O1xcbmApLmpvaW4oJyAgICAnKSB9XG4gICAgZm9yIChsZXQgeiA9IDA7IHogPCBvdXRwdXRaOyB6KyspIHtcbiAgICAgIGNvbnN0IHJlc3VsdFkgPSByZXN1bHRbel0gPSBuZXcgQXJyYXkob3V0cHV0WSk7XG4gICAgICAkeyB0aGlzLl9tYXBTdWJLZXJuZWxzKHN1Yktlcm5lbCA9PiBgY29uc3QgcmVzdWx0WV8keyBzdWJLZXJuZWwubmFtZSB9ID0gcmVzdWx0XyR7c3ViS2VybmVsLm5hbWV9W3pdID0gbmV3IEFycmF5KG91dHB1dFkpO1xcbmApLmpvaW4oJyAgICAgICcpIH1cbiAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgb3V0cHV0WTsgeSsrKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdFggPSByZXN1bHRZW3ldID0gbmV3ICR7Y29uc3RydWN0b3JTdHJpbmd9KG91dHB1dFgpO1xuICAgICAgICAkeyB0aGlzLl9tYXBTdWJLZXJuZWxzKHN1Yktlcm5lbCA9PiBgY29uc3QgcmVzdWx0WF8keyBzdWJLZXJuZWwubmFtZSB9ID0gcmVzdWx0WV8ke3N1Yktlcm5lbC5uYW1lfVt5XSA9IG5ldyAke2NvbnN0cnVjdG9yU3RyaW5nfShvdXRwdXRYKTtcXG5gKS5qb2luKCcgICAgICAgICcpIH1cbiAgICAgIH1cbiAgICB9YDtcbiAgfVxuXG4gIF9yZXN1bHRNdXRhYmxlS2VybmVsM0RMb29wKGtlcm5lbFN0cmluZykge1xuICAgIHJldHVybiBgICBjb25zdCBvdXRwdXRYID0gX3RoaXMub3V0cHV0WzBdO1xuICAgIGNvbnN0IG91dHB1dFkgPSBfdGhpcy5vdXRwdXRbMV07XG4gICAgY29uc3Qgb3V0cHV0WiA9IF90aGlzLm91dHB1dFsyXTtcbiAgICBmb3IgKGxldCB6ID0gMDsgeiA8IG91dHB1dFo7IHorKykge1xuICAgICAgdGhpcy50aHJlYWQueiA9IHo7XG4gICAgICBjb25zdCByZXN1bHRZID0gcmVzdWx0W3pdO1xuICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCBvdXRwdXRZOyB5KyspIHtcbiAgICAgICAgdGhpcy50aHJlYWQueSA9IHk7XG4gICAgICAgIGNvbnN0IHJlc3VsdFggPSByZXN1bHRZW3ldO1xuICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IG91dHB1dFg7IHgrKykge1xuICAgICAgICAgIHRoaXMudGhyZWFkLnggPSB4O1xuICAgICAgICAgICR7IGtlcm5lbFN0cmluZyB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9YDtcbiAgfVxuXG4gIF9rZXJuZWxPdXRwdXQoKSB7XG4gICAgaWYgKCF0aGlzLnN1Yktlcm5lbHMpIHtcbiAgICAgIHJldHVybiAnXFxuICAgIHJldHVybiByZXN1bHQ7JztcbiAgICB9XG4gICAgcmV0dXJuIGBcXG4gICAgcmV0dXJuIHtcbiAgICAgIHJlc3VsdDogcmVzdWx0LFxuICAgICAgJHsgdGhpcy5zdWJLZXJuZWxzLm1hcChzdWJLZXJuZWwgPT4gYCR7IHN1Yktlcm5lbC5wcm9wZXJ0eSB9OiByZXN1bHRfJHsgc3ViS2VybmVsLm5hbWUgfWApLmpvaW4oJyxcXG4gICAgICAnKSB9XG4gICAgfTtgO1xuICB9XG5cbiAgX21hcFN1Yktlcm5lbHMoZm4pIHtcbiAgICByZXR1cm4gdGhpcy5zdWJLZXJuZWxzID09PSBudWxsID8gWycnXSA6XG4gICAgICB0aGlzLnN1Yktlcm5lbHMubWFwKGZuKTtcbiAgfVxuXG4gIGRlc3Ryb3kocmVtb3ZlQ2FudmFzUmVmZXJlbmNlKSB7XG4gICAgaWYgKHJlbW92ZUNhbnZhc1JlZmVyZW5jZSkge1xuICAgICAgZGVsZXRlIHRoaXMuY2FudmFzO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBkZXN0cm95Q29udGV4dChjb250ZXh0KSB7fVxuXG4gIHRvSlNPTigpIHtcbiAgICBjb25zdCBqc29uID0gc3VwZXIudG9KU09OKCk7XG4gICAganNvbi5mdW5jdGlvbk5vZGVzID0gRnVuY3Rpb25CdWlsZGVyLmZyb21LZXJuZWwodGhpcywgQ1BVRnVuY3Rpb25Ob2RlKS50b0pTT04oKTtcbiAgICByZXR1cm4ganNvbjtcbiAgfVxuXG4gIHNldE91dHB1dChvdXRwdXQpIHtcbiAgICBzdXBlci5zZXRPdXRwdXQob3V0cHV0KTtcbiAgICBjb25zdCBbd2lkdGgsIGhlaWdodF0gPSB0aGlzLm91dHB1dDtcbiAgICBpZiAodGhpcy5ncmFwaGljYWwpIHtcbiAgICAgIHRoaXMuX2ltYWdlRGF0YSA9IHRoaXMuY29udGV4dC5jcmVhdGVJbWFnZURhdGEod2lkdGgsIGhlaWdodCk7XG4gICAgICB0aGlzLl9jb2xvckRhdGEgPSBuZXcgVWludDhDbGFtcGVkQXJyYXkod2lkdGggKiBoZWlnaHQgKiA0KTtcbiAgICB9XG4gIH1cblxuICBwcmVwZW5kU3RyaW5nKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuX2tlcm5lbFN0cmluZykgdGhyb3cgbmV3IEVycm9yKCdLZXJuZWwgYWxyZWFkeSBidWlsdCcpO1xuICAgIHRoaXMuX3ByZXBlbmRlZFN0cmluZy5wdXNoKHZhbHVlKTtcbiAgfVxuXG4gIGhhc1ByZXBlbmRTdHJpbmcodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJlcGVuZGVkU3RyaW5nLmluZGV4T2YodmFsdWUpID4gLTE7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIENQVUtlcm5lbFxufTtcbn0se1wiLi4vLi4vdXRpbHNcIjoxMTQsXCIuLi9mdW5jdGlvbi1idWlsZGVyXCI6OSxcIi4uL2tlcm5lbFwiOjM2LFwiLi9mdW5jdGlvbi1ub2RlXCI6NixcIi4va2VybmVsLXN0cmluZ1wiOjd9XSw5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNsYXNzIEZ1bmN0aW9uQnVpbGRlciB7XG4gIHN0YXRpYyBmcm9tS2VybmVsKGtlcm5lbCwgRnVuY3Rpb25Ob2RlLCBleHRyYU5vZGVPcHRpb25zKSB7XG4gICAgY29uc3Qge1xuICAgICAga2VybmVsQXJndW1lbnRzLFxuICAgICAga2VybmVsQ29uc3RhbnRzLFxuICAgICAgYXJndW1lbnROYW1lcyxcbiAgICAgIGFyZ3VtZW50U2l6ZXMsXG4gICAgICBhcmd1bWVudEJpdFJhdGlvcyxcbiAgICAgIGNvbnN0YW50cyxcbiAgICAgIGNvbnN0YW50Qml0UmF0aW9zLFxuICAgICAgZGVidWcsXG4gICAgICBsb29wTWF4SXRlcmF0aW9ucyxcbiAgICAgIG5hdGl2ZUZ1bmN0aW9ucyxcbiAgICAgIG91dHB1dCxcbiAgICAgIG9wdGltaXplRmxvYXRNZW1vcnksXG4gICAgICBwcmVjaXNpb24sXG4gICAgICBwbHVnaW5zLFxuICAgICAgc291cmNlLFxuICAgICAgc3ViS2VybmVscyxcbiAgICAgIGZ1bmN0aW9ucyxcbiAgICAgIGxlYWRpbmdSZXR1cm5TdGF0ZW1lbnQsXG4gICAgICBmb2xsb3dpbmdSZXR1cm5TdGF0ZW1lbnQsXG4gICAgICBkeW5hbWljQXJndW1lbnRzLFxuICAgICAgZHluYW1pY091dHB1dCxcbiAgICB9ID0ga2VybmVsO1xuXG4gICAgY29uc3QgYXJndW1lbnRUeXBlcyA9IG5ldyBBcnJheShrZXJuZWxBcmd1bWVudHMubGVuZ3RoKTtcbiAgICBjb25zdCBjb25zdGFudFR5cGVzID0ge307XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtlcm5lbEFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgYXJndW1lbnRUeXBlc1tpXSA9IGtlcm5lbEFyZ3VtZW50c1tpXS50eXBlO1xuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2VybmVsQ29uc3RhbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBrZXJuZWxDb25zdGFudCA9IGtlcm5lbENvbnN0YW50c1tpXTtcbiAgICAgIGNvbnN0YW50VHlwZXNba2VybmVsQ29uc3RhbnQubmFtZV0gPSBrZXJuZWxDb25zdGFudC50eXBlO1xuICAgIH1cblxuICAgIGNvbnN0IG5lZWRzQXJndW1lbnRUeXBlID0gKGZ1bmN0aW9uTmFtZSwgaW5kZXgpID0+IHtcbiAgICAgIHJldHVybiBmdW5jdGlvbkJ1aWxkZXIubmVlZHNBcmd1bWVudFR5cGUoZnVuY3Rpb25OYW1lLCBpbmRleCk7XG4gICAgfTtcblxuICAgIGNvbnN0IGFzc2lnbkFyZ3VtZW50VHlwZSA9IChmdW5jdGlvbk5hbWUsIGluZGV4LCB0eXBlKSA9PiB7XG4gICAgICBmdW5jdGlvbkJ1aWxkZXIuYXNzaWduQXJndW1lbnRUeXBlKGZ1bmN0aW9uTmFtZSwgaW5kZXgsIHR5cGUpO1xuICAgIH07XG5cbiAgICBjb25zdCBsb29rdXBSZXR1cm5UeXBlID0gKGZ1bmN0aW9uTmFtZSwgYXN0LCByZXF1ZXN0aW5nTm9kZSkgPT4ge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uQnVpbGRlci5sb29rdXBSZXR1cm5UeXBlKGZ1bmN0aW9uTmFtZSwgYXN0LCByZXF1ZXN0aW5nTm9kZSk7XG4gICAgfTtcblxuICAgIGNvbnN0IGxvb2t1cEZ1bmN0aW9uQXJndW1lbnRUeXBlcyA9IChmdW5jdGlvbk5hbWUpID0+IHtcbiAgICAgIHJldHVybiBmdW5jdGlvbkJ1aWxkZXIubG9va3VwRnVuY3Rpb25Bcmd1bWVudFR5cGVzKGZ1bmN0aW9uTmFtZSk7XG4gICAgfTtcblxuICAgIGNvbnN0IGxvb2t1cEZ1bmN0aW9uQXJndW1lbnROYW1lID0gKGZ1bmN0aW9uTmFtZSwgYXJndW1lbnRJbmRleCkgPT4ge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uQnVpbGRlci5sb29rdXBGdW5jdGlvbkFyZ3VtZW50TmFtZShmdW5jdGlvbk5hbWUsIGFyZ3VtZW50SW5kZXgpO1xuICAgIH07XG5cbiAgICBjb25zdCBsb29rdXBGdW5jdGlvbkFyZ3VtZW50Qml0UmF0aW8gPSAoZnVuY3Rpb25OYW1lLCBhcmd1bWVudE5hbWUpID0+IHtcbiAgICAgIHJldHVybiBmdW5jdGlvbkJ1aWxkZXIubG9va3VwRnVuY3Rpb25Bcmd1bWVudEJpdFJhdGlvKGZ1bmN0aW9uTmFtZSwgYXJndW1lbnROYW1lKTtcbiAgICB9O1xuXG4gICAgY29uc3QgdHJpZ2dlckltcGx5QXJndW1lbnRUeXBlID0gKGZ1bmN0aW9uTmFtZSwgaSwgYXJndW1lbnRUeXBlLCByZXF1ZXN0aW5nTm9kZSkgPT4ge1xuICAgICAgZnVuY3Rpb25CdWlsZGVyLmFzc2lnbkFyZ3VtZW50VHlwZShmdW5jdGlvbk5hbWUsIGksIGFyZ3VtZW50VHlwZSwgcmVxdWVzdGluZ05vZGUpO1xuICAgIH07XG5cbiAgICBjb25zdCB0cmlnZ2VySW1wbHlBcmd1bWVudEJpdFJhdGlvID0gKGZ1bmN0aW9uTmFtZSwgYXJndW1lbnROYW1lLCBjYWxsZWVGdW5jdGlvbk5hbWUsIGFyZ3VtZW50SW5kZXgpID0+IHtcbiAgICAgIGZ1bmN0aW9uQnVpbGRlci5hc3NpZ25Bcmd1bWVudEJpdFJhdGlvKGZ1bmN0aW9uTmFtZSwgYXJndW1lbnROYW1lLCBjYWxsZWVGdW5jdGlvbk5hbWUsIGFyZ3VtZW50SW5kZXgpO1xuICAgIH07XG5cbiAgICBjb25zdCBvbkZ1bmN0aW9uQ2FsbCA9IChmdW5jdGlvbk5hbWUsIGNhbGxlZUZ1bmN0aW9uTmFtZSwgYXJncykgPT4ge1xuICAgICAgZnVuY3Rpb25CdWlsZGVyLnRyYWNrRnVuY3Rpb25DYWxsKGZ1bmN0aW9uTmFtZSwgY2FsbGVlRnVuY3Rpb25OYW1lLCBhcmdzKTtcbiAgICB9O1xuXG4gICAgY29uc3Qgb25OZXN0ZWRGdW5jdGlvbiA9IChhc3QsIHNvdXJjZSkgPT4ge1xuICAgICAgY29uc3QgYXJndW1lbnROYW1lcyA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhc3QucGFyYW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFyZ3VtZW50TmFtZXMucHVzaChhc3QucGFyYW1zW2ldLm5hbWUpO1xuICAgICAgfVxuICAgICAgY29uc3QgbmVzdGVkRnVuY3Rpb24gPSBuZXcgRnVuY3Rpb25Ob2RlKHNvdXJjZSwgT2JqZWN0LmFzc2lnbih7fSwgbm9kZU9wdGlvbnMsIHtcbiAgICAgICAgcmV0dXJuVHlwZTogbnVsbCxcbiAgICAgICAgYXN0LFxuICAgICAgICBuYW1lOiBhc3QuaWQubmFtZSxcbiAgICAgICAgYXJndW1lbnROYW1lcyxcbiAgICAgICAgbG9va3VwUmV0dXJuVHlwZSxcbiAgICAgICAgbG9va3VwRnVuY3Rpb25Bcmd1bWVudFR5cGVzLFxuICAgICAgICBsb29rdXBGdW5jdGlvbkFyZ3VtZW50TmFtZSxcbiAgICAgICAgbG9va3VwRnVuY3Rpb25Bcmd1bWVudEJpdFJhdGlvLFxuICAgICAgICBuZWVkc0FyZ3VtZW50VHlwZSxcbiAgICAgICAgYXNzaWduQXJndW1lbnRUeXBlLFxuICAgICAgICB0cmlnZ2VySW1wbHlBcmd1bWVudFR5cGUsXG4gICAgICAgIHRyaWdnZXJJbXBseUFyZ3VtZW50Qml0UmF0aW8sXG4gICAgICAgIG9uRnVuY3Rpb25DYWxsLFxuICAgICAgfSkpO1xuICAgICAgbmVzdGVkRnVuY3Rpb24udHJhY2VGdW5jdGlvbkFTVChhc3QpO1xuICAgICAgZnVuY3Rpb25CdWlsZGVyLmFkZEZ1bmN0aW9uTm9kZShuZXN0ZWRGdW5jdGlvbik7XG4gICAgfTtcblxuICAgIGNvbnN0IG5vZGVPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICBpc1Jvb3RLZXJuZWw6IGZhbHNlLFxuICAgICAgb25OZXN0ZWRGdW5jdGlvbixcbiAgICAgIGxvb2t1cFJldHVyblR5cGUsXG4gICAgICBsb29rdXBGdW5jdGlvbkFyZ3VtZW50VHlwZXMsXG4gICAgICBsb29rdXBGdW5jdGlvbkFyZ3VtZW50TmFtZSxcbiAgICAgIGxvb2t1cEZ1bmN0aW9uQXJndW1lbnRCaXRSYXRpbyxcbiAgICAgIG5lZWRzQXJndW1lbnRUeXBlLFxuICAgICAgYXNzaWduQXJndW1lbnRUeXBlLFxuICAgICAgdHJpZ2dlckltcGx5QXJndW1lbnRUeXBlLFxuICAgICAgdHJpZ2dlckltcGx5QXJndW1lbnRCaXRSYXRpbyxcbiAgICAgIG9uRnVuY3Rpb25DYWxsLFxuICAgICAgb3B0aW1pemVGbG9hdE1lbW9yeSxcbiAgICAgIHByZWNpc2lvbixcbiAgICAgIGNvbnN0YW50cyxcbiAgICAgIGNvbnN0YW50VHlwZXMsXG4gICAgICBjb25zdGFudEJpdFJhdGlvcyxcbiAgICAgIGRlYnVnLFxuICAgICAgbG9vcE1heEl0ZXJhdGlvbnMsXG4gICAgICBvdXRwdXQsXG4gICAgICBwbHVnaW5zLFxuICAgICAgZHluYW1pY0FyZ3VtZW50cyxcbiAgICAgIGR5bmFtaWNPdXRwdXQsXG4gICAgfSwgZXh0cmFOb2RlT3B0aW9ucyB8fCB7fSk7XG5cbiAgICBjb25zdCByb290Tm9kZU9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBub2RlT3B0aW9ucywge1xuICAgICAgaXNSb290S2VybmVsOiB0cnVlLFxuICAgICAgbmFtZTogJ2tlcm5lbCcsXG4gICAgICBhcmd1bWVudE5hbWVzLFxuICAgICAgYXJndW1lbnRUeXBlcyxcbiAgICAgIGFyZ3VtZW50U2l6ZXMsXG4gICAgICBhcmd1bWVudEJpdFJhdGlvcyxcbiAgICAgIGxlYWRpbmdSZXR1cm5TdGF0ZW1lbnQsXG4gICAgICBmb2xsb3dpbmdSZXR1cm5TdGF0ZW1lbnQsXG4gICAgfSk7XG5cbiAgICBpZiAodHlwZW9mIHNvdXJjZSA9PT0gJ29iamVjdCcgJiYgc291cmNlLmZ1bmN0aW9uTm9kZXMpIHtcbiAgICAgIHJldHVybiBuZXcgRnVuY3Rpb25CdWlsZGVyKCkuZnJvbUpTT04oc291cmNlLmZ1bmN0aW9uTm9kZXMsIEZ1bmN0aW9uTm9kZSk7XG4gICAgfVxuXG4gICAgY29uc3Qgcm9vdE5vZGUgPSBuZXcgRnVuY3Rpb25Ob2RlKHNvdXJjZSwgcm9vdE5vZGVPcHRpb25zKTtcblxuICAgIGxldCBmdW5jdGlvbk5vZGVzID0gbnVsbDtcbiAgICBpZiAoZnVuY3Rpb25zKSB7XG4gICAgICBmdW5jdGlvbk5vZGVzID0gZnVuY3Rpb25zLm1hcCgoZm4pID0+IG5ldyBGdW5jdGlvbk5vZGUoZm4uc291cmNlLCB7XG4gICAgICAgIHJldHVyblR5cGU6IGZuLnJldHVyblR5cGUsXG4gICAgICAgIGFyZ3VtZW50VHlwZXM6IGZuLmFyZ3VtZW50VHlwZXMsXG4gICAgICAgIG91dHB1dCxcbiAgICAgICAgcGx1Z2lucyxcbiAgICAgICAgY29uc3RhbnRzLFxuICAgICAgICBjb25zdGFudFR5cGVzLFxuICAgICAgICBjb25zdGFudEJpdFJhdGlvcyxcbiAgICAgICAgb3B0aW1pemVGbG9hdE1lbW9yeSxcbiAgICAgICAgcHJlY2lzaW9uLFxuICAgICAgICBsb29rdXBSZXR1cm5UeXBlLFxuICAgICAgICBsb29rdXBGdW5jdGlvbkFyZ3VtZW50VHlwZXMsXG4gICAgICAgIGxvb2t1cEZ1bmN0aW9uQXJndW1lbnROYW1lLFxuICAgICAgICBsb29rdXBGdW5jdGlvbkFyZ3VtZW50Qml0UmF0aW8sXG4gICAgICAgIG5lZWRzQXJndW1lbnRUeXBlLFxuICAgICAgICBhc3NpZ25Bcmd1bWVudFR5cGUsXG4gICAgICAgIHRyaWdnZXJJbXBseUFyZ3VtZW50VHlwZSxcbiAgICAgICAgdHJpZ2dlckltcGx5QXJndW1lbnRCaXRSYXRpbyxcbiAgICAgICAgb25GdW5jdGlvbkNhbGwsXG4gICAgICAgIG9uTmVzdGVkRnVuY3Rpb24sXG4gICAgICB9KSk7XG4gICAgfVxuXG4gICAgbGV0IHN1Yktlcm5lbE5vZGVzID0gbnVsbDtcbiAgICBpZiAoc3ViS2VybmVscykge1xuICAgICAgc3ViS2VybmVsTm9kZXMgPSBzdWJLZXJuZWxzLm1hcCgoc3ViS2VybmVsKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgbmFtZSwgc291cmNlIH0gPSBzdWJLZXJuZWw7XG4gICAgICAgIHJldHVybiBuZXcgRnVuY3Rpb25Ob2RlKHNvdXJjZSwgT2JqZWN0LmFzc2lnbih7fSwgbm9kZU9wdGlvbnMsIHtcbiAgICAgICAgICBuYW1lLFxuICAgICAgICAgIGlzU3ViS2VybmVsOiB0cnVlLFxuICAgICAgICAgIGlzUm9vdEtlcm5lbDogZmFsc2UsXG4gICAgICAgIH0pKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGNvbnN0IGZ1bmN0aW9uQnVpbGRlciA9IG5ldyBGdW5jdGlvbkJ1aWxkZXIoe1xuICAgICAga2VybmVsLFxuICAgICAgcm9vdE5vZGUsXG4gICAgICBmdW5jdGlvbk5vZGVzLFxuICAgICAgbmF0aXZlRnVuY3Rpb25zLFxuICAgICAgc3ViS2VybmVsTm9kZXNcbiAgICB9KTtcblxuICAgIHJldHVybiBmdW5jdGlvbkJ1aWxkZXI7XG4gIH1cblxuICBjb25zdHJ1Y3RvcihzZXR0aW5ncykge1xuICAgIHNldHRpbmdzID0gc2V0dGluZ3MgfHwge307XG4gICAgdGhpcy5rZXJuZWwgPSBzZXR0aW5ncy5rZXJuZWw7XG4gICAgdGhpcy5yb290Tm9kZSA9IHNldHRpbmdzLnJvb3ROb2RlO1xuICAgIHRoaXMuZnVuY3Rpb25Ob2RlcyA9IHNldHRpbmdzLmZ1bmN0aW9uTm9kZXMgfHwgW107XG4gICAgdGhpcy5zdWJLZXJuZWxOb2RlcyA9IHNldHRpbmdzLnN1Yktlcm5lbE5vZGVzIHx8IFtdO1xuICAgIHRoaXMubmF0aXZlRnVuY3Rpb25zID0gc2V0dGluZ3MubmF0aXZlRnVuY3Rpb25zIHx8IFtdO1xuICAgIHRoaXMuZnVuY3Rpb25NYXAgPSB7fTtcbiAgICB0aGlzLm5hdGl2ZUZ1bmN0aW9uTmFtZXMgPSBbXTtcbiAgICB0aGlzLmxvb2t1cENoYWluID0gW107XG4gICAgdGhpcy5mdW5jdGlvbk5vZGVEZXBlbmRlbmNpZXMgPSB7fTtcbiAgICB0aGlzLmZ1bmN0aW9uQ2FsbHMgPSB7fTtcblxuICAgIGlmICh0aGlzLnJvb3ROb2RlKSB7XG4gICAgICB0aGlzLmZ1bmN0aW9uTWFwWydrZXJuZWwnXSA9IHRoaXMucm9vdE5vZGU7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZnVuY3Rpb25Ob2Rlcykge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmZ1bmN0aW9uTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5mdW5jdGlvbk1hcFt0aGlzLmZ1bmN0aW9uTm9kZXNbaV0ubmFtZV0gPSB0aGlzLmZ1bmN0aW9uTm9kZXNbaV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuc3ViS2VybmVsTm9kZXMpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zdWJLZXJuZWxOb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLmZ1bmN0aW9uTWFwW3RoaXMuc3ViS2VybmVsTm9kZXNbaV0ubmFtZV0gPSB0aGlzLnN1Yktlcm5lbE5vZGVzW2ldO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLm5hdGl2ZUZ1bmN0aW9ucykge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm5hdGl2ZUZ1bmN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBuYXRpdmVGdW5jdGlvbiA9IHRoaXMubmF0aXZlRnVuY3Rpb25zW2ldO1xuICAgICAgICB0aGlzLm5hdGl2ZUZ1bmN0aW9uTmFtZXMucHVzaChuYXRpdmVGdW5jdGlvbi5uYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBhZGRGdW5jdGlvbk5vZGUoZnVuY3Rpb25Ob2RlKSB7XG4gICAgaWYgKCFmdW5jdGlvbk5vZGUubmFtZSkgdGhyb3cgbmV3IEVycm9yKCdmdW5jdGlvbk5vZGUubmFtZSBuZWVkcyBzZXQnKTtcbiAgICB0aGlzLmZ1bmN0aW9uTWFwW2Z1bmN0aW9uTm9kZS5uYW1lXSA9IGZ1bmN0aW9uTm9kZTtcbiAgICBpZiAoZnVuY3Rpb25Ob2RlLmlzUm9vdEtlcm5lbCkge1xuICAgICAgdGhpcy5yb290Tm9kZSA9IGZ1bmN0aW9uTm9kZTtcbiAgICB9XG4gIH1cblxuICB0cmFjZUZ1bmN0aW9uQ2FsbHMoZnVuY3Rpb25OYW1lLCByZXRMaXN0KSB7XG4gICAgZnVuY3Rpb25OYW1lID0gZnVuY3Rpb25OYW1lIHx8ICdrZXJuZWwnO1xuICAgIHJldExpc3QgPSByZXRMaXN0IHx8IFtdO1xuXG4gICAgaWYgKHRoaXMubmF0aXZlRnVuY3Rpb25OYW1lcy5pbmRleE9mKGZ1bmN0aW9uTmFtZSkgPiAtMSkge1xuICAgICAgY29uc3QgbmF0aXZlRnVuY3Rpb25JbmRleCA9IHJldExpc3QuaW5kZXhPZihmdW5jdGlvbk5hbWUpO1xuICAgICAgaWYgKG5hdGl2ZUZ1bmN0aW9uSW5kZXggPT09IC0xKSB7XG4gICAgICAgIHJldExpc3QucHVzaChmdW5jdGlvbk5hbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgZGVwZW5kYW50TmF0aXZlRnVuY3Rpb25OYW1lID0gcmV0TGlzdC5zcGxpY2UobmF0aXZlRnVuY3Rpb25JbmRleCwgMSlbMF07XG4gICAgICAgIHJldExpc3QucHVzaChkZXBlbmRhbnROYXRpdmVGdW5jdGlvbk5hbWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJldExpc3Q7XG4gICAgfVxuXG4gICAgY29uc3QgZnVuY3Rpb25Ob2RlID0gdGhpcy5mdW5jdGlvbk1hcFtmdW5jdGlvbk5hbWVdO1xuICAgIGlmIChmdW5jdGlvbk5vZGUpIHtcbiAgICAgIGNvbnN0IGZ1bmN0aW9uSW5kZXggPSByZXRMaXN0LmluZGV4T2YoZnVuY3Rpb25OYW1lKTtcbiAgICAgIGlmIChmdW5jdGlvbkluZGV4ID09PSAtMSkge1xuICAgICAgICByZXRMaXN0LnB1c2goZnVuY3Rpb25OYW1lKTtcbiAgICAgICAgZnVuY3Rpb25Ob2RlLnRvU3RyaW5nKCk7IFxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZ1bmN0aW9uTm9kZS5jYWxsZWRGdW5jdGlvbnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICB0aGlzLnRyYWNlRnVuY3Rpb25DYWxscyhmdW5jdGlvbk5vZGUuY2FsbGVkRnVuY3Rpb25zW2ldLCByZXRMaXN0KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgZGVwZW5kYW50RnVuY3Rpb25OYW1lID0gcmV0TGlzdC5zcGxpY2UoZnVuY3Rpb25JbmRleCwgMSlbMF07XG4gICAgICAgIHJldExpc3QucHVzaChkZXBlbmRhbnRGdW5jdGlvbk5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXRMaXN0O1xuICB9XG5cbiAgZ2V0UHJvdG90eXBlU3RyaW5nKGZ1bmN0aW9uTmFtZSkge1xuICAgIHJldHVybiB0aGlzLmdldFByb3RvdHlwZXMoZnVuY3Rpb25OYW1lKS5qb2luKCdcXG4nKTtcbiAgfVxuXG4gIGdldFByb3RvdHlwZXMoZnVuY3Rpb25OYW1lKSB7XG4gICAgaWYgKHRoaXMucm9vdE5vZGUpIHtcbiAgICAgIHRoaXMucm9vdE5vZGUudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgaWYgKGZ1bmN0aW9uTmFtZSkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0UHJvdG90eXBlc0Zyb21GdW5jdGlvbk5hbWVzKHRoaXMudHJhY2VGdW5jdGlvbkNhbGxzKGZ1bmN0aW9uTmFtZSwgW10pLnJldmVyc2UoKSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdldFByb3RvdHlwZXNGcm9tRnVuY3Rpb25OYW1lcyhPYmplY3Qua2V5cyh0aGlzLmZ1bmN0aW9uTWFwKSk7XG4gIH1cblxuICBnZXRTdHJpbmdGcm9tRnVuY3Rpb25OYW1lcyhmdW5jdGlvbkxpc3QpIHtcbiAgICBjb25zdCByZXQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZ1bmN0aW9uTGlzdC5sZW5ndGg7ICsraSkge1xuICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuZnVuY3Rpb25NYXBbZnVuY3Rpb25MaXN0W2ldXTtcbiAgICAgIGlmIChub2RlKSB7XG4gICAgICAgIHJldC5wdXNoKHRoaXMuZnVuY3Rpb25NYXBbZnVuY3Rpb25MaXN0W2ldXS50b1N0cmluZygpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldC5qb2luKCdcXG4nKTtcbiAgfVxuXG4gIGdldFByb3RvdHlwZXNGcm9tRnVuY3Rpb25OYW1lcyhmdW5jdGlvbkxpc3QpIHtcbiAgICBjb25zdCByZXQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZ1bmN0aW9uTGlzdC5sZW5ndGg7ICsraSkge1xuICAgICAgY29uc3QgZnVuY3Rpb25OYW1lID0gZnVuY3Rpb25MaXN0W2ldO1xuICAgICAgY29uc3QgZnVuY3Rpb25JbmRleCA9IHRoaXMubmF0aXZlRnVuY3Rpb25OYW1lcy5pbmRleE9mKGZ1bmN0aW9uTmFtZSk7XG4gICAgICBpZiAoZnVuY3Rpb25JbmRleCA+IC0xKSB7XG4gICAgICAgIHJldC5wdXNoKHRoaXMubmF0aXZlRnVuY3Rpb25zW2Z1bmN0aW9uSW5kZXhdLnNvdXJjZSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuZnVuY3Rpb25NYXBbZnVuY3Rpb25OYW1lXTtcbiAgICAgIGlmIChub2RlKSB7XG4gICAgICAgIHJldC5wdXNoKG5vZGUudG9TdHJpbmcoKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cblxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHRoaXMudHJhY2VGdW5jdGlvbkNhbGxzKHRoaXMucm9vdE5vZGUubmFtZSkucmV2ZXJzZSgpLm1hcChuYW1lID0+IHtcbiAgICAgIGNvbnN0IG5hdGl2ZUluZGV4ID0gdGhpcy5uYXRpdmVGdW5jdGlvbnMuaW5kZXhPZihuYW1lKTtcbiAgICAgIGlmIChuYXRpdmVJbmRleCA+IC0xKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgICBzb3VyY2U6IHRoaXMubmF0aXZlRnVuY3Rpb25zW25hdGl2ZUluZGV4XS5zb3VyY2VcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5mdW5jdGlvbk1hcFtuYW1lXSkge1xuICAgICAgICByZXR1cm4gdGhpcy5mdW5jdGlvbk1hcFtuYW1lXS50b0pTT04oKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgZnVuY3Rpb24gJHsgbmFtZSB9IG5vdCBmb3VuZGApO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZnJvbUpTT04oanNvbkZ1bmN0aW9uTm9kZXMsIEZ1bmN0aW9uTm9kZSkge1xuICAgIHRoaXMuZnVuY3Rpb25NYXAgPSB7fTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGpzb25GdW5jdGlvbk5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBqc29uRnVuY3Rpb25Ob2RlID0ganNvbkZ1bmN0aW9uTm9kZXNbaV07XG4gICAgICB0aGlzLmZ1bmN0aW9uTWFwW2pzb25GdW5jdGlvbk5vZGUuc2V0dGluZ3MubmFtZV0gPSBuZXcgRnVuY3Rpb25Ob2RlKGpzb25GdW5jdGlvbk5vZGUuYXN0LCBqc29uRnVuY3Rpb25Ob2RlLnNldHRpbmdzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBnZXRTdHJpbmcoZnVuY3Rpb25OYW1lKSB7XG4gICAgaWYgKGZ1bmN0aW9uTmFtZSkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0U3RyaW5nRnJvbUZ1bmN0aW9uTmFtZXModGhpcy50cmFjZUZ1bmN0aW9uQ2FsbHMoZnVuY3Rpb25OYW1lKS5yZXZlcnNlKCkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5nZXRTdHJpbmdGcm9tRnVuY3Rpb25OYW1lcyhPYmplY3Qua2V5cyh0aGlzLmZ1bmN0aW9uTWFwKSk7XG4gIH1cblxuICBsb29rdXBSZXR1cm5UeXBlKGZ1bmN0aW9uTmFtZSwgYXN0LCByZXF1ZXN0aW5nTm9kZSkge1xuICAgIGlmIChhc3QudHlwZSAhPT0gJ0NhbGxFeHByZXNzaW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBleHBlY3RlZCBhc3QgdHlwZSBvZiBcIkNhbGxFeHByZXNzaW9uXCIsIGJ1dCBpcyAkeyBhc3QudHlwZSB9YCk7XG4gICAgfVxuICAgIGlmICh0aGlzLl9pc05hdGl2ZUZ1bmN0aW9uKGZ1bmN0aW9uTmFtZSkpIHtcbiAgICAgIHJldHVybiB0aGlzLl9sb29rdXBOYXRpdmVGdW5jdGlvblJldHVyblR5cGUoZnVuY3Rpb25OYW1lKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX2lzRnVuY3Rpb24oZnVuY3Rpb25OYW1lKSkge1xuICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuX2dldEZ1bmN0aW9uKGZ1bmN0aW9uTmFtZSk7XG4gICAgICBpZiAobm9kZS5yZXR1cm5UeXBlKSB7XG4gICAgICAgIHJldHVybiBub2RlLnJldHVyblR5cGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubG9va3VwQ2hhaW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAodGhpcy5sb29rdXBDaGFpbltpXS5hc3QgPT09IGFzdCkge1xuICAgICAgICAgICAgaWYgKG5vZGUuYXJndW1lbnRUeXBlcy5sZW5ndGggPT09IDAgJiYgYXN0LmFyZ3VtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGFyZ3MgPSBhc3QuYXJndW1lbnRzO1xuICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGFyZ3MubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvb2t1cENoYWluLnB1c2goe1xuICAgICAgICAgICAgICAgICAgbmFtZTogcmVxdWVzdGluZ05vZGUubmFtZSxcbiAgICAgICAgICAgICAgICAgIGFzdDogYXJnc1tpXSxcbiAgICAgICAgICAgICAgICAgIHJlcXVlc3RpbmdOb2RlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgbm9kZS5hcmd1bWVudFR5cGVzW2pdID0gcmVxdWVzdGluZ05vZGUuZ2V0VHlwZShhcmdzW2pdKTtcbiAgICAgICAgICAgICAgICB0aGlzLmxvb2t1cENoYWluLnBvcCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBub2RlLnJldHVyblR5cGUgPSBub2RlLmdldFR5cGUobm9kZS5nZXRKc0FTVCgpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjaXJjbGljYWwgbG9naWMgZGV0ZWN0ZWQhJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMubG9va3VwQ2hhaW4ucHVzaCh7XG4gICAgICAgICAgbmFtZTogcmVxdWVzdGluZ05vZGUubmFtZSxcbiAgICAgICAgICBhc3QsXG4gICAgICAgICAgcmVxdWVzdGluZ05vZGVcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHR5cGUgPSBub2RlLmdldFR5cGUobm9kZS5nZXRKc0FTVCgpKTtcbiAgICAgICAgdGhpcy5sb29rdXBDaGFpbi5wb3AoKTtcbiAgICAgICAgcmV0dXJuIG5vZGUucmV0dXJuVHlwZSA9IHR5cGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBfZ2V0RnVuY3Rpb24oZnVuY3Rpb25OYW1lKSB7XG4gICAgaWYgKCF0aGlzLl9pc0Z1bmN0aW9uKGZ1bmN0aW9uTmFtZSkpIHtcbiAgICAgIG5ldyBFcnJvcihgRnVuY3Rpb24gJHtmdW5jdGlvbk5hbWV9IG5vdCBmb3VuZGApO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5mdW5jdGlvbk1hcFtmdW5jdGlvbk5hbWVdO1xuICB9XG5cbiAgX2lzRnVuY3Rpb24oZnVuY3Rpb25OYW1lKSB7XG4gICAgcmV0dXJuIEJvb2xlYW4odGhpcy5mdW5jdGlvbk1hcFtmdW5jdGlvbk5hbWVdKTtcbiAgfVxuXG4gIF9nZXROYXRpdmVGdW5jdGlvbihmdW5jdGlvbk5hbWUpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubmF0aXZlRnVuY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodGhpcy5uYXRpdmVGdW5jdGlvbnNbaV0ubmFtZSA9PT0gZnVuY3Rpb25OYW1lKSByZXR1cm4gdGhpcy5uYXRpdmVGdW5jdGlvbnNbaV07XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgX2lzTmF0aXZlRnVuY3Rpb24oZnVuY3Rpb25OYW1lKSB7XG4gICAgcmV0dXJuIEJvb2xlYW4odGhpcy5fZ2V0TmF0aXZlRnVuY3Rpb24oZnVuY3Rpb25OYW1lKSk7XG4gIH1cblxuICBfbG9va3VwTmF0aXZlRnVuY3Rpb25SZXR1cm5UeXBlKGZ1bmN0aW9uTmFtZSkge1xuICAgIGxldCBuYXRpdmVGdW5jdGlvbiA9IHRoaXMuX2dldE5hdGl2ZUZ1bmN0aW9uKGZ1bmN0aW9uTmFtZSk7XG4gICAgaWYgKG5hdGl2ZUZ1bmN0aW9uKSB7XG4gICAgICByZXR1cm4gbmF0aXZlRnVuY3Rpb24ucmV0dXJuVHlwZTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBOYXRpdmUgZnVuY3Rpb24gJHsgZnVuY3Rpb25OYW1lIH0gbm90IGZvdW5kYCk7XG4gIH1cblxuICBsb29rdXBGdW5jdGlvbkFyZ3VtZW50VHlwZXMoZnVuY3Rpb25OYW1lKSB7XG4gICAgaWYgKHRoaXMuX2lzTmF0aXZlRnVuY3Rpb24oZnVuY3Rpb25OYW1lKSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2dldE5hdGl2ZUZ1bmN0aW9uKGZ1bmN0aW9uTmFtZSkuYXJndW1lbnRUeXBlcztcbiAgICB9IGVsc2UgaWYgKHRoaXMuX2lzRnVuY3Rpb24oZnVuY3Rpb25OYW1lKSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2dldEZ1bmN0aW9uKGZ1bmN0aW9uTmFtZSkuYXJndW1lbnRUeXBlcztcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBsb29rdXBGdW5jdGlvbkFyZ3VtZW50TmFtZShmdW5jdGlvbk5hbWUsIGFyZ3VtZW50SW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0RnVuY3Rpb24oZnVuY3Rpb25OYW1lKS5hcmd1bWVudE5hbWVzW2FyZ3VtZW50SW5kZXhdO1xuICB9XG5cbiAgbG9va3VwRnVuY3Rpb25Bcmd1bWVudEJpdFJhdGlvKGZ1bmN0aW9uTmFtZSwgYXJndW1lbnROYW1lKSB7XG4gICAgaWYgKCF0aGlzLl9pc0Z1bmN0aW9uKGZ1bmN0aW9uTmFtZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZnVuY3Rpb24gbm90IGZvdW5kJyk7XG4gICAgfVxuICAgIGlmICh0aGlzLnJvb3ROb2RlLm5hbWUgPT09IGZ1bmN0aW9uTmFtZSkge1xuICAgICAgY29uc3QgaSA9IHRoaXMucm9vdE5vZGUuYXJndW1lbnROYW1lcy5pbmRleE9mKGFyZ3VtZW50TmFtZSk7XG4gICAgICBpZiAoaSAhPT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucm9vdE5vZGUuYXJndW1lbnRCaXRSYXRpb3NbaV07XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IG5vZGUgPSB0aGlzLl9nZXRGdW5jdGlvbihmdW5jdGlvbk5hbWUpO1xuICAgIGNvbnN0IGkgPSBub2RlLmFyZ3VtZW50TmFtZXMuaW5kZXhPZihhcmd1bWVudE5hbWUpO1xuICAgIGlmIChpID09PSAtMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdhcmd1bWVudCBub3QgZm91bmQnKTtcbiAgICB9XG4gICAgY29uc3QgYml0UmF0aW8gPSBub2RlLmFyZ3VtZW50Qml0UmF0aW9zW2ldO1xuICAgIGlmICh0eXBlb2YgYml0UmF0aW8gIT09ICdudW1iZXInKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FyZ3VtZW50IGJpdCByYXRpbyBub3QgZm91bmQnKTtcbiAgICB9XG4gICAgcmV0dXJuIGJpdFJhdGlvO1xuICB9XG5cbiAgbmVlZHNBcmd1bWVudFR5cGUoZnVuY3Rpb25OYW1lLCBpKSB7XG4gICAgaWYgKCF0aGlzLl9pc0Z1bmN0aW9uKGZ1bmN0aW9uTmFtZSkpIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCBmbk5vZGUgPSB0aGlzLl9nZXRGdW5jdGlvbihmdW5jdGlvbk5hbWUpO1xuICAgIHJldHVybiAhZm5Ob2RlLmFyZ3VtZW50VHlwZXNbaV07XG4gIH1cblxuICBhc3NpZ25Bcmd1bWVudFR5cGUoZnVuY3Rpb25OYW1lLCBpLCBhcmd1bWVudFR5cGUsIHJlcXVlc3RpbmdOb2RlKSB7XG4gICAgaWYgKCF0aGlzLl9pc0Z1bmN0aW9uKGZ1bmN0aW9uTmFtZSkpIHJldHVybjtcbiAgICBjb25zdCBmbk5vZGUgPSB0aGlzLl9nZXRGdW5jdGlvbihmdW5jdGlvbk5hbWUpO1xuICAgIGlmICghZm5Ob2RlLmFyZ3VtZW50VHlwZXNbaV0pIHtcbiAgICAgIGZuTm9kZS5hcmd1bWVudFR5cGVzW2ldID0gYXJndW1lbnRUeXBlO1xuICAgIH1cbiAgfVxuXG4gIGFzc2lnbkFyZ3VtZW50Qml0UmF0aW8oZnVuY3Rpb25OYW1lLCBhcmd1bWVudE5hbWUsIGNhbGxlZUZ1bmN0aW9uTmFtZSwgYXJndW1lbnRJbmRleCkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLl9nZXRGdW5jdGlvbihmdW5jdGlvbk5hbWUpO1xuICAgIGlmICh0aGlzLl9pc05hdGl2ZUZ1bmN0aW9uKGNhbGxlZUZ1bmN0aW9uTmFtZSkpIHJldHVybiBudWxsO1xuICAgIGNvbnN0IGNhbGxlZU5vZGUgPSB0aGlzLl9nZXRGdW5jdGlvbihjYWxsZWVGdW5jdGlvbk5hbWUpO1xuICAgIGNvbnN0IGkgPSBub2RlLmFyZ3VtZW50TmFtZXMuaW5kZXhPZihhcmd1bWVudE5hbWUpO1xuICAgIGlmIChpID09PSAtMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBBcmd1bWVudCAke2FyZ3VtZW50TmFtZX0gbm90IGZvdW5kIGluIGFyZ3VtZW50cyBmcm9tIGZ1bmN0aW9uICR7ZnVuY3Rpb25OYW1lfWApO1xuICAgIH1cbiAgICBjb25zdCBiaXRSYXRpbyA9IG5vZGUuYXJndW1lbnRCaXRSYXRpb3NbaV07XG4gICAgaWYgKHR5cGVvZiBiaXRSYXRpbyAhPT0gJ251bWJlcicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQml0IHJhdGlvIGZvciBhcmd1bWVudCAke2FyZ3VtZW50TmFtZX0gbm90IGZvdW5kIGluIGZ1bmN0aW9uICR7ZnVuY3Rpb25OYW1lfWApO1xuICAgIH1cbiAgICBpZiAoIWNhbGxlZU5vZGUuYXJndW1lbnRCaXRSYXRpb3MpIHtcbiAgICAgIGNhbGxlZU5vZGUuYXJndW1lbnRCaXRSYXRpb3MgPSBuZXcgQXJyYXkoY2FsbGVlTm9kZS5hcmd1bWVudE5hbWVzLmxlbmd0aCk7XG4gICAgfVxuICAgIGNvbnN0IGNhbGxlZUJpdFJhdGlvID0gY2FsbGVlTm9kZS5hcmd1bWVudEJpdFJhdGlvc1tpXTtcbiAgICBpZiAodHlwZW9mIGNhbGxlZUJpdFJhdGlvID09PSAnbnVtYmVyJykge1xuICAgICAgaWYgKGNhbGxlZUJpdFJhdGlvICE9PSBiaXRSYXRpbykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEluY29tcGF0aWJsZSBiaXQgcmF0aW8gZm91bmQgYXQgZnVuY3Rpb24gJHtmdW5jdGlvbk5hbWV9IGF0IGFyZ3VtZW50ICR7YXJndW1lbnROYW1lfWApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNhbGxlZUJpdFJhdGlvO1xuICAgIH1cbiAgICBjYWxsZWVOb2RlLmFyZ3VtZW50Qml0UmF0aW9zW2ldID0gYml0UmF0aW87XG4gICAgcmV0dXJuIGJpdFJhdGlvO1xuICB9XG5cbiAgdHJhY2tGdW5jdGlvbkNhbGwoZnVuY3Rpb25OYW1lLCBjYWxsZWVGdW5jdGlvbk5hbWUsIGFyZ3MpIHtcbiAgICBpZiAoIXRoaXMuZnVuY3Rpb25Ob2RlRGVwZW5kZW5jaWVzW2Z1bmN0aW9uTmFtZV0pIHtcbiAgICAgIHRoaXMuZnVuY3Rpb25Ob2RlRGVwZW5kZW5jaWVzW2Z1bmN0aW9uTmFtZV0gPSBuZXcgU2V0KCk7XG4gICAgICB0aGlzLmZ1bmN0aW9uQ2FsbHNbZnVuY3Rpb25OYW1lXSA9IFtdO1xuICAgIH1cbiAgICB0aGlzLmZ1bmN0aW9uTm9kZURlcGVuZGVuY2llc1tmdW5jdGlvbk5hbWVdLmFkZChjYWxsZWVGdW5jdGlvbk5hbWUpO1xuICAgIHRoaXMuZnVuY3Rpb25DYWxsc1tmdW5jdGlvbk5hbWVdLnB1c2goYXJncyk7XG4gIH1cblxuICBnZXRLZXJuZWxSZXN1bHRUeXBlKCkge1xuICAgIHJldHVybiB0aGlzLnJvb3ROb2RlLnJldHVyblR5cGUgfHwgdGhpcy5yb290Tm9kZS5nZXRUeXBlKHRoaXMucm9vdE5vZGUuYXN0KTtcbiAgfVxuXG4gIGdldFN1Yktlcm5lbFJlc3VsdFR5cGUoaW5kZXgpIHtcbiAgICBjb25zdCBzdWJLZXJuZWxOb2RlID0gdGhpcy5zdWJLZXJuZWxOb2Rlc1tpbmRleF07XG4gICAgbGV0IGNhbGxlZCA9IGZhbHNlO1xuICAgIGZvciAobGV0IGZ1bmN0aW9uQ2FsbEluZGV4ID0gMDsgZnVuY3Rpb25DYWxsSW5kZXggPCB0aGlzLnJvb3ROb2RlLmZ1bmN0aW9uQ2FsbHMubGVuZ3RoOyBmdW5jdGlvbkNhbGxJbmRleCsrKSB7XG4gICAgICBjb25zdCBmdW5jdGlvbkNhbGwgPSB0aGlzLnJvb3ROb2RlLmZ1bmN0aW9uQ2FsbHNbZnVuY3Rpb25DYWxsSW5kZXhdO1xuICAgICAgaWYgKGZ1bmN0aW9uQ2FsbC5hc3QuY2FsbGVlLm5hbWUgPT09IHN1Yktlcm5lbE5vZGUubmFtZSkge1xuICAgICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWNhbGxlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBTdWJLZXJuZWwgJHsgc3ViS2VybmVsTm9kZS5uYW1lIH0gbmV2ZXIgY2FsbGVkIGJ5IGtlcm5lbGApO1xuICAgIH1cbiAgICByZXR1cm4gc3ViS2VybmVsTm9kZS5yZXR1cm5UeXBlIHx8IHN1Yktlcm5lbE5vZGUuZ2V0VHlwZShzdWJLZXJuZWxOb2RlLmdldEpzQVNUKCkpO1xuICB9XG5cbiAgZ2V0UmV0dXJuVHlwZXMoKSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgW3RoaXMucm9vdE5vZGUubmFtZV06IHRoaXMucm9vdE5vZGUuZ2V0VHlwZSh0aGlzLnJvb3ROb2RlLmFzdCksXG4gICAgfTtcbiAgICBjb25zdCBsaXN0ID0gdGhpcy50cmFjZUZ1bmN0aW9uQ2FsbHModGhpcy5yb290Tm9kZS5uYW1lKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGZ1bmN0aW9uTmFtZSA9IGxpc3RbaV07XG4gICAgICBjb25zdCBmdW5jdGlvbk5vZGUgPSB0aGlzLmZ1bmN0aW9uTWFwW2Z1bmN0aW9uTmFtZV07XG4gICAgICByZXN1bHRbZnVuY3Rpb25OYW1lXSA9IGZ1bmN0aW9uTm9kZS5nZXRUeXBlKGZ1bmN0aW9uTm9kZS5hc3QpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBGdW5jdGlvbkJ1aWxkZXJcbn07XG59LHt9XSwxMDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCBhY29ybiA9IHJlcXVpcmUoJ2Fjb3JuJyk7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi91dGlscycpO1xuY29uc3QgeyBGdW5jdGlvblRyYWNlciB9ID0gcmVxdWlyZSgnLi9mdW5jdGlvbi10cmFjZXInKTtcblxuY2xhc3MgRnVuY3Rpb25Ob2RlIHtcbiAgY29uc3RydWN0b3Ioc291cmNlLCBzZXR0aW5ncykge1xuICAgIGlmICghc291cmNlICYmICFzZXR0aW5ncy5hc3QpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignc291cmNlIHBhcmFtZXRlciBpcyBtaXNzaW5nJyk7XG4gICAgfVxuICAgIHNldHRpbmdzID0gc2V0dGluZ3MgfHwge307XG4gICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgdGhpcy5hc3QgPSBudWxsO1xuICAgIHRoaXMubmFtZSA9IHR5cGVvZiBzb3VyY2UgPT09ICdzdHJpbmcnID8gc2V0dGluZ3MuaXNSb290S2VybmVsID9cbiAgICAgICdrZXJuZWwnIDpcbiAgICAgIChzZXR0aW5ncy5uYW1lIHx8IHV0aWxzLmdldEZ1bmN0aW9uTmFtZUZyb21TdHJpbmcoc291cmNlKSkgOiBudWxsO1xuICAgIHRoaXMuY2FsbGVkRnVuY3Rpb25zID0gW107XG4gICAgdGhpcy5jb25zdGFudHMgPSB7fTtcbiAgICB0aGlzLmNvbnN0YW50VHlwZXMgPSB7fTtcbiAgICB0aGlzLmNvbnN0YW50Qml0UmF0aW9zID0ge307XG4gICAgdGhpcy5pc1Jvb3RLZXJuZWwgPSBmYWxzZTtcbiAgICB0aGlzLmlzU3ViS2VybmVsID0gZmFsc2U7XG4gICAgdGhpcy5kZWJ1ZyA9IG51bGw7XG4gICAgdGhpcy5mdW5jdGlvbnMgPSBudWxsO1xuICAgIHRoaXMuaWRlbnRpZmllcnMgPSBudWxsO1xuICAgIHRoaXMuY29udGV4dHMgPSBudWxsO1xuICAgIHRoaXMuZnVuY3Rpb25DYWxscyA9IG51bGw7XG4gICAgdGhpcy5zdGF0ZXMgPSBbXTtcbiAgICB0aGlzLm5lZWRzQXJndW1lbnRUeXBlID0gbnVsbDtcbiAgICB0aGlzLmFzc2lnbkFyZ3VtZW50VHlwZSA9IG51bGw7XG4gICAgdGhpcy5sb29rdXBSZXR1cm5UeXBlID0gbnVsbDtcbiAgICB0aGlzLmxvb2t1cEZ1bmN0aW9uQXJndW1lbnRUeXBlcyA9IG51bGw7XG4gICAgdGhpcy5sb29rdXBGdW5jdGlvbkFyZ3VtZW50Qml0UmF0aW8gPSBudWxsO1xuICAgIHRoaXMudHJpZ2dlckltcGx5QXJndW1lbnRUeXBlID0gbnVsbDtcbiAgICB0aGlzLnRyaWdnZXJJbXBseUFyZ3VtZW50Qml0UmF0aW8gPSBudWxsO1xuICAgIHRoaXMub25OZXN0ZWRGdW5jdGlvbiA9IG51bGw7XG4gICAgdGhpcy5vbkZ1bmN0aW9uQ2FsbCA9IG51bGw7XG4gICAgdGhpcy5vcHRpbWl6ZUZsb2F0TWVtb3J5ID0gbnVsbDtcbiAgICB0aGlzLnByZWNpc2lvbiA9IG51bGw7XG4gICAgdGhpcy5sb29wTWF4SXRlcmF0aW9ucyA9IG51bGw7XG4gICAgdGhpcy5hcmd1bWVudE5hbWVzID0gKHR5cGVvZiB0aGlzLnNvdXJjZSA9PT0gJ3N0cmluZycgPyB1dGlscy5nZXRBcmd1bWVudE5hbWVzRnJvbVN0cmluZyh0aGlzLnNvdXJjZSkgOiBudWxsKTtcbiAgICB0aGlzLmFyZ3VtZW50VHlwZXMgPSBbXTtcbiAgICB0aGlzLmFyZ3VtZW50U2l6ZXMgPSBbXTtcbiAgICB0aGlzLmFyZ3VtZW50Qml0UmF0aW9zID0gbnVsbDtcbiAgICB0aGlzLnJldHVyblR5cGUgPSBudWxsO1xuICAgIHRoaXMub3V0cHV0ID0gW107XG4gICAgdGhpcy5wbHVnaW5zID0gbnVsbDtcbiAgICB0aGlzLmxlYWRpbmdSZXR1cm5TdGF0ZW1lbnQgPSBudWxsO1xuICAgIHRoaXMuZm9sbG93aW5nUmV0dXJuU3RhdGVtZW50ID0gbnVsbDtcbiAgICB0aGlzLmR5bmFtaWNPdXRwdXQgPSBudWxsO1xuICAgIHRoaXMuZHluYW1pY0FyZ3VtZW50cyA9IG51bGw7XG4gICAgdGhpcy5zdHJpY3RUeXBpbmdDaGVja2luZyA9IGZhbHNlO1xuICAgIHRoaXMuZml4SW50ZWdlckRpdmlzaW9uQWNjdXJhY3kgPSBudWxsO1xuXG4gICAgaWYgKHNldHRpbmdzKSB7XG4gICAgICBmb3IgKGNvbnN0IHAgaW4gc2V0dGluZ3MpIHtcbiAgICAgICAgaWYgKCFzZXR0aW5ncy5oYXNPd25Qcm9wZXJ0eShwKSkgY29udGludWU7XG4gICAgICAgIGlmICghdGhpcy5oYXNPd25Qcm9wZXJ0eShwKSkgY29udGludWU7XG4gICAgICAgIHRoaXNbcF0gPSBzZXR0aW5nc1twXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmxpdGVyYWxUeXBlcyA9IHt9O1xuXG4gICAgdGhpcy52YWxpZGF0ZSgpO1xuICAgIHRoaXMuX3N0cmluZyA9IG51bGw7XG4gICAgdGhpcy5faW50ZXJuYWxWYXJpYWJsZU5hbWVzID0ge307XG4gIH1cblxuICB2YWxpZGF0ZSgpIHtcbiAgICBpZiAodHlwZW9mIHRoaXMuc291cmNlICE9PSAnc3RyaW5nJyAmJiAhdGhpcy5hc3QpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndGhpcy5zb3VyY2Ugbm90IGEgc3RyaW5nJyk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmFzdCAmJiAhdXRpbHMuaXNGdW5jdGlvblN0cmluZyh0aGlzLnNvdXJjZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndGhpcy5zb3VyY2Ugbm90IGEgZnVuY3Rpb24gc3RyaW5nJyk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLm5hbWUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndGhpcy5uYW1lIGNvdWxkIG5vdCBiZSBzZXQnKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5hcmd1bWVudFR5cGVzLmxlbmd0aCA+IDAgJiYgdGhpcy5hcmd1bWVudFR5cGVzLmxlbmd0aCAhPT0gdGhpcy5hcmd1bWVudE5hbWVzLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBhcmd1bWVudFR5cGVzIGNvdW50IG9mICR7IHRoaXMuYXJndW1lbnRUeXBlcy5sZW5ndGggfSBleGNlZWRzICR7IHRoaXMuYXJndW1lbnROYW1lcy5sZW5ndGggfWApO1xuICAgIH1cblxuICAgIGlmICh0aGlzLm91dHB1dC5sZW5ndGggPCAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RoaXMub3V0cHV0IGlzIG5vdCBiaWcgZW5vdWdoJyk7XG4gICAgfVxuICB9XG5cbiAgaXNJZGVudGlmaWVyQ29uc3RhbnQobmFtZSkge1xuICAgIGlmICghdGhpcy5jb25zdGFudHMpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdGhpcy5jb25zdGFudHMuaGFzT3duUHJvcGVydHkobmFtZSk7XG4gIH1cblxuICBpc0lucHV0KGFyZ3VtZW50TmFtZSkge1xuICAgIHJldHVybiB0aGlzLmFyZ3VtZW50VHlwZXNbdGhpcy5hcmd1bWVudE5hbWVzLmluZGV4T2YoYXJndW1lbnROYW1lKV0gPT09ICdJbnB1dCc7XG4gIH1cblxuICBwdXNoU3RhdGUoc3RhdGUpIHtcbiAgICB0aGlzLnN0YXRlcy5wdXNoKHN0YXRlKTtcbiAgfVxuXG4gIHBvcFN0YXRlKHN0YXRlKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUgIT09IHN0YXRlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBwb3BTdGF0ZSAkeyBzdGF0ZSB9IHdoZW4gaW4gJHsgdGhpcy5zdGF0ZSB9YCk7XG4gICAgfVxuICAgIHRoaXMuc3RhdGVzLnBvcCgpO1xuICB9XG5cbiAgaXNTdGF0ZShzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlID09PSBzdGF0ZTtcbiAgfVxuXG4gIGdldCBzdGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZXNbdGhpcy5zdGF0ZXMubGVuZ3RoIC0gMV07XG4gIH1cblxuICBhc3RNZW1iZXJFeHByZXNzaW9uVW5yb2xsKGFzdCkge1xuICAgIGlmIChhc3QudHlwZSA9PT0gJ0lkZW50aWZpZXInKSB7XG4gICAgICByZXR1cm4gYXN0Lm5hbWU7XG4gICAgfSBlbHNlIGlmIChhc3QudHlwZSA9PT0gJ1RoaXNFeHByZXNzaW9uJykge1xuICAgICAgcmV0dXJuICd0aGlzJztcbiAgICB9XG5cbiAgICBpZiAoYXN0LnR5cGUgPT09ICdNZW1iZXJFeHByZXNzaW9uJykge1xuICAgICAgaWYgKGFzdC5vYmplY3QgJiYgYXN0LnByb3BlcnR5KSB7XG4gICAgICAgIGlmIChhc3Qub2JqZWN0Lmhhc093blByb3BlcnR5KCduYW1lJykgJiYgYXN0Lm9iamVjdC5uYW1lICE9PSAnTWF0aCcpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5hc3RNZW1iZXJFeHByZXNzaW9uVW5yb2xsKGFzdC5wcm9wZXJ0eSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIHRoaXMuYXN0TWVtYmVyRXhwcmVzc2lvblVucm9sbChhc3Qub2JqZWN0KSArXG4gICAgICAgICAgJy4nICtcbiAgICAgICAgICB0aGlzLmFzdE1lbWJlckV4cHJlc3Npb25VbnJvbGwoYXN0LnByb3BlcnR5KVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChhc3QuaGFzT3duUHJvcGVydHkoJ2V4cHJlc3Npb25zJykpIHtcbiAgICAgIGNvbnN0IGZpcnN0RXhwcmVzc2lvbiA9IGFzdC5leHByZXNzaW9uc1swXTtcbiAgICAgIGlmIChmaXJzdEV4cHJlc3Npb24udHlwZSA9PT0gJ0xpdGVyYWwnICYmIGZpcnN0RXhwcmVzc2lvbi52YWx1ZSA9PT0gMCAmJiBhc3QuZXhwcmVzc2lvbnMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFzdE1lbWJlckV4cHJlc3Npb25VbnJvbGwoYXN0LmV4cHJlc3Npb25zWzFdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KCdVbmtub3duIGFzdE1lbWJlckV4cHJlc3Npb25VbnJvbGwnLCBhc3QpO1xuICB9XG5cbiAgZ2V0SnNBU1QoaW5QYXJzZXIpIHtcbiAgICBpZiAodGhpcy5hc3QpIHtcbiAgICAgIHJldHVybiB0aGlzLmFzdDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB0aGlzLnNvdXJjZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHRoaXMudHJhY2VGdW5jdGlvbkFTVCh0aGlzLnNvdXJjZSk7XG4gICAgICByZXR1cm4gdGhpcy5hc3QgPSB0aGlzLnNvdXJjZTtcbiAgICB9XG5cbiAgICBpblBhcnNlciA9IGluUGFyc2VyIHx8IGFjb3JuO1xuICAgIGlmIChpblBhcnNlciA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIEpTIHRvIEFTVCBwYXJzZXInKTtcbiAgICB9XG5cbiAgICBjb25zdCBhc3QgPSBPYmplY3QuZnJlZXplKGluUGFyc2VyLnBhcnNlKGBjb25zdCBwYXJzZXJfJHsgdGhpcy5uYW1lIH0gPSAkeyB0aGlzLnNvdXJjZSB9O2AsIHtcbiAgICAgIGxvY2F0aW9uczogdHJ1ZVxuICAgIH0pKTtcbiAgICBjb25zdCBmdW5jdGlvbkFTVCA9IGFzdC5ib2R5WzBdLmRlY2xhcmF0aW9uc1swXS5pbml0O1xuICAgIHRoaXMudHJhY2VGdW5jdGlvbkFTVChmdW5jdGlvbkFTVCk7XG5cbiAgICBpZiAoIWFzdCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gcGFyc2UgSlMgY29kZScpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmFzdCA9IGZ1bmN0aW9uQVNUO1xuICB9XG5cbiAgdHJhY2VGdW5jdGlvbkFTVChhc3QpIHtcbiAgICBjb25zdCB7IGNvbnRleHRzLCBkZWNsYXJhdGlvbnMsIGZ1bmN0aW9ucywgaWRlbnRpZmllcnMsIGZ1bmN0aW9uQ2FsbHMgfSA9IG5ldyBGdW5jdGlvblRyYWNlcihhc3QpO1xuICAgIHRoaXMuY29udGV4dHMgPSBjb250ZXh0cztcbiAgICB0aGlzLmlkZW50aWZpZXJzID0gaWRlbnRpZmllcnM7XG4gICAgdGhpcy5mdW5jdGlvbkNhbGxzID0gZnVuY3Rpb25DYWxscztcbiAgICB0aGlzLmZ1bmN0aW9ucyA9IGZ1bmN0aW9ucztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRlY2xhcmF0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgZGVjbGFyYXRpb24gPSBkZWNsYXJhdGlvbnNbaV07XG4gICAgICBjb25zdCB7IGFzdCwgaW5Gb3JMb29wSW5pdCwgaW5Gb3JMb29wVGVzdCB9ID0gZGVjbGFyYXRpb247XG4gICAgICBjb25zdCB7IGluaXQgfSA9IGFzdDtcbiAgICAgIGNvbnN0IGRlcGVuZGVuY2llcyA9IHRoaXMuZ2V0RGVwZW5kZW5jaWVzKGluaXQpO1xuICAgICAgbGV0IHZhbHVlVHlwZSA9IG51bGw7XG5cbiAgICAgIGlmIChpbkZvckxvb3BJbml0ICYmIGluRm9yTG9vcFRlc3QpIHtcbiAgICAgICAgdmFsdWVUeXBlID0gJ0ludGVnZXInO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGluaXQpIHtcbiAgICAgICAgICBjb25zdCByZWFsVHlwZSA9IHRoaXMuZ2V0VHlwZShpbml0KTtcbiAgICAgICAgICBzd2l0Y2ggKHJlYWxUeXBlKSB7XG4gICAgICAgICAgICBjYXNlICdJbnRlZ2VyJzpcbiAgICAgICAgICAgIGNhc2UgJ0Zsb2F0JzpcbiAgICAgICAgICAgIGNhc2UgJ051bWJlcic6XG4gICAgICAgICAgICAgIGlmIChpbml0LnR5cGUgPT09ICdNZW1iZXJFeHByZXNzaW9uJykge1xuICAgICAgICAgICAgICAgIHZhbHVlVHlwZSA9IHJlYWxUeXBlO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhbHVlVHlwZSA9ICdOdW1iZXInO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnTGl0ZXJhbEludGVnZXInOlxuICAgICAgICAgICAgICB2YWx1ZVR5cGUgPSAnTnVtYmVyJztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICB2YWx1ZVR5cGUgPSByZWFsVHlwZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGRlY2xhcmF0aW9uLnZhbHVlVHlwZSA9IHZhbHVlVHlwZTtcbiAgICAgIGRlY2xhcmF0aW9uLmRlcGVuZGVuY2llcyA9IGRlcGVuZGVuY2llcztcbiAgICAgIGRlY2xhcmF0aW9uLmlzU2FmZSA9IHRoaXMuaXNTYWZlRGVwZW5kZW5jaWVzKGRlcGVuZGVuY2llcyk7XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmdW5jdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMub25OZXN0ZWRGdW5jdGlvbihmdW5jdGlvbnNbaV0sIHRoaXMuc291cmNlKTtcbiAgICB9XG4gIH1cblxuICBnZXREZWNsYXJhdGlvbihhc3QpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuaWRlbnRpZmllcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGlkZW50aWZpZXIgPSB0aGlzLmlkZW50aWZpZXJzW2ldO1xuICAgICAgaWYgKGFzdCA9PT0gaWRlbnRpZmllci5hc3QpIHtcbiAgICAgICAgcmV0dXJuIGlkZW50aWZpZXIuZGVjbGFyYXRpb247XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZ2V0VmFyaWFibGVUeXBlKGFzdCkge1xuICAgIGlmIChhc3QudHlwZSAhPT0gJ0lkZW50aWZpZXInKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGFzdCBvZiAke2FzdC50eXBlfSBub3QgXCJJZGVudGlmaWVyXCJgKTtcbiAgICB9XG4gICAgbGV0IHR5cGUgPSBudWxsO1xuICAgIGNvbnN0IGFyZ3VtZW50SW5kZXggPSB0aGlzLmFyZ3VtZW50TmFtZXMuaW5kZXhPZihhc3QubmFtZSk7XG4gICAgaWYgKGFyZ3VtZW50SW5kZXggPT09IC0xKSB7XG4gICAgICBjb25zdCBkZWNsYXJhdGlvbiA9IHRoaXMuZ2V0RGVjbGFyYXRpb24oYXN0KTtcbiAgICAgIGlmIChkZWNsYXJhdGlvbikge1xuICAgICAgICByZXR1cm4gZGVjbGFyYXRpb24udmFsdWVUeXBlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBhcmd1bWVudFR5cGUgPSB0aGlzLmFyZ3VtZW50VHlwZXNbYXJndW1lbnRJbmRleF07XG4gICAgICBpZiAoYXJndW1lbnRUeXBlKSB7XG4gICAgICAgIHR5cGUgPSBhcmd1bWVudFR5cGU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghdHlwZSAmJiB0aGlzLnN0cmljdFR5cGluZ0NoZWNraW5nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYERlY2xhcmF0aW9uIG9mICR7bmFtZX0gbm90IGZvdW5kYCk7XG4gICAgfVxuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgZ2V0TG9va3VwVHlwZSh0eXBlKSB7XG4gICAgaWYgKCF0eXBlTG9va3VwTWFwLmhhc093blByb3BlcnR5KHR5cGUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHVua25vd24gdHlwZUxvb2t1cE1hcCAkeyB0eXBlIH1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHR5cGVMb29rdXBNYXBbdHlwZV07XG4gIH1cblxuICBnZXRDb25zdGFudFR5cGUoY29uc3RhbnROYW1lKSB7XG4gICAgaWYgKHRoaXMuY29uc3RhbnRUeXBlc1tjb25zdGFudE5hbWVdKSB7XG4gICAgICBjb25zdCB0eXBlID0gdGhpcy5jb25zdGFudFR5cGVzW2NvbnN0YW50TmFtZV07XG4gICAgICBpZiAodHlwZSA9PT0gJ0Zsb2F0Jykge1xuICAgICAgICByZXR1cm4gJ051bWJlcic7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBUeXBlIGZvciBjb25zdGFudCBcIiR7IGNvbnN0YW50TmFtZSB9XCIgbm90IGRlY2xhcmVkYCk7XG4gIH1cblxuICB0b1N0cmluZygpIHtcbiAgICBpZiAodGhpcy5fc3RyaW5nKSByZXR1cm4gdGhpcy5fc3RyaW5nO1xuICAgIHJldHVybiB0aGlzLl9zdHJpbmcgPSB0aGlzLmFzdEdlbmVyaWModGhpcy5nZXRKc0FTVCgpLCBbXSkuam9pbignJykudHJpbSgpO1xuICB9XG5cbiAgdG9KU09OKCkge1xuICAgIGNvbnN0IHNldHRpbmdzID0ge1xuICAgICAgc291cmNlOiB0aGlzLnNvdXJjZSxcbiAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgIGNvbnN0YW50czogdGhpcy5jb25zdGFudHMsXG4gICAgICBjb25zdGFudFR5cGVzOiB0aGlzLmNvbnN0YW50VHlwZXMsXG4gICAgICBpc1Jvb3RLZXJuZWw6IHRoaXMuaXNSb290S2VybmVsLFxuICAgICAgaXNTdWJLZXJuZWw6IHRoaXMuaXNTdWJLZXJuZWwsXG4gICAgICBkZWJ1ZzogdGhpcy5kZWJ1ZyxcbiAgICAgIG91dHB1dDogdGhpcy5vdXRwdXQsXG4gICAgICBsb29wTWF4SXRlcmF0aW9uczogdGhpcy5sb29wTWF4SXRlcmF0aW9ucyxcbiAgICAgIGFyZ3VtZW50TmFtZXM6IHRoaXMuYXJndW1lbnROYW1lcyxcbiAgICAgIGFyZ3VtZW50VHlwZXM6IHRoaXMuYXJndW1lbnRUeXBlcyxcbiAgICAgIGFyZ3VtZW50U2l6ZXM6IHRoaXMuYXJndW1lbnRTaXplcyxcbiAgICAgIHJldHVyblR5cGU6IHRoaXMucmV0dXJuVHlwZSxcbiAgICAgIGxlYWRpbmdSZXR1cm5TdGF0ZW1lbnQ6IHRoaXMubGVhZGluZ1JldHVyblN0YXRlbWVudCxcbiAgICAgIGZvbGxvd2luZ1JldHVyblN0YXRlbWVudDogdGhpcy5mb2xsb3dpbmdSZXR1cm5TdGF0ZW1lbnQsXG4gICAgfTtcblxuICAgIHJldHVybiB7XG4gICAgICBhc3Q6IHRoaXMuYXN0LFxuICAgICAgc2V0dGluZ3NcbiAgICB9O1xuICB9XG5cbiAgZ2V0VHlwZShhc3QpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhc3QpKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRUeXBlKGFzdFthc3QubGVuZ3RoIC0gMV0pO1xuICAgIH1cbiAgICBzd2l0Y2ggKGFzdC50eXBlKSB7XG4gICAgICBjYXNlICdCbG9ja1N0YXRlbWVudCc6XG4gICAgICAgIHJldHVybiB0aGlzLmdldFR5cGUoYXN0LmJvZHkpO1xuICAgICAgY2FzZSAnQXJyYXlFeHByZXNzaW9uJzpcbiAgICAgICAgY29uc3QgY2hpbGRUeXBlID0gdGhpcy5nZXRUeXBlKGFzdC5lbGVtZW50c1swXSk7XG4gICAgICAgIHN3aXRjaCAoY2hpbGRUeXBlKSB7XG4gICAgICAgICAgY2FzZSAnQXJyYXkoMiknOlxuICAgICAgICAgIGNhc2UgJ0FycmF5KDMpJzpcbiAgICAgICAgICBjYXNlICdBcnJheSg0KSc6XG4gICAgICAgICAgICByZXR1cm4gYE1hdHJpeCgke2FzdC5lbGVtZW50cy5sZW5ndGh9KWA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGBBcnJheSgkeyBhc3QuZWxlbWVudHMubGVuZ3RoIH0pYDtcbiAgICAgIGNhc2UgJ0xpdGVyYWwnOlxuICAgICAgICBjb25zdCBsaXRlcmFsS2V5ID0gdGhpcy5hc3RLZXkoYXN0KTtcbiAgICAgICAgaWYgKHRoaXMubGl0ZXJhbFR5cGVzW2xpdGVyYWxLZXldKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMubGl0ZXJhbFR5cGVzW2xpdGVyYWxLZXldO1xuICAgICAgICB9XG4gICAgICAgIGlmIChOdW1iZXIuaXNJbnRlZ2VyKGFzdC52YWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gJ0xpdGVyYWxJbnRlZ2VyJztcbiAgICAgICAgfSBlbHNlIGlmIChhc3QudmFsdWUgPT09IHRydWUgfHwgYXN0LnZhbHVlID09PSBmYWxzZSkge1xuICAgICAgICAgIHJldHVybiAnQm9vbGVhbic7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuICdOdW1iZXInO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ0Fzc2lnbm1lbnRFeHByZXNzaW9uJzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5nZXRUeXBlKGFzdC5sZWZ0KTtcbiAgICAgICAgY2FzZSAnQ2FsbEV4cHJlc3Npb24nOlxuICAgICAgICAgIGlmICh0aGlzLmlzQXN0TWF0aEZ1bmN0aW9uKGFzdCkpIHtcbiAgICAgICAgICAgIHJldHVybiAnTnVtYmVyJztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFhc3QuY2FsbGVlIHx8ICFhc3QuY2FsbGVlLm5hbWUpIHtcbiAgICAgICAgICAgIGlmIChhc3QuY2FsbGVlLnR5cGUgPT09ICdTZXF1ZW5jZUV4cHJlc3Npb24nICYmIGFzdC5jYWxsZWUuZXhwcmVzc2lvbnNbYXN0LmNhbGxlZS5leHByZXNzaW9ucy5sZW5ndGggLSAxXS5wcm9wZXJ0eS5uYW1lKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGZ1bmN0aW9uTmFtZSA9IGFzdC5jYWxsZWUuZXhwcmVzc2lvbnNbYXN0LmNhbGxlZS5leHByZXNzaW9ucy5sZW5ndGggLSAxXS5wcm9wZXJ0eS5uYW1lO1xuICAgICAgICAgICAgICB0aGlzLmluZmVyQXJndW1lbnRUeXBlc0lmTmVlZGVkKGZ1bmN0aW9uTmFtZSwgYXN0LmFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLmxvb2t1cFJldHVyblR5cGUoZnVuY3Rpb25OYW1lLCBhc3QsIHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuZ2V0VmFyaWFibGVTaWduYXR1cmUoYXN0LmNhbGxlZSwgdHJ1ZSkgPT09ICd0aGlzLmNvbG9yJykge1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhc3QuY2FsbGVlLnR5cGUgPT09ICdNZW1iZXJFeHByZXNzaW9uJyAmJiBhc3QuY2FsbGVlLm9iamVjdCAmJiBhc3QuY2FsbGVlLnByb3BlcnR5ICYmIGFzdC5jYWxsZWUucHJvcGVydHkubmFtZSAmJiBhc3QuYXJndW1lbnRzKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGZ1bmN0aW9uTmFtZSA9IGFzdC5jYWxsZWUucHJvcGVydHkubmFtZTtcbiAgICAgICAgICAgICAgdGhpcy5pbmZlckFyZ3VtZW50VHlwZXNJZk5lZWRlZChmdW5jdGlvbk5hbWUsIGFzdC5hcmd1bWVudHMpO1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5sb29rdXBSZXR1cm5UeXBlKGZ1bmN0aW9uTmFtZSwgYXN0LCB0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoJ1Vua25vd24gY2FsbCBleHByZXNzaW9uJywgYXN0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGFzdC5jYWxsZWUgJiYgYXN0LmNhbGxlZS5uYW1lKSB7XG4gICAgICAgICAgICBjb25zdCBmdW5jdGlvbk5hbWUgPSBhc3QuY2FsbGVlLm5hbWU7XG4gICAgICAgICAgICB0aGlzLmluZmVyQXJndW1lbnRUeXBlc0lmTmVlZGVkKGZ1bmN0aW9uTmFtZSwgYXN0LmFyZ3VtZW50cyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb29rdXBSZXR1cm5UeXBlKGZ1bmN0aW9uTmFtZSwgYXN0LCB0aGlzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dChgVW5oYW5kbGVkIGdldFR5cGUgVHlwZSBcIiR7IGFzdC50eXBlIH1cImAsIGFzdCk7XG4gICAgICAgIGNhc2UgJ0xvZ2ljYWxFeHByZXNzaW9uJzpcbiAgICAgICAgICByZXR1cm4gJ0Jvb2xlYW4nO1xuICAgICAgICBjYXNlICdCaW5hcnlFeHByZXNzaW9uJzpcbiAgICAgICAgICBzd2l0Y2ggKGFzdC5vcGVyYXRvcikge1xuICAgICAgICAgICAgY2FzZSAnJSc6XG4gICAgICAgICAgICBjYXNlICcvJzpcbiAgICAgICAgICAgICAgaWYgKHRoaXMuZml4SW50ZWdlckRpdmlzaW9uQWNjdXJhY3kpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ051bWJlcic7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2FzZSAnPic6XG4gICAgICAgICAgICAgIGNhc2UgJzwnOlxuICAgICAgICAgICAgICAgIHJldHVybiAnQm9vbGVhbic7XG4gICAgICAgICAgICAgIGNhc2UgJyYnOlxuICAgICAgICAgICAgICBjYXNlICd8JzpcbiAgICAgICAgICAgICAgY2FzZSAnXic6XG4gICAgICAgICAgICAgIGNhc2UgJzw8JzpcbiAgICAgICAgICAgICAgY2FzZSAnPj4nOlxuICAgICAgICAgICAgICBjYXNlICc+Pj4nOlxuICAgICAgICAgICAgICAgIHJldHVybiAnSW50ZWdlcic7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHR5cGUgPSB0aGlzLmdldFR5cGUoYXN0LmxlZnQpO1xuICAgICAgICAgIGlmICh0aGlzLmlzU3RhdGUoJ3NraXAtbGl0ZXJhbC1jb3JyZWN0aW9uJykpIHJldHVybiB0eXBlO1xuICAgICAgICAgIGlmICh0eXBlID09PSAnTGl0ZXJhbEludGVnZXInKSB7XG4gICAgICAgICAgICBjb25zdCByaWdodFR5cGUgPSB0aGlzLmdldFR5cGUoYXN0LnJpZ2h0KTtcbiAgICAgICAgICAgIGlmIChyaWdodFR5cGUgPT09ICdMaXRlcmFsSW50ZWdlcicpIHtcbiAgICAgICAgICAgICAgaWYgKGFzdC5sZWZ0LnZhbHVlICUgMSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnSW50ZWdlcic7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdGbG9hdCc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByaWdodFR5cGU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0eXBlTG9va3VwTWFwW3R5cGVdIHx8IHR5cGU7XG4gICAgICAgIGNhc2UgJ1VwZGF0ZUV4cHJlc3Npb24nOlxuICAgICAgICAgIHJldHVybiB0aGlzLmdldFR5cGUoYXN0LmFyZ3VtZW50KTtcbiAgICAgICAgY2FzZSAnVW5hcnlFeHByZXNzaW9uJzpcbiAgICAgICAgICBpZiAoYXN0Lm9wZXJhdG9yID09PSAnficpIHtcbiAgICAgICAgICAgIHJldHVybiAnSW50ZWdlcic7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aGlzLmdldFR5cGUoYXN0LmFyZ3VtZW50KTtcbiAgICAgICAgY2FzZSAnVmFyaWFibGVEZWNsYXJhdGlvbic6IHtcbiAgICAgICAgICBjb25zdCBkZWNsYXJhdGlvbnMgPSBhc3QuZGVjbGFyYXRpb25zO1xuICAgICAgICAgIGxldCBsYXN0VHlwZTtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRlY2xhcmF0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgZGVjbGFyYXRpb24gPSBkZWNsYXJhdGlvbnNbaV07XG4gICAgICAgICAgICBsYXN0VHlwZSA9IHRoaXMuZ2V0VHlwZShkZWNsYXJhdGlvbik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghbGFzdFR5cGUpIHtcbiAgICAgICAgICAgIHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoYFVuYWJsZSB0byBmaW5kIHR5cGUgZm9yIGRlY2xhcmF0aW9uYCwgYXN0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGxhc3RUeXBlO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ1ZhcmlhYmxlRGVjbGFyYXRvcic6XG4gICAgICAgICAgY29uc3QgZGVjbGFyYXRpb24gPSB0aGlzLmdldERlY2xhcmF0aW9uKGFzdC5pZCk7XG4gICAgICAgICAgaWYgKCFkZWNsYXJhdGlvbikge1xuICAgICAgICAgICAgdGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dChgVW5hYmxlIHRvIGZpbmQgZGVjbGFyYXRvcmAsIGFzdCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFkZWNsYXJhdGlvbi52YWx1ZVR5cGUpIHtcbiAgICAgICAgICAgIHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoYFVuYWJsZSB0byBmaW5kIGRlY2xhcmF0b3IgdmFsdWVUeXBlYCwgYXN0KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gZGVjbGFyYXRpb24udmFsdWVUeXBlO1xuICAgICAgICBjYXNlICdJZGVudGlmaWVyJzpcbiAgICAgICAgICBpZiAoYXN0Lm5hbWUgPT09ICdJbmZpbml0eScpIHtcbiAgICAgICAgICAgIHJldHVybiAnTnVtYmVyJztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRoaXMuaXNBc3RWYXJpYWJsZShhc3QpKSB7XG4gICAgICAgICAgICBjb25zdCBzaWduYXR1cmUgPSB0aGlzLmdldFZhcmlhYmxlU2lnbmF0dXJlKGFzdCk7XG4gICAgICAgICAgICBpZiAoc2lnbmF0dXJlID09PSAndmFsdWUnKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldENoZWNrVmFyaWFibGVUeXBlKGFzdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IG9yaWdpbiA9IHRoaXMuZmluZElkZW50aWZpZXJPcmlnaW4oYXN0KTtcbiAgICAgICAgICBpZiAob3JpZ2luICYmIG9yaWdpbi5pbml0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRUeXBlKG9yaWdpbi5pbml0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGNhc2UgJ1JldHVyblN0YXRlbWVudCc6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VHlwZShhc3QuYXJndW1lbnQpO1xuICAgICAgICBjYXNlICdNZW1iZXJFeHByZXNzaW9uJzpcbiAgICAgICAgICBpZiAodGhpcy5pc0FzdE1hdGhGdW5jdGlvbihhc3QpKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGFzdC5wcm9wZXJ0eS5uYW1lKSB7XG4gICAgICAgICAgICAgIGNhc2UgJ2NlaWwnOlxuICAgICAgICAgICAgICAgIHJldHVybiAnSW50ZWdlcic7XG4gICAgICAgICAgICAgIGNhc2UgJ2Zsb29yJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ0ludGVnZXInO1xuICAgICAgICAgICAgICBjYXNlICdyb3VuZCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdJbnRlZ2VyJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAnTnVtYmVyJztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRoaXMuaXNBc3RWYXJpYWJsZShhc3QpKSB7XG4gICAgICAgICAgICBjb25zdCB2YXJpYWJsZVNpZ25hdHVyZSA9IHRoaXMuZ2V0VmFyaWFibGVTaWduYXR1cmUoYXN0KTtcbiAgICAgICAgICAgIHN3aXRjaCAodmFyaWFibGVTaWduYXR1cmUpIHtcbiAgICAgICAgICAgICAgY2FzZSAndmFsdWVbXSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TG9va3VwVHlwZSh0aGlzLmdldENoZWNrVmFyaWFibGVUeXBlKGFzdC5vYmplY3QpKTtcbiAgICAgICAgICAgICAgY2FzZSAndmFsdWVbXVtdJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRMb29rdXBUeXBlKHRoaXMuZ2V0Q2hlY2tWYXJpYWJsZVR5cGUoYXN0Lm9iamVjdC5vYmplY3QpKTtcbiAgICAgICAgICAgICAgY2FzZSAndmFsdWVbXVtdW10nOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldExvb2t1cFR5cGUodGhpcy5nZXRDaGVja1ZhcmlhYmxlVHlwZShhc3Qub2JqZWN0Lm9iamVjdC5vYmplY3QpKTtcbiAgICAgICAgICAgICAgY2FzZSAndmFsdWVbXVtdW11bXSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TG9va3VwVHlwZSh0aGlzLmdldENoZWNrVmFyaWFibGVUeXBlKGFzdC5vYmplY3Qub2JqZWN0Lm9iamVjdC5vYmplY3QpKTtcbiAgICAgICAgICAgICAgY2FzZSAndmFsdWUudGhyZWFkLnZhbHVlJzpcbiAgICAgICAgICAgICAgY2FzZSAndGhpcy50aHJlYWQudmFsdWUnOlxuICAgICAgICAgICAgICAgIHJldHVybiAnSW50ZWdlcic7XG4gICAgICAgICAgICAgIGNhc2UgJ3RoaXMub3V0cHV0LnZhbHVlJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5keW5hbWljT3V0cHV0ID8gJ0ludGVnZXInIDogJ0xpdGVyYWxJbnRlZ2VyJztcbiAgICAgICAgICAgICAgY2FzZSAndGhpcy5jb25zdGFudHMudmFsdWUnOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldENvbnN0YW50VHlwZShhc3QucHJvcGVydHkubmFtZSk7XG4gICAgICAgICAgICAgIGNhc2UgJ3RoaXMuY29uc3RhbnRzLnZhbHVlW10nOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldExvb2t1cFR5cGUodGhpcy5nZXRDb25zdGFudFR5cGUoYXN0Lm9iamVjdC5wcm9wZXJ0eS5uYW1lKSk7XG4gICAgICAgICAgICAgIGNhc2UgJ3RoaXMuY29uc3RhbnRzLnZhbHVlW11bXSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TG9va3VwVHlwZSh0aGlzLmdldENvbnN0YW50VHlwZShhc3Qub2JqZWN0Lm9iamVjdC5wcm9wZXJ0eS5uYW1lKSk7XG4gICAgICAgICAgICAgIGNhc2UgJ3RoaXMuY29uc3RhbnRzLnZhbHVlW11bXVtdJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRMb29rdXBUeXBlKHRoaXMuZ2V0Q29uc3RhbnRUeXBlKGFzdC5vYmplY3Qub2JqZWN0Lm9iamVjdC5wcm9wZXJ0eS5uYW1lKSk7XG4gICAgICAgICAgICAgIGNhc2UgJ3RoaXMuY29uc3RhbnRzLnZhbHVlW11bXVtdW10nOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldExvb2t1cFR5cGUodGhpcy5nZXRDb25zdGFudFR5cGUoYXN0Lm9iamVjdC5vYmplY3Qub2JqZWN0Lm9iamVjdC5wcm9wZXJ0eS5uYW1lKSk7XG4gICAgICAgICAgICAgIGNhc2UgJ2ZuKClbXSc6XG4gICAgICAgICAgICAgIGNhc2UgJ2ZuKClbXVtdJzpcbiAgICAgICAgICAgICAgY2FzZSAnZm4oKVtdW11bXSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TG9va3VwVHlwZSh0aGlzLmdldFR5cGUoYXN0Lm9iamVjdCkpO1xuICAgICAgICAgICAgICBjYXNlICd2YWx1ZS52YWx1ZSc6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNBc3RNYXRoVmFyaWFibGUoYXN0KSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuICdOdW1iZXInO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGFzdC5wcm9wZXJ0eS5uYW1lKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlICdyJzpcbiAgICAgICAgICAgICAgICAgIGNhc2UgJ2cnOlxuICAgICAgICAgICAgICAgICAgY2FzZSAnYic6XG4gICAgICAgICAgICAgICAgICBjYXNlICdhJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TG9va3VwVHlwZSh0aGlzLmdldENoZWNrVmFyaWFibGVUeXBlKGFzdC5vYmplY3QpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAnW11bXSc6XG4gICAgICAgICAgICAgICAgICByZXR1cm4gJ051bWJlcic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KCdVbmhhbmRsZWQgZ2V0VHlwZSBNZW1iZXJFeHByZXNzaW9uJywgYXN0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dCgnVW5oYW5kbGVkIGdldFR5cGUgTWVtYmVyRXhwcmVzc2lvbicsIGFzdCk7XG4gICAgICAgIGNhc2UgJ0NvbmRpdGlvbmFsRXhwcmVzc2lvbic6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VHlwZShhc3QuY29uc2VxdWVudCk7XG4gICAgICAgIGNhc2UgJ0Z1bmN0aW9uRGVjbGFyYXRpb24nOlxuICAgICAgICBjYXNlICdGdW5jdGlvbkV4cHJlc3Npb24nOlxuICAgICAgICAgIGNvbnN0IGxhc3RSZXR1cm4gPSB0aGlzLmZpbmRMYXN0UmV0dXJuKGFzdC5ib2R5KTtcbiAgICAgICAgICBpZiAobGFzdFJldHVybikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VHlwZShsYXN0UmV0dXJuKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGNhc2UgJ0lmU3RhdGVtZW50JzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5nZXRUeXBlKGFzdC5jb25zZXF1ZW50KTtcbiAgICAgICAgY2FzZSAnU2VxdWVuY2VFeHByZXNzaW9uJzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5nZXRUeXBlKGFzdC5leHByZXNzaW9uc1thc3QuZXhwcmVzc2lvbnMubGVuZ3RoIC0gMV0pO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoYFVuaGFuZGxlZCBnZXRUeXBlIFR5cGUgXCIkeyBhc3QudHlwZSB9XCJgLCBhc3QpO1xuICAgIH1cbiAgfVxuXG4gIGdldENoZWNrVmFyaWFibGVUeXBlKGFzdCkge1xuICAgIGNvbnN0IHR5cGUgPSB0aGlzLmdldFZhcmlhYmxlVHlwZShhc3QpO1xuICAgIGlmICghdHlwZSkge1xuICAgICAgdGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dChgJHthc3QudHlwZX0gaXMgbm90IGRlZmluZWRgLCBhc3QpO1xuICAgIH1cbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuXG4gIGluZmVyQXJndW1lbnRUeXBlc0lmTmVlZGVkKGZ1bmN0aW9uTmFtZSwgYXJncykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCF0aGlzLm5lZWRzQXJndW1lbnRUeXBlKGZ1bmN0aW9uTmFtZSwgaSkpIGNvbnRpbnVlO1xuICAgICAgY29uc3QgdHlwZSA9IHRoaXMuZ2V0VHlwZShhcmdzW2ldKTtcbiAgICAgIGlmICghdHlwZSkge1xuICAgICAgICB0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KGBVbmFibGUgdG8gaW5mZXIgYXJndW1lbnQgJHtpfWAsIGFyZ3NbaV0pO1xuICAgICAgfVxuICAgICAgdGhpcy5hc3NpZ25Bcmd1bWVudFR5cGUoZnVuY3Rpb25OYW1lLCBpLCB0eXBlKTtcbiAgICB9XG4gIH1cblxuICBpc0FzdE1hdGhWYXJpYWJsZShhc3QpIHtcbiAgICBjb25zdCBtYXRoUHJvcGVydGllcyA9IFtcbiAgICAgICdFJyxcbiAgICAgICdQSScsXG4gICAgICAnU1FSVDInLFxuICAgICAgJ1NRUlQxXzInLFxuICAgICAgJ0xOMicsXG4gICAgICAnTE4xMCcsXG4gICAgICAnTE9HMkUnLFxuICAgICAgJ0xPRzEwRScsXG4gICAgXTtcbiAgICByZXR1cm4gYXN0LnR5cGUgPT09ICdNZW1iZXJFeHByZXNzaW9uJyAmJlxuICAgICAgYXN0Lm9iamVjdCAmJiBhc3Qub2JqZWN0LnR5cGUgPT09ICdJZGVudGlmaWVyJyAmJlxuICAgICAgYXN0Lm9iamVjdC5uYW1lID09PSAnTWF0aCcgJiZcbiAgICAgIGFzdC5wcm9wZXJ0eSAmJlxuICAgICAgYXN0LnByb3BlcnR5LnR5cGUgPT09ICdJZGVudGlmaWVyJyAmJlxuICAgICAgbWF0aFByb3BlcnRpZXMuaW5kZXhPZihhc3QucHJvcGVydHkubmFtZSkgPiAtMTtcbiAgfVxuXG4gIGlzQXN0TWF0aEZ1bmN0aW9uKGFzdCkge1xuICAgIGNvbnN0IG1hdGhGdW5jdGlvbnMgPSBbXG4gICAgICAnYWJzJyxcbiAgICAgICdhY29zJyxcbiAgICAgICdhY29zaCcsXG4gICAgICAnYXNpbicsXG4gICAgICAnYXNpbmgnLFxuICAgICAgJ2F0YW4nLFxuICAgICAgJ2F0YW4yJyxcbiAgICAgICdhdGFuaCcsXG4gICAgICAnY2JydCcsXG4gICAgICAnY2VpbCcsXG4gICAgICAnY2x6MzInLFxuICAgICAgJ2NvcycsXG4gICAgICAnY29zaCcsXG4gICAgICAnZXhwbTEnLFxuICAgICAgJ2V4cCcsXG4gICAgICAnZmxvb3InLFxuICAgICAgJ2Zyb3VuZCcsXG4gICAgICAnaW11bCcsXG4gICAgICAnbG9nJyxcbiAgICAgICdsb2cyJyxcbiAgICAgICdsb2cxMCcsXG4gICAgICAnbG9nMXAnLFxuICAgICAgJ21heCcsXG4gICAgICAnbWluJyxcbiAgICAgICdwb3cnLFxuICAgICAgJ3JhbmRvbScsXG4gICAgICAncm91bmQnLFxuICAgICAgJ3NpZ24nLFxuICAgICAgJ3NpbicsXG4gICAgICAnc2luaCcsXG4gICAgICAnc3FydCcsXG4gICAgICAndGFuJyxcbiAgICAgICd0YW5oJyxcbiAgICAgICd0cnVuYycsXG4gICAgXTtcbiAgICByZXR1cm4gYXN0LnR5cGUgPT09ICdDYWxsRXhwcmVzc2lvbicgJiZcbiAgICAgIGFzdC5jYWxsZWUgJiZcbiAgICAgIGFzdC5jYWxsZWUudHlwZSA9PT0gJ01lbWJlckV4cHJlc3Npb24nICYmXG4gICAgICBhc3QuY2FsbGVlLm9iamVjdCAmJlxuICAgICAgYXN0LmNhbGxlZS5vYmplY3QudHlwZSA9PT0gJ0lkZW50aWZpZXInICYmXG4gICAgICBhc3QuY2FsbGVlLm9iamVjdC5uYW1lID09PSAnTWF0aCcgJiZcbiAgICAgIGFzdC5jYWxsZWUucHJvcGVydHkgJiZcbiAgICAgIGFzdC5jYWxsZWUucHJvcGVydHkudHlwZSA9PT0gJ0lkZW50aWZpZXInICYmXG4gICAgICBtYXRoRnVuY3Rpb25zLmluZGV4T2YoYXN0LmNhbGxlZS5wcm9wZXJ0eS5uYW1lKSA+IC0xO1xuICB9XG5cbiAgaXNBc3RWYXJpYWJsZShhc3QpIHtcbiAgICByZXR1cm4gYXN0LnR5cGUgPT09ICdJZGVudGlmaWVyJyB8fCBhc3QudHlwZSA9PT0gJ01lbWJlckV4cHJlc3Npb24nO1xuICB9XG5cbiAgaXNTYWZlKGFzdCkge1xuICAgIHJldHVybiB0aGlzLmlzU2FmZURlcGVuZGVuY2llcyh0aGlzLmdldERlcGVuZGVuY2llcyhhc3QpKTtcbiAgfVxuXG4gIGlzU2FmZURlcGVuZGVuY2llcyhkZXBlbmRlbmNpZXMpIHtcbiAgICByZXR1cm4gZGVwZW5kZW5jaWVzICYmIGRlcGVuZGVuY2llcy5ldmVyeSA/IGRlcGVuZGVuY2llcy5ldmVyeShkZXBlbmRlbmN5ID0+IGRlcGVuZGVuY3kuaXNTYWZlKSA6IHRydWU7XG4gIH1cblxuICBnZXREZXBlbmRlbmNpZXMoYXN0LCBkZXBlbmRlbmNpZXMsIGlzTm90U2FmZSkge1xuICAgIGlmICghZGVwZW5kZW5jaWVzKSB7XG4gICAgICBkZXBlbmRlbmNpZXMgPSBbXTtcbiAgICB9XG4gICAgaWYgKCFhc3QpIHJldHVybiBudWxsO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGFzdCkpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuZ2V0RGVwZW5kZW5jaWVzKGFzdFtpXSwgZGVwZW5kZW5jaWVzLCBpc05vdFNhZmUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRlcGVuZGVuY2llcztcbiAgICB9XG4gICAgc3dpdGNoIChhc3QudHlwZSkge1xuICAgICAgY2FzZSAnQXNzaWdubWVudEV4cHJlc3Npb24nOlxuICAgICAgICB0aGlzLmdldERlcGVuZGVuY2llcyhhc3QubGVmdCwgZGVwZW5kZW5jaWVzLCBpc05vdFNhZmUpO1xuICAgICAgICB0aGlzLmdldERlcGVuZGVuY2llcyhhc3QucmlnaHQsIGRlcGVuZGVuY2llcywgaXNOb3RTYWZlKTtcbiAgICAgICAgcmV0dXJuIGRlcGVuZGVuY2llcztcbiAgICAgIGNhc2UgJ0NvbmRpdGlvbmFsRXhwcmVzc2lvbic6XG4gICAgICAgIHRoaXMuZ2V0RGVwZW5kZW5jaWVzKGFzdC50ZXN0LCBkZXBlbmRlbmNpZXMsIGlzTm90U2FmZSk7XG4gICAgICAgIHRoaXMuZ2V0RGVwZW5kZW5jaWVzKGFzdC5hbHRlcm5hdGUsIGRlcGVuZGVuY2llcywgaXNOb3RTYWZlKTtcbiAgICAgICAgdGhpcy5nZXREZXBlbmRlbmNpZXMoYXN0LmNvbnNlcXVlbnQsIGRlcGVuZGVuY2llcywgaXNOb3RTYWZlKTtcbiAgICAgICAgcmV0dXJuIGRlcGVuZGVuY2llcztcbiAgICAgIGNhc2UgJ0xpdGVyYWwnOlxuICAgICAgICBkZXBlbmRlbmNpZXMucHVzaCh7XG4gICAgICAgICAgb3JpZ2luOiAnbGl0ZXJhbCcsXG4gICAgICAgICAgdmFsdWU6IGFzdC52YWx1ZSxcbiAgICAgICAgICBpc1NhZmU6IGlzTm90U2FmZSA9PT0gdHJ1ZSA/IGZhbHNlIDogYXN0LnZhbHVlID4gLUluZmluaXR5ICYmIGFzdC52YWx1ZSA8IEluZmluaXR5ICYmICFpc05hTihhc3QudmFsdWUpXG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ1ZhcmlhYmxlRGVjbGFyYXRvcic6XG4gICAgICAgIHJldHVybiB0aGlzLmdldERlcGVuZGVuY2llcyhhc3QuaW5pdCwgZGVwZW5kZW5jaWVzLCBpc05vdFNhZmUpO1xuICAgICAgY2FzZSAnSWRlbnRpZmllcic6XG4gICAgICAgIGNvbnN0IGRlY2xhcmF0aW9uID0gdGhpcy5nZXREZWNsYXJhdGlvbihhc3QpO1xuICAgICAgICBpZiAoZGVjbGFyYXRpb24pIHtcbiAgICAgICAgICBkZXBlbmRlbmNpZXMucHVzaCh7XG4gICAgICAgICAgICBuYW1lOiBhc3QubmFtZSxcbiAgICAgICAgICAgIG9yaWdpbjogJ2RlY2xhcmF0aW9uJyxcbiAgICAgICAgICAgIGlzU2FmZTogaXNOb3RTYWZlID8gZmFsc2UgOiB0aGlzLmlzU2FmZURlcGVuZGVuY2llcyhkZWNsYXJhdGlvbi5kZXBlbmRlbmNpZXMpLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuYXJndW1lbnROYW1lcy5pbmRleE9mKGFzdC5uYW1lKSA+IC0xKSB7XG4gICAgICAgICAgZGVwZW5kZW5jaWVzLnB1c2goe1xuICAgICAgICAgICAgbmFtZTogYXN0Lm5hbWUsXG4gICAgICAgICAgICBvcmlnaW46ICdhcmd1bWVudCcsXG4gICAgICAgICAgICBpc1NhZmU6IGZhbHNlLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc3RyaWN0VHlwaW5nQ2hlY2tpbmcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBmaW5kIGlkZW50aWZpZXIgb3JpZ2luIFwiJHthc3QubmFtZX1cImApO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnRnVuY3Rpb25EZWNsYXJhdGlvbic6XG4gICAgICAgIHJldHVybiB0aGlzLmdldERlcGVuZGVuY2llcyhhc3QuYm9keS5ib2R5W2FzdC5ib2R5LmJvZHkubGVuZ3RoIC0gMV0sIGRlcGVuZGVuY2llcywgaXNOb3RTYWZlKTtcbiAgICAgIGNhc2UgJ1JldHVyblN0YXRlbWVudCc6XG4gICAgICAgIHJldHVybiB0aGlzLmdldERlcGVuZGVuY2llcyhhc3QuYXJndW1lbnQsIGRlcGVuZGVuY2llcyk7XG4gICAgICBjYXNlICdCaW5hcnlFeHByZXNzaW9uJzpcbiAgICAgIGNhc2UgJ0xvZ2ljYWxFeHByZXNzaW9uJzpcbiAgICAgICAgaXNOb3RTYWZlID0gKGFzdC5vcGVyYXRvciA9PT0gJy8nIHx8IGFzdC5vcGVyYXRvciA9PT0gJyonKTtcbiAgICAgICAgdGhpcy5nZXREZXBlbmRlbmNpZXMoYXN0LmxlZnQsIGRlcGVuZGVuY2llcywgaXNOb3RTYWZlKTtcbiAgICAgICAgdGhpcy5nZXREZXBlbmRlbmNpZXMoYXN0LnJpZ2h0LCBkZXBlbmRlbmNpZXMsIGlzTm90U2FmZSk7XG4gICAgICAgIHJldHVybiBkZXBlbmRlbmNpZXM7XG4gICAgICBjYXNlICdVbmFyeUV4cHJlc3Npb24nOlxuICAgICAgY2FzZSAnVXBkYXRlRXhwcmVzc2lvbic6XG4gICAgICAgIHJldHVybiB0aGlzLmdldERlcGVuZGVuY2llcyhhc3QuYXJndW1lbnQsIGRlcGVuZGVuY2llcywgaXNOb3RTYWZlKTtcbiAgICAgIGNhc2UgJ1ZhcmlhYmxlRGVjbGFyYXRpb24nOlxuICAgICAgICByZXR1cm4gdGhpcy5nZXREZXBlbmRlbmNpZXMoYXN0LmRlY2xhcmF0aW9ucywgZGVwZW5kZW5jaWVzLCBpc05vdFNhZmUpO1xuICAgICAgY2FzZSAnQXJyYXlFeHByZXNzaW9uJzpcbiAgICAgICAgZGVwZW5kZW5jaWVzLnB1c2goe1xuICAgICAgICAgIG9yaWdpbjogJ2RlY2xhcmF0aW9uJyxcbiAgICAgICAgICBpc1NhZmU6IHRydWUsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZGVwZW5kZW5jaWVzO1xuICAgICAgY2FzZSAnQ2FsbEV4cHJlc3Npb24nOlxuICAgICAgICBkZXBlbmRlbmNpZXMucHVzaCh7XG4gICAgICAgICAgb3JpZ2luOiAnZnVuY3Rpb24nLFxuICAgICAgICAgIGlzU2FmZTogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBkZXBlbmRlbmNpZXM7XG4gICAgICBjYXNlICdNZW1iZXJFeHByZXNzaW9uJzpcbiAgICAgICAgY29uc3QgZGV0YWlscyA9IHRoaXMuZ2V0TWVtYmVyRXhwcmVzc2lvbkRldGFpbHMoYXN0KTtcbiAgICAgICAgc3dpdGNoIChkZXRhaWxzLnNpZ25hdHVyZSkge1xuICAgICAgICAgIGNhc2UgJ3ZhbHVlW10nOlxuICAgICAgICAgICAgdGhpcy5nZXREZXBlbmRlbmNpZXMoYXN0Lm9iamVjdCwgZGVwZW5kZW5jaWVzLCBpc05vdFNhZmUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAndmFsdWVbXVtdJzpcbiAgICAgICAgICAgIHRoaXMuZ2V0RGVwZW5kZW5jaWVzKGFzdC5vYmplY3Qub2JqZWN0LCBkZXBlbmRlbmNpZXMsIGlzTm90U2FmZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICd2YWx1ZVtdW11bXSc6XG4gICAgICAgICAgICB0aGlzLmdldERlcGVuZGVuY2llcyhhc3Qub2JqZWN0Lm9iamVjdC5vYmplY3QsIGRlcGVuZGVuY2llcywgaXNOb3RTYWZlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3RoaXMub3V0cHV0LnZhbHVlJzpcbiAgICAgICAgICAgIGlmICh0aGlzLmR5bmFtaWNPdXRwdXQpIHtcbiAgICAgICAgICAgICAgZGVwZW5kZW5jaWVzLnB1c2goe1xuICAgICAgICAgICAgICAgIG5hbWU6IGRldGFpbHMubmFtZSxcbiAgICAgICAgICAgICAgICBvcmlnaW46ICdvdXRwdXQnLFxuICAgICAgICAgICAgICAgIGlzU2FmZTogZmFsc2UsXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRldGFpbHMpIHtcbiAgICAgICAgICBpZiAoZGV0YWlscy5wcm9wZXJ0eSkge1xuICAgICAgICAgICAgdGhpcy5nZXREZXBlbmRlbmNpZXMoZGV0YWlscy5wcm9wZXJ0eSwgZGVwZW5kZW5jaWVzLCBpc05vdFNhZmUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZGV0YWlscy54UHJvcGVydHkpIHtcbiAgICAgICAgICAgIHRoaXMuZ2V0RGVwZW5kZW5jaWVzKGRldGFpbHMueFByb3BlcnR5LCBkZXBlbmRlbmNpZXMsIGlzTm90U2FmZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChkZXRhaWxzLnlQcm9wZXJ0eSkge1xuICAgICAgICAgICAgdGhpcy5nZXREZXBlbmRlbmNpZXMoZGV0YWlscy55UHJvcGVydHksIGRlcGVuZGVuY2llcywgaXNOb3RTYWZlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGRldGFpbHMuelByb3BlcnR5KSB7XG4gICAgICAgICAgICB0aGlzLmdldERlcGVuZGVuY2llcyhkZXRhaWxzLnpQcm9wZXJ0eSwgZGVwZW5kZW5jaWVzLCBpc05vdFNhZmUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZGVwZW5kZW5jaWVzO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ1NlcXVlbmNlRXhwcmVzc2lvbic6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RGVwZW5kZW5jaWVzKGFzdC5leHByZXNzaW9ucywgZGVwZW5kZW5jaWVzLCBpc05vdFNhZmUpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoYFVuaGFuZGxlZCB0eXBlICR7IGFzdC50eXBlIH0gaW4gZ2V0RGVwZW5kZW5jaWVzYCwgYXN0KTtcbiAgICB9XG4gICAgcmV0dXJuIGRlcGVuZGVuY2llcztcbiAgfVxuXG4gIGdldFZhcmlhYmxlU2lnbmF0dXJlKGFzdCwgcmV0dXJuUmF3VmFsdWUpIHtcbiAgICBpZiAoIXRoaXMuaXNBc3RWYXJpYWJsZShhc3QpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGFzdCBvZiB0eXBlIFwiJHsgYXN0LnR5cGUgfVwiIGlzIG5vdCBhIHZhcmlhYmxlIHNpZ25hdHVyZWApO1xuICAgIH1cbiAgICBpZiAoYXN0LnR5cGUgPT09ICdJZGVudGlmaWVyJykge1xuICAgICAgcmV0dXJuICd2YWx1ZSc7XG4gICAgfVxuICAgIGNvbnN0IHNpZ25hdHVyZSA9IFtdO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBpZiAoIWFzdCkgYnJlYWs7XG4gICAgICBpZiAoYXN0LmNvbXB1dGVkKSB7XG4gICAgICAgIHNpZ25hdHVyZS5wdXNoKCdbXScpO1xuICAgICAgfSBlbHNlIGlmIChhc3QudHlwZSA9PT0gJ1RoaXNFeHByZXNzaW9uJykge1xuICAgICAgICBzaWduYXR1cmUudW5zaGlmdCgndGhpcycpO1xuICAgICAgfSBlbHNlIGlmIChhc3QucHJvcGVydHkgJiYgYXN0LnByb3BlcnR5Lm5hbWUpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGFzdC5wcm9wZXJ0eS5uYW1lID09PSAneCcgfHxcbiAgICAgICAgICBhc3QucHJvcGVydHkubmFtZSA9PT0gJ3knIHx8XG4gICAgICAgICAgYXN0LnByb3BlcnR5Lm5hbWUgPT09ICd6J1xuICAgICAgICApIHtcbiAgICAgICAgICBzaWduYXR1cmUudW5zaGlmdChyZXR1cm5SYXdWYWx1ZSA/ICcuJyArIGFzdC5wcm9wZXJ0eS5uYW1lIDogJy52YWx1ZScpO1xuICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgIGFzdC5wcm9wZXJ0eS5uYW1lID09PSAnY29uc3RhbnRzJyB8fFxuICAgICAgICAgIGFzdC5wcm9wZXJ0eS5uYW1lID09PSAndGhyZWFkJyB8fFxuICAgICAgICAgIGFzdC5wcm9wZXJ0eS5uYW1lID09PSAnb3V0cHV0J1xuICAgICAgICApIHtcbiAgICAgICAgICBzaWduYXR1cmUudW5zaGlmdCgnLicgKyBhc3QucHJvcGVydHkubmFtZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2lnbmF0dXJlLnVuc2hpZnQocmV0dXJuUmF3VmFsdWUgPyAnLicgKyBhc3QucHJvcGVydHkubmFtZSA6ICcudmFsdWUnKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChhc3QubmFtZSkge1xuICAgICAgICBzaWduYXR1cmUudW5zaGlmdChyZXR1cm5SYXdWYWx1ZSA/IGFzdC5uYW1lIDogJ3ZhbHVlJyk7XG4gICAgICB9IGVsc2UgaWYgKGFzdC5jYWxsZWUgJiYgYXN0LmNhbGxlZS5uYW1lKSB7XG4gICAgICAgIHNpZ25hdHVyZS51bnNoaWZ0KHJldHVyblJhd1ZhbHVlID8gYXN0LmNhbGxlZS5uYW1lICsgJygpJyA6ICdmbigpJyk7XG4gICAgICB9IGVsc2UgaWYgKGFzdC5lbGVtZW50cykge1xuICAgICAgICBzaWduYXR1cmUudW5zaGlmdCgnW10nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNpZ25hdHVyZS51bnNoaWZ0KCd1bmtub3duJyk7XG4gICAgICB9XG4gICAgICBhc3QgPSBhc3Qub2JqZWN0O1xuICAgIH1cblxuICAgIGNvbnN0IHNpZ25hdHVyZVN0cmluZyA9IHNpZ25hdHVyZS5qb2luKCcnKTtcbiAgICBpZiAocmV0dXJuUmF3VmFsdWUpIHtcbiAgICAgIHJldHVybiBzaWduYXR1cmVTdHJpbmc7XG4gICAgfVxuXG4gICAgY29uc3QgYWxsb3dlZEV4cHJlc3Npb25zID0gW1xuICAgICAgJ3ZhbHVlJyxcbiAgICAgICd2YWx1ZVtdJyxcbiAgICAgICd2YWx1ZVtdW10nLFxuICAgICAgJ3ZhbHVlW11bXVtdJyxcbiAgICAgICd2YWx1ZVtdW11bXVtdJyxcbiAgICAgICd2YWx1ZS52YWx1ZScsXG4gICAgICAndmFsdWUudGhyZWFkLnZhbHVlJyxcbiAgICAgICd0aGlzLnRocmVhZC52YWx1ZScsXG4gICAgICAndGhpcy5vdXRwdXQudmFsdWUnLFxuICAgICAgJ3RoaXMuY29uc3RhbnRzLnZhbHVlJyxcbiAgICAgICd0aGlzLmNvbnN0YW50cy52YWx1ZVtdJyxcbiAgICAgICd0aGlzLmNvbnN0YW50cy52YWx1ZVtdW10nLFxuICAgICAgJ3RoaXMuY29uc3RhbnRzLnZhbHVlW11bXVtdJyxcbiAgICAgICd0aGlzLmNvbnN0YW50cy52YWx1ZVtdW11bXVtdJyxcbiAgICAgICdmbigpW10nLFxuICAgICAgJ2ZuKClbXVtdJyxcbiAgICAgICdmbigpW11bXVtdJyxcbiAgICAgICdbXVtdJyxcbiAgICBdO1xuICAgIGlmIChhbGxvd2VkRXhwcmVzc2lvbnMuaW5kZXhPZihzaWduYXR1cmVTdHJpbmcpID4gLTEpIHtcbiAgICAgIHJldHVybiBzaWduYXR1cmVTdHJpbmc7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgYnVpbGQoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9TdHJpbmcoKS5sZW5ndGggPiAwO1xuICB9XG5cbiAgYXN0R2VuZXJpYyhhc3QsIHJldEFycikge1xuICAgIGlmIChhc3QgPT09IG51bGwpIHtcbiAgICAgIHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoJ05VTEwgYXN0JywgYXN0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXN0KSkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHRoaXMuYXN0R2VuZXJpYyhhc3RbaV0sIHJldEFycik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldEFycjtcbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChhc3QudHlwZSkge1xuICAgICAgICBjYXNlICdGdW5jdGlvbkRlY2xhcmF0aW9uJzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5hc3RGdW5jdGlvbkRlY2xhcmF0aW9uKGFzdCwgcmV0QXJyKTtcbiAgICAgICAgY2FzZSAnRnVuY3Rpb25FeHByZXNzaW9uJzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5hc3RGdW5jdGlvbkV4cHJlc3Npb24oYXN0LCByZXRBcnIpO1xuICAgICAgICBjYXNlICdSZXR1cm5TdGF0ZW1lbnQnOlxuICAgICAgICAgIHJldHVybiB0aGlzLmFzdFJldHVyblN0YXRlbWVudChhc3QsIHJldEFycik7XG4gICAgICAgIGNhc2UgJ0xpdGVyYWwnOlxuICAgICAgICAgIHJldHVybiB0aGlzLmFzdExpdGVyYWwoYXN0LCByZXRBcnIpO1xuICAgICAgICBjYXNlICdCaW5hcnlFeHByZXNzaW9uJzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5hc3RCaW5hcnlFeHByZXNzaW9uKGFzdCwgcmV0QXJyKTtcbiAgICAgICAgY2FzZSAnSWRlbnRpZmllcic6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYXN0SWRlbnRpZmllckV4cHJlc3Npb24oYXN0LCByZXRBcnIpO1xuICAgICAgICBjYXNlICdBc3NpZ25tZW50RXhwcmVzc2lvbic6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYXN0QXNzaWdubWVudEV4cHJlc3Npb24oYXN0LCByZXRBcnIpO1xuICAgICAgICBjYXNlICdFeHByZXNzaW9uU3RhdGVtZW50JzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5hc3RFeHByZXNzaW9uU3RhdGVtZW50KGFzdCwgcmV0QXJyKTtcbiAgICAgICAgY2FzZSAnRW1wdHlTdGF0ZW1lbnQnOlxuICAgICAgICAgIHJldHVybiB0aGlzLmFzdEVtcHR5U3RhdGVtZW50KGFzdCwgcmV0QXJyKTtcbiAgICAgICAgY2FzZSAnQmxvY2tTdGF0ZW1lbnQnOlxuICAgICAgICAgIHJldHVybiB0aGlzLmFzdEJsb2NrU3RhdGVtZW50KGFzdCwgcmV0QXJyKTtcbiAgICAgICAgY2FzZSAnSWZTdGF0ZW1lbnQnOlxuICAgICAgICAgIHJldHVybiB0aGlzLmFzdElmU3RhdGVtZW50KGFzdCwgcmV0QXJyKTtcbiAgICAgICAgY2FzZSAnU3dpdGNoU3RhdGVtZW50JzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5hc3RTd2l0Y2hTdGF0ZW1lbnQoYXN0LCByZXRBcnIpO1xuICAgICAgICBjYXNlICdCcmVha1N0YXRlbWVudCc6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYXN0QnJlYWtTdGF0ZW1lbnQoYXN0LCByZXRBcnIpO1xuICAgICAgICBjYXNlICdDb250aW51ZVN0YXRlbWVudCc6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYXN0Q29udGludWVTdGF0ZW1lbnQoYXN0LCByZXRBcnIpO1xuICAgICAgICBjYXNlICdGb3JTdGF0ZW1lbnQnOlxuICAgICAgICAgIHJldHVybiB0aGlzLmFzdEZvclN0YXRlbWVudChhc3QsIHJldEFycik7XG4gICAgICAgIGNhc2UgJ1doaWxlU3RhdGVtZW50JzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5hc3RXaGlsZVN0YXRlbWVudChhc3QsIHJldEFycik7XG4gICAgICAgIGNhc2UgJ0RvV2hpbGVTdGF0ZW1lbnQnOlxuICAgICAgICAgIHJldHVybiB0aGlzLmFzdERvV2hpbGVTdGF0ZW1lbnQoYXN0LCByZXRBcnIpO1xuICAgICAgICBjYXNlICdWYXJpYWJsZURlY2xhcmF0aW9uJzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5hc3RWYXJpYWJsZURlY2xhcmF0aW9uKGFzdCwgcmV0QXJyKTtcbiAgICAgICAgY2FzZSAnVmFyaWFibGVEZWNsYXJhdG9yJzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5hc3RWYXJpYWJsZURlY2xhcmF0b3IoYXN0LCByZXRBcnIpO1xuICAgICAgICBjYXNlICdUaGlzRXhwcmVzc2lvbic6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYXN0VGhpc0V4cHJlc3Npb24oYXN0LCByZXRBcnIpO1xuICAgICAgICBjYXNlICdTZXF1ZW5jZUV4cHJlc3Npb24nOlxuICAgICAgICAgIHJldHVybiB0aGlzLmFzdFNlcXVlbmNlRXhwcmVzc2lvbihhc3QsIHJldEFycik7XG4gICAgICAgIGNhc2UgJ1VuYXJ5RXhwcmVzc2lvbic6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYXN0VW5hcnlFeHByZXNzaW9uKGFzdCwgcmV0QXJyKTtcbiAgICAgICAgY2FzZSAnVXBkYXRlRXhwcmVzc2lvbic6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYXN0VXBkYXRlRXhwcmVzc2lvbihhc3QsIHJldEFycik7XG4gICAgICAgIGNhc2UgJ0xvZ2ljYWxFeHByZXNzaW9uJzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5hc3RMb2dpY2FsRXhwcmVzc2lvbihhc3QsIHJldEFycik7XG4gICAgICAgIGNhc2UgJ01lbWJlckV4cHJlc3Npb24nOlxuICAgICAgICAgIHJldHVybiB0aGlzLmFzdE1lbWJlckV4cHJlc3Npb24oYXN0LCByZXRBcnIpO1xuICAgICAgICBjYXNlICdDYWxsRXhwcmVzc2lvbic6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYXN0Q2FsbEV4cHJlc3Npb24oYXN0LCByZXRBcnIpO1xuICAgICAgICBjYXNlICdBcnJheUV4cHJlc3Npb24nOlxuICAgICAgICAgIHJldHVybiB0aGlzLmFzdEFycmF5RXhwcmVzc2lvbihhc3QsIHJldEFycik7XG4gICAgICAgIGNhc2UgJ0RlYnVnZ2VyU3RhdGVtZW50JzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5hc3REZWJ1Z2dlclN0YXRlbWVudChhc3QsIHJldEFycik7XG4gICAgICAgIGNhc2UgJ0NvbmRpdGlvbmFsRXhwcmVzc2lvbic6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYXN0Q29uZGl0aW9uYWxFeHByZXNzaW9uKGFzdCwgcmV0QXJyKTtcbiAgICAgIH1cblxuICAgICAgdGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dCgnVW5rbm93biBhc3QgdHlwZSA6ICcgKyBhc3QudHlwZSwgYXN0KTtcbiAgICB9XG4gIH1cbiAgYXN0RXJyb3JPdXRwdXQoZXJyb3IsIGFzdCkge1xuICAgIGlmICh0eXBlb2YgdGhpcy5zb3VyY2UgIT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gbmV3IEVycm9yKGVycm9yKTtcbiAgICB9XG5cbiAgICBjb25zdCBkZWJ1Z1N0cmluZyA9IHV0aWxzLmdldEFzdFN0cmluZyh0aGlzLnNvdXJjZSwgYXN0KTtcbiAgICBjb25zdCBsZWFkaW5nU291cmNlID0gdGhpcy5zb3VyY2Uuc3Vic3RyKGFzdC5zdGFydCk7XG4gICAgY29uc3Qgc3BsaXRMaW5lcyA9IGxlYWRpbmdTb3VyY2Uuc3BsaXQoL1xcbi8pO1xuICAgIGNvbnN0IGxpbmVCZWZvcmUgPSBzcGxpdExpbmVzLmxlbmd0aCA+IDAgPyBzcGxpdExpbmVzW3NwbGl0TGluZXMubGVuZ3RoIC0gMV0gOiAwO1xuICAgIHJldHVybiBuZXcgRXJyb3IoYCR7ZXJyb3J9IG9uIGxpbmUgJHsgc3BsaXRMaW5lcy5sZW5ndGggfSwgcG9zaXRpb24gJHsgbGluZUJlZm9yZS5sZW5ndGggfTpcXG4gJHsgZGVidWdTdHJpbmcgfWApO1xuICB9XG5cbiAgYXN0RGVidWdnZXJTdGF0ZW1lbnQoYXJyTm9kZSwgcmV0QXJyKSB7XG4gICAgcmV0dXJuIHJldEFycjtcbiAgfVxuXG4gIGFzdENvbmRpdGlvbmFsRXhwcmVzc2lvbihhc3QsIHJldEFycikge1xuICAgIGlmIChhc3QudHlwZSAhPT0gJ0NvbmRpdGlvbmFsRXhwcmVzc2lvbicpIHtcbiAgICAgIHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoJ05vdCBhIGNvbmRpdGlvbmFsIGV4cHJlc3Npb24nLCBhc3QpO1xuICAgIH1cbiAgICByZXRBcnIucHVzaCgnKCcpO1xuICAgIHRoaXMuYXN0R2VuZXJpYyhhc3QudGVzdCwgcmV0QXJyKTtcbiAgICByZXRBcnIucHVzaCgnPycpO1xuICAgIHRoaXMuYXN0R2VuZXJpYyhhc3QuY29uc2VxdWVudCwgcmV0QXJyKTtcbiAgICByZXRBcnIucHVzaCgnOicpO1xuICAgIHRoaXMuYXN0R2VuZXJpYyhhc3QuYWx0ZXJuYXRlLCByZXRBcnIpO1xuICAgIHJldEFyci5wdXNoKCcpJyk7XG4gICAgcmV0dXJuIHJldEFycjtcbiAgfVxuXG4gIGFzdEZ1bmN0aW9uKGFzdCwgcmV0QXJyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBcImFzdEZ1bmN0aW9uXCIgbm90IGRlZmluZWQgb24gJHsgdGhpcy5jb25zdHJ1Y3Rvci5uYW1lIH1gKTtcbiAgfVxuXG4gIGFzdEZ1bmN0aW9uRGVjbGFyYXRpb24oYXN0LCByZXRBcnIpIHtcbiAgICBpZiAodGhpcy5pc0NoaWxkRnVuY3Rpb24oYXN0KSkge1xuICAgICAgcmV0dXJuIHJldEFycjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuYXN0RnVuY3Rpb24oYXN0LCByZXRBcnIpO1xuICB9XG4gIGFzdEZ1bmN0aW9uRXhwcmVzc2lvbihhc3QsIHJldEFycikge1xuICAgIGlmICh0aGlzLmlzQ2hpbGRGdW5jdGlvbihhc3QpKSB7XG4gICAgICByZXR1cm4gcmV0QXJyO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5hc3RGdW5jdGlvbihhc3QsIHJldEFycik7XG4gIH1cbiAgaXNDaGlsZEZ1bmN0aW9uKGFzdCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5mdW5jdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0aGlzLmZ1bmN0aW9uc1tpXSA9PT0gYXN0KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgYXN0UmV0dXJuU3RhdGVtZW50KGFzdCwgcmV0QXJyKSB7XG4gICAgcmV0dXJuIHJldEFycjtcbiAgfVxuICBhc3RMaXRlcmFsKGFzdCwgcmV0QXJyKSB7XG4gICAgdGhpcy5saXRlcmFsVHlwZXNbdGhpcy5hc3RLZXkoYXN0KV0gPSAnTnVtYmVyJztcbiAgICByZXR1cm4gcmV0QXJyO1xuICB9XG4gIGFzdEJpbmFyeUV4cHJlc3Npb24oYXN0LCByZXRBcnIpIHtcbiAgICByZXR1cm4gcmV0QXJyO1xuICB9XG4gIGFzdElkZW50aWZpZXJFeHByZXNzaW9uKGFzdCwgcmV0QXJyKSB7XG4gICAgcmV0dXJuIHJldEFycjtcbiAgfVxuICBhc3RBc3NpZ25tZW50RXhwcmVzc2lvbihhc3QsIHJldEFycikge1xuICAgIHJldHVybiByZXRBcnI7XG4gIH1cbiAgYXN0RXhwcmVzc2lvblN0YXRlbWVudChlc05vZGUsIHJldEFycikge1xuICAgIHRoaXMuYXN0R2VuZXJpYyhlc05vZGUuZXhwcmVzc2lvbiwgcmV0QXJyKTtcbiAgICByZXRBcnIucHVzaCgnOycpO1xuICAgIHJldHVybiByZXRBcnI7XG4gIH1cbiAgYXN0RW1wdHlTdGF0ZW1lbnQoZU5vZGUsIHJldEFycikge1xuICAgIHJldHVybiByZXRBcnI7XG4gIH1cbiAgYXN0QmxvY2tTdGF0ZW1lbnQoYXN0LCByZXRBcnIpIHtcbiAgICByZXR1cm4gcmV0QXJyO1xuICB9XG4gIGFzdElmU3RhdGVtZW50KGFzdCwgcmV0QXJyKSB7XG4gICAgcmV0dXJuIHJldEFycjtcbiAgfVxuICBhc3RTd2l0Y2hTdGF0ZW1lbnQoYXN0LCByZXRBcnIpIHtcbiAgICByZXR1cm4gcmV0QXJyO1xuICB9XG4gIGFzdEJyZWFrU3RhdGVtZW50KGJyTm9kZSwgcmV0QXJyKSB7XG4gICAgcmV0QXJyLnB1c2goJ2JyZWFrOycpO1xuICAgIHJldHVybiByZXRBcnI7XG4gIH1cbiAgYXN0Q29udGludWVTdGF0ZW1lbnQoY3JOb2RlLCByZXRBcnIpIHtcbiAgICByZXRBcnIucHVzaCgnY29udGludWU7XFxuJyk7XG4gICAgcmV0dXJuIHJldEFycjtcbiAgfVxuICBhc3RGb3JTdGF0ZW1lbnQoYXN0LCByZXRBcnIpIHtcbiAgICByZXR1cm4gcmV0QXJyO1xuICB9XG4gIGFzdFdoaWxlU3RhdGVtZW50KGFzdCwgcmV0QXJyKSB7XG4gICAgcmV0dXJuIHJldEFycjtcbiAgfVxuICBhc3REb1doaWxlU3RhdGVtZW50KGFzdCwgcmV0QXJyKSB7XG4gICAgcmV0dXJuIHJldEFycjtcbiAgfVxuICBhc3RWYXJpYWJsZURlY2xhcmF0b3IoaVZhckRlY05vZGUsIHJldEFycikge1xuICAgIHRoaXMuYXN0R2VuZXJpYyhpVmFyRGVjTm9kZS5pZCwgcmV0QXJyKTtcbiAgICBpZiAoaVZhckRlY05vZGUuaW5pdCAhPT0gbnVsbCkge1xuICAgICAgcmV0QXJyLnB1c2goJz0nKTtcbiAgICAgIHRoaXMuYXN0R2VuZXJpYyhpVmFyRGVjTm9kZS5pbml0LCByZXRBcnIpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0QXJyO1xuICB9XG4gIGFzdFRoaXNFeHByZXNzaW9uKGFzdCwgcmV0QXJyKSB7XG4gICAgcmV0dXJuIHJldEFycjtcbiAgfVxuICBhc3RTZXF1ZW5jZUV4cHJlc3Npb24oc05vZGUsIHJldEFycikge1xuICAgIGNvbnN0IHsgZXhwcmVzc2lvbnMgfSA9IHNOb2RlO1xuICAgIGNvbnN0IHNlcXVlbmNlUmVzdWx0ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBleHByZXNzaW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgZXhwcmVzc2lvbiA9IGV4cHJlc3Npb25zW2ldO1xuICAgICAgY29uc3QgZXhwcmVzc2lvblJlc3VsdCA9IFtdO1xuICAgICAgdGhpcy5hc3RHZW5lcmljKGV4cHJlc3Npb24sIGV4cHJlc3Npb25SZXN1bHQpO1xuICAgICAgc2VxdWVuY2VSZXN1bHQucHVzaChleHByZXNzaW9uUmVzdWx0LmpvaW4oJycpKTtcbiAgICB9XG4gICAgaWYgKHNlcXVlbmNlUmVzdWx0Lmxlbmd0aCA+IDEpIHtcbiAgICAgIHJldEFyci5wdXNoKCcoJywgc2VxdWVuY2VSZXN1bHQuam9pbignLCcpLCAnKScpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXRBcnIucHVzaChzZXF1ZW5jZVJlc3VsdFswXSk7XG4gICAgfVxuICAgIHJldHVybiByZXRBcnI7XG4gIH1cbiAgYXN0VW5hcnlFeHByZXNzaW9uKHVOb2RlLCByZXRBcnIpIHtcbiAgICBjb25zdCB1bmFyeVJlc3VsdCA9IHRoaXMuY2hlY2tBbmRVcGNvbnZlcnRCaXR3aXNlVW5hcnkodU5vZGUsIHJldEFycik7XG4gICAgaWYgKHVuYXJ5UmVzdWx0KSB7XG4gICAgICByZXR1cm4gcmV0QXJyO1xuICAgIH1cblxuICAgIGlmICh1Tm9kZS5wcmVmaXgpIHtcbiAgICAgIHJldEFyci5wdXNoKHVOb2RlLm9wZXJhdG9yKTtcbiAgICAgIHRoaXMuYXN0R2VuZXJpYyh1Tm9kZS5hcmd1bWVudCwgcmV0QXJyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hc3RHZW5lcmljKHVOb2RlLmFyZ3VtZW50LCByZXRBcnIpO1xuICAgICAgcmV0QXJyLnB1c2godU5vZGUub3BlcmF0b3IpO1xuICAgIH1cblxuICAgIHJldHVybiByZXRBcnI7XG4gIH1cblxuICBjaGVja0FuZFVwY29udmVydEJpdHdpc2VVbmFyeSh1Tm9kZSwgcmV0QXJyKSB7fVxuXG4gIGFzdFVwZGF0ZUV4cHJlc3Npb24odU5vZGUsIHJldEFycikge1xuICAgIGlmICh1Tm9kZS5wcmVmaXgpIHtcbiAgICAgIHJldEFyci5wdXNoKHVOb2RlLm9wZXJhdG9yKTtcbiAgICAgIHRoaXMuYXN0R2VuZXJpYyh1Tm9kZS5hcmd1bWVudCwgcmV0QXJyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hc3RHZW5lcmljKHVOb2RlLmFyZ3VtZW50LCByZXRBcnIpO1xuICAgICAgcmV0QXJyLnB1c2godU5vZGUub3BlcmF0b3IpO1xuICAgIH1cblxuICAgIHJldHVybiByZXRBcnI7XG4gIH1cbiAgYXN0TG9naWNhbEV4cHJlc3Npb24obG9nTm9kZSwgcmV0QXJyKSB7XG4gICAgcmV0QXJyLnB1c2goJygnKTtcbiAgICB0aGlzLmFzdEdlbmVyaWMobG9nTm9kZS5sZWZ0LCByZXRBcnIpO1xuICAgIHJldEFyci5wdXNoKGxvZ05vZGUub3BlcmF0b3IpO1xuICAgIHRoaXMuYXN0R2VuZXJpYyhsb2dOb2RlLnJpZ2h0LCByZXRBcnIpO1xuICAgIHJldEFyci5wdXNoKCcpJyk7XG4gICAgcmV0dXJuIHJldEFycjtcbiAgfVxuICBhc3RNZW1iZXJFeHByZXNzaW9uKGFzdCwgcmV0QXJyKSB7XG4gICAgcmV0dXJuIHJldEFycjtcbiAgfVxuICBhc3RDYWxsRXhwcmVzc2lvbihhc3QsIHJldEFycikge1xuICAgIHJldHVybiByZXRBcnI7XG4gIH1cbiAgYXN0QXJyYXlFeHByZXNzaW9uKGFzdCwgcmV0QXJyKSB7XG4gICAgcmV0dXJuIHJldEFycjtcbiAgfVxuXG4gIGdldE1lbWJlckV4cHJlc3Npb25EZXRhaWxzKGFzdCkge1xuICAgIGlmIChhc3QudHlwZSAhPT0gJ01lbWJlckV4cHJlc3Npb24nKSB7XG4gICAgICB0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KGBFeHByZXNzaW9uICR7IGFzdC50eXBlIH0gbm90IGEgTWVtYmVyRXhwcmVzc2lvbmAsIGFzdCk7XG4gICAgfVxuICAgIGxldCBuYW1lID0gbnVsbDtcbiAgICBsZXQgdHlwZSA9IG51bGw7XG4gICAgY29uc3QgdmFyaWFibGVTaWduYXR1cmUgPSB0aGlzLmdldFZhcmlhYmxlU2lnbmF0dXJlKGFzdCk7XG4gICAgc3dpdGNoICh2YXJpYWJsZVNpZ25hdHVyZSkge1xuICAgICAgY2FzZSAndmFsdWUnOlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIGNhc2UgJ3ZhbHVlLnRocmVhZC52YWx1ZSc6XG4gICAgICBjYXNlICd0aGlzLnRocmVhZC52YWx1ZSc6XG4gICAgICBjYXNlICd0aGlzLm91dHB1dC52YWx1ZSc6XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc2lnbmF0dXJlOiB2YXJpYWJsZVNpZ25hdHVyZSxcbiAgICAgICAgICAgIHR5cGU6ICdJbnRlZ2VyJyxcbiAgICAgICAgICAgIG5hbWU6IGFzdC5wcm9wZXJ0eS5uYW1lXG4gICAgICAgIH07XG4gICAgICBjYXNlICd2YWx1ZVtdJzpcbiAgICAgICAgaWYgKHR5cGVvZiBhc3Qub2JqZWN0Lm5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgdGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dCgnVW5leHBlY3RlZCBleHByZXNzaW9uJywgYXN0KTtcbiAgICAgICAgfVxuICAgICAgICBuYW1lID0gYXN0Lm9iamVjdC5uYW1lO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgb3JpZ2luOiAndXNlcicsXG4gICAgICAgICAgICBzaWduYXR1cmU6IHZhcmlhYmxlU2lnbmF0dXJlLFxuICAgICAgICAgICAgdHlwZTogdGhpcy5nZXRWYXJpYWJsZVR5cGUoYXN0Lm9iamVjdCksXG4gICAgICAgICAgICB4UHJvcGVydHk6IGFzdC5wcm9wZXJ0eVxuICAgICAgICB9O1xuICAgICAgY2FzZSAndmFsdWVbXVtdJzpcbiAgICAgICAgaWYgKHR5cGVvZiBhc3Qub2JqZWN0Lm9iamVjdC5uYW1lICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgIHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoJ1VuZXhwZWN0ZWQgZXhwcmVzc2lvbicsIGFzdCk7XG4gICAgICAgIH1cbiAgICAgICAgbmFtZSA9IGFzdC5vYmplY3Qub2JqZWN0Lm5hbWU7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgICBvcmlnaW46ICd1c2VyJyxcbiAgICAgICAgICAgIHNpZ25hdHVyZTogdmFyaWFibGVTaWduYXR1cmUsXG4gICAgICAgICAgICB0eXBlOiB0aGlzLmdldFZhcmlhYmxlVHlwZShhc3Qub2JqZWN0Lm9iamVjdCksXG4gICAgICAgICAgICB5UHJvcGVydHk6IGFzdC5vYmplY3QucHJvcGVydHksXG4gICAgICAgICAgICB4UHJvcGVydHk6IGFzdC5wcm9wZXJ0eSxcbiAgICAgICAgfTtcbiAgICAgIGNhc2UgJ3ZhbHVlW11bXVtdJzpcbiAgICAgICAgaWYgKHR5cGVvZiBhc3Qub2JqZWN0Lm9iamVjdC5vYmplY3QubmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICB0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KCdVbmV4cGVjdGVkIGV4cHJlc3Npb24nLCBhc3QpO1xuICAgICAgICB9XG4gICAgICAgIG5hbWUgPSBhc3Qub2JqZWN0Lm9iamVjdC5vYmplY3QubmFtZTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBuYW1lLFxuICAgICAgICAgIG9yaWdpbjogJ3VzZXInLFxuICAgICAgICAgICAgc2lnbmF0dXJlOiB2YXJpYWJsZVNpZ25hdHVyZSxcbiAgICAgICAgICAgIHR5cGU6IHRoaXMuZ2V0VmFyaWFibGVUeXBlKGFzdC5vYmplY3Qub2JqZWN0Lm9iamVjdCksXG4gICAgICAgICAgICB6UHJvcGVydHk6IGFzdC5vYmplY3Qub2JqZWN0LnByb3BlcnR5LFxuICAgICAgICAgICAgeVByb3BlcnR5OiBhc3Qub2JqZWN0LnByb3BlcnR5LFxuICAgICAgICAgICAgeFByb3BlcnR5OiBhc3QucHJvcGVydHksXG4gICAgICAgIH07XG4gICAgICBjYXNlICd2YWx1ZVtdW11bXVtdJzpcbiAgICAgICAgaWYgKHR5cGVvZiBhc3Qub2JqZWN0Lm9iamVjdC5vYmplY3Qub2JqZWN0Lm5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgdGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dCgnVW5leHBlY3RlZCBleHByZXNzaW9uJywgYXN0KTtcbiAgICAgICAgfVxuICAgICAgICBuYW1lID0gYXN0Lm9iamVjdC5vYmplY3Qub2JqZWN0Lm9iamVjdC5uYW1lO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgb3JpZ2luOiAndXNlcicsXG4gICAgICAgICAgICBzaWduYXR1cmU6IHZhcmlhYmxlU2lnbmF0dXJlLFxuICAgICAgICAgICAgdHlwZTogdGhpcy5nZXRWYXJpYWJsZVR5cGUoYXN0Lm9iamVjdC5vYmplY3Qub2JqZWN0Lm9iamVjdCksXG4gICAgICAgICAgICB6UHJvcGVydHk6IGFzdC5vYmplY3Qub2JqZWN0LnByb3BlcnR5LFxuICAgICAgICAgICAgeVByb3BlcnR5OiBhc3Qub2JqZWN0LnByb3BlcnR5LFxuICAgICAgICAgICAgeFByb3BlcnR5OiBhc3QucHJvcGVydHksXG4gICAgICAgIH07XG4gICAgICBjYXNlICd2YWx1ZS52YWx1ZSc6XG4gICAgICAgIGlmICh0eXBlb2YgYXN0LnByb3BlcnR5Lm5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgdGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dCgnVW5leHBlY3RlZCBleHByZXNzaW9uJywgYXN0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pc0FzdE1hdGhWYXJpYWJsZShhc3QpKSB7XG4gICAgICAgICAgbmFtZSA9IGFzdC5wcm9wZXJ0eS5uYW1lO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgb3JpZ2luOiAnTWF0aCcsXG4gICAgICAgICAgICB0eXBlOiAnTnVtYmVyJyxcbiAgICAgICAgICAgIHNpZ25hdHVyZTogdmFyaWFibGVTaWduYXR1cmUsXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKGFzdC5wcm9wZXJ0eS5uYW1lKSB7XG4gICAgICAgICAgY2FzZSAncic6XG4gICAgICAgICAgY2FzZSAnZyc6XG4gICAgICAgICAgY2FzZSAnYic6XG4gICAgICAgICAgY2FzZSAnYSc6XG4gICAgICAgICAgICBuYW1lID0gYXN0Lm9iamVjdC5uYW1lO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgcHJvcGVydHk6IGFzdC5wcm9wZXJ0eS5uYW1lLFxuICAgICAgICAgICAgICAgIG9yaWdpbjogJ3VzZXInLFxuICAgICAgICAgICAgICAgIHNpZ25hdHVyZTogdmFyaWFibGVTaWduYXR1cmUsXG4gICAgICAgICAgICAgICAgdHlwZTogJ051bWJlcidcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoJ1VuZXhwZWN0ZWQgZXhwcmVzc2lvbicsIGFzdCk7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAndGhpcy5jb25zdGFudHMudmFsdWUnOlxuICAgICAgICAgIGlmICh0eXBlb2YgYXN0LnByb3BlcnR5Lm5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KCdVbmV4cGVjdGVkIGV4cHJlc3Npb24nLCBhc3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBuYW1lID0gYXN0LnByb3BlcnR5Lm5hbWU7XG4gICAgICAgICAgdHlwZSA9IHRoaXMuZ2V0Q29uc3RhbnRUeXBlKG5hbWUpO1xuICAgICAgICAgIGlmICghdHlwZSkge1xuICAgICAgICAgICAgdGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dCgnQ29uc3RhbnQgaGFzIG5vIHR5cGUnLCBhc3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICBvcmlnaW46ICdjb25zdGFudHMnLFxuICAgICAgICAgICAgICBzaWduYXR1cmU6IHZhcmlhYmxlU2lnbmF0dXJlLFxuICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgJ3RoaXMuY29uc3RhbnRzLnZhbHVlW10nOlxuICAgICAgICAgIGlmICh0eXBlb2YgYXN0Lm9iamVjdC5wcm9wZXJ0eS5uYW1lICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dCgnVW5leHBlY3RlZCBleHByZXNzaW9uJywgYXN0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbmFtZSA9IGFzdC5vYmplY3QucHJvcGVydHkubmFtZTtcbiAgICAgICAgICB0eXBlID0gdGhpcy5nZXRDb25zdGFudFR5cGUobmFtZSk7XG4gICAgICAgICAgaWYgKCF0eXBlKSB7XG4gICAgICAgICAgICB0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KCdDb25zdGFudCBoYXMgbm8gdHlwZScsIGFzdCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgIG9yaWdpbjogJ2NvbnN0YW50cycsXG4gICAgICAgICAgICAgIHNpZ25hdHVyZTogdmFyaWFibGVTaWduYXR1cmUsXG4gICAgICAgICAgICAgIHhQcm9wZXJ0eTogYXN0LnByb3BlcnR5LFxuICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgJ3RoaXMuY29uc3RhbnRzLnZhbHVlW11bXSc6IHtcbiAgICAgICAgICBpZiAodHlwZW9mIGFzdC5vYmplY3Qub2JqZWN0LnByb3BlcnR5Lm5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KCdVbmV4cGVjdGVkIGV4cHJlc3Npb24nLCBhc3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBuYW1lID0gYXN0Lm9iamVjdC5vYmplY3QucHJvcGVydHkubmFtZTtcbiAgICAgICAgICB0eXBlID0gdGhpcy5nZXRDb25zdGFudFR5cGUobmFtZSk7XG4gICAgICAgICAgaWYgKCF0eXBlKSB7XG4gICAgICAgICAgICB0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KCdDb25zdGFudCBoYXMgbm8gdHlwZScsIGFzdCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgIG9yaWdpbjogJ2NvbnN0YW50cycsXG4gICAgICAgICAgICBzaWduYXR1cmU6IHZhcmlhYmxlU2lnbmF0dXJlLFxuICAgICAgICAgICAgeVByb3BlcnR5OiBhc3Qub2JqZWN0LnByb3BlcnR5LFxuICAgICAgICAgICAgeFByb3BlcnR5OiBhc3QucHJvcGVydHksXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICd0aGlzLmNvbnN0YW50cy52YWx1ZVtdW11bXSc6IHtcbiAgICAgICAgICBpZiAodHlwZW9mIGFzdC5vYmplY3Qub2JqZWN0Lm9iamVjdC5wcm9wZXJ0eS5uYW1lICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dCgnVW5leHBlY3RlZCBleHByZXNzaW9uJywgYXN0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbmFtZSA9IGFzdC5vYmplY3Qub2JqZWN0Lm9iamVjdC5wcm9wZXJ0eS5uYW1lO1xuICAgICAgICAgIHR5cGUgPSB0aGlzLmdldENvbnN0YW50VHlwZShuYW1lKTtcbiAgICAgICAgICBpZiAoIXR5cGUpIHtcbiAgICAgICAgICAgIHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoJ0NvbnN0YW50IGhhcyBubyB0eXBlJywgYXN0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgb3JpZ2luOiAnY29uc3RhbnRzJyxcbiAgICAgICAgICAgIHNpZ25hdHVyZTogdmFyaWFibGVTaWduYXR1cmUsXG4gICAgICAgICAgICB6UHJvcGVydHk6IGFzdC5vYmplY3Qub2JqZWN0LnByb3BlcnR5LFxuICAgICAgICAgICAgeVByb3BlcnR5OiBhc3Qub2JqZWN0LnByb3BlcnR5LFxuICAgICAgICAgICAgeFByb3BlcnR5OiBhc3QucHJvcGVydHksXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdmbigpW10nOlxuICAgICAgICBjYXNlICdmbigpW11bXSc6XG4gICAgICAgIGNhc2UgJ1tdW10nOlxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzaWduYXR1cmU6IHZhcmlhYmxlU2lnbmF0dXJlLFxuICAgICAgICAgICAgICBwcm9wZXJ0eTogYXN0LnByb3BlcnR5LFxuICAgICAgICAgIH07XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dCgnVW5leHBlY3RlZCBleHByZXNzaW9uJywgYXN0KTtcbiAgICB9XG4gIH1cblxuICBmaW5kSWRlbnRpZmllck9yaWdpbihhc3RUb0ZpbmQpIHtcbiAgICBjb25zdCBzdGFjayA9IFt0aGlzLmFzdF07XG5cbiAgICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgYXROb2RlID0gc3RhY2tbMF07XG4gICAgICBpZiAoYXROb2RlLnR5cGUgPT09ICdWYXJpYWJsZURlY2xhcmF0b3InICYmIGF0Tm9kZS5pZCAmJiBhdE5vZGUuaWQubmFtZSAmJiBhdE5vZGUuaWQubmFtZSA9PT0gYXN0VG9GaW5kLm5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGF0Tm9kZTtcbiAgICAgIH1cbiAgICAgIHN0YWNrLnNoaWZ0KCk7XG4gICAgICBpZiAoYXROb2RlLmFyZ3VtZW50KSB7XG4gICAgICAgIHN0YWNrLnB1c2goYXROb2RlLmFyZ3VtZW50KTtcbiAgICAgIH0gZWxzZSBpZiAoYXROb2RlLmJvZHkpIHtcbiAgICAgICAgc3RhY2sucHVzaChhdE5vZGUuYm9keSk7XG4gICAgICB9IGVsc2UgaWYgKGF0Tm9kZS5kZWNsYXJhdGlvbnMpIHtcbiAgICAgICAgc3RhY2sucHVzaChhdE5vZGUuZGVjbGFyYXRpb25zKTtcbiAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShhdE5vZGUpKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXROb2RlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgc3RhY2sucHVzaChhdE5vZGVbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZmluZExhc3RSZXR1cm4oYXN0KSB7XG4gICAgY29uc3Qgc3RhY2sgPSBbYXN0IHx8IHRoaXMuYXN0XTtcblxuICAgIHdoaWxlIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBhdE5vZGUgPSBzdGFjay5wb3AoKTtcbiAgICAgIGlmIChhdE5vZGUudHlwZSA9PT0gJ1JldHVyblN0YXRlbWVudCcpIHtcbiAgICAgICAgcmV0dXJuIGF0Tm9kZTtcbiAgICAgIH1cbiAgICAgIGlmIChhdE5vZGUudHlwZSA9PT0gJ0Z1bmN0aW9uRGVjbGFyYXRpb24nKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKGF0Tm9kZS5hcmd1bWVudCkge1xuICAgICAgICBzdGFjay5wdXNoKGF0Tm9kZS5hcmd1bWVudCk7XG4gICAgICB9IGVsc2UgaWYgKGF0Tm9kZS5ib2R5KSB7XG4gICAgICAgIHN0YWNrLnB1c2goYXROb2RlLmJvZHkpO1xuICAgICAgfSBlbHNlIGlmIChhdE5vZGUuZGVjbGFyYXRpb25zKSB7XG4gICAgICAgIHN0YWNrLnB1c2goYXROb2RlLmRlY2xhcmF0aW9ucyk7XG4gICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYXROb2RlKSkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGF0Tm9kZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHN0YWNrLnB1c2goYXROb2RlW2ldKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChhdE5vZGUuY29uc2VxdWVudCkge1xuICAgICAgICBzdGFjay5wdXNoKGF0Tm9kZS5jb25zZXF1ZW50KTtcbiAgICAgIH0gZWxzZSBpZiAoYXROb2RlLmNhc2VzKSB7XG4gICAgICAgIHN0YWNrLnB1c2goYXROb2RlLmNhc2VzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBnZXRJbnRlcm5hbFZhcmlhYmxlTmFtZShuYW1lKSB7XG4gICAgaWYgKCF0aGlzLl9pbnRlcm5hbFZhcmlhYmxlTmFtZXMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgIHRoaXMuX2ludGVybmFsVmFyaWFibGVOYW1lc1tuYW1lXSA9IDA7XG4gICAgfVxuICAgIHRoaXMuX2ludGVybmFsVmFyaWFibGVOYW1lc1tuYW1lXSsrO1xuICAgIGlmICh0aGlzLl9pbnRlcm5hbFZhcmlhYmxlTmFtZXNbbmFtZV0gPT09IDEpIHtcbiAgICAgIHJldHVybiBuYW1lO1xuICAgIH1cbiAgICByZXR1cm4gbmFtZSArIHRoaXMuX2ludGVybmFsVmFyaWFibGVOYW1lc1tuYW1lXTtcbiAgfVxuXG4gIGFzdEtleShhc3QsIHNlcGFyYXRvciA9ICcsJykge1xuICAgIGlmICghYXN0LnN0YXJ0IHx8ICFhc3QuZW5kKSB0aHJvdyBuZXcgRXJyb3IoJ0FTVCBzdGFydCBhbmQgZW5kIG5lZWRlZCcpO1xuICAgIHJldHVybiBgJHthc3Quc3RhcnR9JHtzZXBhcmF0b3J9JHthc3QuZW5kfWA7XG4gIH1cbn1cblxuY29uc3QgdHlwZUxvb2t1cE1hcCA9IHtcbiAgJ051bWJlcic6ICdOdW1iZXInLFxuICAnRmxvYXQnOiAnRmxvYXQnLFxuICAnSW50ZWdlcic6ICdJbnRlZ2VyJyxcbiAgJ0FycmF5JzogJ051bWJlcicsXG4gICdBcnJheSgyKSc6ICdOdW1iZXInLFxuICAnQXJyYXkoMyknOiAnTnVtYmVyJyxcbiAgJ0FycmF5KDQpJzogJ051bWJlcicsXG4gICdNYXRyaXgoMiknOiAnTnVtYmVyJyxcbiAgJ01hdHJpeCgzKSc6ICdOdW1iZXInLFxuICAnTWF0cml4KDQpJzogJ051bWJlcicsXG4gICdBcnJheTJEJzogJ051bWJlcicsXG4gICdBcnJheTNEJzogJ051bWJlcicsXG4gICdJbnB1dCc6ICdOdW1iZXInLFxuICAnSFRNTENhbnZhcyc6ICdBcnJheSg0KScsXG4gICdPZmZzY3JlZW5DYW52YXMnOiAnQXJyYXkoNCknLFxuICAnSFRNTEltYWdlJzogJ0FycmF5KDQpJyxcbiAgJ0ltYWdlQml0bWFwJzogJ0FycmF5KDQpJyxcbiAgJ0ltYWdlRGF0YSc6ICdBcnJheSg0KScsXG4gICdIVE1MVmlkZW8nOiAnQXJyYXkoNCknLFxuICAnSFRNTEltYWdlQXJyYXknOiAnQXJyYXkoNCknLFxuICAnTnVtYmVyVGV4dHVyZSc6ICdOdW1iZXInLFxuICAnTWVtb3J5T3B0aW1pemVkTnVtYmVyVGV4dHVyZSc6ICdOdW1iZXInLFxuICAnQXJyYXkxRCgyKSc6ICdBcnJheSgyKScsXG4gICdBcnJheTFEKDMpJzogJ0FycmF5KDMpJyxcbiAgJ0FycmF5MUQoNCknOiAnQXJyYXkoNCknLFxuICAnQXJyYXkyRCgyKSc6ICdBcnJheSgyKScsXG4gICdBcnJheTJEKDMpJzogJ0FycmF5KDMpJyxcbiAgJ0FycmF5MkQoNCknOiAnQXJyYXkoNCknLFxuICAnQXJyYXkzRCgyKSc6ICdBcnJheSgyKScsXG4gICdBcnJheTNEKDMpJzogJ0FycmF5KDMpJyxcbiAgJ0FycmF5M0QoNCknOiAnQXJyYXkoNCknLFxuICAnQXJyYXlUZXh0dXJlKDEpJzogJ051bWJlcicsXG4gICdBcnJheVRleHR1cmUoMiknOiAnQXJyYXkoMiknLFxuICAnQXJyYXlUZXh0dXJlKDMpJzogJ0FycmF5KDMpJyxcbiAgJ0FycmF5VGV4dHVyZSg0KSc6ICdBcnJheSg0KScsXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgRnVuY3Rpb25Ob2RlXG59O1xufSx7XCIuLi91dGlsc1wiOjExNCxcIi4vZnVuY3Rpb24tdHJhY2VyXCI6MTEsXCJhY29yblwiOjF9XSwxMTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi91dGlscycpO1xuXG5mdW5jdGlvbiBsYXN0KGFycmF5KSB7XG4gIHJldHVybiBhcnJheS5sZW5ndGggPiAwID8gYXJyYXlbYXJyYXkubGVuZ3RoIC0gMV0gOiBudWxsO1xufVxuXG5jb25zdCBzdGF0ZXMgPSB7XG4gIHRyYWNrSWRlbnRpZmllcnM6ICd0cmFja0lkZW50aWZpZXJzJyxcbiAgbWVtYmVyRXhwcmVzc2lvbjogJ21lbWJlckV4cHJlc3Npb24nLFxuICBpbkZvckxvb3BJbml0OiAnaW5Gb3JMb29wSW5pdCdcbn07XG5cbmNsYXNzIEZ1bmN0aW9uVHJhY2VyIHtcbiAgY29uc3RydWN0b3IoYXN0KSB7XG4gICAgdGhpcy5ydW5uaW5nQ29udGV4dHMgPSBbXTtcbiAgICB0aGlzLmZ1bmN0aW9uQ29udGV4dHMgPSBbXTtcbiAgICB0aGlzLmNvbnRleHRzID0gW107XG4gICAgdGhpcy5mdW5jdGlvbkNhbGxzID0gW107XG4gICAgdGhpcy5kZWNsYXJhdGlvbnMgPSBbXTtcbiAgICB0aGlzLmlkZW50aWZpZXJzID0gW107XG4gICAgdGhpcy5mdW5jdGlvbnMgPSBbXTtcbiAgICB0aGlzLnJldHVyblN0YXRlbWVudHMgPSBbXTtcbiAgICB0aGlzLnRyYWNrZWRJZGVudGlmaWVycyA9IG51bGw7XG4gICAgdGhpcy5zdGF0ZXMgPSBbXTtcbiAgICB0aGlzLm5ld0Z1bmN0aW9uQ29udGV4dCgpO1xuICAgIHRoaXMuc2Nhbihhc3QpO1xuICB9XG5cbiAgaXNTdGF0ZShzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlc1t0aGlzLnN0YXRlcy5sZW5ndGggLSAxXSA9PT0gc3RhdGU7XG4gIH1cblxuICBoYXNTdGF0ZShzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlcy5pbmRleE9mKHN0YXRlKSA+IC0xO1xuICB9XG5cbiAgcHVzaFN0YXRlKHN0YXRlKSB7XG4gICAgdGhpcy5zdGF0ZXMucHVzaChzdGF0ZSk7XG4gIH1cblxuICBwb3BTdGF0ZShzdGF0ZSkge1xuICAgIGlmICh0aGlzLmlzU3RhdGUoc3RhdGUpKSB7XG4gICAgICB0aGlzLnN0YXRlcy5wb3AoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgcG9wIHRoZSBub24tYWN0aXZlIHN0YXRlIFwiJHtzdGF0ZX1cImApO1xuICAgIH1cbiAgfVxuXG4gIGdldCBjdXJyZW50RnVuY3Rpb25Db250ZXh0KCkge1xuICAgIHJldHVybiBsYXN0KHRoaXMuZnVuY3Rpb25Db250ZXh0cyk7XG4gIH1cblxuICBnZXQgY3VycmVudENvbnRleHQoKSB7XG4gICAgcmV0dXJuIGxhc3QodGhpcy5ydW5uaW5nQ29udGV4dHMpO1xuICB9XG5cbiAgbmV3RnVuY3Rpb25Db250ZXh0KCkge1xuICAgIGNvbnN0IG5ld0NvbnRleHQgPSB7ICdAY29udGV4dFR5cGUnOiAnZnVuY3Rpb24nIH07XG4gICAgdGhpcy5jb250ZXh0cy5wdXNoKG5ld0NvbnRleHQpO1xuICAgIHRoaXMuZnVuY3Rpb25Db250ZXh0cy5wdXNoKG5ld0NvbnRleHQpO1xuICB9XG5cbiAgbmV3Q29udGV4dChydW4pIHtcbiAgICBjb25zdCBuZXdDb250ZXh0ID0gT2JqZWN0LmFzc2lnbih7ICdAY29udGV4dFR5cGUnOiAnY29uc3QvbGV0JyB9LCB0aGlzLmN1cnJlbnRDb250ZXh0KTtcbiAgICB0aGlzLmNvbnRleHRzLnB1c2gobmV3Q29udGV4dCk7XG4gICAgdGhpcy5ydW5uaW5nQ29udGV4dHMucHVzaChuZXdDb250ZXh0KTtcbiAgICBydW4oKTtcbiAgICBjb25zdCB7IGN1cnJlbnRGdW5jdGlvbkNvbnRleHQgfSA9IHRoaXM7XG4gICAgZm9yIChjb25zdCBwIGluIGN1cnJlbnRGdW5jdGlvbkNvbnRleHQpIHtcbiAgICAgIGlmICghY3VycmVudEZ1bmN0aW9uQ29udGV4dC5oYXNPd25Qcm9wZXJ0eShwKSB8fCBuZXdDb250ZXh0Lmhhc093blByb3BlcnR5KHApKSBjb250aW51ZTtcbiAgICAgIG5ld0NvbnRleHRbcF0gPSBjdXJyZW50RnVuY3Rpb25Db250ZXh0W3BdO1xuICAgIH1cbiAgICB0aGlzLnJ1bm5pbmdDb250ZXh0cy5wb3AoKTtcbiAgICByZXR1cm4gbmV3Q29udGV4dDtcbiAgfVxuXG4gIHVzZUZ1bmN0aW9uQ29udGV4dChydW4pIHtcbiAgICBjb25zdCBmdW5jdGlvbkNvbnRleHQgPSBsYXN0KHRoaXMuZnVuY3Rpb25Db250ZXh0cyk7XG4gICAgdGhpcy5ydW5uaW5nQ29udGV4dHMucHVzaChmdW5jdGlvbkNvbnRleHQpO1xuICAgIHJ1bigpO1xuICAgIHRoaXMucnVubmluZ0NvbnRleHRzLnBvcCgpO1xuICB9XG5cbiAgZ2V0SWRlbnRpZmllcnMocnVuKSB7XG4gICAgY29uc3QgdHJhY2tlZElkZW50aWZpZXJzID0gdGhpcy50cmFja2VkSWRlbnRpZmllcnMgPSBbXTtcbiAgICB0aGlzLnB1c2hTdGF0ZShzdGF0ZXMudHJhY2tJZGVudGlmaWVycyk7XG4gICAgcnVuKCk7XG4gICAgdGhpcy50cmFja2VkSWRlbnRpZmllcnMgPSBudWxsO1xuICAgIHRoaXMucG9wU3RhdGUoc3RhdGVzLnRyYWNrSWRlbnRpZmllcnMpO1xuICAgIHJldHVybiB0cmFja2VkSWRlbnRpZmllcnM7XG4gIH1cblxuICBnZXREZWNsYXJhdGlvbihuYW1lKSB7XG4gICAgY29uc3QgeyBjdXJyZW50Q29udGV4dCwgY3VycmVudEZ1bmN0aW9uQ29udGV4dCwgcnVubmluZ0NvbnRleHRzIH0gPSB0aGlzO1xuICAgIGNvbnN0IGRlY2xhcmF0aW9uID0gY3VycmVudENvbnRleHRbbmFtZV0gfHwgY3VycmVudEZ1bmN0aW9uQ29udGV4dFtuYW1lXSB8fCBudWxsO1xuXG4gICAgaWYgKFxuICAgICAgIWRlY2xhcmF0aW9uICYmXG4gICAgICBjdXJyZW50Q29udGV4dCA9PT0gY3VycmVudEZ1bmN0aW9uQ29udGV4dCAmJlxuICAgICAgcnVubmluZ0NvbnRleHRzLmxlbmd0aCA+IDBcbiAgICApIHtcbiAgICAgIGNvbnN0IHByZXZpb3VzUnVubmluZ0NvbnRleHQgPSBydW5uaW5nQ29udGV4dHNbcnVubmluZ0NvbnRleHRzLmxlbmd0aCAtIDJdO1xuICAgICAgaWYgKHByZXZpb3VzUnVubmluZ0NvbnRleHRbbmFtZV0pIHtcbiAgICAgICAgcmV0dXJuIHByZXZpb3VzUnVubmluZ0NvbnRleHRbbmFtZV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlY2xhcmF0aW9uO1xuICB9XG5cbiAgc2Nhbihhc3QpIHtcbiAgICBpZiAoIWFzdCkgcmV0dXJuO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGFzdCkpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuc2Nhbihhc3RbaV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzd2l0Y2ggKGFzdC50eXBlKSB7XG4gICAgICBjYXNlICdQcm9ncmFtJzpcbiAgICAgICAgdGhpcy51c2VGdW5jdGlvbkNvbnRleHQoKCkgPT4ge1xuICAgICAgICAgIHRoaXMuc2Nhbihhc3QuYm9keSk7XG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0Jsb2NrU3RhdGVtZW50JzpcbiAgICAgICAgdGhpcy5uZXdDb250ZXh0KCgpID0+IHtcbiAgICAgICAgICB0aGlzLnNjYW4oYXN0LmJvZHkpO1xuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdBc3NpZ25tZW50RXhwcmVzc2lvbic6XG4gICAgICBjYXNlICdMb2dpY2FsRXhwcmVzc2lvbic6XG4gICAgICAgIHRoaXMuc2Nhbihhc3QubGVmdCk7XG4gICAgICAgIHRoaXMuc2Nhbihhc3QucmlnaHQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0JpbmFyeUV4cHJlc3Npb24nOlxuICAgICAgICB0aGlzLnNjYW4oYXN0LmxlZnQpO1xuICAgICAgICB0aGlzLnNjYW4oYXN0LnJpZ2h0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdVcGRhdGVFeHByZXNzaW9uJzpcbiAgICAgICAgaWYgKGFzdC5vcGVyYXRvciA9PT0gJysrJykge1xuICAgICAgICAgIGNvbnN0IGRlY2xhcmF0aW9uID0gdGhpcy5nZXREZWNsYXJhdGlvbihhc3QuYXJndW1lbnQubmFtZSk7XG4gICAgICAgICAgaWYgKGRlY2xhcmF0aW9uKSB7XG4gICAgICAgICAgICBkZWNsYXJhdGlvbi5zdWdnZXN0ZWRUeXBlID0gJ0ludGVnZXInO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNjYW4oYXN0LmFyZ3VtZW50KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdVbmFyeUV4cHJlc3Npb24nOlxuICAgICAgICB0aGlzLnNjYW4oYXN0LmFyZ3VtZW50KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdWYXJpYWJsZURlY2xhcmF0aW9uJzpcbiAgICAgICAgaWYgKGFzdC5raW5kID09PSAndmFyJykge1xuICAgICAgICAgIHRoaXMudXNlRnVuY3Rpb25Db250ZXh0KCgpID0+IHtcbiAgICAgICAgICAgIGFzdC5kZWNsYXJhdGlvbnMgPSB1dGlscy5ub3JtYWxpemVEZWNsYXJhdGlvbnMoYXN0KTtcbiAgICAgICAgICAgIHRoaXMuc2Nhbihhc3QuZGVjbGFyYXRpb25zKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhc3QuZGVjbGFyYXRpb25zID0gdXRpbHMubm9ybWFsaXplRGVjbGFyYXRpb25zKGFzdCk7XG4gICAgICAgICAgdGhpcy5zY2FuKGFzdC5kZWNsYXJhdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnVmFyaWFibGVEZWNsYXJhdG9yJzoge1xuICAgICAgICBjb25zdCB7IGN1cnJlbnRDb250ZXh0IH0gPSB0aGlzO1xuICAgICAgICBjb25zdCBpbkZvckxvb3BJbml0ID0gdGhpcy5oYXNTdGF0ZShzdGF0ZXMuaW5Gb3JMb29wSW5pdCk7XG4gICAgICAgIGNvbnN0IGRlY2xhcmF0aW9uID0ge1xuICAgICAgICAgIGFzdDogYXN0LFxuICAgICAgICAgIGNvbnRleHQ6IGN1cnJlbnRDb250ZXh0LFxuICAgICAgICAgIG5hbWU6IGFzdC5pZC5uYW1lLFxuICAgICAgICAgIG9yaWdpbjogJ2RlY2xhcmF0aW9uJyxcbiAgICAgICAgICBpbkZvckxvb3BJbml0LFxuICAgICAgICAgIGluRm9yTG9vcFRlc3Q6IG51bGwsXG4gICAgICAgICAgYXNzaWduYWJsZTogY3VycmVudENvbnRleHQgPT09IHRoaXMuY3VycmVudEZ1bmN0aW9uQ29udGV4dCB8fCAoIWluRm9yTG9vcEluaXQgJiYgIWN1cnJlbnRDb250ZXh0Lmhhc093blByb3BlcnR5KGFzdC5pZC5uYW1lKSksXG4gICAgICAgICAgc3VnZ2VzdGVkVHlwZTogbnVsbCxcbiAgICAgICAgICB2YWx1ZVR5cGU6IG51bGwsXG4gICAgICAgICAgZGVwZW5kZW5jaWVzOiBudWxsLFxuICAgICAgICAgIGlzU2FmZTogbnVsbCxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCFjdXJyZW50Q29udGV4dFthc3QuaWQubmFtZV0pIHtcbiAgICAgICAgICBjdXJyZW50Q29udGV4dFthc3QuaWQubmFtZV0gPSBkZWNsYXJhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlY2xhcmF0aW9ucy5wdXNoKGRlY2xhcmF0aW9uKTtcbiAgICAgICAgdGhpcy5zY2FuKGFzdC5pZCk7XG4gICAgICAgIHRoaXMuc2Nhbihhc3QuaW5pdCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSAnRnVuY3Rpb25FeHByZXNzaW9uJzpcbiAgICAgIGNhc2UgJ0Z1bmN0aW9uRGVjbGFyYXRpb24nOlxuICAgICAgICBpZiAodGhpcy5ydW5uaW5nQ29udGV4dHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5zY2FuKGFzdC5ib2R5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmZ1bmN0aW9ucy5wdXNoKGFzdCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdJZlN0YXRlbWVudCc6XG4gICAgICAgIHRoaXMuc2Nhbihhc3QudGVzdCk7XG4gICAgICAgIHRoaXMuc2Nhbihhc3QuY29uc2VxdWVudCk7XG4gICAgICAgIGlmIChhc3QuYWx0ZXJuYXRlKSB0aGlzLnNjYW4oYXN0LmFsdGVybmF0ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnRm9yU3RhdGVtZW50Jzoge1xuICAgICAgICBsZXQgdGVzdElkZW50aWZpZXJzO1xuICAgICAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5uZXdDb250ZXh0KCgpID0+IHtcbiAgICAgICAgICB0aGlzLnB1c2hTdGF0ZShzdGF0ZXMuaW5Gb3JMb29wSW5pdCk7XG4gICAgICAgICAgdGhpcy5zY2FuKGFzdC5pbml0KTtcbiAgICAgICAgICB0aGlzLnBvcFN0YXRlKHN0YXRlcy5pbkZvckxvb3BJbml0KTtcblxuICAgICAgICAgIHRlc3RJZGVudGlmaWVycyA9IHRoaXMuZ2V0SWRlbnRpZmllcnMoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zY2FuKGFzdC50ZXN0KTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHRoaXMuc2Nhbihhc3QudXBkYXRlKTtcbiAgICAgICAgICB0aGlzLm5ld0NvbnRleHQoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zY2FuKGFzdC5ib2R5KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHRlc3RJZGVudGlmaWVycykge1xuICAgICAgICAgIGZvciAoY29uc3QgcCBpbiBjb250ZXh0KSB7XG4gICAgICAgICAgICBpZiAocCA9PT0gJ0Bjb250ZXh0VHlwZScpIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKHRlc3RJZGVudGlmaWVycy5pbmRleE9mKHApID4gLTEpIHtcbiAgICAgICAgICAgICAgY29udGV4dFtwXS5pbkZvckxvb3BUZXN0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlICdEb1doaWxlU3RhdGVtZW50JzpcbiAgICAgIGNhc2UgJ1doaWxlU3RhdGVtZW50JzpcbiAgICAgICAgdGhpcy5uZXdDb250ZXh0KCgpID0+IHtcbiAgICAgICAgICB0aGlzLnNjYW4oYXN0LmJvZHkpO1xuICAgICAgICAgIHRoaXMuc2Nhbihhc3QudGVzdCk7XG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0lkZW50aWZpZXInOiB7XG4gICAgICAgIGlmICh0aGlzLmlzU3RhdGUoc3RhdGVzLnRyYWNrSWRlbnRpZmllcnMpKSB7XG4gICAgICAgICAgdGhpcy50cmFja2VkSWRlbnRpZmllcnMucHVzaChhc3QubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pZGVudGlmaWVycy5wdXNoKHtcbiAgICAgICAgICBjb250ZXh0OiB0aGlzLmN1cnJlbnRDb250ZXh0LFxuICAgICAgICAgIGRlY2xhcmF0aW9uOiB0aGlzLmdldERlY2xhcmF0aW9uKGFzdC5uYW1lKSxcbiAgICAgICAgICBhc3QsXG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgJ1JldHVyblN0YXRlbWVudCc6XG4gICAgICAgIHRoaXMucmV0dXJuU3RhdGVtZW50cy5wdXNoKGFzdCk7XG4gICAgICAgIHRoaXMuc2Nhbihhc3QuYXJndW1lbnQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ01lbWJlckV4cHJlc3Npb24nOlxuICAgICAgICB0aGlzLnB1c2hTdGF0ZShzdGF0ZXMubWVtYmVyRXhwcmVzc2lvbik7XG4gICAgICAgIHRoaXMuc2Nhbihhc3Qub2JqZWN0KTtcbiAgICAgICAgdGhpcy5zY2FuKGFzdC5wcm9wZXJ0eSk7XG4gICAgICAgIHRoaXMucG9wU3RhdGUoc3RhdGVzLm1lbWJlckV4cHJlc3Npb24pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0V4cHJlc3Npb25TdGF0ZW1lbnQnOlxuICAgICAgICB0aGlzLnNjYW4oYXN0LmV4cHJlc3Npb24pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ1NlcXVlbmNlRXhwcmVzc2lvbic6XG4gICAgICAgIHRoaXMuc2Nhbihhc3QuZXhwcmVzc2lvbnMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0NhbGxFeHByZXNzaW9uJzpcbiAgICAgICAgdGhpcy5mdW5jdGlvbkNhbGxzLnB1c2goe1xuICAgICAgICAgIGNvbnRleHQ6IHRoaXMuY3VycmVudENvbnRleHQsXG4gICAgICAgICAgYXN0LFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zY2FuKGFzdC5hcmd1bWVudHMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0FycmF5RXhwcmVzc2lvbic6XG4gICAgICAgIHRoaXMuc2Nhbihhc3QuZWxlbWVudHMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0NvbmRpdGlvbmFsRXhwcmVzc2lvbic6XG4gICAgICAgIHRoaXMuc2Nhbihhc3QudGVzdCk7XG4gICAgICAgIHRoaXMuc2Nhbihhc3QuYWx0ZXJuYXRlKTtcbiAgICAgICAgdGhpcy5zY2FuKGFzdC5jb25zZXF1ZW50KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdTd2l0Y2hTdGF0ZW1lbnQnOlxuICAgICAgICB0aGlzLnNjYW4oYXN0LmRpc2NyaW1pbmFudCk7XG4gICAgICAgIHRoaXMuc2Nhbihhc3QuY2FzZXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ1N3aXRjaENhc2UnOlxuICAgICAgICB0aGlzLnNjYW4oYXN0LnRlc3QpO1xuICAgICAgICB0aGlzLnNjYW4oYXN0LmNvbnNlcXVlbnQpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnVGhpc0V4cHJlc3Npb24nOlxuICAgICAgY2FzZSAnTGl0ZXJhbCc6XG4gICAgICBjYXNlICdEZWJ1Z2dlclN0YXRlbWVudCc6XG4gICAgICBjYXNlICdFbXB0eVN0YXRlbWVudCc6XG4gICAgICBjYXNlICdCcmVha1N0YXRlbWVudCc6XG4gICAgICBjYXNlICdDb250aW51ZVN0YXRlbWVudCc6XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmhhbmRsZWQgdHlwZSBcIiR7YXN0LnR5cGV9XCJgKTtcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEZ1bmN0aW9uVHJhY2VyLFxufTtcbn0se1wiLi4vdXRpbHNcIjoxMTR9XSwxMjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IGdsV2lyZXRhcCB9ID0gcmVxdWlyZSgnZ2wtd2lyZXRhcCcpO1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMnKTtcblxuZnVuY3Rpb24gdG9TdHJpbmdXaXRob3V0VXRpbHMoZm4pIHtcbiAgcmV0dXJuIGZuLnRvU3RyaW5nKClcbiAgICAucmVwbGFjZSgnPT4nLCAnJylcbiAgICAucmVwbGFjZSgvXmZ1bmN0aW9uIC8sICcnKVxuICAgIC5yZXBsYWNlKC91dGlsc1suXS9nLCAnLyp1dGlscy4qLycpO1xufVxuXG5mdW5jdGlvbiBnbEtlcm5lbFN0cmluZyhLZXJuZWwsIGFyZ3MsIG9yaWdpbktlcm5lbCwgc2V0dXBDb250ZXh0U3RyaW5nLCBkZXN0cm95Q29udGV4dFN0cmluZykge1xuICBpZiAoIW9yaWdpbktlcm5lbC5idWlsdCkge1xuICAgIG9yaWdpbktlcm5lbC5idWlsZC5hcHBseShvcmlnaW5LZXJuZWwsIGFyZ3MpO1xuICB9XG4gIGFyZ3MgPSBhcmdzID8gQXJyYXkuZnJvbShhcmdzKS5tYXAoYXJnID0+IHtcbiAgICBzd2l0Y2ggKHR5cGVvZiBhcmcpIHtcbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICByZXR1cm4gbmV3IEJvb2xlYW4oYXJnKTtcbiAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgIHJldHVybiBuZXcgTnVtYmVyKGFyZyk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gYXJnO1xuICAgIH1cbiAgfSkgOiBudWxsO1xuICBjb25zdCB1cGxvYWRlZFZhbHVlcyA9IFtdO1xuICBjb25zdCBwb3N0UmVzdWx0ID0gW107XG4gIGNvbnN0IGNvbnRleHQgPSBnbFdpcmV0YXAob3JpZ2luS2VybmVsLmNvbnRleHQsIHtcbiAgICB1c2VUcmFja2FibGVQcmltaXRpdmVzOiB0cnVlLFxuICAgIG9uUmVhZFBpeGVsczogKHRhcmdldE5hbWUpID0+IHtcbiAgICAgIGlmIChrZXJuZWwuc3ViS2VybmVscykge1xuICAgICAgICBpZiAoIXN1Yktlcm5lbHNSZXN1bHRWYXJpYWJsZVNldHVwKSB7XG4gICAgICAgICAgcG9zdFJlc3VsdC5wdXNoKGAgICAgY29uc3QgcmVzdWx0ID0geyByZXN1bHQ6ICR7Z2V0UmVuZGVyU3RyaW5nKHRhcmdldE5hbWUsIGtlcm5lbCl9IH07YCk7XG4gICAgICAgICAgc3ViS2VybmVsc1Jlc3VsdFZhcmlhYmxlU2V0dXAgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IHByb3BlcnR5ID0ga2VybmVsLnN1Yktlcm5lbHNbc3ViS2VybmVsc1Jlc3VsdEluZGV4KytdLnByb3BlcnR5O1xuICAgICAgICAgIHBvc3RSZXN1bHQucHVzaChgICAgIHJlc3VsdCR7aXNOYU4ocHJvcGVydHkpID8gJy4nICsgcHJvcGVydHkgOiBgWyR7cHJvcGVydHl9XWB9ID0gJHtnZXRSZW5kZXJTdHJpbmcodGFyZ2V0TmFtZSwga2VybmVsKX07YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN1Yktlcm5lbHNSZXN1bHRJbmRleCA9PT0ga2VybmVsLnN1Yktlcm5lbHMubGVuZ3RoKSB7XG4gICAgICAgICAgcG9zdFJlc3VsdC5wdXNoKCcgICAgcmV0dXJuIHJlc3VsdDsnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodGFyZ2V0TmFtZSkge1xuICAgICAgICBwb3N0UmVzdWx0LnB1c2goYCAgICByZXR1cm4gJHtnZXRSZW5kZXJTdHJpbmcodGFyZ2V0TmFtZSwga2VybmVsKX07YCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwb3N0UmVzdWx0LnB1c2goYCAgICByZXR1cm4gbnVsbDtgKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIG9uVW5yZWNvZ25pemVkQXJndW1lbnRMb29rdXA6IChhcmd1bWVudCkgPT4ge1xuICAgICAgY29uc3QgYXJndW1lbnROYW1lID0gZmluZEtlcm5lbFZhbHVlKGFyZ3VtZW50LCBrZXJuZWwua2VybmVsQXJndW1lbnRzLCBbXSwgY29udGV4dCwgdXBsb2FkZWRWYWx1ZXMpO1xuICAgICAgaWYgKGFyZ3VtZW50TmFtZSkge1xuICAgICAgICByZXR1cm4gYXJndW1lbnROYW1lO1xuICAgICAgfVxuICAgICAgY29uc3QgY29uc3RhbnROYW1lID0gZmluZEtlcm5lbFZhbHVlKGFyZ3VtZW50LCBrZXJuZWwua2VybmVsQ29uc3RhbnRzLCBjb25zdGFudHMgPyBPYmplY3Qua2V5cyhjb25zdGFudHMpLm1hcChrZXkgPT4gY29uc3RhbnRzW2tleV0pIDogW10sIGNvbnRleHQsIHVwbG9hZGVkVmFsdWVzKTtcbiAgICAgIGlmIChjb25zdGFudE5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGNvbnN0YW50TmFtZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfSk7XG4gIGxldCBzdWJLZXJuZWxzUmVzdWx0VmFyaWFibGVTZXR1cCA9IGZhbHNlO1xuICBsZXQgc3ViS2VybmVsc1Jlc3VsdEluZGV4ID0gMDtcbiAgY29uc3Qge1xuICAgIHNvdXJjZSxcbiAgICBjYW52YXMsXG4gICAgb3V0cHV0LFxuICAgIHBpcGVsaW5lLFxuICAgIGdyYXBoaWNhbCxcbiAgICBsb29wTWF4SXRlcmF0aW9ucyxcbiAgICBjb25zdGFudHMsXG4gICAgb3B0aW1pemVGbG9hdE1lbW9yeSxcbiAgICBwcmVjaXNpb24sXG4gICAgZml4SW50ZWdlckRpdmlzaW9uQWNjdXJhY3ksXG4gICAgZnVuY3Rpb25zLFxuICAgIG5hdGl2ZUZ1bmN0aW9ucyxcbiAgICBzdWJLZXJuZWxzLFxuICAgIGltbXV0YWJsZSxcbiAgICBhcmd1bWVudFR5cGVzLFxuICAgIGNvbnN0YW50VHlwZXMsXG4gICAga2VybmVsQXJndW1lbnRzLFxuICAgIGtlcm5lbENvbnN0YW50cyxcbiAgICB0YWN0aWMsXG4gIH0gPSBvcmlnaW5LZXJuZWw7XG4gIGNvbnN0IGtlcm5lbCA9IG5ldyBLZXJuZWwoc291cmNlLCB7XG4gICAgY2FudmFzLFxuICAgIGNvbnRleHQsXG4gICAgY2hlY2tDb250ZXh0OiBmYWxzZSxcbiAgICBvdXRwdXQsXG4gICAgcGlwZWxpbmUsXG4gICAgZ3JhcGhpY2FsLFxuICAgIGxvb3BNYXhJdGVyYXRpb25zLFxuICAgIGNvbnN0YW50cyxcbiAgICBvcHRpbWl6ZUZsb2F0TWVtb3J5LFxuICAgIHByZWNpc2lvbixcbiAgICBmaXhJbnRlZ2VyRGl2aXNpb25BY2N1cmFjeSxcbiAgICBmdW5jdGlvbnMsXG4gICAgbmF0aXZlRnVuY3Rpb25zLFxuICAgIHN1Yktlcm5lbHMsXG4gICAgaW1tdXRhYmxlLFxuICAgIGFyZ3VtZW50VHlwZXMsXG4gICAgY29uc3RhbnRUeXBlcyxcbiAgICB0YWN0aWMsXG4gIH0pO1xuICBsZXQgcmVzdWx0ID0gW107XG4gIGNvbnRleHQuc2V0SW5kZW50KDIpO1xuICBrZXJuZWwuYnVpbGQuYXBwbHkoa2VybmVsLCBhcmdzKTtcbiAgcmVzdWx0LnB1c2goY29udGV4dC50b1N0cmluZygpKTtcbiAgY29udGV4dC5yZXNldCgpO1xuXG4gIGtlcm5lbC5rZXJuZWxBcmd1bWVudHMuZm9yRWFjaCgoa2VybmVsQXJndW1lbnQsIGkpID0+IHtcbiAgICBzd2l0Y2ggKGtlcm5lbEFyZ3VtZW50LnR5cGUpIHtcbiAgICAgIGNhc2UgJ0ludGVnZXInOlxuICAgICAgY2FzZSAnQm9vbGVhbic6XG4gICAgICBjYXNlICdOdW1iZXInOlxuICAgICAgY2FzZSAnRmxvYXQnOlxuICAgICAgY2FzZSAnQXJyYXknOlxuICAgICAgY2FzZSAnQXJyYXkoMiknOlxuICAgICAgY2FzZSAnQXJyYXkoMyknOlxuICAgICAgY2FzZSAnQXJyYXkoNCknOlxuICAgICAgY2FzZSAnSFRNTENhbnZhcyc6XG4gICAgICBjYXNlICdIVE1MSW1hZ2UnOlxuICAgICAgY2FzZSAnSFRNTFZpZGVvJzpcbiAgICAgICAgY29udGV4dC5pbnNlcnRWYXJpYWJsZShgdXBsb2FkVmFsdWVfJHtrZXJuZWxBcmd1bWVudC5uYW1lfWAsIGtlcm5lbEFyZ3VtZW50LnVwbG9hZFZhbHVlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdIVE1MSW1hZ2VBcnJheSc6XG4gICAgICAgIGZvciAobGV0IGltYWdlSW5kZXggPSAwOyBpbWFnZUluZGV4IDwgYXJnc1tpXS5sZW5ndGg7IGltYWdlSW5kZXgrKykge1xuICAgICAgICAgIGNvbnN0IGFyZyA9IGFyZ3NbaV07XG4gICAgICAgICAgY29udGV4dC5pbnNlcnRWYXJpYWJsZShgdXBsb2FkVmFsdWVfJHtrZXJuZWxBcmd1bWVudC5uYW1lfVske2ltYWdlSW5kZXh9XWAsIGFyZ1tpbWFnZUluZGV4XSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdJbnB1dCc6XG4gICAgICAgIGNvbnRleHQuaW5zZXJ0VmFyaWFibGUoYHVwbG9hZFZhbHVlXyR7a2VybmVsQXJndW1lbnQubmFtZX1gLCBrZXJuZWxBcmd1bWVudC51cGxvYWRWYWx1ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnTWVtb3J5T3B0aW1pemVkTnVtYmVyVGV4dHVyZSc6XG4gICAgICBjYXNlICdOdW1iZXJUZXh0dXJlJzpcbiAgICAgIGNhc2UgJ0FycmF5MUQoMiknOlxuICAgICAgY2FzZSAnQXJyYXkxRCgzKSc6XG4gICAgICBjYXNlICdBcnJheTFEKDQpJzpcbiAgICAgIGNhc2UgJ0FycmF5MkQoMiknOlxuICAgICAgY2FzZSAnQXJyYXkyRCgzKSc6XG4gICAgICBjYXNlICdBcnJheTJEKDQpJzpcbiAgICAgIGNhc2UgJ0FycmF5M0QoMiknOlxuICAgICAgY2FzZSAnQXJyYXkzRCgzKSc6XG4gICAgICBjYXNlICdBcnJheTNEKDQpJzpcbiAgICAgIGNhc2UgJ0FycmF5VGV4dHVyZSgxKSc6XG4gICAgICBjYXNlICdBcnJheVRleHR1cmUoMiknOlxuICAgICAgY2FzZSAnQXJyYXlUZXh0dXJlKDMpJzpcbiAgICAgIGNhc2UgJ0FycmF5VGV4dHVyZSg0KSc6XG4gICAgICAgIGNvbnRleHQuaW5zZXJ0VmFyaWFibGUoYHVwbG9hZFZhbHVlXyR7a2VybmVsQXJndW1lbnQubmFtZX1gLCBhcmdzW2ldLnRleHR1cmUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgdW5oYW5kbGVkIGtlcm5lbEFyZ3VtZW50VHlwZSBpbnNlcnRpb24gZm9yIGdsV2lyZXRhcCBvZiB0eXBlICR7a2VybmVsQXJndW1lbnQudHlwZX1gKTtcbiAgICB9XG4gIH0pO1xuICByZXN1bHQucHVzaCgnLyoqIHN0YXJ0IG9mIGluamVjdGVkIGZ1bmN0aW9ucyAqKi8nKTtcbiAgcmVzdWx0LnB1c2goYGZ1bmN0aW9uICR7dG9TdHJpbmdXaXRob3V0VXRpbHModXRpbHMuZmxhdHRlblRvKX1gKTtcbiAgcmVzdWx0LnB1c2goYGZ1bmN0aW9uICR7dG9TdHJpbmdXaXRob3V0VXRpbHModXRpbHMuZmxhdHRlbjJkQXJyYXlUbyl9YCk7XG4gIHJlc3VsdC5wdXNoKGBmdW5jdGlvbiAke3RvU3RyaW5nV2l0aG91dFV0aWxzKHV0aWxzLmZsYXR0ZW4zZEFycmF5VG8pfWApO1xuICByZXN1bHQucHVzaChgZnVuY3Rpb24gJHt0b1N0cmluZ1dpdGhvdXRVdGlscyh1dGlscy5mbGF0dGVuNGRBcnJheVRvKX1gKTtcbiAgcmVzdWx0LnB1c2goYGZ1bmN0aW9uICR7dG9TdHJpbmdXaXRob3V0VXRpbHModXRpbHMuaXNBcnJheSl9YCk7XG4gIGlmIChrZXJuZWwucmVuZGVyT3V0cHV0ICE9PSBrZXJuZWwucmVuZGVyVGV4dHVyZSAmJiBrZXJuZWwuZm9ybWF0VmFsdWVzKSB7XG4gICAgcmVzdWx0LnB1c2goXG4gICAgICBgICBjb25zdCByZW5kZXJPdXRwdXQgPSBmdW5jdGlvbiAke3RvU3RyaW5nV2l0aG91dFV0aWxzKGtlcm5lbC5mb3JtYXRWYWx1ZXMpfTtgXG4gICAgKTtcbiAgfVxuICByZXN1bHQucHVzaCgnLyoqIGVuZCBvZiBpbmplY3RlZCBmdW5jdGlvbnMgKiovJyk7XG4gIHJlc3VsdC5wdXNoKGAgIGNvbnN0IGlubmVyS2VybmVsID0gZnVuY3Rpb24gKCR7a2VybmVsLmtlcm5lbEFyZ3VtZW50cy5tYXAoa2VybmVsQXJndW1lbnQgPT4ga2VybmVsQXJndW1lbnQudmFyTmFtZSkuam9pbignLCAnKX0pIHtgKTtcbiAgY29udGV4dC5zZXRJbmRlbnQoNCk7XG4gIGtlcm5lbC5ydW4uYXBwbHkoa2VybmVsLCBhcmdzKTtcbiAgaWYgKGtlcm5lbC5yZW5kZXJLZXJuZWxzKSB7XG4gICAga2VybmVsLnJlbmRlcktlcm5lbHMoKTtcbiAgfSBlbHNlIGlmIChrZXJuZWwucmVuZGVyT3V0cHV0KSB7XG4gICAga2VybmVsLnJlbmRlck91dHB1dCgpO1xuICB9XG4gIHJlc3VsdC5wdXNoKCcgICAgLyoqIHN0YXJ0IHNldHVwIHVwbG9hZHMgZm9yIGtlcm5lbCB2YWx1ZXMgKiovJyk7XG4gIGtlcm5lbC5rZXJuZWxBcmd1bWVudHMuZm9yRWFjaChrZXJuZWxBcmd1bWVudCA9PiB7XG4gICAgcmVzdWx0LnB1c2goJyAgICAnICsga2VybmVsQXJndW1lbnQuZ2V0U3RyaW5nVmFsdWVIYW5kbGVyKCkuc3BsaXQoJ1xcbicpLmpvaW4oJ1xcbiAgICAnKSk7XG4gIH0pO1xuICByZXN1bHQucHVzaCgnICAgIC8qKiBlbmQgc2V0dXAgdXBsb2FkcyBmb3Iga2VybmVsIHZhbHVlcyAqKi8nKTtcbiAgcmVzdWx0LnB1c2goY29udGV4dC50b1N0cmluZygpKTtcbiAgaWYgKGtlcm5lbC5yZW5kZXJPdXRwdXQgPT09IGtlcm5lbC5yZW5kZXJUZXh0dXJlKSB7XG4gICAgY29udGV4dC5yZXNldCgpO1xuICAgIGNvbnN0IGZyYW1lYnVmZmVyTmFtZSA9IGNvbnRleHQuZ2V0Q29udGV4dFZhcmlhYmxlTmFtZShrZXJuZWwuZnJhbWVidWZmZXIpO1xuICAgIGlmIChrZXJuZWwucmVuZGVyS2VybmVscykge1xuICAgICAgY29uc3QgcmVzdWx0cyA9IGtlcm5lbC5yZW5kZXJLZXJuZWxzKCk7XG4gICAgICBjb25zdCB0ZXh0dXJlTmFtZSA9IGNvbnRleHQuZ2V0Q29udGV4dFZhcmlhYmxlTmFtZShrZXJuZWwudGV4dHVyZS50ZXh0dXJlKTtcbiAgICAgIHJlc3VsdC5wdXNoKGAgICAgcmV0dXJuIHtcbiAgICAgIHJlc3VsdDoge1xuICAgICAgICB0ZXh0dXJlOiAkeyB0ZXh0dXJlTmFtZSB9LFxuICAgICAgICB0eXBlOiAnJHsgcmVzdWx0cy5yZXN1bHQudHlwZSB9JyxcbiAgICAgICAgdG9BcnJheTogJHsgZ2V0VG9BcnJheVN0cmluZyhyZXN1bHRzLnJlc3VsdCwgdGV4dHVyZU5hbWUsIGZyYW1lYnVmZmVyTmFtZSkgfVxuICAgICAgfSxgKTtcbiAgICAgIGNvbnN0IHsgc3ViS2VybmVscywgbWFwcGVkVGV4dHVyZXMgfSA9IGtlcm5lbDtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3ViS2VybmVscy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCB0ZXh0dXJlID0gbWFwcGVkVGV4dHVyZXNbaV07XG4gICAgICAgIGNvbnN0IHN1Yktlcm5lbCA9IHN1Yktlcm5lbHNbaV07XG4gICAgICAgIGNvbnN0IHN1Yktlcm5lbFJlc3VsdCA9IHJlc3VsdHNbc3ViS2VybmVsLnByb3BlcnR5XTtcbiAgICAgICAgY29uc3Qgc3ViS2VybmVsVGV4dHVyZU5hbWUgPSBjb250ZXh0LmdldENvbnRleHRWYXJpYWJsZU5hbWUodGV4dHVyZS50ZXh0dXJlKTtcbiAgICAgICAgcmVzdWx0LnB1c2goYFxuICAgICAgJHtzdWJLZXJuZWwucHJvcGVydHl9OiB7XG4gICAgICAgIHRleHR1cmU6ICR7IHN1Yktlcm5lbFRleHR1cmVOYW1lIH0sXG4gICAgICAgIHR5cGU6ICckeyBzdWJLZXJuZWxSZXN1bHQudHlwZSB9JyxcbiAgICAgICAgdG9BcnJheTogJHsgZ2V0VG9BcnJheVN0cmluZyhzdWJLZXJuZWxSZXN1bHQsIHN1Yktlcm5lbFRleHR1cmVOYW1lLCBmcmFtZWJ1ZmZlck5hbWUpIH1cbiAgICAgIH0sYCk7XG4gICAgICB9XG4gICAgICByZXN1bHQucHVzaChgICAgIH07YCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHJlbmRlcmVkID0ga2VybmVsLnJlbmRlck91dHB1dCgpO1xuICAgICAgY29uc3QgdGV4dHVyZU5hbWUgPSBjb250ZXh0LmdldENvbnRleHRWYXJpYWJsZU5hbWUoa2VybmVsLnRleHR1cmUudGV4dHVyZSk7XG4gICAgICByZXN1bHQucHVzaChgICAgIHJldHVybiB7XG4gICAgICAgIHRleHR1cmU6ICR7IHRleHR1cmVOYW1lIH0sXG4gICAgICAgIHR5cGU6ICckeyByZW5kZXJlZC50eXBlIH0nLFxuICAgICAgICB0b0FycmF5OiAkeyBnZXRUb0FycmF5U3RyaW5nKHJlbmRlcmVkLCB0ZXh0dXJlTmFtZSwgZnJhbWVidWZmZXJOYW1lKSB9XG4gICAgICB9O2ApO1xuICAgIH1cbiAgfVxuICByZXN1bHQucHVzaChgICAgICR7ZGVzdHJveUNvbnRleHRTdHJpbmcgPyAnXFxuJyArIGRlc3Ryb3lDb250ZXh0U3RyaW5nICsgJyAgICAnOiAnJ31gKTtcbiAgcmVzdWx0LnB1c2gocG9zdFJlc3VsdC5qb2luKCdcXG4nKSk7XG4gIHJlc3VsdC5wdXNoKCcgIH07Jyk7XG4gIGlmIChrZXJuZWwuZ3JhcGhpY2FsKSB7XG4gICAgcmVzdWx0LnB1c2goZ2V0R2V0UGl4ZWxzU3RyaW5nKGtlcm5lbCkpO1xuICAgIHJlc3VsdC5wdXNoKGAgIGlubmVyS2VybmVsLmdldFBpeGVscyA9IGdldFBpeGVscztgKTtcbiAgfVxuICByZXN1bHQucHVzaCgnICByZXR1cm4gaW5uZXJLZXJuZWw7Jyk7XG5cbiAgbGV0IGNvbnN0YW50c1VwbG9hZCA9IFtdO1xuICBrZXJuZWxDb25zdGFudHMuZm9yRWFjaCgoa2VybmVsQ29uc3RhbnQpID0+IHtcbiAgICBjb25zdGFudHNVcGxvYWQucHVzaChgJHtrZXJuZWxDb25zdGFudC5nZXRTdHJpbmdWYWx1ZUhhbmRsZXIoKX1gKTtcbiAgfSk7XG4gIHJldHVybiBgZnVuY3Rpb24ga2VybmVsKHNldHRpbmdzKSB7XG4gIGNvbnN0IHsgY29udGV4dCwgY29uc3RhbnRzIH0gPSBzZXR0aW5ncztcbiAgJHtjb25zdGFudHNVcGxvYWQuam9pbignJyl9XG4gICR7c2V0dXBDb250ZXh0U3RyaW5nID8gc2V0dXBDb250ZXh0U3RyaW5nIDogJyd9XG4ke3Jlc3VsdC5qb2luKCdcXG4nKX1cbn1gO1xufVxuXG5mdW5jdGlvbiBnZXRSZW5kZXJTdHJpbmcodGFyZ2V0TmFtZSwga2VybmVsKSB7XG4gIGNvbnN0IHJlYWRCYWNrVmFsdWUgPSBrZXJuZWwucHJlY2lzaW9uID09PSAnc2luZ2xlJyA/IHRhcmdldE5hbWUgOiBgbmV3IEZsb2F0MzJBcnJheSgke3RhcmdldE5hbWV9LmJ1ZmZlcilgO1xuICBpZiAoa2VybmVsLm91dHB1dFsyXSkge1xuICAgIHJldHVybiBgcmVuZGVyT3V0cHV0KCR7cmVhZEJhY2tWYWx1ZX0sICR7a2VybmVsLm91dHB1dFswXX0sICR7a2VybmVsLm91dHB1dFsxXX0sICR7a2VybmVsLm91dHB1dFsyXX0pYDtcbiAgfVxuICBpZiAoa2VybmVsLm91dHB1dFsxXSkge1xuICAgIHJldHVybiBgcmVuZGVyT3V0cHV0KCR7cmVhZEJhY2tWYWx1ZX0sICR7a2VybmVsLm91dHB1dFswXX0sICR7a2VybmVsLm91dHB1dFsxXX0pYDtcbiAgfVxuXG4gIHJldHVybiBgcmVuZGVyT3V0cHV0KCR7cmVhZEJhY2tWYWx1ZX0sICR7a2VybmVsLm91dHB1dFswXX0pYDtcbn1cblxuZnVuY3Rpb24gZ2V0R2V0UGl4ZWxzU3RyaW5nKGtlcm5lbCkge1xuICBjb25zdCBnZXRQaXhlbHMgPSBrZXJuZWwuZ2V0UGl4ZWxzLnRvU3RyaW5nKCk7XG4gIGNvbnN0IHVzZUZ1bmN0aW9uS2V5d29yZCA9ICEvXmZ1bmN0aW9uLy50ZXN0KGdldFBpeGVscyk7XG4gIHJldHVybiB1dGlscy5mbGF0dGVuRnVuY3Rpb25Ub1N0cmluZyhgJHt1c2VGdW5jdGlvbktleXdvcmQgPyAnZnVuY3Rpb24gJyA6ICcnfSR7IGdldFBpeGVscyB9YCwge1xuICAgIGZpbmREZXBlbmRlbmN5OiAob2JqZWN0LCBuYW1lKSA9PiB7XG4gICAgICBpZiAob2JqZWN0ID09PSAndXRpbHMnKSB7XG4gICAgICAgIHJldHVybiBgY29uc3QgJHtuYW1lfSA9ICR7dXRpbHNbbmFtZV0udG9TdHJpbmcoKX07YDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG4gICAgdGhpc0xvb2t1cDogKHByb3BlcnR5KSA9PiB7XG4gICAgICBpZiAocHJvcGVydHkgPT09ICdjb250ZXh0Jykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmIChrZXJuZWwuaGFzT3duUHJvcGVydHkocHJvcGVydHkpKSB7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShrZXJuZWxbcHJvcGVydHldKTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcihgdW5oYW5kbGVkIHRoaXNMb29rdXAgJHsgcHJvcGVydHkgfWApO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldFRvQXJyYXlTdHJpbmcoa2VybmVsUmVzdWx0LCB0ZXh0dXJlTmFtZSwgZnJhbWVidWZmZXJOYW1lKSB7XG4gIGNvbnN0IHRvQXJyYXkgPSBrZXJuZWxSZXN1bHQudG9BcnJheS50b1N0cmluZygpO1xuICBjb25zdCB1c2VGdW5jdGlvbktleXdvcmQgPSAhL15mdW5jdGlvbi8udGVzdCh0b0FycmF5KTtcbiAgY29uc3QgZmxhdHRlbmVkRnVuY3Rpb25zID0gdXRpbHMuZmxhdHRlbkZ1bmN0aW9uVG9TdHJpbmcoYCR7dXNlRnVuY3Rpb25LZXl3b3JkID8gJ2Z1bmN0aW9uICcgOiAnJ30keyB0b0FycmF5IH1gLCB7XG4gICAgZmluZERlcGVuZGVuY3k6IChvYmplY3QsIG5hbWUpID0+IHtcbiAgICAgIGlmIChvYmplY3QgPT09ICd1dGlscycpIHtcbiAgICAgICAgcmV0dXJuIGBjb25zdCAke25hbWV9ID0gJHt1dGlsc1tuYW1lXS50b1N0cmluZygpfTtgO1xuICAgICAgfSBlbHNlIGlmIChvYmplY3QgPT09ICd0aGlzJykge1xuICAgICAgICBpZiAobmFtZSA9PT0gJ2ZyYW1lYnVmZmVyJykge1xuICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYCR7dXNlRnVuY3Rpb25LZXl3b3JkID8gJ2Z1bmN0aW9uICcgOiAnJ30ke2tlcm5lbFJlc3VsdFtuYW1lXS50b1N0cmluZygpfWA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VuaGFuZGxlZCBmcm9tT2JqZWN0Jyk7XG4gICAgICB9XG4gICAgfSxcbiAgICB0aGlzTG9va3VwOiAocHJvcGVydHksIGlzRGVjbGFyYXRpb24pID0+IHtcbiAgICAgIGlmIChwcm9wZXJ0eSA9PT0gJ3RleHR1cmUnKSB7XG4gICAgICAgIHJldHVybiB0ZXh0dXJlTmFtZTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9wZXJ0eSA9PT0gJ2NvbnRleHQnKSB7XG4gICAgICAgIGlmIChpc0RlY2xhcmF0aW9uKSByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuICdnbCc7XG4gICAgICB9XG4gICAgICBpZiAoa2VybmVsUmVzdWx0Lmhhc093blByb3BlcnR5KHByb3BlcnR5KSkge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoa2VybmVsUmVzdWx0W3Byb3BlcnR5XSk7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHVuaGFuZGxlZCB0aGlzTG9va3VwICR7IHByb3BlcnR5IH1gKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gYCgpID0+IHtcbiAgZnVuY3Rpb24gZnJhbWVidWZmZXIoKSB7IHJldHVybiAke2ZyYW1lYnVmZmVyTmFtZX07IH07XG4gICR7ZmxhdHRlbmVkRnVuY3Rpb25zfVxuICByZXR1cm4gdG9BcnJheSgpO1xuICB9YDtcbn1cblxuZnVuY3Rpb24gZmluZEtlcm5lbFZhbHVlKGFyZ3VtZW50LCBrZXJuZWxWYWx1ZXMsIHZhbHVlcywgY29udGV4dCwgdXBsb2FkZWRWYWx1ZXMpIHtcbiAgaWYgKGFyZ3VtZW50ID09PSBudWxsKSByZXR1cm4gbnVsbDtcbiAgaWYgKGtlcm5lbFZhbHVlcyA9PT0gbnVsbCkgcmV0dXJuIG51bGw7XG4gIHN3aXRjaCAodHlwZW9mIGFyZ3VtZW50KSB7XG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChcbiAgICB0eXBlb2YgSFRNTEltYWdlRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICBhcmd1bWVudCBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnRcbiAgKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXJuZWxWYWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGtlcm5lbFZhbHVlID0ga2VybmVsVmFsdWVzW2ldO1xuICAgICAgaWYgKGtlcm5lbFZhbHVlLnR5cGUgIT09ICdIVE1MSW1hZ2VBcnJheScgJiYga2VybmVsVmFsdWUpIGNvbnRpbnVlO1xuICAgICAgaWYgKGtlcm5lbFZhbHVlLnVwbG9hZFZhbHVlICE9PSBhcmd1bWVudCkgY29udGludWU7XG4gICAgICBjb25zdCB2YXJpYWJsZUluZGV4ID0gdmFsdWVzW2ldLmluZGV4T2YoYXJndW1lbnQpO1xuICAgICAgaWYgKHZhcmlhYmxlSW5kZXggPT09IC0xKSBjb250aW51ZTtcbiAgICAgIGNvbnN0IHZhcmlhYmxlTmFtZSA9IGB1cGxvYWRWYWx1ZV8ke2tlcm5lbFZhbHVlLm5hbWV9WyR7dmFyaWFibGVJbmRleH1dYDtcbiAgICAgIGNvbnRleHQuaW5zZXJ0VmFyaWFibGUodmFyaWFibGVOYW1lLCBhcmd1bWVudCk7XG4gICAgICByZXR1cm4gdmFyaWFibGVOYW1lO1xuICAgIH1cbiAgfVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwga2VybmVsVmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qga2VybmVsVmFsdWUgPSBrZXJuZWxWYWx1ZXNbaV07XG4gICAgaWYgKGFyZ3VtZW50ICE9PSBrZXJuZWxWYWx1ZS51cGxvYWRWYWx1ZSkgY29udGludWU7XG4gICAgY29uc3QgdmFyaWFibGUgPSBgdXBsb2FkVmFsdWVfJHtrZXJuZWxWYWx1ZS5uYW1lfWA7XG4gICAgY29udGV4dC5pbnNlcnRWYXJpYWJsZSh2YXJpYWJsZSwga2VybmVsVmFsdWUpO1xuICAgIHJldHVybiB2YXJpYWJsZTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGdsS2VybmVsU3RyaW5nXG59O1xufSx7XCIuLi8uLi91dGlsc1wiOjExNCxcImdsLXdpcmV0YXBcIjozfV0sMTM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyBLZXJuZWwgfSA9IHJlcXVpcmUoJy4uL2tlcm5lbCcpO1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHsgR0xUZXh0dXJlQXJyYXkyRmxvYXQgfSA9IHJlcXVpcmUoJy4vdGV4dHVyZS9hcnJheS0yLWZsb2F0Jyk7XG5jb25zdCB7IEdMVGV4dHVyZUFycmF5MkZsb2F0MkQgfSA9IHJlcXVpcmUoJy4vdGV4dHVyZS9hcnJheS0yLWZsb2F0LTJkJyk7XG5jb25zdCB7IEdMVGV4dHVyZUFycmF5MkZsb2F0M0QgfSA9IHJlcXVpcmUoJy4vdGV4dHVyZS9hcnJheS0yLWZsb2F0LTNkJyk7XG5jb25zdCB7IEdMVGV4dHVyZUFycmF5M0Zsb2F0IH0gPSByZXF1aXJlKCcuL3RleHR1cmUvYXJyYXktMy1mbG9hdCcpO1xuY29uc3QgeyBHTFRleHR1cmVBcnJheTNGbG9hdDJEIH0gPSByZXF1aXJlKCcuL3RleHR1cmUvYXJyYXktMy1mbG9hdC0yZCcpO1xuY29uc3QgeyBHTFRleHR1cmVBcnJheTNGbG9hdDNEIH0gPSByZXF1aXJlKCcuL3RleHR1cmUvYXJyYXktMy1mbG9hdC0zZCcpO1xuY29uc3QgeyBHTFRleHR1cmVBcnJheTRGbG9hdCB9ID0gcmVxdWlyZSgnLi90ZXh0dXJlL2FycmF5LTQtZmxvYXQnKTtcbmNvbnN0IHsgR0xUZXh0dXJlQXJyYXk0RmxvYXQyRCB9ID0gcmVxdWlyZSgnLi90ZXh0dXJlL2FycmF5LTQtZmxvYXQtMmQnKTtcbmNvbnN0IHsgR0xUZXh0dXJlQXJyYXk0RmxvYXQzRCB9ID0gcmVxdWlyZSgnLi90ZXh0dXJlL2FycmF5LTQtZmxvYXQtM2QnKTtcbmNvbnN0IHsgR0xUZXh0dXJlRmxvYXQgfSA9IHJlcXVpcmUoJy4vdGV4dHVyZS9mbG9hdCcpO1xuY29uc3QgeyBHTFRleHR1cmVGbG9hdDJEIH0gPSByZXF1aXJlKCcuL3RleHR1cmUvZmxvYXQtMmQnKTtcbmNvbnN0IHsgR0xUZXh0dXJlRmxvYXQzRCB9ID0gcmVxdWlyZSgnLi90ZXh0dXJlL2Zsb2F0LTNkJyk7XG5jb25zdCB7IEdMVGV4dHVyZU1lbW9yeU9wdGltaXplZCB9ID0gcmVxdWlyZSgnLi90ZXh0dXJlL21lbW9yeS1vcHRpbWl6ZWQnKTtcbmNvbnN0IHsgR0xUZXh0dXJlTWVtb3J5T3B0aW1pemVkMkQgfSA9IHJlcXVpcmUoJy4vdGV4dHVyZS9tZW1vcnktb3B0aW1pemVkLTJkJyk7XG5jb25zdCB7IEdMVGV4dHVyZU1lbW9yeU9wdGltaXplZDNEIH0gPSByZXF1aXJlKCcuL3RleHR1cmUvbWVtb3J5LW9wdGltaXplZC0zZCcpO1xuY29uc3QgeyBHTFRleHR1cmVVbnNpZ25lZCB9ID0gcmVxdWlyZSgnLi90ZXh0dXJlL3Vuc2lnbmVkJyk7XG5jb25zdCB7IEdMVGV4dHVyZVVuc2lnbmVkMkQgfSA9IHJlcXVpcmUoJy4vdGV4dHVyZS91bnNpZ25lZC0yZCcpO1xuY29uc3QgeyBHTFRleHR1cmVVbnNpZ25lZDNEIH0gPSByZXF1aXJlKCcuL3RleHR1cmUvdW5zaWduZWQtM2QnKTtcbmNvbnN0IHsgR0xUZXh0dXJlR3JhcGhpY2FsIH0gPSByZXF1aXJlKCcuL3RleHR1cmUvZ3JhcGhpY2FsJyk7XG5cbmNsYXNzIEdMS2VybmVsIGV4dGVuZHMgS2VybmVsIHtcbiAgc3RhdGljIGdldCBtb2RlKCkge1xuICAgIHJldHVybiAnZ3B1JztcbiAgfVxuXG4gIHN0YXRpYyBnZXRJc0Zsb2F0UmVhZCgpIHtcbiAgICBjb25zdCBrZXJuZWxTdHJpbmcgPSBgZnVuY3Rpb24ga2VybmVsRnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9YDtcbiAgICBjb25zdCBrZXJuZWwgPSBuZXcgdGhpcyhrZXJuZWxTdHJpbmcsIHtcbiAgICAgIGNvbnRleHQ6IHRoaXMudGVzdENvbnRleHQsXG4gICAgICBjYW52YXM6IHRoaXMudGVzdENhbnZhcyxcbiAgICAgIHZhbGlkYXRlOiBmYWxzZSxcbiAgICAgIG91dHB1dDogWzFdLFxuICAgICAgcHJlY2lzaW9uOiAnc2luZ2xlJyxcbiAgICAgIHJldHVyblR5cGU6ICdOdW1iZXInLFxuICAgICAgdGFjdGljOiAnc3BlZWQnLFxuICAgIH0pO1xuICAgIGtlcm5lbC5idWlsZCgpO1xuICAgIGtlcm5lbC5ydW4oKTtcbiAgICBjb25zdCByZXN1bHQgPSBrZXJuZWwucmVuZGVyT3V0cHV0KCk7XG4gICAga2VybmVsLmRlc3Ryb3kodHJ1ZSk7XG4gICAgcmV0dXJuIHJlc3VsdFswXSA9PT0gMTtcbiAgfVxuXG4gIHN0YXRpYyBnZXRJc0ludGVnZXJEaXZpc2lvbkFjY3VyYXRlKCkge1xuICAgIGZ1bmN0aW9uIGtlcm5lbEZ1bmN0aW9uKHYxLCB2Mikge1xuICAgICAgcmV0dXJuIHYxW3RoaXMudGhyZWFkLnhdIC8gdjJbdGhpcy50aHJlYWQueF07XG4gICAgfVxuICAgIGNvbnN0IGtlcm5lbCA9IG5ldyB0aGlzKGtlcm5lbEZ1bmN0aW9uLnRvU3RyaW5nKCksIHtcbiAgICAgIGNvbnRleHQ6IHRoaXMudGVzdENvbnRleHQsXG4gICAgICBjYW52YXM6IHRoaXMudGVzdENhbnZhcyxcbiAgICAgIHZhbGlkYXRlOiBmYWxzZSxcbiAgICAgIG91dHB1dDogWzJdLFxuICAgICAgcmV0dXJuVHlwZTogJ051bWJlcicsXG4gICAgICBwcmVjaXNpb246ICd1bnNpZ25lZCcsXG4gICAgICB0YWN0aWM6ICdzcGVlZCcsXG4gICAgfSk7XG4gICAgY29uc3QgYXJncyA9IFtcbiAgICAgIFs2LCA2MDMwNDAxXSxcbiAgICAgIFszLCAzOTkxXVxuICAgIF07XG4gICAga2VybmVsLmJ1aWxkLmFwcGx5KGtlcm5lbCwgYXJncyk7XG4gICAga2VybmVsLnJ1bi5hcHBseShrZXJuZWwsIGFyZ3MpO1xuICAgIGNvbnN0IHJlc3VsdCA9IGtlcm5lbC5yZW5kZXJPdXRwdXQoKTtcbiAgICBrZXJuZWwuZGVzdHJveSh0cnVlKTtcbiAgICByZXR1cm4gcmVzdWx0WzBdID09PSAyICYmIHJlc3VsdFsxXSA9PT0gMTUxMTtcbiAgfVxuXG4gIHN0YXRpYyBnZXRJc1NwZWVkVGFjdGljU3VwcG9ydGVkKCkge1xuICAgIGZ1bmN0aW9uIGtlcm5lbEZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWVbdGhpcy50aHJlYWQueF07XG4gICAgfVxuICAgIGNvbnN0IGtlcm5lbCA9IG5ldyB0aGlzKGtlcm5lbEZ1bmN0aW9uLnRvU3RyaW5nKCksIHtcbiAgICAgIGNvbnRleHQ6IHRoaXMudGVzdENvbnRleHQsXG4gICAgICBjYW52YXM6IHRoaXMudGVzdENhbnZhcyxcbiAgICAgIHZhbGlkYXRlOiBmYWxzZSxcbiAgICAgIG91dHB1dDogWzRdLFxuICAgICAgcmV0dXJuVHlwZTogJ051bWJlcicsXG4gICAgICBwcmVjaXNpb246ICd1bnNpZ25lZCcsXG4gICAgICB0YWN0aWM6ICdzcGVlZCcsXG4gICAgfSk7XG4gICAgY29uc3QgYXJncyA9IFtcbiAgICAgIFswLCAxLCAyLCAzXVxuICAgIF07XG4gICAga2VybmVsLmJ1aWxkLmFwcGx5KGtlcm5lbCwgYXJncyk7XG4gICAga2VybmVsLnJ1bi5hcHBseShrZXJuZWwsIGFyZ3MpO1xuICAgIGNvbnN0IHJlc3VsdCA9IGtlcm5lbC5yZW5kZXJPdXRwdXQoKTtcbiAgICBrZXJuZWwuZGVzdHJveSh0cnVlKTtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChyZXN1bHRbMF0pID09PSAwICYmIE1hdGgucm91bmQocmVzdWx0WzFdKSA9PT0gMSAmJiBNYXRoLnJvdW5kKHJlc3VsdFsyXSkgPT09IDIgJiYgTWF0aC5yb3VuZChyZXN1bHRbM10pID09PSAzO1xuICB9XG5cbiAgc3RhdGljIGdldCB0ZXN0Q2FudmFzKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgXCJ0ZXN0Q2FudmFzXCIgbm90IGRlZmluZWQgb24gJHsgdGhpcy5uYW1lIH1gKTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgdGVzdENvbnRleHQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBcInRlc3RDb250ZXh0XCIgbm90IGRlZmluZWQgb24gJHsgdGhpcy5uYW1lIH1gKTtcbiAgfVxuXG4gIHN0YXRpYyBnZXRGZWF0dXJlcygpIHtcbiAgICBjb25zdCBnbCA9IHRoaXMudGVzdENvbnRleHQ7XG4gICAgY29uc3QgaXNEcmF3QnVmZmVycyA9IHRoaXMuZ2V0SXNEcmF3QnVmZmVycygpO1xuICAgIHJldHVybiBPYmplY3QuZnJlZXplKHtcbiAgICAgIGlzRmxvYXRSZWFkOiB0aGlzLmdldElzRmxvYXRSZWFkKCksXG4gICAgICBpc0ludGVnZXJEaXZpc2lvbkFjY3VyYXRlOiB0aGlzLmdldElzSW50ZWdlckRpdmlzaW9uQWNjdXJhdGUoKSxcbiAgICAgIGlzU3BlZWRUYWN0aWNTdXBwb3J0ZWQ6IHRoaXMuZ2V0SXNTcGVlZFRhY3RpY1N1cHBvcnRlZCgpLFxuICAgICAgaXNUZXh0dXJlRmxvYXQ6IHRoaXMuZ2V0SXNUZXh0dXJlRmxvYXQoKSxcbiAgICAgIGlzRHJhd0J1ZmZlcnMsXG4gICAgICBrZXJuZWxNYXA6IGlzRHJhd0J1ZmZlcnMsXG4gICAgICBjaGFubmVsQ291bnQ6IHRoaXMuZ2V0Q2hhbm5lbENvdW50KCksXG4gICAgICBtYXhUZXh0dXJlU2l6ZTogdGhpcy5nZXRNYXhUZXh0dXJlU2l6ZSgpLFxuICAgICAgbG93SW50UHJlY2lzaW9uOiBnbC5nZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXQoZ2wuRlJBR01FTlRfU0hBREVSLCBnbC5MT1dfSU5UKSxcbiAgICAgIGxvd0Zsb2F0UHJlY2lzaW9uOiBnbC5nZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXQoZ2wuRlJBR01FTlRfU0hBREVSLCBnbC5MT1dfRkxPQVQpLFxuICAgICAgbWVkaXVtSW50UHJlY2lzaW9uOiBnbC5nZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXQoZ2wuRlJBR01FTlRfU0hBREVSLCBnbC5NRURJVU1fSU5UKSxcbiAgICAgIG1lZGl1bUZsb2F0UHJlY2lzaW9uOiBnbC5nZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXQoZ2wuRlJBR01FTlRfU0hBREVSLCBnbC5NRURJVU1fRkxPQVQpLFxuICAgICAgaGlnaEludFByZWNpc2lvbjogZ2wuZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0KGdsLkZSQUdNRU5UX1NIQURFUiwgZ2wuSElHSF9JTlQpLFxuICAgICAgaGlnaEZsb2F0UHJlY2lzaW9uOiBnbC5nZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXQoZ2wuRlJBR01FTlRfU0hBREVSLCBnbC5ISUdIX0ZMT0FUKSxcbiAgICB9KTtcbiAgfVxuXG4gIHN0YXRpYyBzZXR1cEZlYXR1cmVDaGVja3MoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBcInNldHVwRmVhdHVyZUNoZWNrc1wiIG5vdCBkZWZpbmVkIG9uICR7IHRoaXMubmFtZSB9YCk7XG4gIH1cblxuICBzdGF0aWMgZ2V0U2lnbmF0dXJlKGtlcm5lbCwgYXJndW1lbnRUeXBlcykge1xuICAgIHJldHVybiBrZXJuZWwuZ2V0VmFyaWFibGVQcmVjaXNpb25TdHJpbmcoKSArIChhcmd1bWVudFR5cGVzLmxlbmd0aCA+IDAgPyAnOicgKyBhcmd1bWVudFR5cGVzLmpvaW4oJywnKSA6ICcnKTtcbiAgfVxuXG4gIHNldEZpeEludGVnZXJEaXZpc2lvbkFjY3VyYWN5KGZpeCkge1xuICAgIHRoaXMuZml4SW50ZWdlckRpdmlzaW9uQWNjdXJhY3kgPSBmaXg7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBzZXRQcmVjaXNpb24oZmxhZykge1xuICAgIHRoaXMucHJlY2lzaW9uID0gZmxhZztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHNldEZsb2F0VGV4dHVyZXMoZmxhZykge1xuICAgIHV0aWxzLndhcm5EZXByZWNhdGVkKCdtZXRob2QnLCAnc2V0RmxvYXRUZXh0dXJlcycsICdzZXRPcHRpbWl6ZUZsb2F0TWVtb3J5Jyk7XG4gICAgdGhpcy5mbG9hdFRleHR1cmVzID0gZmxhZztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHN0YXRpYyBuYXRpdmVGdW5jdGlvbkFyZ3VtZW50cyhzb3VyY2UpIHtcbiAgICBjb25zdCBhcmd1bWVudFR5cGVzID0gW107XG4gICAgY29uc3QgYXJndW1lbnROYW1lcyA9IFtdO1xuICAgIGNvbnN0IHN0YXRlcyA9IFtdO1xuICAgIGNvbnN0IGlzU3RhcnRpbmdWYXJpYWJsZU5hbWUgPSAvXlthLXpBLVpfXS87XG4gICAgY29uc3QgaXNWYXJpYWJsZUNoYXIgPSAvW2EtekEtWl8wLTldLztcbiAgICBsZXQgaSA9IDA7XG4gICAgbGV0IGFyZ3VtZW50TmFtZSA9IG51bGw7XG4gICAgbGV0IGFyZ3VtZW50VHlwZSA9IG51bGw7XG4gICAgd2hpbGUgKGkgPCBzb3VyY2UubGVuZ3RoKSB7XG4gICAgICBjb25zdCBjaGFyID0gc291cmNlW2ldO1xuICAgICAgY29uc3QgbmV4dENoYXIgPSBzb3VyY2VbaSArIDFdO1xuICAgICAgY29uc3Qgc3RhdGUgPSBzdGF0ZXMubGVuZ3RoID4gMCA/IHN0YXRlc1tzdGF0ZXMubGVuZ3RoIC0gMV0gOiBudWxsO1xuXG4gICAgICBpZiAoc3RhdGUgPT09ICdGVU5DVElPTl9BUkdVTUVOVFMnICYmIGNoYXIgPT09ICcvJyAmJiBuZXh0Q2hhciA9PT0gJyonKSB7XG4gICAgICAgIHN0YXRlcy5wdXNoKCdNVUxUSV9MSU5FX0NPTU1FTlQnKTtcbiAgICAgICAgaSArPSAyO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUgPT09ICdNVUxUSV9MSU5FX0NPTU1FTlQnICYmIGNoYXIgPT09ICcqJyAmJiBuZXh0Q2hhciA9PT0gJy8nKSB7XG4gICAgICAgIHN0YXRlcy5wb3AoKTtcbiAgICAgICAgaSArPSAyO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgZWxzZSBpZiAoc3RhdGUgPT09ICdGVU5DVElPTl9BUkdVTUVOVFMnICYmIGNoYXIgPT09ICcvJyAmJiBuZXh0Q2hhciA9PT0gJy8nKSB7XG4gICAgICAgIHN0YXRlcy5wdXNoKCdDT01NRU5UJyk7XG4gICAgICAgIGkgKz0gMjtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlID09PSAnQ09NTUVOVCcgJiYgY2hhciA9PT0gJ1xcbicpIHtcbiAgICAgICAgc3RhdGVzLnBvcCgpO1xuICAgICAgICBpKys7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBlbHNlIGlmIChzdGF0ZSA9PT0gbnVsbCAmJiBjaGFyID09PSAnKCcpIHtcbiAgICAgICAgc3RhdGVzLnB1c2goJ0ZVTkNUSU9OX0FSR1VNRU5UUycpO1xuICAgICAgICBpKys7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZSA9PT0gJ0ZVTkNUSU9OX0FSR1VNRU5UUycpIHtcbiAgICAgICAgaWYgKGNoYXIgPT09ICcpJykge1xuICAgICAgICAgIHN0YXRlcy5wb3AoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhciA9PT0gJ2YnICYmIG5leHRDaGFyID09PSAnbCcgJiYgc291cmNlW2kgKyAyXSA9PT0gJ28nICYmIHNvdXJjZVtpICsgM10gPT09ICdhJyAmJiBzb3VyY2VbaSArIDRdID09PSAndCcgJiYgc291cmNlW2kgKyA1XSA9PT0gJyAnKSB7XG4gICAgICAgICAgc3RhdGVzLnB1c2goJ0RFQ0xBUkVfVkFSSUFCTEUnKTtcbiAgICAgICAgICBhcmd1bWVudFR5cGUgPSAnZmxvYXQnO1xuICAgICAgICAgIGFyZ3VtZW50TmFtZSA9ICcnO1xuICAgICAgICAgIGkgKz0gNjtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSBlbHNlIGlmIChjaGFyID09PSAnaScgJiYgbmV4dENoYXIgPT09ICduJyAmJiBzb3VyY2VbaSArIDJdID09PSAndCcgJiYgc291cmNlW2kgKyAzXSA9PT0gJyAnKSB7XG4gICAgICAgICAgc3RhdGVzLnB1c2goJ0RFQ0xBUkVfVkFSSUFCTEUnKTtcbiAgICAgICAgICBhcmd1bWVudFR5cGUgPSAnaW50JztcbiAgICAgICAgICBhcmd1bWVudE5hbWUgPSAnJztcbiAgICAgICAgICBpICs9IDQ7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gZWxzZSBpZiAoY2hhciA9PT0gJ3YnICYmIG5leHRDaGFyID09PSAnZScgJiYgc291cmNlW2kgKyAyXSA9PT0gJ2MnICYmIHNvdXJjZVtpICsgM10gPT09ICcyJyAmJiBzb3VyY2VbaSArIDRdID09PSAnICcpIHtcbiAgICAgICAgICBzdGF0ZXMucHVzaCgnREVDTEFSRV9WQVJJQUJMRScpO1xuICAgICAgICAgIGFyZ3VtZW50VHlwZSA9ICd2ZWMyJztcbiAgICAgICAgICBhcmd1bWVudE5hbWUgPSAnJztcbiAgICAgICAgICBpICs9IDU7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gZWxzZSBpZiAoY2hhciA9PT0gJ3YnICYmIG5leHRDaGFyID09PSAnZScgJiYgc291cmNlW2kgKyAyXSA9PT0gJ2MnICYmIHNvdXJjZVtpICsgM10gPT09ICczJyAmJiBzb3VyY2VbaSArIDRdID09PSAnICcpIHtcbiAgICAgICAgICBzdGF0ZXMucHVzaCgnREVDTEFSRV9WQVJJQUJMRScpO1xuICAgICAgICAgIGFyZ3VtZW50VHlwZSA9ICd2ZWMzJztcbiAgICAgICAgICBhcmd1bWVudE5hbWUgPSAnJztcbiAgICAgICAgICBpICs9IDU7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gZWxzZSBpZiAoY2hhciA9PT0gJ3YnICYmIG5leHRDaGFyID09PSAnZScgJiYgc291cmNlW2kgKyAyXSA9PT0gJ2MnICYmIHNvdXJjZVtpICsgM10gPT09ICc0JyAmJiBzb3VyY2VbaSArIDRdID09PSAnICcpIHtcbiAgICAgICAgICBzdGF0ZXMucHVzaCgnREVDTEFSRV9WQVJJQUJMRScpO1xuICAgICAgICAgIGFyZ3VtZW50VHlwZSA9ICd2ZWM0JztcbiAgICAgICAgICBhcmd1bWVudE5hbWUgPSAnJztcbiAgICAgICAgICBpICs9IDU7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZWxzZSBpZiAoc3RhdGUgPT09ICdERUNMQVJFX1ZBUklBQkxFJykge1xuICAgICAgICBpZiAoYXJndW1lbnROYW1lID09PSAnJykge1xuICAgICAgICAgIGlmIChjaGFyID09PSAnICcpIHtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWlzU3RhcnRpbmdWYXJpYWJsZU5hbWUudGVzdChjaGFyKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd2YXJpYWJsZSBuYW1lIGlzIG5vdCBleHBlY3RlZCBzdHJpbmcnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYXJndW1lbnROYW1lICs9IGNoYXI7XG4gICAgICAgIGlmICghaXNWYXJpYWJsZUNoYXIudGVzdChuZXh0Q2hhcikpIHtcbiAgICAgICAgICBzdGF0ZXMucG9wKCk7XG4gICAgICAgICAgYXJndW1lbnROYW1lcy5wdXNoKGFyZ3VtZW50TmFtZSk7XG4gICAgICAgICAgYXJndW1lbnRUeXBlcy5wdXNoKHR5cGVNYXBbYXJndW1lbnRUeXBlXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaSsrO1xuICAgIH1cbiAgICBpZiAoc3RhdGVzLmxlbmd0aCA+IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignR0xTTCBmdW5jdGlvbiB3YXMgbm90IHBhcnNhYmxlJyk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBhcmd1bWVudE5hbWVzLFxuICAgICAgYXJndW1lbnRUeXBlcyxcbiAgICB9O1xuICB9XG5cbiAgc3RhdGljIG5hdGl2ZUZ1bmN0aW9uUmV0dXJuVHlwZShzb3VyY2UpIHtcbiAgICByZXR1cm4gdHlwZU1hcFtzb3VyY2UubWF0Y2goL2ludHxmbG9hdHx2ZWNbMi00XS8pWzBdXTtcbiAgfVxuXG4gIHN0YXRpYyBjb21iaW5lS2VybmVscyhjb21iaW5lZEtlcm5lbCwgbGFzdEtlcm5lbCkge1xuICAgIGNvbWJpbmVkS2VybmVsLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgY29uc3Qge1xuICAgICAgdGV4U2l6ZSxcbiAgICAgIGNvbnRleHQsXG4gICAgICB0aHJlYWREaW1cbiAgICB9ID0gbGFzdEtlcm5lbC50ZXhTaXplO1xuICAgIGxldCByZXN1bHQ7XG4gICAgaWYgKGxhc3RLZXJuZWwucHJlY2lzaW9uID09PSAnc2luZ2xlJykge1xuICAgICAgY29uc3QgdyA9IHRleFNpemVbMF07XG4gICAgICBjb25zdCBoID0gTWF0aC5jZWlsKHRleFNpemVbMV0gLyA0KTtcbiAgICAgIHJlc3VsdCA9IG5ldyBGbG9hdDMyQXJyYXkodyAqIGggKiA0ICogNCk7XG4gICAgICBjb250ZXh0LnJlYWRQaXhlbHMoMCwgMCwgdywgaCAqIDQsIGNvbnRleHQuUkdCQSwgY29udGV4dC5GTE9BVCwgcmVzdWx0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheSh0ZXhTaXplWzBdICogdGV4U2l6ZVsxXSAqIDQpO1xuICAgICAgY29udGV4dC5yZWFkUGl4ZWxzKDAsIDAsIHRleFNpemVbMF0sIHRleFNpemVbMV0sIGNvbnRleHQuUkdCQSwgY29udGV4dC5VTlNJR05FRF9CWVRFLCBieXRlcyk7XG4gICAgICByZXN1bHQgPSBuZXcgRmxvYXQzMkFycmF5KGJ5dGVzLmJ1ZmZlcik7XG4gICAgfVxuXG4gICAgcmVzdWx0ID0gcmVzdWx0LnN1YmFycmF5KDAsIHRocmVhZERpbVswXSAqIHRocmVhZERpbVsxXSAqIHRocmVhZERpbVsyXSk7XG5cbiAgICBpZiAobGFzdEtlcm5lbC5vdXRwdXQubGVuZ3RoID09PSAxKSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0gZWxzZSBpZiAobGFzdEtlcm5lbC5vdXRwdXQubGVuZ3RoID09PSAyKSB7XG4gICAgICByZXR1cm4gdXRpbHMuc3BsaXRBcnJheShyZXN1bHQsIGxhc3RLZXJuZWwub3V0cHV0WzBdKTtcbiAgICB9IGVsc2UgaWYgKGxhc3RLZXJuZWwub3V0cHV0Lmxlbmd0aCA9PT0gMykge1xuICAgICAgY29uc3QgY3ViZSA9IHV0aWxzLnNwbGl0QXJyYXkocmVzdWx0LCBsYXN0S2VybmVsLm91dHB1dFswXSAqIGxhc3RLZXJuZWwub3V0cHV0WzFdKTtcbiAgICAgIHJldHVybiBjdWJlLm1hcChmdW5jdGlvbih4KSB7XG4gICAgICAgIHJldHVybiB1dGlscy5zcGxpdEFycmF5KHgsIGxhc3RLZXJuZWwub3V0cHV0WzBdKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0cnVjdG9yKHNvdXJjZSwgc2V0dGluZ3MpIHtcbiAgICBzdXBlcihzb3VyY2UsIHNldHRpbmdzKTtcbiAgICB0aGlzLnRyYW5zZmVyVmFsdWVzID0gbnVsbDtcbiAgICB0aGlzLmZvcm1hdFZhbHVlcyA9IG51bGw7XG4gICAgdGhpcy5UZXh0dXJlQ29uc3RydWN0b3IgPSBudWxsO1xuICAgIHRoaXMucmVuZGVyT3V0cHV0ID0gbnVsbDtcbiAgICB0aGlzLnJlbmRlclJhd091dHB1dCA9IG51bGw7XG4gICAgdGhpcy50ZXhTaXplID0gbnVsbDtcbiAgICB0aGlzLnRyYW5zbGF0ZWRTb3VyY2UgPSBudWxsO1xuICAgIHRoaXMuY29tcGlsZWRGcmFnbWVudFNoYWRlciA9IG51bGw7XG4gICAgdGhpcy5jb21waWxlZFZlcnRleFNoYWRlciA9IG51bGw7XG4gICAgdGhpcy5zd2l0Y2hpbmdLZXJuZWxzID0gbnVsbDtcbiAgICB0aGlzLl90ZXh0dXJlU3dpdGNoZWQgPSBudWxsO1xuICAgIHRoaXMuX21hcHBlZFRleHR1cmVTd2l0Y2hlZCA9IG51bGw7XG4gIH1cblxuICBjaGVja1RleHR1cmVTaXplKCkge1xuICAgIGNvbnN0IHsgZmVhdHVyZXMgfSA9IHRoaXMuY29uc3RydWN0b3I7XG4gICAgaWYgKHRoaXMudGV4U2l6ZVswXSA+IGZlYXR1cmVzLm1heFRleHR1cmVTaXplIHx8IHRoaXMudGV4U2l6ZVsxXSA+IGZlYXR1cmVzLm1heFRleHR1cmVTaXplKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRleHR1cmUgc2l6ZSBbJHt0aGlzLnRleFNpemVbMF19LCR7dGhpcy50ZXhTaXplWzFdfV0gZ2VuZXJhdGVkIGJ5IGtlcm5lbCBpcyBsYXJnZXIgdGhhbiBzdXBwb3J0ZWQgc2l6ZSBbJHtmZWF0dXJlcy5tYXhUZXh0dXJlU2l6ZX0sJHtmZWF0dXJlcy5tYXhUZXh0dXJlU2l6ZX1dYCk7XG4gICAgfVxuICB9XG5cbiAgdHJhbnNsYXRlU291cmNlKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgXCJ0cmFuc2xhdGVTb3VyY2VcIiBub3QgZGVmaW5lZCBvbiAke3RoaXMuY29uc3RydWN0b3IubmFtZX1gKTtcbiAgfVxuXG4gIHBpY2tSZW5kZXJTdHJhdGVneShhcmdzKSB7XG4gICAgaWYgKHRoaXMuZ3JhcGhpY2FsKSB7XG4gICAgICB0aGlzLnJlbmRlclJhd091dHB1dCA9IHRoaXMucmVhZFBhY2tlZFBpeGVsc1RvVWludDhBcnJheTtcbiAgICAgIHRoaXMudHJhbnNmZXJWYWx1ZXMgPSAocGl4ZWxzKSA9PiBwaXhlbHM7XG4gICAgICB0aGlzLlRleHR1cmVDb25zdHJ1Y3RvciA9IEdMVGV4dHVyZUdyYXBoaWNhbDtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAodGhpcy5wcmVjaXNpb24gPT09ICd1bnNpZ25lZCcpIHtcbiAgICAgIHRoaXMucmVuZGVyUmF3T3V0cHV0ID0gdGhpcy5yZWFkUGFja2VkUGl4ZWxzVG9VaW50OEFycmF5O1xuICAgICAgdGhpcy50cmFuc2ZlclZhbHVlcyA9IHRoaXMucmVhZFBhY2tlZFBpeGVsc1RvRmxvYXQzMkFycmF5O1xuICAgICAgaWYgKHRoaXMucGlwZWxpbmUpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJPdXRwdXQgPSB0aGlzLnJlbmRlclRleHR1cmU7XG4gICAgICAgIGlmICh0aGlzLnN1Yktlcm5lbHMgIT09IG51bGwpIHtcbiAgICAgICAgICB0aGlzLnJlbmRlcktlcm5lbHMgPSB0aGlzLnJlbmRlcktlcm5lbHNUb1RleHR1cmVzO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAodGhpcy5yZXR1cm5UeXBlKSB7XG4gICAgICAgICAgY2FzZSAnTGl0ZXJhbEludGVnZXInOlxuICAgICAgICAgIGNhc2UgJ0Zsb2F0JzpcbiAgICAgICAgICBjYXNlICdOdW1iZXInOlxuICAgICAgICAgIGNhc2UgJ0ludGVnZXInOlxuICAgICAgICAgICAgaWYgKHRoaXMub3V0cHV0WzJdID4gMCkge1xuICAgICAgICAgICAgICB0aGlzLlRleHR1cmVDb25zdHJ1Y3RvciA9IEdMVGV4dHVyZVVuc2lnbmVkM0Q7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLm91dHB1dFsxXSA+IDApIHtcbiAgICAgICAgICAgICAgdGhpcy5UZXh0dXJlQ29uc3RydWN0b3IgPSBHTFRleHR1cmVVbnNpZ25lZDJEO1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuVGV4dHVyZUNvbnN0cnVjdG9yID0gR0xUZXh0dXJlVW5zaWduZWQ7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnQXJyYXkoMiknOlxuICAgICAgICAgICAgY2FzZSAnQXJyYXkoMyknOlxuICAgICAgICAgICAgY2FzZSAnQXJyYXkoNCknOlxuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0RmFsbGJhY2soYXJncyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLnN1Yktlcm5lbHMgIT09IG51bGwpIHtcbiAgICAgICAgICB0aGlzLnJlbmRlcktlcm5lbHMgPSB0aGlzLnJlbmRlcktlcm5lbHNUb0FycmF5cztcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKHRoaXMucmV0dXJuVHlwZSkge1xuICAgICAgICAgIGNhc2UgJ0xpdGVyYWxJbnRlZ2VyJzpcbiAgICAgICAgICBjYXNlICdGbG9hdCc6XG4gICAgICAgICAgY2FzZSAnTnVtYmVyJzpcbiAgICAgICAgICBjYXNlICdJbnRlZ2VyJzpcbiAgICAgICAgICAgIHRoaXMucmVuZGVyT3V0cHV0ID0gdGhpcy5yZW5kZXJWYWx1ZXM7XG4gICAgICAgICAgICBpZiAodGhpcy5vdXRwdXRbMl0gPiAwKSB7XG4gICAgICAgICAgICAgIHRoaXMuVGV4dHVyZUNvbnN0cnVjdG9yID0gR0xUZXh0dXJlVW5zaWduZWQzRDtcbiAgICAgICAgICAgICAgdGhpcy5mb3JtYXRWYWx1ZXMgPSB1dGlscy5lcmVjdDNEUGFja2VkRmxvYXQ7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLm91dHB1dFsxXSA+IDApIHtcbiAgICAgICAgICAgICAgdGhpcy5UZXh0dXJlQ29uc3RydWN0b3IgPSBHTFRleHR1cmVVbnNpZ25lZDJEO1xuICAgICAgICAgICAgICB0aGlzLmZvcm1hdFZhbHVlcyA9IHV0aWxzLmVyZWN0MkRQYWNrZWRGbG9hdDtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLlRleHR1cmVDb25zdHJ1Y3RvciA9IEdMVGV4dHVyZVVuc2lnbmVkO1xuICAgICAgICAgICAgICB0aGlzLmZvcm1hdFZhbHVlcyA9IHV0aWxzLmVyZWN0UGFja2VkRmxvYXQ7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnQXJyYXkoMiknOlxuICAgICAgICAgICAgY2FzZSAnQXJyYXkoMyknOlxuICAgICAgICAgICAgY2FzZSAnQXJyYXkoNCknOlxuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0RmFsbGJhY2soYXJncyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMucHJlY2lzaW9uID09PSAnc2luZ2xlJykge1xuICAgICAgdGhpcy5yZW5kZXJSYXdPdXRwdXQgPSB0aGlzLnJlYWRGbG9hdFBpeGVsc1RvRmxvYXQzMkFycmF5O1xuICAgICAgdGhpcy50cmFuc2ZlclZhbHVlcyA9IHRoaXMucmVhZEZsb2F0UGl4ZWxzVG9GbG9hdDMyQXJyYXk7XG4gICAgICBpZiAodGhpcy5waXBlbGluZSkge1xuICAgICAgICB0aGlzLnJlbmRlck91dHB1dCA9IHRoaXMucmVuZGVyVGV4dHVyZTtcbiAgICAgICAgaWYgKHRoaXMuc3ViS2VybmVscyAhPT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMucmVuZGVyS2VybmVscyA9IHRoaXMucmVuZGVyS2VybmVsc1RvVGV4dHVyZXM7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoICh0aGlzLnJldHVyblR5cGUpIHtcbiAgICAgICAgICBjYXNlICdMaXRlcmFsSW50ZWdlcic6XG4gICAgICAgICAgY2FzZSAnRmxvYXQnOlxuICAgICAgICAgIGNhc2UgJ051bWJlcic6XG4gICAgICAgICAgY2FzZSAnSW50ZWdlcic6IHtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGltaXplRmxvYXRNZW1vcnkpIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMub3V0cHV0WzJdID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuVGV4dHVyZUNvbnN0cnVjdG9yID0gR0xUZXh0dXJlTWVtb3J5T3B0aW1pemVkM0Q7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5vdXRwdXRbMV0gPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5UZXh0dXJlQ29uc3RydWN0b3IgPSBHTFRleHR1cmVNZW1vcnlPcHRpbWl6ZWQyRDtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLlRleHR1cmVDb25zdHJ1Y3RvciA9IEdMVGV4dHVyZU1lbW9yeU9wdGltaXplZDtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMub3V0cHV0WzJdID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuVGV4dHVyZUNvbnN0cnVjdG9yID0gR0xUZXh0dXJlRmxvYXQzRDtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLm91dHB1dFsxXSA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLlRleHR1cmVDb25zdHJ1Y3RvciA9IEdMVGV4dHVyZUZsb2F0MkQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5UZXh0dXJlQ29uc3RydWN0b3IgPSBHTFRleHR1cmVGbG9hdDtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlICdBcnJheSgyKSc6IHtcbiAgICAgICAgICAgIGlmICh0aGlzLm91dHB1dFsyXSA+IDApIHtcbiAgICAgICAgICAgICAgdGhpcy5UZXh0dXJlQ29uc3RydWN0b3IgPSBHTFRleHR1cmVBcnJheTJGbG9hdDNEO1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5vdXRwdXRbMV0gPiAwKSB7XG4gICAgICAgICAgICAgIHRoaXMuVGV4dHVyZUNvbnN0cnVjdG9yID0gR0xUZXh0dXJlQXJyYXkyRmxvYXQyRDtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLlRleHR1cmVDb25zdHJ1Y3RvciA9IEdMVGV4dHVyZUFycmF5MkZsb2F0O1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAnQXJyYXkoMyknOiB7XG4gICAgICAgICAgICBpZiAodGhpcy5vdXRwdXRbMl0gPiAwKSB7XG4gICAgICAgICAgICAgIHRoaXMuVGV4dHVyZUNvbnN0cnVjdG9yID0gR0xUZXh0dXJlQXJyYXkzRmxvYXQzRDtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMub3V0cHV0WzFdID4gMCkge1xuICAgICAgICAgICAgICB0aGlzLlRleHR1cmVDb25zdHJ1Y3RvciA9IEdMVGV4dHVyZUFycmF5M0Zsb2F0MkQ7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5UZXh0dXJlQ29uc3RydWN0b3IgPSBHTFRleHR1cmVBcnJheTNGbG9hdDtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgJ0FycmF5KDQpJzoge1xuICAgICAgICAgICAgaWYgKHRoaXMub3V0cHV0WzJdID4gMCkge1xuICAgICAgICAgICAgICB0aGlzLlRleHR1cmVDb25zdHJ1Y3RvciA9IEdMVGV4dHVyZUFycmF5NEZsb2F0M0Q7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLm91dHB1dFsxXSA+IDApIHtcbiAgICAgICAgICAgICAgdGhpcy5UZXh0dXJlQ29uc3RydWN0b3IgPSBHTFRleHR1cmVBcnJheTRGbG9hdDJEO1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuVGV4dHVyZUNvbnN0cnVjdG9yID0gR0xUZXh0dXJlQXJyYXk0RmxvYXQ7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5yZW5kZXJPdXRwdXQgPSB0aGlzLnJlbmRlclZhbHVlcztcbiAgICAgIGlmICh0aGlzLnN1Yktlcm5lbHMgIT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJLZXJuZWxzID0gdGhpcy5yZW5kZXJLZXJuZWxzVG9BcnJheXM7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5vcHRpbWl6ZUZsb2F0TWVtb3J5KSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5yZXR1cm5UeXBlKSB7XG4gICAgICAgICAgY2FzZSAnTGl0ZXJhbEludGVnZXInOlxuICAgICAgICAgIGNhc2UgJ0Zsb2F0JzpcbiAgICAgICAgICBjYXNlICdOdW1iZXInOlxuICAgICAgICAgIGNhc2UgJ0ludGVnZXInOiB7XG4gICAgICAgICAgICBpZiAodGhpcy5vdXRwdXRbMl0gPiAwKSB7XG4gICAgICAgICAgICAgIHRoaXMuVGV4dHVyZUNvbnN0cnVjdG9yID0gR0xUZXh0dXJlTWVtb3J5T3B0aW1pemVkM0Q7XG4gICAgICAgICAgICAgIHRoaXMuZm9ybWF0VmFsdWVzID0gdXRpbHMuZXJlY3RNZW1vcnlPcHRpbWl6ZWQzREZsb2F0O1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5vdXRwdXRbMV0gPiAwKSB7XG4gICAgICAgICAgICAgIHRoaXMuVGV4dHVyZUNvbnN0cnVjdG9yID0gR0xUZXh0dXJlTWVtb3J5T3B0aW1pemVkMkQ7XG4gICAgICAgICAgICAgIHRoaXMuZm9ybWF0VmFsdWVzID0gdXRpbHMuZXJlY3RNZW1vcnlPcHRpbWl6ZWQyREZsb2F0O1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuVGV4dHVyZUNvbnN0cnVjdG9yID0gR0xUZXh0dXJlTWVtb3J5T3B0aW1pemVkO1xuICAgICAgICAgICAgICB0aGlzLmZvcm1hdFZhbHVlcyA9IHV0aWxzLmVyZWN0TWVtb3J5T3B0aW1pemVkRmxvYXQ7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlICdBcnJheSgyKSc6IHtcbiAgICAgICAgICAgIGlmICh0aGlzLm91dHB1dFsyXSA+IDApIHtcbiAgICAgICAgICAgICAgdGhpcy5UZXh0dXJlQ29uc3RydWN0b3IgPSBHTFRleHR1cmVBcnJheTJGbG9hdDNEO1xuICAgICAgICAgICAgICB0aGlzLmZvcm1hdFZhbHVlcyA9IHV0aWxzLmVyZWN0M0RBcnJheTI7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLm91dHB1dFsxXSA+IDApIHtcbiAgICAgICAgICAgICAgdGhpcy5UZXh0dXJlQ29uc3RydWN0b3IgPSBHTFRleHR1cmVBcnJheTJGbG9hdDJEO1xuICAgICAgICAgICAgICB0aGlzLmZvcm1hdFZhbHVlcyA9IHV0aWxzLmVyZWN0MkRBcnJheTI7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5UZXh0dXJlQ29uc3RydWN0b3IgPSBHTFRleHR1cmVBcnJheTJGbG9hdDtcbiAgICAgICAgICAgICAgdGhpcy5mb3JtYXRWYWx1ZXMgPSB1dGlscy5lcmVjdEFycmF5MjtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgJ0FycmF5KDMpJzoge1xuICAgICAgICAgICAgaWYgKHRoaXMub3V0cHV0WzJdID4gMCkge1xuICAgICAgICAgICAgICB0aGlzLlRleHR1cmVDb25zdHJ1Y3RvciA9IEdMVGV4dHVyZUFycmF5M0Zsb2F0M0Q7XG4gICAgICAgICAgICAgIHRoaXMuZm9ybWF0VmFsdWVzID0gdXRpbHMuZXJlY3QzREFycmF5MztcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMub3V0cHV0WzFdID4gMCkge1xuICAgICAgICAgICAgICB0aGlzLlRleHR1cmVDb25zdHJ1Y3RvciA9IEdMVGV4dHVyZUFycmF5M0Zsb2F0MkQ7XG4gICAgICAgICAgICAgIHRoaXMuZm9ybWF0VmFsdWVzID0gdXRpbHMuZXJlY3QyREFycmF5MztcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLlRleHR1cmVDb25zdHJ1Y3RvciA9IEdMVGV4dHVyZUFycmF5M0Zsb2F0O1xuICAgICAgICAgICAgICB0aGlzLmZvcm1hdFZhbHVlcyA9IHV0aWxzLmVyZWN0QXJyYXkzO1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAnQXJyYXkoNCknOiB7XG4gICAgICAgICAgICBpZiAodGhpcy5vdXRwdXRbMl0gPiAwKSB7XG4gICAgICAgICAgICAgIHRoaXMuVGV4dHVyZUNvbnN0cnVjdG9yID0gR0xUZXh0dXJlQXJyYXk0RmxvYXQzRDtcbiAgICAgICAgICAgICAgdGhpcy5mb3JtYXRWYWx1ZXMgPSB1dGlscy5lcmVjdDNEQXJyYXk0O1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5vdXRwdXRbMV0gPiAwKSB7XG4gICAgICAgICAgICAgIHRoaXMuVGV4dHVyZUNvbnN0cnVjdG9yID0gR0xUZXh0dXJlQXJyYXk0RmxvYXQyRDtcbiAgICAgICAgICAgICAgdGhpcy5mb3JtYXRWYWx1ZXMgPSB1dGlscy5lcmVjdDJEQXJyYXk0O1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuVGV4dHVyZUNvbnN0cnVjdG9yID0gR0xUZXh0dXJlQXJyYXk0RmxvYXQ7XG4gICAgICAgICAgICAgIHRoaXMuZm9ybWF0VmFsdWVzID0gdXRpbHMuZXJlY3RBcnJheTQ7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLnJldHVyblR5cGUpIHtcbiAgICAgICAgICBjYXNlICdMaXRlcmFsSW50ZWdlcic6XG4gICAgICAgICAgY2FzZSAnRmxvYXQnOlxuICAgICAgICAgIGNhc2UgJ051bWJlcic6XG4gICAgICAgICAgY2FzZSAnSW50ZWdlcic6IHtcbiAgICAgICAgICAgIGlmICh0aGlzLm91dHB1dFsyXSA+IDApIHtcbiAgICAgICAgICAgICAgdGhpcy5UZXh0dXJlQ29uc3RydWN0b3IgPSBHTFRleHR1cmVGbG9hdDNEO1xuICAgICAgICAgICAgICB0aGlzLmZvcm1hdFZhbHVlcyA9IHV0aWxzLmVyZWN0M0RGbG9hdDtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMub3V0cHV0WzFdID4gMCkge1xuICAgICAgICAgICAgICB0aGlzLlRleHR1cmVDb25zdHJ1Y3RvciA9IEdMVGV4dHVyZUZsb2F0MkQ7XG4gICAgICAgICAgICAgIHRoaXMuZm9ybWF0VmFsdWVzID0gdXRpbHMuZXJlY3QyREZsb2F0O1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuVGV4dHVyZUNvbnN0cnVjdG9yID0gR0xUZXh0dXJlRmxvYXQ7XG4gICAgICAgICAgICAgIHRoaXMuZm9ybWF0VmFsdWVzID0gdXRpbHMuZXJlY3RGbG9hdDtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgJ0FycmF5KDIpJzoge1xuICAgICAgICAgICAgaWYgKHRoaXMub3V0cHV0WzJdID4gMCkge1xuICAgICAgICAgICAgICB0aGlzLlRleHR1cmVDb25zdHJ1Y3RvciA9IEdMVGV4dHVyZUFycmF5MkZsb2F0M0Q7XG4gICAgICAgICAgICAgIHRoaXMuZm9ybWF0VmFsdWVzID0gdXRpbHMuZXJlY3QzREFycmF5MjtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMub3V0cHV0WzFdID4gMCkge1xuICAgICAgICAgICAgICB0aGlzLlRleHR1cmVDb25zdHJ1Y3RvciA9IEdMVGV4dHVyZUFycmF5MkZsb2F0MkQ7XG4gICAgICAgICAgICAgIHRoaXMuZm9ybWF0VmFsdWVzID0gdXRpbHMuZXJlY3QyREFycmF5MjtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLlRleHR1cmVDb25zdHJ1Y3RvciA9IEdMVGV4dHVyZUFycmF5MkZsb2F0O1xuICAgICAgICAgICAgICB0aGlzLmZvcm1hdFZhbHVlcyA9IHV0aWxzLmVyZWN0QXJyYXkyO1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAnQXJyYXkoMyknOiB7XG4gICAgICAgICAgICBpZiAodGhpcy5vdXRwdXRbMl0gPiAwKSB7XG4gICAgICAgICAgICAgIHRoaXMuVGV4dHVyZUNvbnN0cnVjdG9yID0gR0xUZXh0dXJlQXJyYXkzRmxvYXQzRDtcbiAgICAgICAgICAgICAgdGhpcy5mb3JtYXRWYWx1ZXMgPSB1dGlscy5lcmVjdDNEQXJyYXkzO1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5vdXRwdXRbMV0gPiAwKSB7XG4gICAgICAgICAgICAgIHRoaXMuVGV4dHVyZUNvbnN0cnVjdG9yID0gR0xUZXh0dXJlQXJyYXkzRmxvYXQyRDtcbiAgICAgICAgICAgICAgdGhpcy5mb3JtYXRWYWx1ZXMgPSB1dGlscy5lcmVjdDJEQXJyYXkzO1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuVGV4dHVyZUNvbnN0cnVjdG9yID0gR0xUZXh0dXJlQXJyYXkzRmxvYXQ7XG4gICAgICAgICAgICAgIHRoaXMuZm9ybWF0VmFsdWVzID0gdXRpbHMuZXJlY3RBcnJheTM7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlICdBcnJheSg0KSc6IHtcbiAgICAgICAgICAgIGlmICh0aGlzLm91dHB1dFsyXSA+IDApIHtcbiAgICAgICAgICAgICAgdGhpcy5UZXh0dXJlQ29uc3RydWN0b3IgPSBHTFRleHR1cmVBcnJheTRGbG9hdDNEO1xuICAgICAgICAgICAgICB0aGlzLmZvcm1hdFZhbHVlcyA9IHV0aWxzLmVyZWN0M0RBcnJheTQ7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLm91dHB1dFsxXSA+IDApIHtcbiAgICAgICAgICAgICAgdGhpcy5UZXh0dXJlQ29uc3RydWN0b3IgPSBHTFRleHR1cmVBcnJheTRGbG9hdDJEO1xuICAgICAgICAgICAgICB0aGlzLmZvcm1hdFZhbHVlcyA9IHV0aWxzLmVyZWN0MkRBcnJheTQ7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5UZXh0dXJlQ29uc3RydWN0b3IgPSBHTFRleHR1cmVBcnJheTRGbG9hdDtcbiAgICAgICAgICAgICAgdGhpcy5mb3JtYXRWYWx1ZXMgPSB1dGlscy5lcmVjdEFycmF5NDtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgdW5oYW5kbGVkIHByZWNpc2lvbiBvZiBcIiR7dGhpcy5wcmVjaXNpb259XCJgKTtcbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgRXJyb3IoYHVuaGFuZGxlZCByZXR1cm4gdHlwZSBcIiR7dGhpcy5yZXR1cm5UeXBlfVwiYCk7XG4gIH1cblxuICBnZXRLZXJuZWxTdHJpbmcoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBhYnN0cmFjdCBtZXRob2QgY2FsbGApO1xuICB9XG5cbiAgZ2V0TWFpblJlc3VsdFRleHR1cmUoKSB7XG4gICAgc3dpdGNoICh0aGlzLnJldHVyblR5cGUpIHtcbiAgICAgIGNhc2UgJ0xpdGVyYWxJbnRlZ2VyJzpcbiAgICAgIGNhc2UgJ0Zsb2F0JzpcbiAgICAgIGNhc2UgJ0ludGVnZXInOlxuICAgICAgY2FzZSAnTnVtYmVyJzpcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TWFpblJlc3VsdE51bWJlclRleHR1cmUoKTtcbiAgICAgIGNhc2UgJ0FycmF5KDIpJzpcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TWFpblJlc3VsdEFycmF5MlRleHR1cmUoKTtcbiAgICAgIGNhc2UgJ0FycmF5KDMpJzpcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TWFpblJlc3VsdEFycmF5M1RleHR1cmUoKTtcbiAgICAgIGNhc2UgJ0FycmF5KDQpJzpcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TWFpblJlc3VsdEFycmF5NFRleHR1cmUoKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgdW5oYW5kbGVkIHJldHVyblR5cGUgdHlwZSAkeyB0aGlzLnJldHVyblR5cGUgfWApO1xuICAgIH1cbiAgfVxuXG4gIGdldE1haW5SZXN1bHRLZXJuZWxOdW1iZXJUZXh0dXJlKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgYWJzdHJhY3QgbWV0aG9kIGNhbGxgKTtcbiAgfVxuICBnZXRNYWluUmVzdWx0U3ViS2VybmVsTnVtYmVyVGV4dHVyZSgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGFic3RyYWN0IG1ldGhvZCBjYWxsYCk7XG4gIH1cbiAgZ2V0TWFpblJlc3VsdEtlcm5lbEFycmF5MlRleHR1cmUoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBhYnN0cmFjdCBtZXRob2QgY2FsbGApO1xuICB9XG4gIGdldE1haW5SZXN1bHRTdWJLZXJuZWxBcnJheTJUZXh0dXJlKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgYWJzdHJhY3QgbWV0aG9kIGNhbGxgKTtcbiAgfVxuICBnZXRNYWluUmVzdWx0S2VybmVsQXJyYXkzVGV4dHVyZSgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGFic3RyYWN0IG1ldGhvZCBjYWxsYCk7XG4gIH1cbiAgZ2V0TWFpblJlc3VsdFN1Yktlcm5lbEFycmF5M1RleHR1cmUoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBhYnN0cmFjdCBtZXRob2QgY2FsbGApO1xuICB9XG4gIGdldE1haW5SZXN1bHRLZXJuZWxBcnJheTRUZXh0dXJlKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgYWJzdHJhY3QgbWV0aG9kIGNhbGxgKTtcbiAgfVxuICBnZXRNYWluUmVzdWx0U3ViS2VybmVsQXJyYXk0VGV4dHVyZSgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGFic3RyYWN0IG1ldGhvZCBjYWxsYCk7XG4gIH1cbiAgZ2V0TWFpblJlc3VsdEdyYXBoaWNhbCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGFic3RyYWN0IG1ldGhvZCBjYWxsYCk7XG4gIH1cbiAgZ2V0TWFpblJlc3VsdE1lbW9yeU9wdGltaXplZEZsb2F0cygpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGFic3RyYWN0IG1ldGhvZCBjYWxsYCk7XG4gIH1cbiAgZ2V0TWFpblJlc3VsdFBhY2tlZFBpeGVscygpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGFic3RyYWN0IG1ldGhvZCBjYWxsYCk7XG4gIH1cblxuICBnZXRNYWluUmVzdWx0U3RyaW5nKCkge1xuICAgIGlmICh0aGlzLmdyYXBoaWNhbCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0TWFpblJlc3VsdEdyYXBoaWNhbCgpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5wcmVjaXNpb24gPT09ICdzaW5nbGUnKSB7XG4gICAgICBpZiAodGhpcy5vcHRpbWl6ZUZsb2F0TWVtb3J5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldE1haW5SZXN1bHRNZW1vcnlPcHRpbWl6ZWRGbG9hdHMoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmdldE1haW5SZXN1bHRUZXh0dXJlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmdldE1haW5SZXN1bHRQYWNrZWRQaXhlbHMoKTtcbiAgICB9XG4gIH1cblxuICBnZXRNYWluUmVzdWx0TnVtYmVyVGV4dHVyZSgpIHtcbiAgICByZXR1cm4gdXRpbHMubGluZXNUb1N0cmluZyh0aGlzLmdldE1haW5SZXN1bHRLZXJuZWxOdW1iZXJUZXh0dXJlKCkpICtcbiAgICAgIHV0aWxzLmxpbmVzVG9TdHJpbmcodGhpcy5nZXRNYWluUmVzdWx0U3ViS2VybmVsTnVtYmVyVGV4dHVyZSgpKTtcbiAgfVxuXG4gIGdldE1haW5SZXN1bHRBcnJheTJUZXh0dXJlKCkge1xuICAgIHJldHVybiB1dGlscy5saW5lc1RvU3RyaW5nKHRoaXMuZ2V0TWFpblJlc3VsdEtlcm5lbEFycmF5MlRleHR1cmUoKSkgK1xuICAgICAgdXRpbHMubGluZXNUb1N0cmluZyh0aGlzLmdldE1haW5SZXN1bHRTdWJLZXJuZWxBcnJheTJUZXh0dXJlKCkpO1xuICB9XG5cbiAgZ2V0TWFpblJlc3VsdEFycmF5M1RleHR1cmUoKSB7XG4gICAgcmV0dXJuIHV0aWxzLmxpbmVzVG9TdHJpbmcodGhpcy5nZXRNYWluUmVzdWx0S2VybmVsQXJyYXkzVGV4dHVyZSgpKSArXG4gICAgICB1dGlscy5saW5lc1RvU3RyaW5nKHRoaXMuZ2V0TWFpblJlc3VsdFN1Yktlcm5lbEFycmF5M1RleHR1cmUoKSk7XG4gIH1cblxuICBnZXRNYWluUmVzdWx0QXJyYXk0VGV4dHVyZSgpIHtcbiAgICByZXR1cm4gdXRpbHMubGluZXNUb1N0cmluZyh0aGlzLmdldE1haW5SZXN1bHRLZXJuZWxBcnJheTRUZXh0dXJlKCkpICtcbiAgICAgIHV0aWxzLmxpbmVzVG9TdHJpbmcodGhpcy5nZXRNYWluUmVzdWx0U3ViS2VybmVsQXJyYXk0VGV4dHVyZSgpKTtcbiAgfVxuXG4gIGdldEZsb2F0VGFjdGljRGVjbGFyYXRpb24oKSB7XG4gICAgY29uc3QgdmFyaWFibGVQcmVjaXNpb24gPSB0aGlzLmdldFZhcmlhYmxlUHJlY2lzaW9uU3RyaW5nKHRoaXMudGV4U2l6ZSwgdGhpcy50YWN0aWMpO1xuICAgIHJldHVybiBgcHJlY2lzaW9uICR7dmFyaWFibGVQcmVjaXNpb259IGZsb2F0O1xcbmA7XG4gIH1cblxuICBnZXRJbnRUYWN0aWNEZWNsYXJhdGlvbigpIHtcbiAgICByZXR1cm4gYHByZWNpc2lvbiAke3RoaXMuZ2V0VmFyaWFibGVQcmVjaXNpb25TdHJpbmcodGhpcy50ZXhTaXplLCB0aGlzLnRhY3RpYywgdHJ1ZSl9IGludDtcXG5gO1xuICB9XG5cbiAgZ2V0U2FtcGxlcjJEVGFjdGljRGVjbGFyYXRpb24oKSB7XG4gICAgcmV0dXJuIGBwcmVjaXNpb24gJHt0aGlzLmdldFZhcmlhYmxlUHJlY2lzaW9uU3RyaW5nKHRoaXMudGV4U2l6ZSwgdGhpcy50YWN0aWMpfSBzYW1wbGVyMkQ7XFxuYDtcbiAgfVxuXG4gIGdldFNhbXBsZXIyREFycmF5VGFjdGljRGVjbGFyYXRpb24oKSB7XG4gICAgcmV0dXJuIGBwcmVjaXNpb24gJHt0aGlzLmdldFZhcmlhYmxlUHJlY2lzaW9uU3RyaW5nKHRoaXMudGV4U2l6ZSwgdGhpcy50YWN0aWMpfSBzYW1wbGVyMkRBcnJheTtcXG5gO1xuICB9XG5cbiAgcmVuZGVyVGV4dHVyZSgpIHtcbiAgICByZXR1cm4gdGhpcy5pbW11dGFibGUgPyB0aGlzLnRleHR1cmUuY2xvbmUoKSA6IHRoaXMudGV4dHVyZTtcbiAgfVxuICByZWFkUGFja2VkUGl4ZWxzVG9VaW50OEFycmF5KCkge1xuICAgIGlmICh0aGlzLnByZWNpc2lvbiAhPT0gJ3Vuc2lnbmVkJykgdGhyb3cgbmV3IEVycm9yKCdSZXF1aXJlcyB0aGlzLnByZWNpc2lvbiB0byBiZSBcInVuc2lnbmVkXCInKTtcbiAgICBjb25zdCB7XG4gICAgICB0ZXhTaXplLFxuICAgICAgY29udGV4dDogZ2xcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgVWludDhBcnJheSh0ZXhTaXplWzBdICogdGV4U2l6ZVsxXSAqIDQpO1xuICAgIGdsLnJlYWRQaXhlbHMoMCwgMCwgdGV4U2l6ZVswXSwgdGV4U2l6ZVsxXSwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgcmVzdWx0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgcmVhZFBhY2tlZFBpeGVsc1RvRmxvYXQzMkFycmF5KCkge1xuICAgIHJldHVybiBuZXcgRmxvYXQzMkFycmF5KHRoaXMucmVhZFBhY2tlZFBpeGVsc1RvVWludDhBcnJheSgpLmJ1ZmZlcik7XG4gIH1cblxuICByZWFkRmxvYXRQaXhlbHNUb0Zsb2F0MzJBcnJheSgpIHtcbiAgICBpZiAodGhpcy5wcmVjaXNpb24gIT09ICdzaW5nbGUnKSB0aHJvdyBuZXcgRXJyb3IoJ1JlcXVpcmVzIHRoaXMucHJlY2lzaW9uIHRvIGJlIFwic2luZ2xlXCInKTtcbiAgICBjb25zdCB7XG4gICAgICB0ZXhTaXplLFxuICAgICAgY29udGV4dDogZ2xcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCB3ID0gdGV4U2l6ZVswXTtcbiAgICBjb25zdCBoID0gdGV4U2l6ZVsxXTtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgRmxvYXQzMkFycmF5KHcgKiBoICogNCk7XG4gICAgZ2wucmVhZFBpeGVscygwLCAwLCB3LCBoLCBnbC5SR0JBLCBnbC5GTE9BVCwgcmVzdWx0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZ2V0UGl4ZWxzKGZsaXApIHtcbiAgICBjb25zdCB7XG4gICAgICBjb250ZXh0OiBnbCxcbiAgICAgIG91dHB1dFxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IFt3aWR0aCwgaGVpZ2h0XSA9IG91dHB1dDtcbiAgICBjb25zdCBwaXhlbHMgPSBuZXcgVWludDhBcnJheSh3aWR0aCAqIGhlaWdodCAqIDQpO1xuICAgIGdsLnJlYWRQaXhlbHMoMCwgMCwgd2lkdGgsIGhlaWdodCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgcGl4ZWxzKTtcbiAgICByZXR1cm4gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KChmbGlwID8gcGl4ZWxzIDogdXRpbHMuZmxpcFBpeGVscyhwaXhlbHMsIHdpZHRoLCBoZWlnaHQpKS5idWZmZXIpO1xuICB9XG5cbiAgcmVuZGVyS2VybmVsc1RvQXJyYXlzKCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgIHJlc3VsdDogdGhpcy5yZW5kZXJPdXRwdXQoKSxcbiAgICB9O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zdWJLZXJuZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICByZXN1bHRbdGhpcy5zdWJLZXJuZWxzW2ldLnByb3BlcnR5XSA9IHRoaXMubWFwcGVkVGV4dHVyZXNbaV0udG9BcnJheSgpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgcmVuZGVyS2VybmVsc1RvVGV4dHVyZXMoKSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgcmVzdWx0OiB0aGlzLnJlbmRlck91dHB1dCgpLFxuICAgIH07XG4gICAgaWYgKHRoaXMuaW1tdXRhYmxlKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc3ViS2VybmVscy5sZW5ndGg7IGkrKykge1xuICAgICAgICByZXN1bHRbdGhpcy5zdWJLZXJuZWxzW2ldLnByb3BlcnR5XSA9IHRoaXMubWFwcGVkVGV4dHVyZXNbaV0uY2xvbmUoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnN1Yktlcm5lbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzdWx0W3RoaXMuc3ViS2VybmVsc1tpXS5wcm9wZXJ0eV0gPSB0aGlzLm1hcHBlZFRleHR1cmVzW2ldO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgcmVzZXRTd2l0Y2hpbmdLZXJuZWxzKCkge1xuICAgIGNvbnN0IGV4aXN0aW5nVmFsdWUgPSB0aGlzLnN3aXRjaGluZ0tlcm5lbHM7XG4gICAgdGhpcy5zd2l0Y2hpbmdLZXJuZWxzID0gbnVsbDtcbiAgICByZXR1cm4gZXhpc3RpbmdWYWx1ZTtcbiAgfVxuXG4gIHNldE91dHB1dChvdXRwdXQpIHtcbiAgICBjb25zdCBuZXdPdXRwdXQgPSB0aGlzLnRvS2VybmVsT3V0cHV0KG91dHB1dCk7XG4gICAgaWYgKHRoaXMucHJvZ3JhbSkge1xuICAgICAgaWYgKCF0aGlzLmR5bmFtaWNPdXRwdXQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZXNpemluZyBhIGtlcm5lbCB3aXRoIGR5bmFtaWNPdXRwdXQ6IGZhbHNlIGlzIG5vdCBwb3NzaWJsZScpO1xuICAgICAgfVxuICAgICAgY29uc3QgbmV3VGhyZWFkRGltID0gW25ld091dHB1dFswXSwgbmV3T3V0cHV0WzFdIHx8IDEsIG5ld091dHB1dFsyXSB8fCAxXTtcbiAgICAgIGNvbnN0IG5ld1RleFNpemUgPSB1dGlscy5nZXRLZXJuZWxUZXh0dXJlU2l6ZSh7XG4gICAgICAgIG9wdGltaXplRmxvYXRNZW1vcnk6IHRoaXMub3B0aW1pemVGbG9hdE1lbW9yeSxcbiAgICAgICAgcHJlY2lzaW9uOiB0aGlzLnByZWNpc2lvbixcbiAgICAgIH0sIG5ld1RocmVhZERpbSk7XG4gICAgICBjb25zdCBvbGRUZXhTaXplID0gdGhpcy50ZXhTaXplO1xuICAgICAgaWYgKG9sZFRleFNpemUpIHtcbiAgICAgICAgY29uc3Qgb2xkUHJlY2lzaW9uID0gdGhpcy5nZXRWYXJpYWJsZVByZWNpc2lvblN0cmluZyhvbGRUZXhTaXplLCB0aGlzLnRhY3RpYyk7XG4gICAgICAgIGNvbnN0IG5ld1ByZWNpc2lvbiA9IHRoaXMuZ2V0VmFyaWFibGVQcmVjaXNpb25TdHJpbmcobmV3VGV4U2l6ZSwgdGhpcy50YWN0aWMpO1xuICAgICAgICBpZiAob2xkUHJlY2lzaW9uICE9PSBuZXdQcmVjaXNpb24pIHtcbiAgICAgICAgICBpZiAodGhpcy5kZWJ1Zykge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdQcmVjaXNpb24gcmVxdWlyZW1lbnQgY2hhbmdlZCwgYXNraW5nIEdQVSBpbnN0YW5jZSB0byByZWNvbXBpbGUnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5zd2l0Y2hLZXJuZWxzKHtcbiAgICAgICAgICAgIHR5cGU6ICdvdXRwdXRQcmVjaXNpb25NaXNtYXRjaCcsXG4gICAgICAgICAgICBwcmVjaXNpb246IG5ld1ByZWNpc2lvbixcbiAgICAgICAgICAgIG5lZWRlZDogb3V0cHV0XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLm91dHB1dCA9IG5ld091dHB1dDtcbiAgICAgIHRoaXMudGhyZWFkRGltID0gbmV3VGhyZWFkRGltO1xuICAgICAgdGhpcy50ZXhTaXplID0gbmV3VGV4U2l6ZTtcbiAgICAgIGNvbnN0IHsgY29udGV4dDogZ2wgfSA9IHRoaXM7XG4gICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIHRoaXMuZnJhbWVidWZmZXIpO1xuICAgICAgdGhpcy51cGRhdGVNYXhUZXhTaXplKCk7XG4gICAgICB0aGlzLmZyYW1lYnVmZmVyLndpZHRoID0gdGhpcy50ZXhTaXplWzBdO1xuICAgICAgdGhpcy5mcmFtZWJ1ZmZlci5oZWlnaHQgPSB0aGlzLnRleFNpemVbMV07XG4gICAgICBnbC52aWV3cG9ydCgwLCAwLCB0aGlzLm1heFRleFNpemVbMF0sIHRoaXMubWF4VGV4U2l6ZVsxXSk7XG4gICAgICB0aGlzLmNhbnZhcy53aWR0aCA9IHRoaXMubWF4VGV4U2l6ZVswXTtcbiAgICAgIHRoaXMuY2FudmFzLmhlaWdodCA9IHRoaXMubWF4VGV4U2l6ZVsxXTtcbiAgICAgIGlmICh0aGlzLnRleHR1cmUpIHtcbiAgICAgICAgdGhpcy50ZXh0dXJlLmRlbGV0ZSgpO1xuICAgICAgfVxuICAgICAgdGhpcy50ZXh0dXJlID0gbnVsbDtcbiAgICAgIHRoaXMuX3NldHVwT3V0cHV0VGV4dHVyZSgpO1xuICAgICAgaWYgKHRoaXMubWFwcGVkVGV4dHVyZXMgJiYgdGhpcy5tYXBwZWRUZXh0dXJlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5tYXBwZWRUZXh0dXJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHRoaXMubWFwcGVkVGV4dHVyZXNbaV0uZGVsZXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tYXBwZWRUZXh0dXJlcyA9IG51bGw7XG4gICAgICAgIHRoaXMuX3NldHVwU3ViT3V0cHV0VGV4dHVyZXMoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5vdXRwdXQgPSBuZXdPdXRwdXQ7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJlbmRlclZhbHVlcygpIHtcbiAgICByZXR1cm4gdGhpcy5mb3JtYXRWYWx1ZXMoXG4gICAgICB0aGlzLnRyYW5zZmVyVmFsdWVzKCksXG4gICAgICB0aGlzLm91dHB1dFswXSxcbiAgICAgIHRoaXMub3V0cHV0WzFdLFxuICAgICAgdGhpcy5vdXRwdXRbMl1cbiAgICApO1xuICB9XG4gIHN3aXRjaEtlcm5lbHMocmVhc29uKSB7XG4gICAgaWYgKHRoaXMuc3dpdGNoaW5nS2VybmVscykge1xuICAgICAgdGhpcy5zd2l0Y2hpbmdLZXJuZWxzLnB1c2gocmVhc29uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zd2l0Y2hpbmdLZXJuZWxzID0gW3JlYXNvbl07XG4gICAgfVxuICB9XG4gIGdldFZhcmlhYmxlUHJlY2lzaW9uU3RyaW5nKHRleHR1cmVTaXplID0gdGhpcy50ZXhTaXplLCB0YWN0aWMgPSB0aGlzLnRhY3RpYywgaXNJbnQgPSBmYWxzZSkge1xuICAgIGlmICghdGFjdGljKSB7XG4gICAgICBpZiAoIXRoaXMuY29uc3RydWN0b3IuZmVhdHVyZXMuaXNTcGVlZFRhY3RpY1N1cHBvcnRlZCkgcmV0dXJuICdoaWdocCc7XG4gICAgICBjb25zdCBsb3cgPSB0aGlzLmNvbnN0cnVjdG9yLmZlYXR1cmVzW2lzSW50ID8gJ2xvd0ludFByZWNpc2lvbicgOiAnbG93RmxvYXRQcmVjaXNpb24nXTtcbiAgICAgIGNvbnN0IG1lZGl1bSA9IHRoaXMuY29uc3RydWN0b3IuZmVhdHVyZXNbaXNJbnQgPyAnbWVkaXVtSW50UHJlY2lzaW9uJyA6ICdtZWRpdW1GbG9hdFByZWNpc2lvbiddO1xuICAgICAgY29uc3QgaGlnaCA9IHRoaXMuY29uc3RydWN0b3IuZmVhdHVyZXNbaXNJbnQgPyAnaGlnaEludFByZWNpc2lvbicgOiAnaGlnaEZsb2F0UHJlY2lzaW9uJ107XG4gICAgICBjb25zdCByZXF1aXJlZFNpemUgPSBNYXRoLmxvZzIodGV4dHVyZVNpemVbMF0gKiB0ZXh0dXJlU2l6ZVsxXSk7XG4gICAgICBpZiAocmVxdWlyZWRTaXplIDw9IGxvdy5yYW5nZU1heCkge1xuICAgICAgICByZXR1cm4gJ2xvd3AnO1xuICAgICAgfSBlbHNlIGlmIChyZXF1aXJlZFNpemUgPD0gbWVkaXVtLnJhbmdlTWF4KSB7XG4gICAgICAgIHJldHVybiAnbWVkaXVtcCc7XG4gICAgICB9IGVsc2UgaWYgKHJlcXVpcmVkU2l6ZSA8PSBoaWdoLnJhbmdlTWF4KSB7XG4gICAgICAgIHJldHVybiAnaGlnaHAnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgcmVxdWlyZWQgc2l6ZSBleGNlZWRzIHRoYXQgb2YgdGhlIGFiaWxpdHkgb2YgeW91ciBzeXN0ZW1gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgc3dpdGNoICh0YWN0aWMpIHtcbiAgICAgIGNhc2UgJ3NwZWVkJzpcbiAgICAgICAgcmV0dXJuICdsb3dwJztcbiAgICAgIGNhc2UgJ2JhbGFuY2VkJzpcbiAgICAgICAgcmV0dXJuICdtZWRpdW1wJztcbiAgICAgIGNhc2UgJ3ByZWNpc2lvbic6XG4gICAgICAgIHJldHVybiAnaGlnaHAnO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIHRhY3RpYyBcIiR7dGFjdGljfVwiIHVzZSBcInNwZWVkXCIsIFwiYmFsYW5jZWRcIiwgXCJwcmVjaXNpb25cIiwgb3IgZW1wdHkgZm9yIGF1dG9gKTtcbiAgICB9XG4gIH1cblxuICB1cGRhdGVUZXh0dXJlQXJndW1lbnRSZWZzKGtlcm5lbFZhbHVlLCBhcmcpIHtcbiAgICBpZiAoIXRoaXMuaW1tdXRhYmxlKSByZXR1cm47XG4gICAgaWYgKHRoaXMudGV4dHVyZS50ZXh0dXJlID09PSBhcmcudGV4dHVyZSkge1xuICAgICAgY29uc3QgeyBwcmV2QXJnIH0gPSBrZXJuZWxWYWx1ZTtcbiAgICAgIGlmIChwcmV2QXJnKSB7XG4gICAgICAgIGlmIChwcmV2QXJnLnRleHR1cmUuX3JlZnMgPT09IDEpIHtcbiAgICAgICAgICB0aGlzLnRleHR1cmUuZGVsZXRlKCk7XG4gICAgICAgICAgdGhpcy50ZXh0dXJlID0gcHJldkFyZy5jbG9uZSgpO1xuICAgICAgICAgIHRoaXMuX3RleHR1cmVTd2l0Y2hlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcHJldkFyZy5kZWxldGUoKTtcbiAgICAgIH1cbiAgICAgIGtlcm5lbFZhbHVlLnByZXZBcmcgPSBhcmcuY2xvbmUoKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMubWFwcGVkVGV4dHVyZXMgJiYgdGhpcy5tYXBwZWRUZXh0dXJlcy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCB7IG1hcHBlZFRleHR1cmVzIH0gPSB0aGlzO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXBwZWRUZXh0dXJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBtYXBwZWRUZXh0dXJlID0gbWFwcGVkVGV4dHVyZXNbaV07XG4gICAgICAgIGlmIChtYXBwZWRUZXh0dXJlLnRleHR1cmUgPT09IGFyZy50ZXh0dXJlKSB7XG4gICAgICAgICAgY29uc3QgeyBwcmV2QXJnIH0gPSBrZXJuZWxWYWx1ZTtcbiAgICAgICAgICBpZiAocHJldkFyZykge1xuICAgICAgICAgICAgaWYgKHByZXZBcmcudGV4dHVyZS5fcmVmcyA9PT0gMSkge1xuICAgICAgICAgICAgICBtYXBwZWRUZXh0dXJlLmRlbGV0ZSgpO1xuICAgICAgICAgICAgICBtYXBwZWRUZXh0dXJlc1tpXSA9IHByZXZBcmcuY2xvbmUoKTtcbiAgICAgICAgICAgICAgdGhpcy5fbWFwcGVkVGV4dHVyZVN3aXRjaGVkW2ldID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByZXZBcmcuZGVsZXRlKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGtlcm5lbFZhbHVlLnByZXZBcmcgPSBhcmcuY2xvbmUoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBvbkFjdGl2YXRlKHByZXZpb3VzS2VybmVsKSB7XG4gICAgdGhpcy5fdGV4dHVyZVN3aXRjaGVkID0gdHJ1ZTtcbiAgICB0aGlzLnRleHR1cmUgPSBwcmV2aW91c0tlcm5lbC50ZXh0dXJlO1xuICAgIGlmICh0aGlzLm1hcHBlZFRleHR1cmVzKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubWFwcGVkVGV4dHVyZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5fbWFwcGVkVGV4dHVyZVN3aXRjaGVkW2ldID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHRoaXMubWFwcGVkVGV4dHVyZXMgPSBwcmV2aW91c0tlcm5lbC5tYXBwZWRUZXh0dXJlcztcbiAgICB9XG4gIH1cblxuICBpbml0Q2FudmFzKCkge31cbn1cblxuY29uc3QgdHlwZU1hcCA9IHtcbiAgaW50OiAnSW50ZWdlcicsXG4gIGZsb2F0OiAnTnVtYmVyJyxcbiAgdmVjMjogJ0FycmF5KDIpJyxcbiAgdmVjMzogJ0FycmF5KDMpJyxcbiAgdmVjNDogJ0FycmF5KDQpJyxcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBHTEtlcm5lbFxufTtcbn0se1wiLi4vLi4vdXRpbHNcIjoxMTQsXCIuLi9rZXJuZWxcIjozNixcIi4vdGV4dHVyZS9hcnJheS0yLWZsb2F0XCI6MTYsXCIuL3RleHR1cmUvYXJyYXktMi1mbG9hdC0yZFwiOjE0LFwiLi90ZXh0dXJlL2FycmF5LTItZmxvYXQtM2RcIjoxNSxcIi4vdGV4dHVyZS9hcnJheS0zLWZsb2F0XCI6MTksXCIuL3RleHR1cmUvYXJyYXktMy1mbG9hdC0yZFwiOjE3LFwiLi90ZXh0dXJlL2FycmF5LTMtZmxvYXQtM2RcIjoxOCxcIi4vdGV4dHVyZS9hcnJheS00LWZsb2F0XCI6MjIsXCIuL3RleHR1cmUvYXJyYXktNC1mbG9hdC0yZFwiOjIwLFwiLi90ZXh0dXJlL2FycmF5LTQtZmxvYXQtM2RcIjoyMSxcIi4vdGV4dHVyZS9mbG9hdFwiOjI1LFwiLi90ZXh0dXJlL2Zsb2F0LTJkXCI6MjMsXCIuL3RleHR1cmUvZmxvYXQtM2RcIjoyNCxcIi4vdGV4dHVyZS9ncmFwaGljYWxcIjoyNixcIi4vdGV4dHVyZS9tZW1vcnktb3B0aW1pemVkXCI6MzAsXCIuL3RleHR1cmUvbWVtb3J5LW9wdGltaXplZC0yZFwiOjI4LFwiLi90ZXh0dXJlL21lbW9yeS1vcHRpbWl6ZWQtM2RcIjoyOSxcIi4vdGV4dHVyZS91bnNpZ25lZFwiOjMzLFwiLi90ZXh0dXJlL3Vuc2lnbmVkLTJkXCI6MzEsXCIuL3RleHR1cmUvdW5zaWduZWQtM2RcIjozMn1dLDE0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzJyk7XG5jb25zdCB7IEdMVGV4dHVyZUZsb2F0IH0gPSByZXF1aXJlKCcuL2Zsb2F0Jyk7XG5cbmNsYXNzIEdMVGV4dHVyZUFycmF5MkZsb2F0MkQgZXh0ZW5kcyBHTFRleHR1cmVGbG9hdCB7XG4gIGNvbnN0cnVjdG9yKHNldHRpbmdzKSB7XG4gICAgc3VwZXIoc2V0dGluZ3MpO1xuICAgIHRoaXMudHlwZSA9ICdBcnJheVRleHR1cmUoMiknO1xuICB9XG4gIHRvQXJyYXkoKSB7XG4gICAgcmV0dXJuIHV0aWxzLmVyZWN0MkRBcnJheTIodGhpcy5yZW5kZXJWYWx1ZXMoKSwgdGhpcy5vdXRwdXRbMF0sIHRoaXMub3V0cHV0WzFdKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgR0xUZXh0dXJlQXJyYXkyRmxvYXQyRFxufTtcbn0se1wiLi4vLi4vLi4vdXRpbHNcIjoxMTQsXCIuL2Zsb2F0XCI6MjV9XSwxNTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xuY29uc3QgeyBHTFRleHR1cmVGbG9hdCB9ID0gcmVxdWlyZSgnLi9mbG9hdCcpO1xuXG5jbGFzcyBHTFRleHR1cmVBcnJheTJGbG9hdDNEIGV4dGVuZHMgR0xUZXh0dXJlRmxvYXQge1xuICBjb25zdHJ1Y3RvcihzZXR0aW5ncykge1xuICAgIHN1cGVyKHNldHRpbmdzKTtcbiAgICB0aGlzLnR5cGUgPSAnQXJyYXlUZXh0dXJlKDIpJztcbiAgfVxuICB0b0FycmF5KCkge1xuICAgIHJldHVybiB1dGlscy5lcmVjdDNEQXJyYXkyKHRoaXMucmVuZGVyVmFsdWVzKCksIHRoaXMub3V0cHV0WzBdLCB0aGlzLm91dHB1dFsxXSwgdGhpcy5vdXRwdXRbMl0pO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBHTFRleHR1cmVBcnJheTJGbG9hdDNEXG59O1xufSx7XCIuLi8uLi8uLi91dGlsc1wiOjExNCxcIi4vZmxvYXRcIjoyNX1dLDE2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzJyk7XG5jb25zdCB7IEdMVGV4dHVyZUZsb2F0IH0gPSByZXF1aXJlKCcuL2Zsb2F0Jyk7XG5cbmNsYXNzIEdMVGV4dHVyZUFycmF5MkZsb2F0IGV4dGVuZHMgR0xUZXh0dXJlRmxvYXQge1xuICBjb25zdHJ1Y3RvcihzZXR0aW5ncykge1xuICAgIHN1cGVyKHNldHRpbmdzKTtcbiAgICB0aGlzLnR5cGUgPSAnQXJyYXlUZXh0dXJlKDIpJztcbiAgfVxuICB0b0FycmF5KCkge1xuICAgIHJldHVybiB1dGlscy5lcmVjdEFycmF5Mih0aGlzLnJlbmRlclZhbHVlcygpLCB0aGlzLm91dHB1dFswXSwgdGhpcy5vdXRwdXRbMV0pO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBHTFRleHR1cmVBcnJheTJGbG9hdFxufTtcbn0se1wiLi4vLi4vLi4vdXRpbHNcIjoxMTQsXCIuL2Zsb2F0XCI6MjV9XSwxNzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xuY29uc3QgeyBHTFRleHR1cmVGbG9hdCB9ID0gcmVxdWlyZSgnLi9mbG9hdCcpO1xuXG5jbGFzcyBHTFRleHR1cmVBcnJheTNGbG9hdDJEIGV4dGVuZHMgR0xUZXh0dXJlRmxvYXQge1xuICBjb25zdHJ1Y3RvcihzZXR0aW5ncykge1xuICAgIHN1cGVyKHNldHRpbmdzKTtcbiAgICB0aGlzLnR5cGUgPSAnQXJyYXlUZXh0dXJlKDMpJztcbiAgfVxuICB0b0FycmF5KCkge1xuICAgIHJldHVybiB1dGlscy5lcmVjdDJEQXJyYXkzKHRoaXMucmVuZGVyVmFsdWVzKCksIHRoaXMub3V0cHV0WzBdLCB0aGlzLm91dHB1dFsxXSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEdMVGV4dHVyZUFycmF5M0Zsb2F0MkRcbn07XG59LHtcIi4uLy4uLy4uL3V0aWxzXCI6MTE0LFwiLi9mbG9hdFwiOjI1fV0sMTg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHsgR0xUZXh0dXJlRmxvYXQgfSA9IHJlcXVpcmUoJy4vZmxvYXQnKTtcblxuY2xhc3MgR0xUZXh0dXJlQXJyYXkzRmxvYXQzRCBleHRlbmRzIEdMVGV4dHVyZUZsb2F0IHtcbiAgY29uc3RydWN0b3Ioc2V0dGluZ3MpIHtcbiAgICBzdXBlcihzZXR0aW5ncyk7XG4gICAgdGhpcy50eXBlID0gJ0FycmF5VGV4dHVyZSgzKSc7XG4gIH1cbiAgdG9BcnJheSgpIHtcbiAgICByZXR1cm4gdXRpbHMuZXJlY3QzREFycmF5Myh0aGlzLnJlbmRlclZhbHVlcygpLCB0aGlzLm91dHB1dFswXSwgdGhpcy5vdXRwdXRbMV0sIHRoaXMub3V0cHV0WzJdKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgR0xUZXh0dXJlQXJyYXkzRmxvYXQzRFxufTtcbn0se1wiLi4vLi4vLi4vdXRpbHNcIjoxMTQsXCIuL2Zsb2F0XCI6MjV9XSwxOTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xuY29uc3QgeyBHTFRleHR1cmVGbG9hdCB9ID0gcmVxdWlyZSgnLi9mbG9hdCcpO1xuXG5jbGFzcyBHTFRleHR1cmVBcnJheTNGbG9hdCBleHRlbmRzIEdMVGV4dHVyZUZsb2F0IHtcbiAgY29uc3RydWN0b3Ioc2V0dGluZ3MpIHtcbiAgICBzdXBlcihzZXR0aW5ncyk7XG4gICAgdGhpcy50eXBlID0gJ0FycmF5VGV4dHVyZSgzKSc7XG4gIH1cbiAgdG9BcnJheSgpIHtcbiAgICByZXR1cm4gdXRpbHMuZXJlY3RBcnJheTModGhpcy5yZW5kZXJWYWx1ZXMoKSwgdGhpcy5vdXRwdXRbMF0pO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBHTFRleHR1cmVBcnJheTNGbG9hdFxufTtcbn0se1wiLi4vLi4vLi4vdXRpbHNcIjoxMTQsXCIuL2Zsb2F0XCI6MjV9XSwyMDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xuY29uc3QgeyBHTFRleHR1cmVGbG9hdCB9ID0gcmVxdWlyZSgnLi9mbG9hdCcpO1xuXG5jbGFzcyBHTFRleHR1cmVBcnJheTRGbG9hdDJEIGV4dGVuZHMgR0xUZXh0dXJlRmxvYXQge1xuICBjb25zdHJ1Y3RvcihzZXR0aW5ncykge1xuICAgIHN1cGVyKHNldHRpbmdzKTtcbiAgICB0aGlzLnR5cGUgPSAnQXJyYXlUZXh0dXJlKDQpJztcbiAgfVxuICB0b0FycmF5KCkge1xuICAgIHJldHVybiB1dGlscy5lcmVjdDJEQXJyYXk0KHRoaXMucmVuZGVyVmFsdWVzKCksIHRoaXMub3V0cHV0WzBdLCB0aGlzLm91dHB1dFsxXSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEdMVGV4dHVyZUFycmF5NEZsb2F0MkRcbn07XG59LHtcIi4uLy4uLy4uL3V0aWxzXCI6MTE0LFwiLi9mbG9hdFwiOjI1fV0sMjE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHsgR0xUZXh0dXJlRmxvYXQgfSA9IHJlcXVpcmUoJy4vZmxvYXQnKTtcblxuY2xhc3MgR0xUZXh0dXJlQXJyYXk0RmxvYXQzRCBleHRlbmRzIEdMVGV4dHVyZUZsb2F0IHtcbiAgY29uc3RydWN0b3Ioc2V0dGluZ3MpIHtcbiAgICBzdXBlcihzZXR0aW5ncyk7XG4gICAgdGhpcy50eXBlID0gJ0FycmF5VGV4dHVyZSg0KSc7XG4gIH1cbiAgdG9BcnJheSgpIHtcbiAgICByZXR1cm4gdXRpbHMuZXJlY3QzREFycmF5NCh0aGlzLnJlbmRlclZhbHVlcygpLCB0aGlzLm91dHB1dFswXSwgdGhpcy5vdXRwdXRbMV0sIHRoaXMub3V0cHV0WzJdKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgR0xUZXh0dXJlQXJyYXk0RmxvYXQzRFxufTtcbn0se1wiLi4vLi4vLi4vdXRpbHNcIjoxMTQsXCIuL2Zsb2F0XCI6MjV9XSwyMjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xuY29uc3QgeyBHTFRleHR1cmVGbG9hdCB9ID0gcmVxdWlyZSgnLi9mbG9hdCcpO1xuXG5jbGFzcyBHTFRleHR1cmVBcnJheTRGbG9hdCBleHRlbmRzIEdMVGV4dHVyZUZsb2F0IHtcbiAgY29uc3RydWN0b3Ioc2V0dGluZ3MpIHtcbiAgICBzdXBlcihzZXR0aW5ncyk7XG4gICAgdGhpcy50eXBlID0gJ0FycmF5VGV4dHVyZSg0KSc7XG4gIH1cbiAgdG9BcnJheSgpIHtcbiAgICByZXR1cm4gdXRpbHMuZXJlY3RBcnJheTQodGhpcy5yZW5kZXJWYWx1ZXMoKSwgdGhpcy5vdXRwdXRbMF0pO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBHTFRleHR1cmVBcnJheTRGbG9hdFxufTtcbn0se1wiLi4vLi4vLi4vdXRpbHNcIjoxMTQsXCIuL2Zsb2F0XCI6MjV9XSwyMzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xuY29uc3QgeyBHTFRleHR1cmVGbG9hdCB9ID0gcmVxdWlyZSgnLi9mbG9hdCcpO1xuXG5jbGFzcyBHTFRleHR1cmVGbG9hdDJEIGV4dGVuZHMgR0xUZXh0dXJlRmxvYXQge1xuICBjb25zdHJ1Y3RvcihzZXR0aW5ncykge1xuICAgIHN1cGVyKHNldHRpbmdzKTtcbiAgICB0aGlzLnR5cGUgPSAnQXJyYXlUZXh0dXJlKDEpJztcbiAgfVxuICB0b0FycmF5KCkge1xuICAgIHJldHVybiB1dGlscy5lcmVjdDJERmxvYXQodGhpcy5yZW5kZXJWYWx1ZXMoKSwgdGhpcy5vdXRwdXRbMF0sIHRoaXMub3V0cHV0WzFdKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgR0xUZXh0dXJlRmxvYXQyRFxufTtcbn0se1wiLi4vLi4vLi4vdXRpbHNcIjoxMTQsXCIuL2Zsb2F0XCI6MjV9XSwyNDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xuY29uc3QgeyBHTFRleHR1cmVGbG9hdCB9ID0gcmVxdWlyZSgnLi9mbG9hdCcpO1xuXG5jbGFzcyBHTFRleHR1cmVGbG9hdDNEIGV4dGVuZHMgR0xUZXh0dXJlRmxvYXQge1xuICBjb25zdHJ1Y3RvcihzZXR0aW5ncykge1xuICAgIHN1cGVyKHNldHRpbmdzKTtcbiAgICB0aGlzLnR5cGUgPSAnQXJyYXlUZXh0dXJlKDEpJztcbiAgfVxuICB0b0FycmF5KCkge1xuICAgIHJldHVybiB1dGlscy5lcmVjdDNERmxvYXQodGhpcy5yZW5kZXJWYWx1ZXMoKSwgdGhpcy5vdXRwdXRbMF0sIHRoaXMub3V0cHV0WzFdLCB0aGlzLm91dHB1dFsyXSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEdMVGV4dHVyZUZsb2F0M0Rcbn07XG59LHtcIi4uLy4uLy4uL3V0aWxzXCI6MTE0LFwiLi9mbG9hdFwiOjI1fV0sMjU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHsgR0xUZXh0dXJlIH0gPSByZXF1aXJlKCcuL2luZGV4Jyk7XG5cbmNsYXNzIEdMVGV4dHVyZUZsb2F0IGV4dGVuZHMgR0xUZXh0dXJlIHtcbiAgZ2V0IHRleHR1cmVUeXBlKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRleHQuRkxPQVQ7XG4gIH1cbiAgY29uc3RydWN0b3Ioc2V0dGluZ3MpIHtcbiAgICBzdXBlcihzZXR0aW5ncyk7XG4gICAgdGhpcy50eXBlID0gJ0FycmF5VGV4dHVyZSgxKSc7XG4gIH1cbiAgcmVuZGVyUmF3T3V0cHV0KCkge1xuICAgIGNvbnN0IGdsID0gdGhpcy5jb250ZXh0O1xuICAgIGNvbnN0IHNpemUgPSB0aGlzLnNpemU7XG4gICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCB0aGlzLmZyYW1lYnVmZmVyKCkpO1xuICAgIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKFxuICAgICAgZ2wuRlJBTUVCVUZGRVIsXG4gICAgICBnbC5DT0xPUl9BVFRBQ0hNRU5UMCxcbiAgICAgIGdsLlRFWFRVUkVfMkQsXG4gICAgICB0aGlzLnRleHR1cmUsXG4gICAgICAwXG4gICAgKTtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgRmxvYXQzMkFycmF5KHNpemVbMF0gKiBzaXplWzFdICogNCk7XG4gICAgZ2wucmVhZFBpeGVscygwLCAwLCBzaXplWzBdLCBzaXplWzFdLCBnbC5SR0JBLCBnbC5GTE9BVCwgcmVzdWx0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIHJlbmRlclZhbHVlcygpIHtcbiAgICBpZiAodGhpcy5fZGVsZXRlZCkgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIHRoaXMucmVuZGVyUmF3T3V0cHV0KCk7XG4gIH1cbiAgdG9BcnJheSgpIHtcbiAgICByZXR1cm4gdXRpbHMuZXJlY3RGbG9hdCh0aGlzLnJlbmRlclZhbHVlcygpLCB0aGlzLm91dHB1dFswXSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEdMVGV4dHVyZUZsb2F0XG59O1xufSx7XCIuLi8uLi8uLi91dGlsc1wiOjExNCxcIi4vaW5kZXhcIjoyN31dLDI2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgR0xUZXh0dXJlVW5zaWduZWQgfSA9IHJlcXVpcmUoJy4vdW5zaWduZWQnKTtcblxuY2xhc3MgR0xUZXh0dXJlR3JhcGhpY2FsIGV4dGVuZHMgR0xUZXh0dXJlVW5zaWduZWQge1xuICBjb25zdHJ1Y3RvcihzZXR0aW5ncykge1xuICAgIHN1cGVyKHNldHRpbmdzKTtcbiAgICB0aGlzLnR5cGUgPSAnQXJyYXlUZXh0dXJlKDQpJztcbiAgfVxuICB0b0FycmF5KCkge1xuICAgIHJldHVybiB0aGlzLnJlbmRlclZhbHVlcygpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBHTFRleHR1cmVHcmFwaGljYWxcbn07XG59LHtcIi4vdW5zaWduZWRcIjozM31dLDI3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgVGV4dHVyZSB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vdGV4dHVyZScpO1xuXG5jbGFzcyBHTFRleHR1cmUgZXh0ZW5kcyBUZXh0dXJlIHtcbiAgZ2V0IHRleHR1cmVUeXBlKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgXCJ0ZXh0dXJlVHlwZVwiIG5vdCBpbXBsZW1lbnRlZCBvbiAkeyB0aGlzLm5hbWUgfWApO1xuICB9XG5cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMpO1xuICB9XG5cbiAgYmVmb3JlTXV0YXRlKCkge1xuICAgIGlmICh0aGlzLnRleHR1cmUuX3JlZnMgPiAxKSB7XG4gICAgICB0aGlzLm5ld1RleHR1cmUoKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBjbG9uZVRleHR1cmUoKSB7XG4gICAgdGhpcy50ZXh0dXJlLl9yZWZzLS07XG4gICAgY29uc3QgeyBjb250ZXh0OiBnbCwgc2l6ZSwgdGV4dHVyZSwga2VybmVsIH0gPSB0aGlzO1xuICAgIGlmIChrZXJuZWwuZGVidWcpIHtcbiAgICAgIGNvbnNvbGUud2FybignY2xvbmluZyBpbnRlcm5hbCB0ZXh0dXJlJyk7XG4gICAgfVxuICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgdGhpcy5mcmFtZWJ1ZmZlcigpKTtcbiAgICBzZWxlY3RUZXh0dXJlKGdsLCB0ZXh0dXJlKTtcbiAgICBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChnbC5GUkFNRUJVRkZFUiwgZ2wuQ09MT1JfQVRUQUNITUVOVDAsIGdsLlRFWFRVUkVfMkQsIHRleHR1cmUsIDApO1xuICAgIGNvbnN0IHRhcmdldCA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcbiAgICBzZWxlY3RUZXh0dXJlKGdsLCB0YXJnZXQpO1xuICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgdGhpcy5pbnRlcm5hbEZvcm1hdCwgc2l6ZVswXSwgc2l6ZVsxXSwgMCwgdGhpcy50ZXh0dXJlRm9ybWF0LCB0aGlzLnRleHR1cmVUeXBlLCBudWxsKTtcbiAgICBnbC5jb3B5VGV4U3ViSW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCAwLCAwLCAwLCAwLCBzaXplWzBdLCBzaXplWzFdKTtcbiAgICB0YXJnZXQuX3JlZnMgPSAxO1xuICAgIHRoaXMudGV4dHVyZSA9IHRhcmdldDtcbiAgfVxuXG4gIG5ld1RleHR1cmUoKSB7XG4gICAgdGhpcy50ZXh0dXJlLl9yZWZzLS07XG4gICAgY29uc3QgZ2wgPSB0aGlzLmNvbnRleHQ7XG4gICAgY29uc3Qgc2l6ZSA9IHRoaXMuc2l6ZTtcbiAgICBjb25zdCBrZXJuZWwgPSB0aGlzLmtlcm5lbDtcbiAgICBpZiAoa2VybmVsLmRlYnVnKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ25ldyBpbnRlcm5hbCB0ZXh0dXJlJyk7XG4gICAgfVxuICAgIGNvbnN0IHRhcmdldCA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcbiAgICBzZWxlY3RUZXh0dXJlKGdsLCB0YXJnZXQpO1xuICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgdGhpcy5pbnRlcm5hbEZvcm1hdCwgc2l6ZVswXSwgc2l6ZVsxXSwgMCwgdGhpcy50ZXh0dXJlRm9ybWF0LCB0aGlzLnRleHR1cmVUeXBlLCBudWxsKTtcbiAgICB0YXJnZXQuX3JlZnMgPSAxO1xuICAgIHRoaXMudGV4dHVyZSA9IHRhcmdldDtcbiAgfVxuXG4gIGNsZWFyKCkge1xuICAgIGlmICh0aGlzLnRleHR1cmUuX3JlZnMpIHtcbiAgICAgIHRoaXMudGV4dHVyZS5fcmVmcy0tO1xuICAgICAgY29uc3QgZ2wgPSB0aGlzLmNvbnRleHQ7XG4gICAgICBjb25zdCB0YXJnZXQgPSB0aGlzLnRleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XG4gICAgICBzZWxlY3RUZXh0dXJlKGdsLCB0YXJnZXQpO1xuICAgICAgY29uc3Qgc2l6ZSA9IHRoaXMuc2l6ZTtcbiAgICAgIHRhcmdldC5fcmVmcyA9IDE7XG4gICAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIHRoaXMuaW50ZXJuYWxGb3JtYXQsIHNpemVbMF0sIHNpemVbMV0sIDAsIHRoaXMudGV4dHVyZUZvcm1hdCwgdGhpcy50ZXh0dXJlVHlwZSwgbnVsbCk7XG4gICAgfVxuICAgIGNvbnN0IHsgY29udGV4dDogZ2wsIHRleHR1cmUgfSA9IHRoaXM7XG4gICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCB0aGlzLmZyYW1lYnVmZmVyKCkpO1xuICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmUpO1xuICAgIHNlbGVjdFRleHR1cmUoZ2wsIHRleHR1cmUpO1xuICAgIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGdsLkZSQU1FQlVGRkVSLCBnbC5DT0xPUl9BVFRBQ0hNRU5UMCwgZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSwgMCk7XG4gICAgZ2wuY2xlYXJDb2xvcigwLCAwLCAwLCAwKTtcbiAgICBnbC5jbGVhcihnbC5DT0xPUl9CVUZGRVJfQklUIHwgZ2wuREVQVEhfQlVGRkVSX0JJVCk7XG4gIH1cblxuICBkZWxldGUoKSB7XG4gICAgaWYgKHRoaXMuX2RlbGV0ZWQpIHJldHVybjtcbiAgICB0aGlzLl9kZWxldGVkID0gdHJ1ZTtcbiAgICBpZiAodGhpcy50ZXh0dXJlLl9yZWZzKSB7XG4gICAgICB0aGlzLnRleHR1cmUuX3JlZnMtLTtcbiAgICAgIGlmICh0aGlzLnRleHR1cmUuX3JlZnMpIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5jb250ZXh0LmRlbGV0ZVRleHR1cmUodGhpcy50ZXh0dXJlKTtcbiAgfVxuXG4gIGZyYW1lYnVmZmVyKCkge1xuICAgIGlmICghdGhpcy5fZnJhbWVidWZmZXIpIHtcbiAgICAgIHRoaXMuX2ZyYW1lYnVmZmVyID0gdGhpcy5rZXJuZWwuZ2V0UmF3VmFsdWVGcmFtZWJ1ZmZlcih0aGlzLnNpemVbMF0sIHRoaXMuc2l6ZVsxXSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9mcmFtZWJ1ZmZlcjtcbiAgfVxufVxuXG5mdW5jdGlvbiBzZWxlY3RUZXh0dXJlKGdsLCB0ZXh0dXJlKSB7XG4gIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTE1KTtcbiAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSk7XG4gIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsLkNMQU1QX1RPX0VER0UpO1xuICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFKTtcbiAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLk5FQVJFU1QpO1xuICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTkVBUkVTVCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0geyBHTFRleHR1cmUgfTtcbn0se1wiLi4vLi4vLi4vdGV4dHVyZVwiOjExM31dLDI4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzJyk7XG5jb25zdCB7IEdMVGV4dHVyZUZsb2F0IH0gPSByZXF1aXJlKCcuL2Zsb2F0Jyk7XG5cbmNsYXNzIEdMVGV4dHVyZU1lbW9yeU9wdGltaXplZDJEIGV4dGVuZHMgR0xUZXh0dXJlRmxvYXQge1xuICBjb25zdHJ1Y3RvcihzZXR0aW5ncykge1xuICAgIHN1cGVyKHNldHRpbmdzKTtcbiAgICB0aGlzLnR5cGUgPSAnTWVtb3J5T3B0aW1pemVkTnVtYmVyVGV4dHVyZSc7XG4gIH1cbiAgdG9BcnJheSgpIHtcbiAgICByZXR1cm4gdXRpbHMuZXJlY3RNZW1vcnlPcHRpbWl6ZWQyREZsb2F0KHRoaXMucmVuZGVyVmFsdWVzKCksIHRoaXMub3V0cHV0WzBdLCB0aGlzLm91dHB1dFsxXSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEdMVGV4dHVyZU1lbW9yeU9wdGltaXplZDJEXG59O1xufSx7XCIuLi8uLi8uLi91dGlsc1wiOjExNCxcIi4vZmxvYXRcIjoyNX1dLDI5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzJyk7XG5jb25zdCB7IEdMVGV4dHVyZUZsb2F0IH0gPSByZXF1aXJlKCcuL2Zsb2F0Jyk7XG5cbmNsYXNzIEdMVGV4dHVyZU1lbW9yeU9wdGltaXplZDNEIGV4dGVuZHMgR0xUZXh0dXJlRmxvYXQge1xuICBjb25zdHJ1Y3RvcihzZXR0aW5ncykge1xuICAgIHN1cGVyKHNldHRpbmdzKTtcbiAgICB0aGlzLnR5cGUgPSAnTWVtb3J5T3B0aW1pemVkTnVtYmVyVGV4dHVyZSc7XG4gIH1cbiAgdG9BcnJheSgpIHtcbiAgICByZXR1cm4gdXRpbHMuZXJlY3RNZW1vcnlPcHRpbWl6ZWQzREZsb2F0KHRoaXMucmVuZGVyVmFsdWVzKCksIHRoaXMub3V0cHV0WzBdLCB0aGlzLm91dHB1dFsxXSwgdGhpcy5vdXRwdXRbMl0pO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBHTFRleHR1cmVNZW1vcnlPcHRpbWl6ZWQzRFxufTtcbn0se1wiLi4vLi4vLi4vdXRpbHNcIjoxMTQsXCIuL2Zsb2F0XCI6MjV9XSwzMDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xuY29uc3QgeyBHTFRleHR1cmVGbG9hdCB9ID0gcmVxdWlyZSgnLi9mbG9hdCcpO1xuXG5jbGFzcyBHTFRleHR1cmVNZW1vcnlPcHRpbWl6ZWQgZXh0ZW5kcyBHTFRleHR1cmVGbG9hdCB7XG4gIGNvbnN0cnVjdG9yKHNldHRpbmdzKSB7XG4gICAgc3VwZXIoc2V0dGluZ3MpO1xuICAgIHRoaXMudHlwZSA9ICdNZW1vcnlPcHRpbWl6ZWROdW1iZXJUZXh0dXJlJztcbiAgfVxuICB0b0FycmF5KCkge1xuICAgIHJldHVybiB1dGlscy5lcmVjdE1lbW9yeU9wdGltaXplZEZsb2F0KHRoaXMucmVuZGVyVmFsdWVzKCksIHRoaXMub3V0cHV0WzBdKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgR0xUZXh0dXJlTWVtb3J5T3B0aW1pemVkXG59O1xufSx7XCIuLi8uLi8uLi91dGlsc1wiOjExNCxcIi4vZmxvYXRcIjoyNX1dLDMxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzJyk7XG5jb25zdCB7IEdMVGV4dHVyZVVuc2lnbmVkIH0gPSByZXF1aXJlKCcuL3Vuc2lnbmVkJyk7XG5cbmNsYXNzIEdMVGV4dHVyZVVuc2lnbmVkMkQgZXh0ZW5kcyBHTFRleHR1cmVVbnNpZ25lZCB7XG4gIGNvbnN0cnVjdG9yKHNldHRpbmdzKSB7XG4gICAgc3VwZXIoc2V0dGluZ3MpO1xuICAgIHRoaXMudHlwZSA9ICdOdW1iZXJUZXh0dXJlJztcbiAgfVxuICB0b0FycmF5KCkge1xuICAgIHJldHVybiB1dGlscy5lcmVjdDJEUGFja2VkRmxvYXQodGhpcy5yZW5kZXJWYWx1ZXMoKSwgdGhpcy5vdXRwdXRbMF0sIHRoaXMub3V0cHV0WzFdKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgR0xUZXh0dXJlVW5zaWduZWQyRFxufTtcbn0se1wiLi4vLi4vLi4vdXRpbHNcIjoxMTQsXCIuL3Vuc2lnbmVkXCI6MzN9XSwzMjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xuY29uc3QgeyBHTFRleHR1cmVVbnNpZ25lZCB9ID0gcmVxdWlyZSgnLi91bnNpZ25lZCcpO1xuXG5jbGFzcyBHTFRleHR1cmVVbnNpZ25lZDNEIGV4dGVuZHMgR0xUZXh0dXJlVW5zaWduZWQge1xuICBjb25zdHJ1Y3RvcihzZXR0aW5ncykge1xuICAgIHN1cGVyKHNldHRpbmdzKTtcbiAgICB0aGlzLnR5cGUgPSAnTnVtYmVyVGV4dHVyZSc7XG4gIH1cbiAgdG9BcnJheSgpIHtcbiAgICByZXR1cm4gdXRpbHMuZXJlY3QzRFBhY2tlZEZsb2F0KHRoaXMucmVuZGVyVmFsdWVzKCksIHRoaXMub3V0cHV0WzBdLCB0aGlzLm91dHB1dFsxXSwgdGhpcy5vdXRwdXRbMl0pO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBHTFRleHR1cmVVbnNpZ25lZDNEXG59O1xufSx7XCIuLi8uLi8uLi91dGlsc1wiOjExNCxcIi4vdW5zaWduZWRcIjozM31dLDMzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzJyk7XG5jb25zdCB7IEdMVGV4dHVyZSB9ID0gcmVxdWlyZSgnLi9pbmRleCcpO1xuXG5jbGFzcyBHTFRleHR1cmVVbnNpZ25lZCBleHRlbmRzIEdMVGV4dHVyZSB7XG4gIGdldCB0ZXh0dXJlVHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy5jb250ZXh0LlVOU0lHTkVEX0JZVEU7XG4gIH1cbiAgY29uc3RydWN0b3Ioc2V0dGluZ3MpIHtcbiAgICBzdXBlcihzZXR0aW5ncyk7XG4gICAgdGhpcy50eXBlID0gJ051bWJlclRleHR1cmUnO1xuICB9XG4gIHJlbmRlclJhd091dHB1dCgpIHtcbiAgICBjb25zdCB7IGNvbnRleHQ6IGdsIH0gPSB0aGlzO1xuICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgdGhpcy5mcmFtZWJ1ZmZlcigpKTtcbiAgICBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChcbiAgICAgIGdsLkZSQU1FQlVGRkVSLFxuICAgICAgZ2wuQ09MT1JfQVRUQUNITUVOVDAsXG4gICAgICBnbC5URVhUVVJFXzJELFxuICAgICAgdGhpcy50ZXh0dXJlLFxuICAgICAgMFxuICAgICk7XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5zaXplWzBdICogdGhpcy5zaXplWzFdICogNCk7XG4gICAgZ2wucmVhZFBpeGVscygwLCAwLCB0aGlzLnNpemVbMF0sIHRoaXMuc2l6ZVsxXSwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgcmVzdWx0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIHJlbmRlclZhbHVlcygpIHtcbiAgICBpZiAodGhpcy5fZGVsZXRlZCkgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkodGhpcy5yZW5kZXJSYXdPdXRwdXQoKS5idWZmZXIpO1xuICB9XG4gIHRvQXJyYXkoKSB7XG4gICAgcmV0dXJuIHV0aWxzLmVyZWN0UGFja2VkRmxvYXQodGhpcy5yZW5kZXJWYWx1ZXMoKSwgdGhpcy5vdXRwdXRbMF0pO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBHTFRleHR1cmVVbnNpZ25lZFxufTtcbn0se1wiLi4vLi4vLi4vdXRpbHNcIjoxMTQsXCIuL2luZGV4XCI6Mjd9XSwzNDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCBnZXRDb250ZXh0ID0gcmVxdWlyZSgnZ2wnKTtcbmNvbnN0IHsgV2ViR0xLZXJuZWwgfSA9IHJlcXVpcmUoJy4uL3dlYi1nbC9rZXJuZWwnKTtcbmNvbnN0IHsgZ2xLZXJuZWxTdHJpbmcgfSA9IHJlcXVpcmUoJy4uL2dsL2tlcm5lbC1zdHJpbmcnKTtcblxubGV0IGlzU3VwcG9ydGVkID0gbnVsbDtcbmxldCB0ZXN0Q2FudmFzID0gbnVsbDtcbmxldCB0ZXN0Q29udGV4dCA9IG51bGw7XG5sZXQgdGVzdEV4dGVuc2lvbnMgPSBudWxsO1xubGV0IGZlYXR1cmVzID0gbnVsbDtcblxuY2xhc3MgSGVhZGxlc3NHTEtlcm5lbCBleHRlbmRzIFdlYkdMS2VybmVsIHtcbiAgc3RhdGljIGdldCBpc1N1cHBvcnRlZCgpIHtcbiAgICBpZiAoaXNTdXBwb3J0ZWQgIT09IG51bGwpIHJldHVybiBpc1N1cHBvcnRlZDtcbiAgICB0aGlzLnNldHVwRmVhdHVyZUNoZWNrcygpO1xuICAgIGlzU3VwcG9ydGVkID0gdGVzdENvbnRleHQgIT09IG51bGw7XG4gICAgcmV0dXJuIGlzU3VwcG9ydGVkO1xuICB9XG5cbiAgc3RhdGljIHNldHVwRmVhdHVyZUNoZWNrcygpIHtcbiAgICB0ZXN0Q2FudmFzID0gbnVsbDtcbiAgICB0ZXN0RXh0ZW5zaW9ucyA9IG51bGw7XG4gICAgaWYgKHR5cGVvZiBnZXRDb250ZXh0ICE9PSAnZnVuY3Rpb24nKSByZXR1cm47XG4gICAgdHJ5IHsgXG4gICAgICB0ZXN0Q29udGV4dCA9IGdldENvbnRleHQoMiwgMiwge1xuICAgICAgICBwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6IHRydWVcbiAgICAgIH0pO1xuICAgICAgaWYgKCF0ZXN0Q29udGV4dCB8fCAhdGVzdENvbnRleHQuZ2V0RXh0ZW5zaW9uKSByZXR1cm47XG4gICAgICB0ZXN0RXh0ZW5zaW9ucyA9IHtcbiAgICAgICAgU1RBQ0tHTF9yZXNpemVfZHJhd2luZ2J1ZmZlcjogdGVzdENvbnRleHQuZ2V0RXh0ZW5zaW9uKCdTVEFDS0dMX3Jlc2l6ZV9kcmF3aW5nYnVmZmVyJyksXG4gICAgICAgIFNUQUNLR0xfZGVzdHJveV9jb250ZXh0OiB0ZXN0Q29udGV4dC5nZXRFeHRlbnNpb24oJ1NUQUNLR0xfZGVzdHJveV9jb250ZXh0JyksXG4gICAgICAgIE9FU190ZXh0dXJlX2Zsb2F0OiB0ZXN0Q29udGV4dC5nZXRFeHRlbnNpb24oJ09FU190ZXh0dXJlX2Zsb2F0JyksXG4gICAgICAgIE9FU190ZXh0dXJlX2Zsb2F0X2xpbmVhcjogdGVzdENvbnRleHQuZ2V0RXh0ZW5zaW9uKCdPRVNfdGV4dHVyZV9mbG9hdF9saW5lYXInKSxcbiAgICAgICAgT0VTX2VsZW1lbnRfaW5kZXhfdWludDogdGVzdENvbnRleHQuZ2V0RXh0ZW5zaW9uKCdPRVNfZWxlbWVudF9pbmRleF91aW50JyksXG4gICAgICAgIFdFQkdMX2RyYXdfYnVmZmVyczogdGVzdENvbnRleHQuZ2V0RXh0ZW5zaW9uKCdXRUJHTF9kcmF3X2J1ZmZlcnMnKSxcbiAgICAgICAgV0VCR0xfY29sb3JfYnVmZmVyX2Zsb2F0OiB0ZXN0Q29udGV4dC5nZXRFeHRlbnNpb24oJ1dFQkdMX2NvbG9yX2J1ZmZlcl9mbG9hdCcpLFxuICAgICAgfTtcbiAgICAgIGZlYXR1cmVzID0gdGhpcy5nZXRGZWF0dXJlcygpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnNvbGUud2FybihlKTtcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgaXNDb250ZXh0TWF0Y2goY29udGV4dCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gY29udGV4dC5nZXRQYXJhbWV0ZXIoY29udGV4dC5SRU5ERVJFUikgPT09ICdBTkdMRSc7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBnZXRJc1RleHR1cmVGbG9hdCgpIHtcbiAgICByZXR1cm4gQm9vbGVhbih0ZXN0RXh0ZW5zaW9ucy5PRVNfdGV4dHVyZV9mbG9hdCk7XG4gIH1cblxuICBzdGF0aWMgZ2V0SXNEcmF3QnVmZmVycygpIHtcbiAgICByZXR1cm4gQm9vbGVhbih0ZXN0RXh0ZW5zaW9ucy5XRUJHTF9kcmF3X2J1ZmZlcnMpO1xuICB9XG5cbiAgc3RhdGljIGdldENoYW5uZWxDb3VudCgpIHtcbiAgICByZXR1cm4gdGVzdEV4dGVuc2lvbnMuV0VCR0xfZHJhd19idWZmZXJzID9cbiAgICAgIHRlc3RDb250ZXh0LmdldFBhcmFtZXRlcih0ZXN0RXh0ZW5zaW9ucy5XRUJHTF9kcmF3X2J1ZmZlcnMuTUFYX0RSQVdfQlVGRkVSU19XRUJHTCkgOlxuICAgICAgMTtcbiAgfVxuXG4gIHN0YXRpYyBnZXRNYXhUZXh0dXJlU2l6ZSgpIHtcbiAgICByZXR1cm4gdGVzdENvbnRleHQuZ2V0UGFyYW1ldGVyKHRlc3RDb250ZXh0Lk1BWF9URVhUVVJFX1NJWkUpO1xuICB9XG5cbiAgc3RhdGljIGdldCB0ZXN0Q2FudmFzKCkge1xuICAgIHJldHVybiB0ZXN0Q2FudmFzO1xuICB9XG5cbiAgc3RhdGljIGdldCB0ZXN0Q29udGV4dCgpIHtcbiAgICByZXR1cm4gdGVzdENvbnRleHQ7XG4gIH1cblxuICBzdGF0aWMgZ2V0IGZlYXR1cmVzKCkge1xuICAgIHJldHVybiBmZWF0dXJlcztcbiAgfVxuXG4gIGluaXRDYW52YXMoKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG5cbiAgaW5pdENvbnRleHQoKSB7XG4gICAgcmV0dXJuIGdldENvbnRleHQoMiwgMiwge1xuICAgICAgcHJlc2VydmVEcmF3aW5nQnVmZmVyOiB0cnVlXG4gICAgfSk7XG4gIH1cblxuICBpbml0RXh0ZW5zaW9ucygpIHtcbiAgICB0aGlzLmV4dGVuc2lvbnMgPSB7XG4gICAgICBTVEFDS0dMX3Jlc2l6ZV9kcmF3aW5nYnVmZmVyOiB0aGlzLmNvbnRleHQuZ2V0RXh0ZW5zaW9uKCdTVEFDS0dMX3Jlc2l6ZV9kcmF3aW5nYnVmZmVyJyksXG4gICAgICBTVEFDS0dMX2Rlc3Ryb3lfY29udGV4dDogdGhpcy5jb250ZXh0LmdldEV4dGVuc2lvbignU1RBQ0tHTF9kZXN0cm95X2NvbnRleHQnKSxcbiAgICAgIE9FU190ZXh0dXJlX2Zsb2F0OiB0aGlzLmNvbnRleHQuZ2V0RXh0ZW5zaW9uKCdPRVNfdGV4dHVyZV9mbG9hdCcpLFxuICAgICAgT0VTX3RleHR1cmVfZmxvYXRfbGluZWFyOiB0aGlzLmNvbnRleHQuZ2V0RXh0ZW5zaW9uKCdPRVNfdGV4dHVyZV9mbG9hdF9saW5lYXInKSxcbiAgICAgIE9FU19lbGVtZW50X2luZGV4X3VpbnQ6IHRoaXMuY29udGV4dC5nZXRFeHRlbnNpb24oJ09FU19lbGVtZW50X2luZGV4X3VpbnQnKSxcbiAgICAgIFdFQkdMX2RyYXdfYnVmZmVyczogdGhpcy5jb250ZXh0LmdldEV4dGVuc2lvbignV0VCR0xfZHJhd19idWZmZXJzJyksXG4gICAgfTtcbiAgfVxuXG4gIGJ1aWxkKCkge1xuICAgIHN1cGVyLmJ1aWxkLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgaWYgKCF0aGlzLmZhbGxiYWNrUmVxdWVzdGVkKSB7XG4gICAgICB0aGlzLmV4dGVuc2lvbnMuU1RBQ0tHTF9yZXNpemVfZHJhd2luZ2J1ZmZlci5yZXNpemUodGhpcy5tYXhUZXhTaXplWzBdLCB0aGlzLm1heFRleFNpemVbMV0pO1xuICAgIH1cbiAgfVxuXG4gIGRlc3Ryb3lFeHRlbnNpb25zKCkge1xuICAgIHRoaXMuZXh0ZW5zaW9ucy5TVEFDS0dMX3Jlc2l6ZV9kcmF3aW5nYnVmZmVyID0gbnVsbDtcbiAgICB0aGlzLmV4dGVuc2lvbnMuU1RBQ0tHTF9kZXN0cm95X2NvbnRleHQgPSBudWxsO1xuICAgIHRoaXMuZXh0ZW5zaW9ucy5PRVNfdGV4dHVyZV9mbG9hdCA9IG51bGw7XG4gICAgdGhpcy5leHRlbnNpb25zLk9FU190ZXh0dXJlX2Zsb2F0X2xpbmVhciA9IG51bGw7XG4gICAgdGhpcy5leHRlbnNpb25zLk9FU19lbGVtZW50X2luZGV4X3VpbnQgPSBudWxsO1xuICAgIHRoaXMuZXh0ZW5zaW9ucy5XRUJHTF9kcmF3X2J1ZmZlcnMgPSBudWxsO1xuICB9XG5cbiAgc3RhdGljIGRlc3Ryb3lDb250ZXh0KGNvbnRleHQpIHtcbiAgICBjb25zdCBleHRlbnNpb24gPSBjb250ZXh0LmdldEV4dGVuc2lvbignU1RBQ0tHTF9kZXN0cm95X2NvbnRleHQnKTtcbiAgICBpZiAoZXh0ZW5zaW9uICYmIGV4dGVuc2lvbi5kZXN0cm95KSB7XG4gICAgICBleHRlbnNpb24uZGVzdHJveSgpO1xuICAgIH1cbiAgfVxuXG4gIHRvU3RyaW5nKCkge1xuICAgIGNvbnN0IHNldHVwQ29udGV4dFN0cmluZyA9IGBjb25zdCBnbCA9IGNvbnRleHQgfHwgcmVxdWlyZSgnZ2wnKSgxLCAxKTtcXG5gO1xuICAgIGNvbnN0IGRlc3Ryb3lDb250ZXh0U3RyaW5nID0gYCAgICBpZiAoIWNvbnRleHQpIHsgZ2wuZ2V0RXh0ZW5zaW9uKCdTVEFDS0dMX2Rlc3Ryb3lfY29udGV4dCcpLmRlc3Ryb3koKTsgfVxcbmA7XG4gICAgcmV0dXJuIGdsS2VybmVsU3RyaW5nKHRoaXMuY29uc3RydWN0b3IsIGFyZ3VtZW50cywgdGhpcywgc2V0dXBDb250ZXh0U3RyaW5nLCBkZXN0cm95Q29udGV4dFN0cmluZyk7XG4gIH1cblxuICBzZXRPdXRwdXQob3V0cHV0KSB7XG4gICAgc3VwZXIuc2V0T3V0cHV0KG91dHB1dCk7XG4gICAgaWYgKHRoaXMuZ3JhcGhpY2FsICYmIHRoaXMuZXh0ZW5zaW9ucy5TVEFDS0dMX3Jlc2l6ZV9kcmF3aW5nYnVmZmVyKSB7XG4gICAgICB0aGlzLmV4dGVuc2lvbnMuU1RBQ0tHTF9yZXNpemVfZHJhd2luZ2J1ZmZlci5yZXNpemUodGhpcy5tYXhUZXhTaXplWzBdLCB0aGlzLm1heFRleFNpemVbMV0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgSGVhZGxlc3NHTEtlcm5lbFxufTtcbn0se1wiLi4vZ2wva2VybmVsLXN0cmluZ1wiOjEyLFwiLi4vd2ViLWdsL2tlcm5lbFwiOjcwLFwiZ2xcIjoyfV0sMzU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY2xhc3MgS2VybmVsVmFsdWUge1xuICBjb25zdHJ1Y3Rvcih2YWx1ZSwgc2V0dGluZ3MpIHtcbiAgICBjb25zdCB7XG4gICAgICBuYW1lLFxuICAgICAga2VybmVsLFxuICAgICAgY29udGV4dCxcbiAgICAgIGNoZWNrQ29udGV4dCxcbiAgICAgIG9uUmVxdWVzdENvbnRleHRIYW5kbGUsXG4gICAgICBvblVwZGF0ZVZhbHVlTWlzbWF0Y2gsXG4gICAgICBvcmlnaW4sXG4gICAgICBzdHJpY3RJbnRlZ2VycyxcbiAgICAgIHR5cGUsXG4gICAgICB0YWN0aWMsXG4gICAgfSA9IHNldHRpbmdzO1xuICAgIGlmICghbmFtZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCduYW1lIG5vdCBzZXQnKTtcbiAgICB9XG4gICAgaWYgKCF0eXBlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3R5cGUgbm90IHNldCcpO1xuICAgIH1cbiAgICBpZiAoIW9yaWdpbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdvcmlnaW4gbm90IHNldCcpO1xuICAgIH1cbiAgICBpZiAob3JpZ2luICE9PSAndXNlcicgJiYgb3JpZ2luICE9PSAnY29uc3RhbnRzJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBvcmlnaW4gbXVzdCBiZSBcInVzZXJcIiBvciBcImNvbnN0YW50c1wiIHZhbHVlIGlzIFwiJHsgb3JpZ2luIH1cImApO1xuICAgIH1cbiAgICBpZiAoIW9uUmVxdWVzdENvbnRleHRIYW5kbGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignb25SZXF1ZXN0Q29udGV4dEhhbmRsZSBpcyBub3Qgc2V0Jyk7XG4gICAgfVxuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy5vcmlnaW4gPSBvcmlnaW47XG4gICAgdGhpcy50YWN0aWMgPSB0YWN0aWM7XG4gICAgdGhpcy52YXJOYW1lID0gb3JpZ2luID09PSAnY29uc3RhbnRzJyA/IGBjb25zdGFudHMuJHtuYW1lfWAgOiBuYW1lO1xuICAgIHRoaXMua2VybmVsID0ga2VybmVsO1xuICAgIHRoaXMuc3RyaWN0SW50ZWdlcnMgPSBzdHJpY3RJbnRlZ2VycztcbiAgICB0aGlzLnR5cGUgPSB2YWx1ZS50eXBlIHx8IHR5cGU7XG4gICAgdGhpcy5zaXplID0gdmFsdWUuc2l6ZSB8fCBudWxsO1xuICAgIHRoaXMuaW5kZXggPSBudWxsO1xuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgdGhpcy5jaGVja0NvbnRleHQgPSBjaGVja0NvbnRleHQgIT09IG51bGwgJiYgY2hlY2tDb250ZXh0ICE9PSB1bmRlZmluZWQgPyBjaGVja0NvbnRleHQgOiB0cnVlO1xuICAgIHRoaXMuY29udGV4dEhhbmRsZSA9IG51bGw7XG4gICAgdGhpcy5vblJlcXVlc3RDb250ZXh0SGFuZGxlID0gb25SZXF1ZXN0Q29udGV4dEhhbmRsZTtcbiAgICB0aGlzLm9uVXBkYXRlVmFsdWVNaXNtYXRjaCA9IG9uVXBkYXRlVmFsdWVNaXNtYXRjaDtcbiAgICB0aGlzLmZvcmNlVXBsb2FkRWFjaFJ1biA9IG51bGw7XG4gIH1cblxuICBnZXQgaWQoKSB7XG4gICAgcmV0dXJuIGAke3RoaXMub3JpZ2lufV8ke25hbWV9YDtcbiAgfVxuXG4gIGdldFNvdXJjZSgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFwiZ2V0U291cmNlXCIgbm90IGRlZmluZWQgb24gJHsgdGhpcy5jb25zdHJ1Y3Rvci5uYW1lIH1gKTtcbiAgfVxuXG4gIHVwZGF0ZVZhbHVlKHZhbHVlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBcInVwZGF0ZVZhbHVlXCIgbm90IGRlZmluZWQgb24gJHsgdGhpcy5jb25zdHJ1Y3Rvci5uYW1lIH1gKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgS2VybmVsVmFsdWVcbn07XG59LHt9XSwzNjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi91dGlscycpO1xuY29uc3QgeyBJbnB1dCB9ID0gcmVxdWlyZSgnLi4vaW5wdXQnKTtcblxuY2xhc3MgS2VybmVsIHtcbiAgc3RhdGljIGdldCBpc1N1cHBvcnRlZCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFwiaXNTdXBwb3J0ZWRcIiBub3QgaW1wbGVtZW50ZWQgb24gJHsgdGhpcy5uYW1lIH1gKTtcbiAgfVxuXG4gIHN0YXRpYyBpc0NvbnRleHRNYXRjaChjb250ZXh0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBcImlzQ29udGV4dE1hdGNoXCIgbm90IGltcGxlbWVudGVkIG9uICR7IHRoaXMubmFtZSB9YCk7XG4gIH1cblxuICBzdGF0aWMgZ2V0RmVhdHVyZXMoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBcImdldEZlYXR1cmVzXCIgbm90IGltcGxlbWVudGVkIG9uICR7IHRoaXMubmFtZSB9YCk7XG4gIH1cblxuICBzdGF0aWMgZGVzdHJveUNvbnRleHQoY29udGV4dCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgXCJkZXN0cm95Q29udGV4dFwiIGNhbGxlZCBvbiAkeyB0aGlzLm5hbWUgfWApO1xuICB9XG5cbiAgc3RhdGljIG5hdGl2ZUZ1bmN0aW9uQXJndW1lbnRzKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgXCJuYXRpdmVGdW5jdGlvbkFyZ3VtZW50c1wiIGNhbGxlZCBvbiAkeyB0aGlzLm5hbWUgfWApO1xuICB9XG5cbiAgc3RhdGljIG5hdGl2ZUZ1bmN0aW9uUmV0dXJuVHlwZSgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFwibmF0aXZlRnVuY3Rpb25SZXR1cm5UeXBlXCIgY2FsbGVkIG9uICR7IHRoaXMubmFtZSB9YCk7XG4gIH1cblxuICBzdGF0aWMgY29tYmluZUtlcm5lbHMoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBcImNvbWJpbmVLZXJuZWxzXCIgY2FsbGVkIG9uICR7IHRoaXMubmFtZSB9YCk7XG4gIH1cblxuICBjb25zdHJ1Y3Rvcihzb3VyY2UsIHNldHRpbmdzKSB7XG4gICAgaWYgKHR5cGVvZiBzb3VyY2UgIT09ICdvYmplY3QnKSB7XG4gICAgICBpZiAodHlwZW9mIHNvdXJjZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzb3VyY2Ugbm90IGEgc3RyaW5nJyk7XG4gICAgICB9XG4gICAgICBpZiAoIXV0aWxzLmlzRnVuY3Rpb25TdHJpbmcoc291cmNlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NvdXJjZSBub3QgYSBmdW5jdGlvbiBzdHJpbmcnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy51c2VMZWdhY3lFbmNvZGVyID0gZmFsc2U7XG4gICAgdGhpcy5mYWxsYmFja1JlcXVlc3RlZCA9IGZhbHNlO1xuICAgIHRoaXMub25SZXF1ZXN0RmFsbGJhY2sgPSBudWxsO1xuXG4gICAgdGhpcy5hcmd1bWVudE5hbWVzID0gdHlwZW9mIHNvdXJjZSA9PT0gJ3N0cmluZycgPyB1dGlscy5nZXRBcmd1bWVudE5hbWVzRnJvbVN0cmluZyhzb3VyY2UpIDogbnVsbDtcbiAgICB0aGlzLmFyZ3VtZW50VHlwZXMgPSBudWxsO1xuICAgIHRoaXMuYXJndW1lbnRTaXplcyA9IG51bGw7XG4gICAgdGhpcy5hcmd1bWVudEJpdFJhdGlvcyA9IG51bGw7XG4gICAgdGhpcy5rZXJuZWxBcmd1bWVudHMgPSBudWxsO1xuICAgIHRoaXMua2VybmVsQ29uc3RhbnRzID0gbnVsbDtcbiAgICB0aGlzLmZvcmNlVXBsb2FkS2VybmVsQ29uc3RhbnRzID0gbnVsbDtcblxuXG4gICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG5cbiAgICB0aGlzLm91dHB1dCA9IG51bGw7XG5cbiAgICB0aGlzLmRlYnVnID0gZmFsc2U7XG5cbiAgICB0aGlzLmdyYXBoaWNhbCA9IGZhbHNlO1xuXG4gICAgdGhpcy5sb29wTWF4SXRlcmF0aW9ucyA9IDA7XG5cbiAgICB0aGlzLmNvbnN0YW50cyA9IG51bGw7XG5cbiAgICB0aGlzLmNvbnN0YW50VHlwZXMgPSBudWxsO1xuXG4gICAgdGhpcy5jb25zdGFudEJpdFJhdGlvcyA9IG51bGw7XG5cbiAgICB0aGlzLmR5bmFtaWNBcmd1bWVudHMgPSBmYWxzZTtcblxuICAgIHRoaXMuZHluYW1pY091dHB1dCA9IGZhbHNlO1xuXG4gICAgdGhpcy5jYW52YXMgPSBudWxsO1xuXG4gICAgdGhpcy5jb250ZXh0ID0gbnVsbDtcblxuICAgIHRoaXMuY2hlY2tDb250ZXh0ID0gbnVsbDtcblxuICAgIHRoaXMuZ3B1ID0gbnVsbDtcblxuICAgIHRoaXMuZnVuY3Rpb25zID0gbnVsbDtcblxuICAgIHRoaXMubmF0aXZlRnVuY3Rpb25zID0gbnVsbDtcblxuICAgIHRoaXMuaW5qZWN0ZWROYXRpdmUgPSBudWxsO1xuXG4gICAgdGhpcy5zdWJLZXJuZWxzID0gbnVsbDtcblxuICAgIHRoaXMudmFsaWRhdGUgPSB0cnVlO1xuXG4gICAgdGhpcy5pbW11dGFibGUgPSBmYWxzZTtcblxuICAgIHRoaXMucGlwZWxpbmUgPSBmYWxzZTtcblxuICAgIHRoaXMucHJlY2lzaW9uID0gbnVsbDtcblxuICAgIHRoaXMudGFjdGljID0gbnVsbDtcblxuICAgIHRoaXMucGx1Z2lucyA9IG51bGw7XG5cbiAgICB0aGlzLnJldHVyblR5cGUgPSBudWxsO1xuICAgIHRoaXMubGVhZGluZ1JldHVyblN0YXRlbWVudCA9IG51bGw7XG4gICAgdGhpcy5mb2xsb3dpbmdSZXR1cm5TdGF0ZW1lbnQgPSBudWxsO1xuICAgIHRoaXMub3B0aW1pemVGbG9hdE1lbW9yeSA9IG51bGw7XG4gICAgdGhpcy5zdHJpY3RJbnRlZ2VycyA9IGZhbHNlO1xuICAgIHRoaXMuZml4SW50ZWdlckRpdmlzaW9uQWNjdXJhY3kgPSBudWxsO1xuICAgIHRoaXMuYnVpbHQgPSBmYWxzZTtcbiAgICB0aGlzLnNpZ25hdHVyZSA9IG51bGw7XG4gIH1cblxuICBtZXJnZVNldHRpbmdzKHNldHRpbmdzKSB7XG4gICAgZm9yIChsZXQgcCBpbiBzZXR0aW5ncykge1xuICAgICAgaWYgKCFzZXR0aW5ncy5oYXNPd25Qcm9wZXJ0eShwKSB8fCAhdGhpcy5oYXNPd25Qcm9wZXJ0eShwKSkgY29udGludWU7XG4gICAgICBzd2l0Y2ggKHApIHtcbiAgICAgICAgY2FzZSAnb3V0cHV0JzpcbiAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoc2V0dGluZ3Mub3V0cHV0KSkge1xuICAgICAgICAgICAgdGhpcy5zZXRPdXRwdXQoc2V0dGluZ3Mub3V0cHV0KTsgXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2Z1bmN0aW9ucyc6XG4gICAgICAgICAgdGhpcy5mdW5jdGlvbnMgPSBbXTtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNldHRpbmdzLmZ1bmN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5hZGRGdW5jdGlvbihzZXR0aW5ncy5mdW5jdGlvbnNbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgY2FzZSAnZ3JhcGhpY2FsJzpcbiAgICAgICAgICBpZiAoc2V0dGluZ3NbcF0gJiYgIXNldHRpbmdzLmhhc093blByb3BlcnR5KCdwcmVjaXNpb24nKSkge1xuICAgICAgICAgICAgdGhpcy5wcmVjaXNpb24gPSAndW5zaWduZWQnO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzW3BdID0gc2V0dGluZ3NbcF07XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIGNhc2UgJ25hdGl2ZUZ1bmN0aW9ucyc6XG4gICAgICAgICAgaWYgKCFzZXR0aW5ncy5uYXRpdmVGdW5jdGlvbnMpIGNvbnRpbnVlO1xuICAgICAgICAgIHRoaXMubmF0aXZlRnVuY3Rpb25zID0gW107XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZXR0aW5ncy5uYXRpdmVGdW5jdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHMgPSBzZXR0aW5ncy5uYXRpdmVGdW5jdGlvbnNbaV07XG4gICAgICAgICAgICBjb25zdCB7IG5hbWUsIHNvdXJjZSB9ID0gcztcbiAgICAgICAgICAgIHRoaXMuYWRkTmF0aXZlRnVuY3Rpb24obmFtZSwgc291cmNlLCBzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB0aGlzW3BdID0gc2V0dGluZ3NbcF07XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmNhbnZhcykgdGhpcy5jYW52YXMgPSB0aGlzLmluaXRDYW52YXMoKTtcbiAgICBpZiAoIXRoaXMuY29udGV4dCkgdGhpcy5jb250ZXh0ID0gdGhpcy5pbml0Q29udGV4dCgpO1xuICAgIGlmICghdGhpcy5wbHVnaW5zKSB0aGlzLnBsdWdpbnMgPSB0aGlzLmluaXRQbHVnaW5zKHNldHRpbmdzKTtcbiAgfVxuICBidWlsZCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFwiYnVpbGRcIiBub3QgZGVmaW5lZCBvbiAkeyB0aGlzLmNvbnN0cnVjdG9yLm5hbWUgfWApO1xuICB9XG5cbiAgcnVuKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgXCJydW5cIiBub3QgZGVmaW5lZCBvbiAkeyB0aGlzLmNvbnN0cnVjdG9yLm5hbWUgfWApXG4gIH1cblxuICBpbml0Q2FudmFzKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgXCJpbml0Q2FudmFzXCIgbm90IGRlZmluZWQgb24gJHsgdGhpcy5jb25zdHJ1Y3Rvci5uYW1lIH1gKTtcbiAgfVxuXG4gIGluaXRDb250ZXh0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgXCJpbml0Q29udGV4dFwiIG5vdCBkZWZpbmVkIG9uICR7IHRoaXMuY29uc3RydWN0b3IubmFtZSB9YCk7XG4gIH1cblxuICBpbml0UGx1Z2lucyhzZXR0aW5ncykge1xuICAgIHRocm93IG5ldyBFcnJvcihgXCJpbml0UGx1Z2luc1wiIG5vdCBkZWZpbmVkIG9uICR7IHRoaXMuY29uc3RydWN0b3IubmFtZSB9YCk7XG4gIH1cblxuICBhZGRGdW5jdGlvbihzb3VyY2UsIHNldHRpbmdzID0ge30pIHtcbiAgICBpZiAoc291cmNlLm5hbWUgJiYgc291cmNlLnNvdXJjZSAmJiBzb3VyY2UuYXJndW1lbnRUeXBlcyAmJiAncmV0dXJuVHlwZScgaW4gc291cmNlKSB7XG4gICAgICB0aGlzLmZ1bmN0aW9ucy5wdXNoKHNvdXJjZSk7XG4gICAgfSBlbHNlIGlmICgnc2V0dGluZ3MnIGluIHNvdXJjZSAmJiAnc291cmNlJyBpbiBzb3VyY2UpIHtcbiAgICAgIHRoaXMuZnVuY3Rpb25zLnB1c2godGhpcy5mdW5jdGlvblRvSUdQVUZ1bmN0aW9uKHNvdXJjZS5zb3VyY2UsIHNvdXJjZS5zZXR0aW5ncykpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHNvdXJjZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHNvdXJjZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy5mdW5jdGlvbnMucHVzaCh0aGlzLmZ1bmN0aW9uVG9JR1BVRnVuY3Rpb24oc291cmNlLCBzZXR0aW5ncykpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGZ1bmN0aW9uIG5vdCBwcm9wZXJseSBkZWZpbmVkYCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgYWRkTmF0aXZlRnVuY3Rpb24obmFtZSwgc291cmNlLCBzZXR0aW5ncyA9IHt9KSB7XG4gICAgY29uc3QgeyBhcmd1bWVudFR5cGVzLCBhcmd1bWVudE5hbWVzIH0gPSBzZXR0aW5ncy5hcmd1bWVudFR5cGVzID9cbiAgICAgIHNwbGl0QXJndW1lbnRUeXBlcyhzZXR0aW5ncy5hcmd1bWVudFR5cGVzKSA6XG4gICAgICB0aGlzLmNvbnN0cnVjdG9yLm5hdGl2ZUZ1bmN0aW9uQXJndW1lbnRzKHNvdXJjZSkgfHwge307XG4gICAgdGhpcy5uYXRpdmVGdW5jdGlvbnMucHVzaCh7XG4gICAgICBuYW1lLFxuICAgICAgc291cmNlLFxuICAgICAgc2V0dGluZ3MsXG4gICAgICBhcmd1bWVudFR5cGVzLFxuICAgICAgYXJndW1lbnROYW1lcyxcbiAgICAgIHJldHVyblR5cGU6IHNldHRpbmdzLnJldHVyblR5cGUgfHwgdGhpcy5jb25zdHJ1Y3Rvci5uYXRpdmVGdW5jdGlvblJldHVyblR5cGUoc291cmNlKVxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgc2V0dXBBcmd1bWVudHMoYXJncykge1xuICAgIHRoaXMua2VybmVsQXJndW1lbnRzID0gW107XG4gICAgaWYgKCF0aGlzLmFyZ3VtZW50VHlwZXMpIHtcbiAgICAgIGlmICghdGhpcy5hcmd1bWVudFR5cGVzKSB7XG4gICAgICAgIHRoaXMuYXJndW1lbnRUeXBlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBhcmdUeXBlID0gdXRpbHMuZ2V0VmFyaWFibGVUeXBlKGFyZ3NbaV0sIHRoaXMuc3RyaWN0SW50ZWdlcnMpO1xuICAgICAgICAgIGNvbnN0IHR5cGUgPSBhcmdUeXBlID09PSAnSW50ZWdlcicgPyAnTnVtYmVyJyA6IGFyZ1R5cGU7XG4gICAgICAgICAgdGhpcy5hcmd1bWVudFR5cGVzLnB1c2godHlwZSk7XG4gICAgICAgICAgdGhpcy5rZXJuZWxBcmd1bWVudHMucHVzaCh7XG4gICAgICAgICAgICB0eXBlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmFyZ3VtZW50VHlwZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5rZXJuZWxBcmd1bWVudHMucHVzaCh7XG4gICAgICAgICAgdHlwZTogdGhpcy5hcmd1bWVudFR5cGVzW2ldXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuYXJndW1lbnRTaXplcyA9IG5ldyBBcnJheShhcmdzLmxlbmd0aCk7XG4gICAgdGhpcy5hcmd1bWVudEJpdFJhdGlvcyA9IG5ldyBJbnQzMkFycmF5KGFyZ3MubGVuZ3RoKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgYXJnID0gYXJnc1tpXTtcbiAgICAgIHRoaXMuYXJndW1lbnRTaXplc1tpXSA9IGFyZy5jb25zdHJ1Y3RvciA9PT0gSW5wdXQgPyBhcmcuc2l6ZSA6IG51bGw7XG4gICAgICB0aGlzLmFyZ3VtZW50Qml0UmF0aW9zW2ldID0gdGhpcy5nZXRCaXRSYXRpbyhhcmcpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmFyZ3VtZW50TmFtZXMubGVuZ3RoICE9PSBhcmdzLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBhcmd1bWVudHMgYXJlIG1pc3MtYWxpZ25lZGApO1xuICAgIH1cbiAgfVxuXG4gIHNldHVwQ29uc3RhbnRzKCkge1xuICAgIHRoaXMua2VybmVsQ29uc3RhbnRzID0gW107XG4gICAgbGV0IG5lZWRzQ29uc3RhbnRUeXBlcyA9IHRoaXMuY29uc3RhbnRUeXBlcyA9PT0gbnVsbDtcbiAgICBpZiAobmVlZHNDb25zdGFudFR5cGVzKSB7XG4gICAgICB0aGlzLmNvbnN0YW50VHlwZXMgPSB7fTtcbiAgICB9XG4gICAgdGhpcy5jb25zdGFudEJpdFJhdGlvcyA9IHt9O1xuICAgIGlmICh0aGlzLmNvbnN0YW50cykge1xuICAgICAgZm9yIChsZXQgbmFtZSBpbiB0aGlzLmNvbnN0YW50cykge1xuICAgICAgICBpZiAobmVlZHNDb25zdGFudFR5cGVzKSB7XG4gICAgICAgICAgY29uc3QgdHlwZSA9IHV0aWxzLmdldFZhcmlhYmxlVHlwZSh0aGlzLmNvbnN0YW50c1tuYW1lXSwgdGhpcy5zdHJpY3RJbnRlZ2Vycyk7XG4gICAgICAgICAgdGhpcy5jb25zdGFudFR5cGVzW25hbWVdID0gdHlwZTtcbiAgICAgICAgICB0aGlzLmtlcm5lbENvbnN0YW50cy5wdXNoKHtcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICB0eXBlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5rZXJuZWxDb25zdGFudHMucHVzaCh7XG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgdHlwZTogdGhpcy5jb25zdGFudFR5cGVzW25hbWVdXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb25zdGFudEJpdFJhdGlvc1tuYW1lXSA9IHRoaXMuZ2V0Qml0UmF0aW8odGhpcy5jb25zdGFudHNbbmFtZV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHNldE9wdGltaXplRmxvYXRNZW1vcnkoZmxhZykge1xuICAgIHRoaXMub3B0aW1pemVGbG9hdE1lbW9yeSA9IGZsYWc7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB0b0tlcm5lbE91dHB1dChvdXRwdXQpIHtcbiAgICBpZiAob3V0cHV0Lmhhc093blByb3BlcnR5KCd4JykpIHtcbiAgICAgIGlmIChvdXRwdXQuaGFzT3duUHJvcGVydHkoJ3knKSkge1xuICAgICAgICBpZiAob3V0cHV0Lmhhc093blByb3BlcnR5KCd6JykpIHtcbiAgICAgICAgICByZXR1cm4gW291dHB1dC54LCBvdXRwdXQueSwgb3V0cHV0LnpdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBbb3V0cHV0LngsIG91dHB1dC55XTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFtvdXRwdXQueF07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfVxuICB9XG5cbiAgc2V0T3V0cHV0KG91dHB1dCkge1xuICAgIHRoaXMub3V0cHV0ID0gdGhpcy50b0tlcm5lbE91dHB1dChvdXRwdXQpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgc2V0RGVidWcoZmxhZykge1xuICAgIHRoaXMuZGVidWcgPSBmbGFnO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgc2V0R3JhcGhpY2FsKGZsYWcpIHtcbiAgICB0aGlzLmdyYXBoaWNhbCA9IGZsYWc7XG4gICAgdGhpcy5wcmVjaXNpb24gPSAndW5zaWduZWQnO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgc2V0TG9vcE1heEl0ZXJhdGlvbnMobWF4KSB7XG4gICAgdGhpcy5sb29wTWF4SXRlcmF0aW9ucyA9IG1heDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHNldENvbnN0YW50cyhjb25zdGFudHMpIHtcbiAgICB0aGlzLmNvbnN0YW50cyA9IGNvbnN0YW50cztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHNldENvbnN0YW50VHlwZXMoY29uc3RhbnRUeXBlcykge1xuICAgIHRoaXMuY29uc3RhbnRUeXBlcyA9IGNvbnN0YW50VHlwZXM7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBzZXRGdW5jdGlvbnMoZnVuY3Rpb25zKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmdW5jdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuYWRkRnVuY3Rpb24oZnVuY3Rpb25zW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBzZXROYXRpdmVGdW5jdGlvbnMobmF0aXZlRnVuY3Rpb25zKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuYXRpdmVGdW5jdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHNldHRpbmdzID0gbmF0aXZlRnVuY3Rpb25zW2ldO1xuICAgICAgY29uc3QgeyBuYW1lLCBzb3VyY2UgfSA9IHNldHRpbmdzO1xuICAgICAgdGhpcy5hZGROYXRpdmVGdW5jdGlvbihuYW1lLCBzb3VyY2UsIHNldHRpbmdzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBzZXRJbmplY3RlZE5hdGl2ZShpbmplY3RlZE5hdGl2ZSkge1xuICAgIHRoaXMuaW5qZWN0ZWROYXRpdmUgPSBpbmplY3RlZE5hdGl2ZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHNldFBpcGVsaW5lKGZsYWcpIHtcbiAgICB0aGlzLnBpcGVsaW5lID0gZmxhZztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHNldFByZWNpc2lvbihmbGFnKSB7XG4gICAgdGhpcy5wcmVjaXNpb24gPSBmbGFnO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgc2V0RGltZW5zaW9ucyhmbGFnKSB7XG4gICAgdXRpbHMud2FybkRlcHJlY2F0ZWQoJ21ldGhvZCcsICdzZXREaW1lbnNpb25zJywgJ3NldE91dHB1dCcpO1xuICAgIHRoaXMub3V0cHV0ID0gZmxhZztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHNldE91dHB1dFRvVGV4dHVyZShmbGFnKSB7XG4gICAgdXRpbHMud2FybkRlcHJlY2F0ZWQoJ21ldGhvZCcsICdzZXRPdXRwdXRUb1RleHR1cmUnLCAnc2V0UGlwZWxpbmUnKTtcbiAgICB0aGlzLnBpcGVsaW5lID0gZmxhZztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHNldEltbXV0YWJsZShmbGFnKSB7XG4gICAgdGhpcy5pbW11dGFibGUgPSBmbGFnO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgc2V0Q2FudmFzKGNhbnZhcykge1xuICAgIHRoaXMuY2FudmFzID0gY2FudmFzO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgc2V0U3RyaWN0SW50ZWdlcnMoZmxhZykge1xuICAgIHRoaXMuc3RyaWN0SW50ZWdlcnMgPSBmbGFnO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgc2V0RHluYW1pY091dHB1dChmbGFnKSB7XG4gICAgdGhpcy5keW5hbWljT3V0cHV0ID0gZmxhZztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHNldEhhcmRjb2RlQ29uc3RhbnRzKGZsYWcpIHtcbiAgICB1dGlscy53YXJuRGVwcmVjYXRlZCgnbWV0aG9kJywgJ3NldEhhcmRjb2RlQ29uc3RhbnRzJyk7XG4gICAgdGhpcy5zZXREeW5hbWljT3V0cHV0KGZsYWcpO1xuICAgIHRoaXMuc2V0RHluYW1pY0FyZ3VtZW50cyhmbGFnKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHNldER5bmFtaWNBcmd1bWVudHMoZmxhZykge1xuICAgIHRoaXMuZHluYW1pY0FyZ3VtZW50cyA9IGZsYWc7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBzZXRVc2VMZWdhY3lFbmNvZGVyKGZsYWcpIHtcbiAgICB0aGlzLnVzZUxlZ2FjeUVuY29kZXIgPSBmbGFnO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgc2V0V2FyblZhclVzYWdlKGZsYWcpIHtcbiAgICB1dGlscy53YXJuRGVwcmVjYXRlZCgnbWV0aG9kJywgJ3NldFdhcm5WYXJVc2FnZScpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZ2V0Q2FudmFzKCkge1xuICAgIHV0aWxzLndhcm5EZXByZWNhdGVkKCdtZXRob2QnLCAnZ2V0Q2FudmFzJyk7XG4gICAgcmV0dXJuIHRoaXMuY2FudmFzO1xuICB9XG5cbiAgZ2V0V2ViR2woKSB7XG4gICAgdXRpbHMud2FybkRlcHJlY2F0ZWQoJ21ldGhvZCcsICdnZXRXZWJHbCcpO1xuICAgIHJldHVybiB0aGlzLmNvbnRleHQ7XG4gIH1cblxuICBzZXRDb250ZXh0KGNvbnRleHQpIHtcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgc2V0QXJndW1lbnRUeXBlcyhhcmd1bWVudFR5cGVzKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYXJndW1lbnRUeXBlcykpIHtcbiAgICAgIHRoaXMuYXJndW1lbnRUeXBlcyA9IGFyZ3VtZW50VHlwZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYXJndW1lbnRUeXBlcyA9IFtdO1xuICAgICAgZm9yIChjb25zdCBwIGluIGFyZ3VtZW50VHlwZXMpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudFR5cGVzLmhhc093blByb3BlcnR5KHApKSBjb250aW51ZTtcbiAgICAgICAgY29uc3QgYXJndW1lbnRJbmRleCA9IHRoaXMuYXJndW1lbnROYW1lcy5pbmRleE9mKHApO1xuICAgICAgICBpZiAoYXJndW1lbnRJbmRleCA9PT0gLTEpIHRocm93IG5ldyBFcnJvcihgdW5hYmxlIHRvIGZpbmQgYXJndW1lbnQgJHsgcCB9YCk7XG4gICAgICAgIHRoaXMuYXJndW1lbnRUeXBlc1thcmd1bWVudEluZGV4XSA9IGFyZ3VtZW50VHlwZXNbcF07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgc2V0VGFjdGljKHRhY3RpYykge1xuICAgIHRoaXMudGFjdGljID0gdGFjdGljO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgcmVxdWVzdEZhbGxiYWNrKGFyZ3MpIHtcbiAgICBpZiAoIXRoaXMub25SZXF1ZXN0RmFsbGJhY2spIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgXCJvblJlcXVlc3RGYWxsYmFja1wiIG5vdCBkZWZpbmVkIG9uICR7IHRoaXMuY29uc3RydWN0b3IubmFtZSB9YCk7XG4gICAgfVxuICAgIHRoaXMuZmFsbGJhY2tSZXF1ZXN0ZWQgPSB0cnVlO1xuICAgIHJldHVybiB0aGlzLm9uUmVxdWVzdEZhbGxiYWNrKGFyZ3MpO1xuICB9XG5cbiAgdmFsaWRhdGVTZXR0aW5ncygpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFwidmFsaWRhdGVTZXR0aW5nc1wiIG5vdCBkZWZpbmVkIG9uICR7IHRoaXMuY29uc3RydWN0b3IubmFtZSB9YCk7XG4gIH1cblxuICBhZGRTdWJLZXJuZWwoc3ViS2VybmVsKSB7XG4gICAgaWYgKHRoaXMuc3ViS2VybmVscyA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5zdWJLZXJuZWxzID0gW107XG4gICAgfVxuICAgIGlmICghc3ViS2VybmVsLnNvdXJjZSkgdGhyb3cgbmV3IEVycm9yKCdzdWJLZXJuZWwgbWlzc2luZyBcInNvdXJjZVwiIHByb3BlcnR5Jyk7XG4gICAgaWYgKCFzdWJLZXJuZWwucHJvcGVydHkgJiYgaXNOYU4oc3ViS2VybmVsLnByb3BlcnR5KSkgdGhyb3cgbmV3IEVycm9yKCdzdWJLZXJuZWwgbWlzc2luZyBcInByb3BlcnR5XCIgcHJvcGVydHknKTtcbiAgICBpZiAoIXN1Yktlcm5lbC5uYW1lKSB0aHJvdyBuZXcgRXJyb3IoJ3N1Yktlcm5lbCBtaXNzaW5nIFwibmFtZVwiIHByb3BlcnR5Jyk7XG4gICAgdGhpcy5zdWJLZXJuZWxzLnB1c2goc3ViS2VybmVsKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGRlc3Ryb3kocmVtb3ZlQ2FudmFzUmVmZXJlbmNlcykge1xuICAgIHRocm93IG5ldyBFcnJvcihgXCJkZXN0cm95XCIgY2FsbGVkIG9uICR7IHRoaXMuY29uc3RydWN0b3IubmFtZSB9YCk7XG4gIH1cblxuICBnZXRCaXRSYXRpbyh2YWx1ZSkge1xuICAgIGlmICh0aGlzLnByZWNpc2lvbiA9PT0gJ3NpbmdsZScpIHtcbiAgICAgIHJldHVybiA0O1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZVswXSkpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldEJpdFJhdGlvKHZhbHVlWzBdKTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlLmNvbnN0cnVjdG9yID09PSBJbnB1dCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0Qml0UmF0aW8odmFsdWUudmFsdWUpO1xuICAgIH1cbiAgICBzd2l0Y2ggKHZhbHVlLmNvbnN0cnVjdG9yKSB7XG4gICAgICBjYXNlIFVpbnQ4Q2xhbXBlZEFycmF5OlxuICAgICAgY2FzZSBVaW50OEFycmF5OlxuICAgICAgY2FzZSBJbnQ4QXJyYXk6XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgY2FzZSBVaW50MTZBcnJheTpcbiAgICAgIGNhc2UgSW50MTZBcnJheTpcbiAgICAgICAgcmV0dXJuIDI7XG4gICAgICBjYXNlIEZsb2F0MzJBcnJheTpcbiAgICAgIGNhc2UgSW50MzJBcnJheTpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiA0O1xuICAgIH1cbiAgfVxuXG4gIGdldFBpeGVscyhmbGlwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBcImdldFBpeGVsc1wiIGNhbGxlZCBvbiAkeyB0aGlzLmNvbnN0cnVjdG9yLm5hbWUgfWApO1xuICB9XG5cbiAgY2hlY2tPdXRwdXQoKSB7XG4gICAgaWYgKCF0aGlzLm91dHB1dCB8fCAhdXRpbHMuaXNBcnJheSh0aGlzLm91dHB1dCkpIHRocm93IG5ldyBFcnJvcigna2VybmVsLm91dHB1dCBub3QgYW4gYXJyYXknKTtcbiAgICBpZiAodGhpcy5vdXRwdXQubGVuZ3RoIDwgMSkgdGhyb3cgbmV3IEVycm9yKCdrZXJuZWwub3V0cHV0IGlzIGVtcHR5LCBuZWVkcyBhdCBsZWFzdCAxIHZhbHVlJyk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm91dHB1dC5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGlzTmFOKHRoaXMub3V0cHV0W2ldKSB8fCB0aGlzLm91dHB1dFtpXSA8IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAkeyB0aGlzLmNvbnN0cnVjdG9yLm5hbWUgfS5vdXRwdXRbJHsgaSB9XSBpbmNvcnJlY3RseSBkZWZpbmVkIGFzIFxcYCR7IHRoaXMub3V0cHV0W2ldIH1cXGAsIG5lZWRzIHRvIGJlIG51bWVyaWMsIGFuZCBncmVhdGVyIHRoYW4gMGApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByZXBlbmRTdHJpbmcodmFsdWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFwicHJlcGVuZFN0cmluZ1wiIGNhbGxlZCBvbiAkeyB0aGlzLmNvbnN0cnVjdG9yLm5hbWUgfWApO1xuICB9XG5cbiAgaGFzUHJlcGVuZFN0cmluZyh2YWx1ZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgXCJoYXNQcmVwZW5kU3RyaW5nXCIgY2FsbGVkIG9uICR7IHRoaXMuY29uc3RydWN0b3IubmFtZSB9YCk7XG4gIH1cblxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNldHRpbmdzOiB7XG4gICAgICAgIG91dHB1dDogdGhpcy5vdXRwdXQsXG4gICAgICAgIHBpcGVsaW5lOiB0aGlzLnBpcGVsaW5lLFxuICAgICAgICBhcmd1bWVudE5hbWVzOiB0aGlzLmFyZ3VtZW50TmFtZXMsXG4gICAgICAgIGFyZ3VtZW50c1R5cGVzOiB0aGlzLmFyZ3VtZW50VHlwZXMsXG4gICAgICAgIGNvbnN0YW50czogdGhpcy5jb25zdGFudHMsXG4gICAgICAgIHBsdWdpbk5hbWVzOiB0aGlzLnBsdWdpbnMgPyB0aGlzLnBsdWdpbnMubWFwKHBsdWdpbiA9PiBwbHVnaW4ubmFtZSkgOiBudWxsLFxuICAgICAgICByZXR1cm5UeXBlOiB0aGlzLnJldHVyblR5cGUsXG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIGJ1aWxkU2lnbmF0dXJlKGFyZ3MpIHtcbiAgICBjb25zdCBDb25zdHJ1Y3RvciA9IHRoaXMuY29uc3RydWN0b3I7XG4gICAgdGhpcy5zaWduYXR1cmUgPSBDb25zdHJ1Y3Rvci5nZXRTaWduYXR1cmUodGhpcywgQ29uc3RydWN0b3IuZ2V0QXJndW1lbnRUeXBlcyh0aGlzLCBhcmdzKSk7XG4gIH1cblxuICBzdGF0aWMgZ2V0QXJndW1lbnRUeXBlcyhrZXJuZWwsIGFyZ3MpIHtcbiAgICBjb25zdCBhcmd1bWVudFR5cGVzID0gbmV3IEFycmF5KGFyZ3MubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGFyZyA9IGFyZ3NbaV07XG4gICAgICBjb25zdCB0eXBlID0ga2VybmVsLmFyZ3VtZW50VHlwZXNbaV07XG4gICAgICBpZiAoYXJnLnR5cGUpIHtcbiAgICAgICAgYXJndW1lbnRUeXBlc1tpXSA9IGFyZy50eXBlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgY2FzZSAnTnVtYmVyJzpcbiAgICAgICAgICBjYXNlICdJbnRlZ2VyJzpcbiAgICAgICAgICBjYXNlICdGbG9hdCc6XG4gICAgICAgICAgY2FzZSAnQXJyYXlUZXh0dXJlKDEpJzpcbiAgICAgICAgICAgIGFyZ3VtZW50VHlwZXNbaV0gPSB1dGlscy5nZXRWYXJpYWJsZVR5cGUoYXJnKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBhcmd1bWVudFR5cGVzW2ldID0gdHlwZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJndW1lbnRUeXBlcztcbiAgfVxuXG4gIHN0YXRpYyBnZXRTaWduYXR1cmUoa2VybmVsLCBhcmd1bWVudFR5cGVzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBcImdldFNpZ25hdHVyZVwiIG5vdCBpbXBsZW1lbnRlZCBvbiAkeyB0aGlzLm5hbWUgfWApO1xuICB9XG5cbiAgZnVuY3Rpb25Ub0lHUFVGdW5jdGlvbihzb3VyY2UsIHNldHRpbmdzID0ge30pIHtcbiAgICBpZiAodHlwZW9mIHNvdXJjZSAhPT0gJ3N0cmluZycgJiYgdHlwZW9mIHNvdXJjZSAhPT0gJ2Z1bmN0aW9uJykgdGhyb3cgbmV3IEVycm9yKCdzb3VyY2Ugbm90IGEgc3RyaW5nIG9yIGZ1bmN0aW9uJyk7XG4gICAgY29uc3Qgc291cmNlU3RyaW5nID0gdHlwZW9mIHNvdXJjZSA9PT0gJ3N0cmluZycgPyBzb3VyY2UgOiBzb3VyY2UudG9TdHJpbmcoKTtcbiAgICBsZXQgYXJndW1lbnRUeXBlcyA9IFtdO1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc2V0dGluZ3MuYXJndW1lbnRUeXBlcykpIHtcbiAgICAgIGFyZ3VtZW50VHlwZXMgPSBzZXR0aW5ncy5hcmd1bWVudFR5cGVzO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHNldHRpbmdzLmFyZ3VtZW50VHlwZXMgPT09ICdvYmplY3QnKSB7XG4gICAgICBhcmd1bWVudFR5cGVzID0gdXRpbHMuZ2V0QXJndW1lbnROYW1lc0Zyb21TdHJpbmcoc291cmNlU3RyaW5nKVxuICAgICAgICAubWFwKG5hbWUgPT4gc2V0dGluZ3MuYXJndW1lbnRUeXBlc1tuYW1lXSkgfHwgW107XG4gICAgfSBlbHNlIHtcbiAgICAgIGFyZ3VtZW50VHlwZXMgPSBzZXR0aW5ncy5hcmd1bWVudFR5cGVzIHx8IFtdO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiB1dGlscy5nZXRGdW5jdGlvbk5hbWVGcm9tU3RyaW5nKHNvdXJjZVN0cmluZykgfHwgbnVsbCxcbiAgICAgIHNvdXJjZTogc291cmNlU3RyaW5nLFxuICAgICAgYXJndW1lbnRUeXBlcyxcbiAgICAgIHJldHVyblR5cGU6IHNldHRpbmdzLnJldHVyblR5cGUgfHwgbnVsbCxcbiAgICB9O1xuICB9XG5cbiAgb25BY3RpdmF0ZShwcmV2aW91c0tlcm5lbCkge31cbn1cblxuZnVuY3Rpb24gc3BsaXRBcmd1bWVudFR5cGVzKGFyZ3VtZW50VHlwZXNPYmplY3QpIHtcbiAgY29uc3QgYXJndW1lbnROYW1lcyA9IE9iamVjdC5rZXlzKGFyZ3VtZW50VHlwZXNPYmplY3QpO1xuICBjb25zdCBhcmd1bWVudFR5cGVzID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXJndW1lbnROYW1lcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGFyZ3VtZW50TmFtZSA9IGFyZ3VtZW50TmFtZXNbaV07XG4gICAgYXJndW1lbnRUeXBlcy5wdXNoKGFyZ3VtZW50VHlwZXNPYmplY3RbYXJndW1lbnROYW1lXSk7XG4gIH1cbiAgcmV0dXJuIHsgYXJndW1lbnRUeXBlcywgYXJndW1lbnROYW1lcyB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgS2VybmVsXG59O1xufSx7XCIuLi9pbnB1dFwiOjExMCxcIi4uL3V0aWxzXCI6MTE0fV0sMzc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgZnJhZ21lbnRTaGFkZXIgPSBgX19IRUFERVJfXztcbl9fRkxPQVRfVEFDVElDX0RFQ0xBUkFUSU9OX187XG5fX0lOVF9UQUNUSUNfREVDTEFSQVRJT05fXztcbl9fU0FNUExFUl8yRF9UQUNUSUNfREVDTEFSQVRJT05fXztcblxuY29uc3QgaW50IExPT1BfTUFYID0gX19MT09QX01BWF9fO1xuXG5fX1BMVUdJTlNfXztcbl9fQ09OU1RBTlRTX187XG5cbnZhcnlpbmcgdmVjMiB2VGV4Q29vcmQ7XG5cbmZsb2F0IGFjb3NoKGZsb2F0IHgpIHtcbiAgcmV0dXJuIGxvZyh4ICsgc3FydCh4ICogeCAtIDEuMCkpO1xufVxuXG5mbG9hdCBzaW5oKGZsb2F0IHgpIHtcbiAgcmV0dXJuIChwb3coJHtNYXRoLkV9LCB4KSAtIHBvdygke01hdGguRX0sIC14KSkgLyAyLjA7XG59XG5cbmZsb2F0IGFzaW5oKGZsb2F0IHgpIHtcbiAgcmV0dXJuIGxvZyh4ICsgc3FydCh4ICogeCArIDEuMCkpO1xufVxuXG5mbG9hdCBhdGFuMihmbG9hdCB2MSwgZmxvYXQgdjIpIHtcbiAgaWYgKHYxID09IDAuMCB8fCB2MiA9PSAwLjApIHJldHVybiAwLjA7XG4gIHJldHVybiBhdGFuKHYxIC8gdjIpO1xufVxuXG5mbG9hdCBhdGFuaChmbG9hdCB4KSB7XG4gIHggPSAoeCArIDEuMCkgLyAoeCAtIDEuMCk7XG4gIGlmICh4IDwgMC4wKSB7XG4gICAgcmV0dXJuIDAuNSAqIGxvZygteCk7XG4gIH1cbiAgcmV0dXJuIDAuNSAqIGxvZyh4KTtcbn1cblxuZmxvYXQgY2JydChmbG9hdCB4KSB7XG4gIGlmICh4ID49IDAuMCkge1xuICAgIHJldHVybiBwb3coeCwgMS4wIC8gMy4wKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gLXBvdyh4LCAxLjAgLyAzLjApO1xuICB9XG59XG5cbmZsb2F0IGNvc2goZmxvYXQgeCkge1xuICByZXR1cm4gKHBvdygke01hdGguRX0sIHgpICsgcG93KCR7TWF0aC5FfSwgLXgpKSAvIDIuMDsgXG59XG5cbmZsb2F0IGV4cG0xKGZsb2F0IHgpIHtcbiAgcmV0dXJuIHBvdygke01hdGguRX0sIHgpIC0gMS4wOyBcbn1cblxuZmxvYXQgZnJvdW5kKGhpZ2hwIGZsb2F0IHgpIHtcbiAgcmV0dXJuIHg7XG59XG5cbmZsb2F0IGltdWwoZmxvYXQgdjEsIGZsb2F0IHYyKSB7XG4gIHJldHVybiBmbG9hdChpbnQodjEpICogaW50KHYyKSk7XG59XG5cbmZsb2F0IGxvZzEwKGZsb2F0IHgpIHtcbiAgcmV0dXJuIGxvZzIoeCkgKiAoMS4wIC8gbG9nMigxMC4wKSk7XG59XG5cbmZsb2F0IGxvZzFwKGZsb2F0IHgpIHtcbiAgcmV0dXJuIGxvZygxLjAgKyB4KTtcbn1cblxuZmxvYXQgX3BvdyhmbG9hdCB2MSwgZmxvYXQgdjIpIHtcbiAgaWYgKHYyID09IDAuMCkgcmV0dXJuIDEuMDtcbiAgcmV0dXJuIHBvdyh2MSwgdjIpO1xufVxuXG5mbG9hdCB0YW5oKGZsb2F0IHgpIHtcbiAgZmxvYXQgZSA9IGV4cCgyLjAgKiB4KTtcbiAgcmV0dXJuIChlIC0gMS4wKSAvIChlICsgMS4wKTtcbn1cblxuZmxvYXQgdHJ1bmMoZmxvYXQgeCkge1xuICBpZiAoeCA+PSAwLjApIHtcbiAgICByZXR1cm4gZmxvb3IoeCk7IFxuICB9IGVsc2Uge1xuICAgIHJldHVybiBjZWlsKHgpO1xuICB9XG59XG5cbnZlYzQgX3JvdW5kKHZlYzQgeCkge1xuICByZXR1cm4gZmxvb3IoeCArIDAuNSk7XG59XG5cbmZsb2F0IF9yb3VuZChmbG9hdCB4KSB7XG4gIHJldHVybiBmbG9vcih4ICsgMC41KTtcbn1cblxuY29uc3QgaW50IEJJVF9DT1VOVCA9IDMyO1xuaW50IG1vZGkoaW50IHgsIGludCB5KSB7XG4gIHJldHVybiB4IC0geSAqICh4IC8geSk7XG59XG5cbmludCBiaXR3aXNlT3IoaW50IGEsIGludCBiKSB7XG4gIGludCByZXN1bHQgPSAwO1xuICBpbnQgbiA9IDE7XG4gIFxuICBmb3IgKGludCBpID0gMDsgaSA8IEJJVF9DT1VOVDsgaSsrKSB7XG4gICAgaWYgKChtb2RpKGEsIDIpID09IDEpIHx8IChtb2RpKGIsIDIpID09IDEpKSB7XG4gICAgICByZXN1bHQgKz0gbjtcbiAgICB9XG4gICAgYSA9IGEgLyAyO1xuICAgIGIgPSBiIC8gMjtcbiAgICBuID0gbiAqIDI7XG4gICAgaWYoIShhID4gMCB8fCBiID4gMCkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuaW50IGJpdHdpc2VYT1IoaW50IGEsIGludCBiKSB7XG4gIGludCByZXN1bHQgPSAwO1xuICBpbnQgbiA9IDE7XG4gIFxuICBmb3IgKGludCBpID0gMDsgaSA8IEJJVF9DT1VOVDsgaSsrKSB7XG4gICAgaWYgKChtb2RpKGEsIDIpID09IDEpICE9IChtb2RpKGIsIDIpID09IDEpKSB7XG4gICAgICByZXN1bHQgKz0gbjtcbiAgICB9XG4gICAgYSA9IGEgLyAyO1xuICAgIGIgPSBiIC8gMjtcbiAgICBuID0gbiAqIDI7XG4gICAgaWYoIShhID4gMCB8fCBiID4gMCkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuaW50IGJpdHdpc2VBbmQoaW50IGEsIGludCBiKSB7XG4gIGludCByZXN1bHQgPSAwO1xuICBpbnQgbiA9IDE7XG4gIGZvciAoaW50IGkgPSAwOyBpIDwgQklUX0NPVU5UOyBpKyspIHtcbiAgICBpZiAoKG1vZGkoYSwgMikgPT0gMSkgJiYgKG1vZGkoYiwgMikgPT0gMSkpIHtcbiAgICAgIHJlc3VsdCArPSBuO1xuICAgIH1cbiAgICBhID0gYSAvIDI7XG4gICAgYiA9IGIgLyAyO1xuICAgIG4gPSBuICogMjtcbiAgICBpZighKGEgPiAwICYmIGIgPiAwKSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5pbnQgYml0d2lzZU5vdChpbnQgYSkge1xuICBpbnQgcmVzdWx0ID0gMDtcbiAgaW50IG4gPSAxO1xuICBcbiAgZm9yIChpbnQgaSA9IDA7IGkgPCBCSVRfQ09VTlQ7IGkrKykge1xuICAgIGlmIChtb2RpKGEsIDIpID09IDApIHtcbiAgICAgIHJlc3VsdCArPSBuOyAgICBcbiAgICB9XG4gICAgYSA9IGEgLyAyO1xuICAgIG4gPSBuICogMjtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuaW50IGJpdHdpc2VaZXJvRmlsbExlZnRTaGlmdChpbnQgbiwgaW50IHNoaWZ0KSB7XG4gIGludCBtYXhCeXRlcyA9IEJJVF9DT1VOVDtcbiAgZm9yIChpbnQgaSA9IDA7IGkgPCBCSVRfQ09VTlQ7IGkrKykge1xuICAgIGlmIChtYXhCeXRlcyA+PSBuKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgbWF4Qnl0ZXMgKj0gMjtcbiAgfVxuICBmb3IgKGludCBpID0gMDsgaSA8IEJJVF9DT1VOVDsgaSsrKSB7XG4gICAgaWYgKGkgPj0gc2hpZnQpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBuICo9IDI7XG4gIH1cblxuICBpbnQgcmVzdWx0ID0gMDtcbiAgaW50IGJ5dGVWYWwgPSAxO1xuICBmb3IgKGludCBpID0gMDsgaSA8IEJJVF9DT1VOVDsgaSsrKSB7XG4gICAgaWYgKGkgPj0gbWF4Qnl0ZXMpIGJyZWFrO1xuICAgIGlmIChtb2RpKG4sIDIpID4gMCkgeyByZXN1bHQgKz0gYnl0ZVZhbDsgfVxuICAgIG4gPSBpbnQobiAvIDIpO1xuICAgIGJ5dGVWYWwgKj0gMjtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5pbnQgYml0d2lzZVNpZ25lZFJpZ2h0U2hpZnQoaW50IG51bSwgaW50IHNoaWZ0cykge1xuICByZXR1cm4gaW50KGZsb29yKGZsb2F0KG51bSkgLyBwb3coMi4wLCBmbG9hdChzaGlmdHMpKSkpO1xufVxuXG5pbnQgYml0d2lzZVplcm9GaWxsUmlnaHRTaGlmdChpbnQgbiwgaW50IHNoaWZ0KSB7XG4gIGludCBtYXhCeXRlcyA9IEJJVF9DT1VOVDtcbiAgZm9yIChpbnQgaSA9IDA7IGkgPCBCSVRfQ09VTlQ7IGkrKykge1xuICAgIGlmIChtYXhCeXRlcyA+PSBuKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgbWF4Qnl0ZXMgKj0gMjtcbiAgfVxuICBmb3IgKGludCBpID0gMDsgaSA8IEJJVF9DT1VOVDsgaSsrKSB7XG4gICAgaWYgKGkgPj0gc2hpZnQpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBuIC89IDI7XG4gIH1cbiAgaW50IHJlc3VsdCA9IDA7XG4gIGludCBieXRlVmFsID0gMTtcbiAgZm9yIChpbnQgaSA9IDA7IGkgPCBCSVRfQ09VTlQ7IGkrKykge1xuICAgIGlmIChpID49IG1heEJ5dGVzKSBicmVhaztcbiAgICBpZiAobW9kaShuLCAyKSA+IDApIHsgcmVzdWx0ICs9IGJ5dGVWYWw7IH1cbiAgICBuID0gaW50KG4gLyAyKTtcbiAgICBieXRlVmFsICo9IDI7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxudmVjMiBpbnRlZ2VyTW9kKHZlYzIgeCwgZmxvYXQgeSkge1xuICB2ZWMyIHJlcyA9IGZsb29yKG1vZCh4LCB5KSk7XG4gIHJldHVybiByZXMgKiBzdGVwKDEuMCAtIGZsb29yKHkpLCAtcmVzKTtcbn1cblxudmVjMyBpbnRlZ2VyTW9kKHZlYzMgeCwgZmxvYXQgeSkge1xuICB2ZWMzIHJlcyA9IGZsb29yKG1vZCh4LCB5KSk7XG4gIHJldHVybiByZXMgKiBzdGVwKDEuMCAtIGZsb29yKHkpLCAtcmVzKTtcbn1cblxudmVjNCBpbnRlZ2VyTW9kKHZlYzQgeCwgdmVjNCB5KSB7XG4gIHZlYzQgcmVzID0gZmxvb3IobW9kKHgsIHkpKTtcbiAgcmV0dXJuIHJlcyAqIHN0ZXAoMS4wIC0gZmxvb3IoeSksIC1yZXMpO1xufVxuXG5mbG9hdCBpbnRlZ2VyTW9kKGZsb2F0IHgsIGZsb2F0IHkpIHtcbiAgZmxvYXQgcmVzID0gZmxvb3IobW9kKHgsIHkpKTtcbiAgcmV0dXJuIHJlcyAqIChyZXMgPiBmbG9vcih5KSAtIDEuMCA/IDAuMCA6IDEuMCk7XG59XG5cbmludCBpbnRlZ2VyTW9kKGludCB4LCBpbnQgeSkge1xuICByZXR1cm4geCAtICh5ICogaW50KHggLyB5KSk7XG59XG5cbl9fRElWSURFX1dJVEhfSU5URUdFUl9DSEVDS19fO1xuXG4vLyBIZXJlIGJlIGRyYWdvbnMhXG4vLyBETyBOT1QgT1BUSU1JWkUgVEhJUyBDT0RFXG4vLyBZT1UgV0lMTCBCUkVBSyBTT01FVEhJTkcgT04gU09NRUJPRFlcXCdTIE1BQ0hJTkVcbi8vIExFQVZFIElUIEFTIElUIElTLCBMRVNUIFlPVSBXQVNURSBZT1VSIE9XTiBUSU1FXG5jb25zdCB2ZWMyIE1BR0lDX1ZFQyA9IHZlYzIoMS4wLCAtMjU2LjApO1xuY29uc3QgdmVjNCBTQ0FMRV9GQUNUT1IgPSB2ZWM0KDEuMCwgMjU2LjAsIDY1NTM2LjAsIDAuMCk7XG5jb25zdCB2ZWM0IFNDQUxFX0ZBQ1RPUl9JTlYgPSB2ZWM0KDEuMCwgMC4wMDM5MDYyNSwgMC4wMDAwMTUyNTg3ODkwNjI1LCAwLjApOyAvLyAxLCAxLzI1NiwgMS82NTUzNlxuZmxvYXQgZGVjb2RlMzIodmVjNCB0ZXhlbCkge1xuICBfX0RFQ09ERTMyX0VORElBTk5FU1NfXztcbiAgdGV4ZWwgKj0gMjU1LjA7XG4gIHZlYzIgZ3RlMTI4O1xuICBndGUxMjgueCA9IHRleGVsLmIgPj0gMTI4LjAgPyAxLjAgOiAwLjA7XG4gIGd0ZTEyOC55ID0gdGV4ZWwuYSA+PSAxMjguMCA/IDEuMCA6IDAuMDtcbiAgZmxvYXQgZXhwb25lbnQgPSAyLjAgKiB0ZXhlbC5hIC0gMTI3LjAgKyBkb3QoZ3RlMTI4LCBNQUdJQ19WRUMpO1xuICBmbG9hdCByZXMgPSBleHAyKF9yb3VuZChleHBvbmVudCkpO1xuICB0ZXhlbC5iID0gdGV4ZWwuYiAtIDEyOC4wICogZ3RlMTI4Lng7XG4gIHJlcyA9IGRvdCh0ZXhlbCwgU0NBTEVfRkFDVE9SKSAqIGV4cDIoX3JvdW5kKGV4cG9uZW50LTIzLjApKSArIHJlcztcbiAgcmVzICo9IGd0ZTEyOC55ICogLTIuMCArIDEuMDtcbiAgcmV0dXJuIHJlcztcbn1cblxuZmxvYXQgZGVjb2RlMTYodmVjNCB0ZXhlbCwgaW50IGluZGV4KSB7XG4gIGludCBjaGFubmVsID0gaW50ZWdlck1vZChpbmRleCwgMik7XG4gIGlmIChjaGFubmVsID09IDApIHJldHVybiB0ZXhlbC5yICogMjU1LjAgKyB0ZXhlbC5nICogNjUyODAuMDtcbiAgaWYgKGNoYW5uZWwgPT0gMSkgcmV0dXJuIHRleGVsLmIgKiAyNTUuMCArIHRleGVsLmEgKiA2NTI4MC4wO1xuICByZXR1cm4gMC4wO1xufVxuXG5mbG9hdCBkZWNvZGU4KHZlYzQgdGV4ZWwsIGludCBpbmRleCkge1xuICBpbnQgY2hhbm5lbCA9IGludGVnZXJNb2QoaW5kZXgsIDQpO1xuICBpZiAoY2hhbm5lbCA9PSAwKSByZXR1cm4gdGV4ZWwuciAqIDI1NS4wO1xuICBpZiAoY2hhbm5lbCA9PSAxKSByZXR1cm4gdGV4ZWwuZyAqIDI1NS4wO1xuICBpZiAoY2hhbm5lbCA9PSAyKSByZXR1cm4gdGV4ZWwuYiAqIDI1NS4wO1xuICBpZiAoY2hhbm5lbCA9PSAzKSByZXR1cm4gdGV4ZWwuYSAqIDI1NS4wO1xuICByZXR1cm4gMC4wO1xufVxuXG52ZWM0IGxlZ2FjeUVuY29kZTMyKGZsb2F0IGYpIHtcbiAgZmxvYXQgRiA9IGFicyhmKTtcbiAgZmxvYXQgc2lnbiA9IGYgPCAwLjAgPyAxLjAgOiAwLjA7XG4gIGZsb2F0IGV4cG9uZW50ID0gZmxvb3IobG9nMihGKSk7XG4gIGZsb2F0IG1hbnRpc3NhID0gKGV4cDIoLWV4cG9uZW50KSAqIEYpO1xuICAvLyBleHBvbmVudCArPSBmbG9vcihsb2cyKG1hbnRpc3NhKSk7XG4gIHZlYzQgdGV4ZWwgPSB2ZWM0KEYgKiBleHAyKDIzLjAtZXhwb25lbnQpKSAqIFNDQUxFX0ZBQ1RPUl9JTlY7XG4gIHRleGVsLnJnID0gaW50ZWdlck1vZCh0ZXhlbC5yZywgMjU2LjApO1xuICB0ZXhlbC5iID0gaW50ZWdlck1vZCh0ZXhlbC5iLCAxMjguMCk7XG4gIHRleGVsLmEgPSBleHBvbmVudCowLjUgKyA2My41O1xuICB0ZXhlbC5iYSArPSB2ZWMyKGludGVnZXJNb2QoZXhwb25lbnQrMTI3LjAsIDIuMCksIHNpZ24pICogMTI4LjA7XG4gIHRleGVsID0gZmxvb3IodGV4ZWwpO1xuICB0ZXhlbCAqPSAwLjAwMzkyMTU2OTsgLy8gMS8yNTVcbiAgX19FTkNPREUzMl9FTkRJQU5ORVNTX187XG4gIHJldHVybiB0ZXhlbDtcbn1cblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2dwdWpzL2dwdS5qcy93aWtpL0VuY29kZXItZGV0YWlsc1xudmVjNCBlbmNvZGUzMihmbG9hdCB2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gMC4wKSByZXR1cm4gdmVjNCgwLCAwLCAwLCAwKTtcblxuICBmbG9hdCBleHBvbmVudDtcbiAgZmxvYXQgbWFudGlzc2E7XG4gIHZlYzQgIHJlc3VsdDtcbiAgZmxvYXQgc2duO1xuXG4gIHNnbiA9IHN0ZXAoMC4wLCAtdmFsdWUpO1xuICB2YWx1ZSA9IGFicyh2YWx1ZSk7XG5cbiAgZXhwb25lbnQgPSBmbG9vcihsb2cyKHZhbHVlKSk7XG5cbiAgbWFudGlzc2EgPSB2YWx1ZSpwb3coMi4wLCAtZXhwb25lbnQpLTEuMDtcbiAgZXhwb25lbnQgPSBleHBvbmVudCsxMjcuMDtcbiAgcmVzdWx0ICAgPSB2ZWM0KDAsMCwwLDApO1xuXG4gIHJlc3VsdC5hID0gZmxvb3IoZXhwb25lbnQvMi4wKTtcbiAgZXhwb25lbnQgPSBleHBvbmVudCAtIHJlc3VsdC5hKjIuMDtcbiAgcmVzdWx0LmEgPSByZXN1bHQuYSArIDEyOC4wKnNnbjtcblxuICByZXN1bHQuYiA9IGZsb29yKG1hbnRpc3NhICogMTI4LjApO1xuICBtYW50aXNzYSA9IG1hbnRpc3NhIC0gcmVzdWx0LmIgLyAxMjguMDtcbiAgcmVzdWx0LmIgPSByZXN1bHQuYiArIGV4cG9uZW50KjEyOC4wO1xuXG4gIHJlc3VsdC5nID0gZmxvb3IobWFudGlzc2EqMzI3NjguMCk7XG4gIG1hbnRpc3NhID0gbWFudGlzc2EgLSByZXN1bHQuZy8zMjc2OC4wO1xuXG4gIHJlc3VsdC5yID0gZmxvb3IobWFudGlzc2EqODM4ODYwOC4wKTtcbiAgcmV0dXJuIHJlc3VsdC8yNTUuMDtcbn1cbi8vIERyYWdvbnMgZW5kIGhlcmVcblxuaW50IGluZGV4O1xuaXZlYzMgdGhyZWFkSWQ7XG5cbml2ZWMzIGluZGV4VG8zRChpbnQgaWR4LCBpdmVjMyB0ZXhEaW0pIHtcbiAgaW50IHogPSBpbnQoaWR4IC8gKHRleERpbS54ICogdGV4RGltLnkpKTtcbiAgaWR4IC09IHogKiBpbnQodGV4RGltLnggKiB0ZXhEaW0ueSk7XG4gIGludCB5ID0gaW50KGlkeCAvIHRleERpbS54KTtcbiAgaW50IHggPSBpbnQoaW50ZWdlck1vZChpZHgsIHRleERpbS54KSk7XG4gIHJldHVybiBpdmVjMyh4LCB5LCB6KTtcbn1cblxuZmxvYXQgZ2V0MzIoc2FtcGxlcjJEIHRleCwgaXZlYzIgdGV4U2l6ZSwgaXZlYzMgdGV4RGltLCBpbnQgeiwgaW50IHksIGludCB4KSB7XG4gIGludCBpbmRleCA9IHggKyB0ZXhEaW0ueCAqICh5ICsgdGV4RGltLnkgKiB6KTtcbiAgaW50IHcgPSB0ZXhTaXplLng7XG4gIHZlYzIgc3QgPSB2ZWMyKGZsb2F0KGludGVnZXJNb2QoaW5kZXgsIHcpKSwgZmxvYXQoaW5kZXggLyB3KSkgKyAwLjU7XG4gIHZlYzQgdGV4ZWwgPSB0ZXh0dXJlMkQodGV4LCBzdCAvIHZlYzIodGV4U2l6ZSkpO1xuICByZXR1cm4gZGVjb2RlMzIodGV4ZWwpO1xufVxuXG5mbG9hdCBnZXQxNihzYW1wbGVyMkQgdGV4LCBpdmVjMiB0ZXhTaXplLCBpdmVjMyB0ZXhEaW0sIGludCB6LCBpbnQgeSwgaW50IHgpIHtcbiAgaW50IGluZGV4ID0geCArIHRleERpbS54ICogKHkgKyB0ZXhEaW0ueSAqIHopO1xuICBpbnQgdyA9IHRleFNpemUueCAqIDI7XG4gIHZlYzIgc3QgPSB2ZWMyKGZsb2F0KGludGVnZXJNb2QoaW5kZXgsIHcpKSwgZmxvYXQoaW5kZXggLyB3KSkgKyAwLjU7XG4gIHZlYzQgdGV4ZWwgPSB0ZXh0dXJlMkQodGV4LCBzdCAvIHZlYzIodGV4U2l6ZS54ICogMiwgdGV4U2l6ZS55KSk7XG4gIHJldHVybiBkZWNvZGUxNih0ZXhlbCwgaW5kZXgpO1xufVxuXG5mbG9hdCBnZXQ4KHNhbXBsZXIyRCB0ZXgsIGl2ZWMyIHRleFNpemUsIGl2ZWMzIHRleERpbSwgaW50IHosIGludCB5LCBpbnQgeCkge1xuICBpbnQgaW5kZXggPSB4ICsgdGV4RGltLnggKiAoeSArIHRleERpbS55ICogeik7XG4gIGludCB3ID0gdGV4U2l6ZS54ICogNDtcbiAgdmVjMiBzdCA9IHZlYzIoZmxvYXQoaW50ZWdlck1vZChpbmRleCwgdykpLCBmbG9hdChpbmRleCAvIHcpKSArIDAuNTtcbiAgdmVjNCB0ZXhlbCA9IHRleHR1cmUyRCh0ZXgsIHN0IC8gdmVjMih0ZXhTaXplLnggKiA0LCB0ZXhTaXplLnkpKTtcbiAgcmV0dXJuIGRlY29kZTgodGV4ZWwsIGluZGV4KTtcbn1cblxuZmxvYXQgZ2V0TWVtb3J5T3B0aW1pemVkMzIoc2FtcGxlcjJEIHRleCwgaXZlYzIgdGV4U2l6ZSwgaXZlYzMgdGV4RGltLCBpbnQgeiwgaW50IHksIGludCB4KSB7XG4gIGludCBpbmRleCA9IHggKyB0ZXhEaW0ueCAqICh5ICsgdGV4RGltLnkgKiB6KTtcbiAgaW50IGNoYW5uZWwgPSBpbnRlZ2VyTW9kKGluZGV4LCA0KTtcbiAgaW5kZXggPSBpbmRleCAvIDQ7XG4gIGludCB3ID0gdGV4U2l6ZS54O1xuICB2ZWMyIHN0ID0gdmVjMihmbG9hdChpbnRlZ2VyTW9kKGluZGV4LCB3KSksIGZsb2F0KGluZGV4IC8gdykpICsgMC41O1xuICB2ZWM0IHRleGVsID0gdGV4dHVyZTJEKHRleCwgc3QgLyB2ZWMyKHRleFNpemUpKTtcbiAgaWYgKGNoYW5uZWwgPT0gMCkgcmV0dXJuIHRleGVsLnI7XG4gIGlmIChjaGFubmVsID09IDEpIHJldHVybiB0ZXhlbC5nO1xuICBpZiAoY2hhbm5lbCA9PSAyKSByZXR1cm4gdGV4ZWwuYjtcbiAgaWYgKGNoYW5uZWwgPT0gMykgcmV0dXJuIHRleGVsLmE7XG4gIHJldHVybiAwLjA7XG59XG5cbnZlYzQgZ2V0SW1hZ2UyRChzYW1wbGVyMkQgdGV4LCBpdmVjMiB0ZXhTaXplLCBpdmVjMyB0ZXhEaW0sIGludCB6LCBpbnQgeSwgaW50IHgpIHtcbiAgaW50IGluZGV4ID0geCArIHRleERpbS54ICogKHkgKyB0ZXhEaW0ueSAqIHopO1xuICBpbnQgdyA9IHRleFNpemUueDtcbiAgdmVjMiBzdCA9IHZlYzIoZmxvYXQoaW50ZWdlck1vZChpbmRleCwgdykpLCBmbG9hdChpbmRleCAvIHcpKSArIDAuNTtcbiAgcmV0dXJuIHRleHR1cmUyRCh0ZXgsIHN0IC8gdmVjMih0ZXhTaXplKSk7XG59XG5cbmZsb2F0IGdldEZsb2F0RnJvbVNhbXBsZXIyRChzYW1wbGVyMkQgdGV4LCBpdmVjMiB0ZXhTaXplLCBpdmVjMyB0ZXhEaW0sIGludCB6LCBpbnQgeSwgaW50IHgpIHtcbiAgdmVjNCByZXN1bHQgPSBnZXRJbWFnZTJEKHRleCwgdGV4U2l6ZSwgdGV4RGltLCB6LCB5LCB4KTtcbiAgcmV0dXJuIHJlc3VsdFswXTtcbn1cblxudmVjMiBnZXRWZWMyRnJvbVNhbXBsZXIyRChzYW1wbGVyMkQgdGV4LCBpdmVjMiB0ZXhTaXplLCBpdmVjMyB0ZXhEaW0sIGludCB6LCBpbnQgeSwgaW50IHgpIHtcbiAgdmVjNCByZXN1bHQgPSBnZXRJbWFnZTJEKHRleCwgdGV4U2l6ZSwgdGV4RGltLCB6LCB5LCB4KTtcbiAgcmV0dXJuIHZlYzIocmVzdWx0WzBdLCByZXN1bHRbMV0pO1xufVxuXG52ZWMyIGdldE1lbW9yeU9wdGltaXplZFZlYzIoc2FtcGxlcjJEIHRleCwgaXZlYzIgdGV4U2l6ZSwgaXZlYzMgdGV4RGltLCBpbnQgeiwgaW50IHksIGludCB4KSB7XG4gIGludCBpbmRleCA9IHggKyAodGV4RGltLnggKiAoeSArICh0ZXhEaW0ueSAqIHopKSk7XG4gIGludCBjaGFubmVsID0gaW50ZWdlck1vZChpbmRleCwgMik7XG4gIGluZGV4ID0gaW5kZXggLyAyO1xuICBpbnQgdyA9IHRleFNpemUueDtcbiAgdmVjMiBzdCA9IHZlYzIoZmxvYXQoaW50ZWdlck1vZChpbmRleCwgdykpLCBmbG9hdChpbmRleCAvIHcpKSArIDAuNTtcbiAgdmVjNCB0ZXhlbCA9IHRleHR1cmUyRCh0ZXgsIHN0IC8gdmVjMih0ZXhTaXplKSk7XG4gIGlmIChjaGFubmVsID09IDApIHJldHVybiB2ZWMyKHRleGVsLnIsIHRleGVsLmcpO1xuICBpZiAoY2hhbm5lbCA9PSAxKSByZXR1cm4gdmVjMih0ZXhlbC5iLCB0ZXhlbC5hKTtcbiAgcmV0dXJuIHZlYzIoMC4wLCAwLjApO1xufVxuXG52ZWMzIGdldFZlYzNGcm9tU2FtcGxlcjJEKHNhbXBsZXIyRCB0ZXgsIGl2ZWMyIHRleFNpemUsIGl2ZWMzIHRleERpbSwgaW50IHosIGludCB5LCBpbnQgeCkge1xuICB2ZWM0IHJlc3VsdCA9IGdldEltYWdlMkQodGV4LCB0ZXhTaXplLCB0ZXhEaW0sIHosIHksIHgpO1xuICByZXR1cm4gdmVjMyhyZXN1bHRbMF0sIHJlc3VsdFsxXSwgcmVzdWx0WzJdKTtcbn1cblxudmVjMyBnZXRNZW1vcnlPcHRpbWl6ZWRWZWMzKHNhbXBsZXIyRCB0ZXgsIGl2ZWMyIHRleFNpemUsIGl2ZWMzIHRleERpbSwgaW50IHosIGludCB5LCBpbnQgeCkge1xuICBpbnQgZmllbGRJbmRleCA9IDMgKiAoeCArIHRleERpbS54ICogKHkgKyB0ZXhEaW0ueSAqIHopKTtcbiAgaW50IHZlY3RvckluZGV4ID0gZmllbGRJbmRleCAvIDQ7XG4gIGludCB2ZWN0b3JPZmZzZXQgPSBmaWVsZEluZGV4IC0gdmVjdG9ySW5kZXggKiA0O1xuICBpbnQgcmVhZFkgPSB2ZWN0b3JJbmRleCAvIHRleFNpemUueDtcbiAgaW50IHJlYWRYID0gdmVjdG9ySW5kZXggLSByZWFkWSAqIHRleFNpemUueDtcbiAgdmVjNCB0ZXgxID0gdGV4dHVyZTJEKHRleCwgKHZlYzIocmVhZFgsIHJlYWRZKSArIDAuNSkgLyB2ZWMyKHRleFNpemUpKTtcbiAgXG4gIGlmICh2ZWN0b3JPZmZzZXQgPT0gMCkge1xuICAgIHJldHVybiB0ZXgxLnh5ejtcbiAgfSBlbHNlIGlmICh2ZWN0b3JPZmZzZXQgPT0gMSkge1xuICAgIHJldHVybiB0ZXgxLnl6dztcbiAgfSBlbHNlIHtcbiAgICByZWFkWCsrO1xuICAgIGlmIChyZWFkWCA+PSB0ZXhTaXplLngpIHtcbiAgICAgIHJlYWRYID0gMDtcbiAgICAgIHJlYWRZKys7XG4gICAgfVxuICAgIHZlYzQgdGV4MiA9IHRleHR1cmUyRCh0ZXgsIHZlYzIocmVhZFgsIHJlYWRZKSAvIHZlYzIodGV4U2l6ZSkpO1xuICAgIGlmICh2ZWN0b3JPZmZzZXQgPT0gMikge1xuICAgICAgcmV0dXJuIHZlYzModGV4MS56LCB0ZXgxLncsIHRleDIueCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB2ZWMzKHRleDEudywgdGV4Mi54LCB0ZXgyLnkpO1xuICAgIH1cbiAgfVxufVxuXG52ZWM0IGdldFZlYzRGcm9tU2FtcGxlcjJEKHNhbXBsZXIyRCB0ZXgsIGl2ZWMyIHRleFNpemUsIGl2ZWMzIHRleERpbSwgaW50IHosIGludCB5LCBpbnQgeCkge1xuICByZXR1cm4gZ2V0SW1hZ2UyRCh0ZXgsIHRleFNpemUsIHRleERpbSwgeiwgeSwgeCk7XG59XG5cbnZlYzQgZ2V0TWVtb3J5T3B0aW1pemVkVmVjNChzYW1wbGVyMkQgdGV4LCBpdmVjMiB0ZXhTaXplLCBpdmVjMyB0ZXhEaW0sIGludCB6LCBpbnQgeSwgaW50IHgpIHtcbiAgaW50IGluZGV4ID0geCArIHRleERpbS54ICogKHkgKyB0ZXhEaW0ueSAqIHopO1xuICBpbnQgY2hhbm5lbCA9IGludGVnZXJNb2QoaW5kZXgsIDIpO1xuICBpbnQgdyA9IHRleFNpemUueDtcbiAgdmVjMiBzdCA9IHZlYzIoZmxvYXQoaW50ZWdlck1vZChpbmRleCwgdykpLCBmbG9hdChpbmRleCAvIHcpKSArIDAuNTtcbiAgdmVjNCB0ZXhlbCA9IHRleHR1cmUyRCh0ZXgsIHN0IC8gdmVjMih0ZXhTaXplKSk7XG4gIHJldHVybiB2ZWM0KHRleGVsLnIsIHRleGVsLmcsIHRleGVsLmIsIHRleGVsLmEpO1xufVxuXG52ZWM0IGFjdHVhbENvbG9yO1xudm9pZCBjb2xvcihmbG9hdCByLCBmbG9hdCBnLCBmbG9hdCBiLCBmbG9hdCBhKSB7XG4gIGFjdHVhbENvbG9yID0gdmVjNChyLGcsYixhKTtcbn1cblxudm9pZCBjb2xvcihmbG9hdCByLCBmbG9hdCBnLCBmbG9hdCBiKSB7XG4gIGNvbG9yKHIsZyxiLDEuMCk7XG59XG5cbnZvaWQgY29sb3Ioc2FtcGxlcjJEIGltYWdlKSB7XG4gIGFjdHVhbENvbG9yID0gdGV4dHVyZTJEKGltYWdlLCB2VGV4Q29vcmQpO1xufVxuXG5mbG9hdCBtb2R1bG8oZmxvYXQgbnVtYmVyLCBmbG9hdCBkaXZpc29yKSB7XG4gIGlmIChudW1iZXIgPCAwLjApIHtcbiAgICBudW1iZXIgPSBhYnMobnVtYmVyKTtcbiAgICBpZiAoZGl2aXNvciA8IDAuMCkge1xuICAgICAgZGl2aXNvciA9IGFicyhkaXZpc29yKTtcbiAgICB9XG4gICAgcmV0dXJuIC1tb2QobnVtYmVyLCBkaXZpc29yKTtcbiAgfVxuICBpZiAoZGl2aXNvciA8IDAuMCkge1xuICAgIGRpdmlzb3IgPSBhYnMoZGl2aXNvcik7XG4gIH1cbiAgcmV0dXJuIG1vZChudW1iZXIsIGRpdmlzb3IpO1xufVxuXG5fX0lOSkVDVEVEX05BVElWRV9fO1xuX19NQUlOX0NPTlNUQU5UU19fO1xuX19NQUlOX0FSR1VNRU5UU19fO1xuX19LRVJORUxfXztcblxudm9pZCBtYWluKHZvaWQpIHtcbiAgaW5kZXggPSBpbnQodlRleENvb3JkLnMgKiBmbG9hdCh1VGV4U2l6ZS54KSkgKyBpbnQodlRleENvb3JkLnQgKiBmbG9hdCh1VGV4U2l6ZS55KSkgKiB1VGV4U2l6ZS54O1xuICBfX01BSU5fUkVTVUxUX187XG59YDtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGZyYWdtZW50U2hhZGVyXG59O1xufSx7fV0sMzg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHsgRnVuY3Rpb25Ob2RlIH0gPSByZXF1aXJlKCcuLi9mdW5jdGlvbi1ub2RlJyk7XG5cbmNsYXNzIFdlYkdMRnVuY3Rpb25Ob2RlIGV4dGVuZHMgRnVuY3Rpb25Ob2RlIHtcbiAgY29uc3RydWN0b3Ioc291cmNlLCBzZXR0aW5ncykge1xuICAgIHN1cGVyKHNvdXJjZSwgc2V0dGluZ3MpO1xuICAgIGlmIChzZXR0aW5ncyAmJiBzZXR0aW5ncy5oYXNPd25Qcm9wZXJ0eSgnZml4SW50ZWdlckRpdmlzaW9uQWNjdXJhY3knKSkge1xuICAgICAgdGhpcy5maXhJbnRlZ2VyRGl2aXNpb25BY2N1cmFjeSA9IHNldHRpbmdzLmZpeEludGVnZXJEaXZpc2lvbkFjY3VyYWN5O1xuICAgIH1cbiAgfVxuXG4gIGFzdENvbmRpdGlvbmFsRXhwcmVzc2lvbihhc3QsIHJldEFycikge1xuICAgIGlmIChhc3QudHlwZSAhPT0gJ0NvbmRpdGlvbmFsRXhwcmVzc2lvbicpIHtcbiAgICAgIHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoJ05vdCBhIGNvbmRpdGlvbmFsIGV4cHJlc3Npb24nLCBhc3QpO1xuICAgIH1cbiAgICBjb25zdCBjb25zZXF1ZW50VHlwZSA9IHRoaXMuZ2V0VHlwZShhc3QuY29uc2VxdWVudCk7XG4gICAgY29uc3QgYWx0ZXJuYXRlVHlwZSA9IHRoaXMuZ2V0VHlwZShhc3QuYWx0ZXJuYXRlKTtcbiAgICBpZiAoY29uc2VxdWVudFR5cGUgPT09IG51bGwgJiYgYWx0ZXJuYXRlVHlwZSA9PT0gbnVsbCkge1xuICAgICAgcmV0QXJyLnB1c2goJ2lmICgnKTtcbiAgICAgIHRoaXMuYXN0R2VuZXJpYyhhc3QudGVzdCwgcmV0QXJyKTtcbiAgICAgIHJldEFyci5wdXNoKCcpIHsnKTtcbiAgICAgIHRoaXMuYXN0R2VuZXJpYyhhc3QuY29uc2VxdWVudCwgcmV0QXJyKTtcbiAgICAgIHJldEFyci5wdXNoKCc7Jyk7XG4gICAgICByZXRBcnIucHVzaCgnfSBlbHNlIHsnKTtcbiAgICAgIHRoaXMuYXN0R2VuZXJpYyhhc3QuYWx0ZXJuYXRlLCByZXRBcnIpO1xuICAgICAgcmV0QXJyLnB1c2goJzsnKTtcbiAgICAgIHJldEFyci5wdXNoKCd9Jyk7XG4gICAgICByZXR1cm4gcmV0QXJyO1xuICAgIH1cbiAgICByZXRBcnIucHVzaCgnKCcpO1xuICAgIHRoaXMuYXN0R2VuZXJpYyhhc3QudGVzdCwgcmV0QXJyKTtcbiAgICByZXRBcnIucHVzaCgnPycpO1xuICAgIHRoaXMuYXN0R2VuZXJpYyhhc3QuY29uc2VxdWVudCwgcmV0QXJyKTtcbiAgICByZXRBcnIucHVzaCgnOicpO1xuICAgIHRoaXMuYXN0R2VuZXJpYyhhc3QuYWx0ZXJuYXRlLCByZXRBcnIpO1xuICAgIHJldEFyci5wdXNoKCcpJyk7XG4gICAgcmV0dXJuIHJldEFycjtcbiAgfVxuXG4gIGFzdEZ1bmN0aW9uKGFzdCwgcmV0QXJyKSB7XG4gICAgaWYgKHRoaXMuaXNSb290S2VybmVsKSB7XG4gICAgICByZXRBcnIucHVzaCgndm9pZCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIXRoaXMucmV0dXJuVHlwZSkge1xuICAgICAgICBjb25zdCBsYXN0UmV0dXJuID0gdGhpcy5maW5kTGFzdFJldHVybigpO1xuICAgICAgICBpZiAobGFzdFJldHVybikge1xuICAgICAgICAgIHRoaXMucmV0dXJuVHlwZSA9IHRoaXMuZ2V0VHlwZShhc3QuYm9keSk7XG4gICAgICAgICAgaWYgKHRoaXMucmV0dXJuVHlwZSA9PT0gJ0xpdGVyYWxJbnRlZ2VyJykge1xuICAgICAgICAgICAgdGhpcy5yZXR1cm5UeXBlID0gJ051bWJlcic7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHsgcmV0dXJuVHlwZSB9ID0gdGhpcztcbiAgICAgIGlmICghcmV0dXJuVHlwZSkge1xuICAgICAgICByZXRBcnIucHVzaCgndm9pZCcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgdHlwZSA9IHR5cGVNYXBbcmV0dXJuVHlwZV07XG4gICAgICAgIGlmICghdHlwZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgdW5rbm93biB0eXBlICR7cmV0dXJuVHlwZX1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXRBcnIucHVzaCh0eXBlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0QXJyLnB1c2goJyAnKTtcbiAgICByZXRBcnIucHVzaCh0aGlzLm5hbWUpO1xuICAgIHJldEFyci5wdXNoKCcoJyk7XG5cbiAgICBpZiAoIXRoaXMuaXNSb290S2VybmVsKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuYXJndW1lbnROYW1lcy5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBhcmd1bWVudE5hbWUgPSB0aGlzLmFyZ3VtZW50TmFtZXNbaV07XG5cbiAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgcmV0QXJyLnB1c2goJywgJyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGFyZ3VtZW50VHlwZSA9IHRoaXMuYXJndW1lbnRUeXBlc1t0aGlzLmFyZ3VtZW50TmFtZXMuaW5kZXhPZihhcmd1bWVudE5hbWUpXTtcbiAgICAgICAgaWYgKCFhcmd1bWVudFR5cGUpIHtcbiAgICAgICAgICB0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KGBVbmtub3duIGFyZ3VtZW50ICR7YXJndW1lbnROYW1lfSB0eXBlYCwgYXN0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXJndW1lbnRUeXBlID09PSAnTGl0ZXJhbEludGVnZXInKSB7XG4gICAgICAgICAgdGhpcy5hcmd1bWVudFR5cGVzW2ldID0gYXJndW1lbnRUeXBlID0gJ051bWJlcic7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdHlwZSA9IHR5cGVNYXBbYXJndW1lbnRUeXBlXTtcbiAgICAgICAgaWYgKCF0eXBlKSB7XG4gICAgICAgICAgdGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dCgnVW5leHBlY3RlZCBleHByZXNzaW9uJywgYXN0KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuYW1lID0gdXRpbHMuc2FuaXRpemVOYW1lKGFyZ3VtZW50TmFtZSk7XG4gICAgICAgIGlmICh0eXBlID09PSAnc2FtcGxlcjJEJyB8fCB0eXBlID09PSAnc2FtcGxlcjJEQXJyYXknKSB7XG4gICAgICAgICAgcmV0QXJyLnB1c2goYCR7dHlwZX0gdXNlcl8ke25hbWV9LGl2ZWMyIHVzZXJfJHtuYW1lfVNpemUsaXZlYzMgdXNlcl8ke25hbWV9RGltYCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0QXJyLnB1c2goYCR7dHlwZX0gdXNlcl8ke25hbWV9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXRBcnIucHVzaCgnKSB7XFxuJyk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFzdC5ib2R5LmJvZHkubGVuZ3RoOyArK2kpIHtcbiAgICAgIHRoaXMuYXN0R2VuZXJpYyhhc3QuYm9keS5ib2R5W2ldLCByZXRBcnIpO1xuICAgICAgcmV0QXJyLnB1c2goJ1xcbicpO1xuICAgIH1cblxuICAgIHJldEFyci5wdXNoKCd9XFxuJyk7XG4gICAgcmV0dXJuIHJldEFycjtcbiAgfVxuXG4gIGFzdFJldHVyblN0YXRlbWVudChhc3QsIHJldEFycikge1xuICAgIGlmICghYXN0LmFyZ3VtZW50KSB0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KCdVbmV4cGVjdGVkIHJldHVybiBzdGF0ZW1lbnQnLCBhc3QpO1xuICAgIHRoaXMucHVzaFN0YXRlKCdza2lwLWxpdGVyYWwtY29ycmVjdGlvbicpO1xuICAgIGNvbnN0IHR5cGUgPSB0aGlzLmdldFR5cGUoYXN0LmFyZ3VtZW50KTtcbiAgICB0aGlzLnBvcFN0YXRlKCdza2lwLWxpdGVyYWwtY29ycmVjdGlvbicpO1xuXG4gICAgY29uc3QgcmVzdWx0ID0gW107XG5cbiAgICBpZiAoIXRoaXMucmV0dXJuVHlwZSkge1xuICAgICAgaWYgKHR5cGUgPT09ICdMaXRlcmFsSW50ZWdlcicgfHwgdHlwZSA9PT0gJ0ludGVnZXInKSB7XG4gICAgICAgIHRoaXMucmV0dXJuVHlwZSA9ICdOdW1iZXInO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5yZXR1cm5UeXBlID0gdHlwZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzd2l0Y2ggKHRoaXMucmV0dXJuVHlwZSkge1xuICAgICAgY2FzZSAnTGl0ZXJhbEludGVnZXInOlxuICAgICAgY2FzZSAnTnVtYmVyJzpcbiAgICAgIGNhc2UgJ0Zsb2F0JzpcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgY2FzZSAnSW50ZWdlcic6XG4gICAgICAgICAgICByZXN1bHQucHVzaCgnZmxvYXQoJyk7XG4gICAgICAgICAgICB0aGlzLmFzdEdlbmVyaWMoYXN0LmFyZ3VtZW50LCByZXN1bHQpO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goJyknKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ0xpdGVyYWxJbnRlZ2VyJzpcbiAgICAgICAgICAgIHRoaXMuY2FzdExpdGVyYWxUb0Zsb2F0KGFzdC5hcmd1bWVudCwgcmVzdWx0KTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuZ2V0VHlwZShhc3QpID09PSAnSW50ZWdlcicpIHtcbiAgICAgICAgICAgICAgcmVzdWx0LnVuc2hpZnQoJ2Zsb2F0KCcpO1xuICAgICAgICAgICAgICByZXN1bHQucHVzaCgnKScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRoaXMuYXN0R2VuZXJpYyhhc3QuYXJndW1lbnQsIHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdJbnRlZ2VyJzpcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgY2FzZSAnRmxvYXQnOlxuICAgICAgICAgIGNhc2UgJ051bWJlcic6XG4gICAgICAgICAgICB0aGlzLmNhc3RWYWx1ZVRvSW50ZWdlcihhc3QuYXJndW1lbnQsIHJlc3VsdCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdMaXRlcmFsSW50ZWdlcic6XG4gICAgICAgICAgICB0aGlzLmNhc3RMaXRlcmFsVG9JbnRlZ2VyKGFzdC5hcmd1bWVudCwgcmVzdWx0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aGlzLmFzdEdlbmVyaWMoYXN0LmFyZ3VtZW50LCByZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnQXJyYXkoNCknOlxuICAgICAgY2FzZSAnQXJyYXkoMyknOlxuICAgICAgY2FzZSAnQXJyYXkoMiknOlxuICAgICAgY2FzZSAnTWF0cml4KDIpJzpcbiAgICAgIGNhc2UgJ01hdHJpeCgzKSc6XG4gICAgICBjYXNlICdNYXRyaXgoNCknOlxuICAgICAgY2FzZSAnSW5wdXQnOlxuICAgICAgICB0aGlzLmFzdEdlbmVyaWMoYXN0LmFyZ3VtZW50LCByZXN1bHQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoYHVuaGFuZGxlZCByZXR1cm4gdHlwZSAke3RoaXMucmV0dXJuVHlwZX1gLCBhc3QpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmlzUm9vdEtlcm5lbCkge1xuICAgICAgcmV0QXJyLnB1c2goYGtlcm5lbFJlc3VsdCA9ICR7IHJlc3VsdC5qb2luKCcnKSB9O2ApO1xuICAgICAgcmV0QXJyLnB1c2goJ3JldHVybjsnKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNTdWJLZXJuZWwpIHtcbiAgICAgIHJldEFyci5wdXNoKGBzdWJLZXJuZWxSZXN1bHRfJHsgdGhpcy5uYW1lIH0gPSAkeyByZXN1bHQuam9pbignJykgfTtgKTtcbiAgICAgIHJldEFyci5wdXNoKGByZXR1cm4gc3ViS2VybmVsUmVzdWx0XyR7IHRoaXMubmFtZSB9O2ApO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXRBcnIucHVzaChgcmV0dXJuICR7IHJlc3VsdC5qb2luKCcnKSB9O2ApO1xuICAgIH1cbiAgICByZXR1cm4gcmV0QXJyO1xuICB9XG5cbiAgYXN0TGl0ZXJhbChhc3QsIHJldEFycikge1xuICAgIGlmIChpc05hTihhc3QudmFsdWUpKSB7XG4gICAgICB0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KFxuICAgICAgICAnTm9uLW51bWVyaWMgbGl0ZXJhbCBub3Qgc3VwcG9ydGVkIDogJyArIGFzdC52YWx1ZSxcbiAgICAgICAgYXN0XG4gICAgICApO1xuICAgIH1cblxuICAgIGNvbnN0IGtleSA9IHRoaXMuYXN0S2V5KGFzdCk7XG4gICAgaWYgKE51bWJlci5pc0ludGVnZXIoYXN0LnZhbHVlKSkge1xuICAgICAgaWYgKHRoaXMuaXNTdGF0ZSgnY2FzdGluZy10by1pbnRlZ2VyJykgfHwgdGhpcy5pc1N0YXRlKCdidWlsZGluZy1pbnRlZ2VyJykpIHtcbiAgICAgICAgdGhpcy5saXRlcmFsVHlwZXNba2V5XSA9ICdJbnRlZ2VyJztcbiAgICAgICAgcmV0QXJyLnB1c2goYCR7YXN0LnZhbHVlfWApO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmlzU3RhdGUoJ2Nhc3RpbmctdG8tZmxvYXQnKSB8fCB0aGlzLmlzU3RhdGUoJ2J1aWxkaW5nLWZsb2F0JykpIHtcbiAgICAgICAgdGhpcy5saXRlcmFsVHlwZXNba2V5XSA9ICdOdW1iZXInO1xuICAgICAgICByZXRBcnIucHVzaChgJHthc3QudmFsdWV9LjBgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubGl0ZXJhbFR5cGVzW2tleV0gPSAnTnVtYmVyJztcbiAgICAgICAgcmV0QXJyLnB1c2goYCR7YXN0LnZhbHVlfS4wYCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzU3RhdGUoJ2Nhc3RpbmctdG8taW50ZWdlcicpIHx8IHRoaXMuaXNTdGF0ZSgnYnVpbGRpbmctaW50ZWdlcicpKSB7XG4gICAgICB0aGlzLmxpdGVyYWxUeXBlc1trZXldID0gJ0ludGVnZXInO1xuICAgICAgcmV0QXJyLnB1c2goTWF0aC5yb3VuZChhc3QudmFsdWUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5saXRlcmFsVHlwZXNba2V5XSA9ICdOdW1iZXInO1xuICAgICAgcmV0QXJyLnB1c2goYCR7YXN0LnZhbHVlfWApO1xuICAgIH1cbiAgICByZXR1cm4gcmV0QXJyO1xuICB9XG5cbiAgYXN0QmluYXJ5RXhwcmVzc2lvbihhc3QsIHJldEFycikge1xuICAgIGlmICh0aGlzLmNoZWNrQW5kVXBjb252ZXJ0T3BlcmF0b3IoYXN0LCByZXRBcnIpKSB7XG4gICAgICByZXR1cm4gcmV0QXJyO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmZpeEludGVnZXJEaXZpc2lvbkFjY3VyYWN5ICYmIGFzdC5vcGVyYXRvciA9PT0gJy8nKSB7XG4gICAgICByZXRBcnIucHVzaCgnZGl2V2l0aEludENoZWNrKCcpO1xuICAgICAgdGhpcy5wdXNoU3RhdGUoJ2J1aWxkaW5nLWZsb2F0Jyk7XG4gICAgICBzd2l0Y2ggKHRoaXMuZ2V0VHlwZShhc3QubGVmdCkpIHtcbiAgICAgICAgY2FzZSAnSW50ZWdlcic6XG4gICAgICAgICAgdGhpcy5jYXN0VmFsdWVUb0Zsb2F0KGFzdC5sZWZ0LCByZXRBcnIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdMaXRlcmFsSW50ZWdlcic6XG4gICAgICAgICAgdGhpcy5jYXN0TGl0ZXJhbFRvRmxvYXQoYXN0LmxlZnQsIHJldEFycik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhpcy5hc3RHZW5lcmljKGFzdC5sZWZ0LCByZXRBcnIpO1xuICAgICAgfVxuICAgICAgcmV0QXJyLnB1c2goJywgJyk7XG4gICAgICBzd2l0Y2ggKHRoaXMuZ2V0VHlwZShhc3QucmlnaHQpKSB7XG4gICAgICAgIGNhc2UgJ0ludGVnZXInOlxuICAgICAgICAgIHRoaXMuY2FzdFZhbHVlVG9GbG9hdChhc3QucmlnaHQsIHJldEFycik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ0xpdGVyYWxJbnRlZ2VyJzpcbiAgICAgICAgICB0aGlzLmNhc3RMaXRlcmFsVG9GbG9hdChhc3QucmlnaHQsIHJldEFycik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhpcy5hc3RHZW5lcmljKGFzdC5yaWdodCwgcmV0QXJyKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucG9wU3RhdGUoJ2J1aWxkaW5nLWZsb2F0Jyk7XG4gICAgICByZXRBcnIucHVzaCgnKScpO1xuICAgICAgcmV0dXJuIHJldEFycjtcbiAgICB9XG5cbiAgICByZXRBcnIucHVzaCgnKCcpO1xuICAgIGNvbnN0IGxlZnRUeXBlID0gdGhpcy5nZXRUeXBlKGFzdC5sZWZ0KSB8fCAnTnVtYmVyJztcbiAgICBjb25zdCByaWdodFR5cGUgPSB0aGlzLmdldFR5cGUoYXN0LnJpZ2h0KSB8fCAnTnVtYmVyJztcbiAgICBpZiAoIWxlZnRUeXBlIHx8ICFyaWdodFR5cGUpIHtcbiAgICAgIHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoYFVuaGFuZGxlZCBiaW5hcnkgZXhwcmVzc2lvbmAsIGFzdCk7XG4gICAgfVxuICAgIGNvbnN0IGtleSA9IGxlZnRUeXBlICsgJyAmICcgKyByaWdodFR5cGU7XG4gICAgc3dpdGNoIChrZXkpIHtcbiAgICAgIGNhc2UgJ0ludGVnZXIgJiBJbnRlZ2VyJzpcbiAgICAgICAgdGhpcy5wdXNoU3RhdGUoJ2J1aWxkaW5nLWludGVnZXInKTtcbiAgICAgICAgdGhpcy5hc3RHZW5lcmljKGFzdC5sZWZ0LCByZXRBcnIpO1xuICAgICAgICByZXRBcnIucHVzaChvcGVyYXRvck1hcFthc3Qub3BlcmF0b3JdIHx8IGFzdC5vcGVyYXRvcik7XG4gICAgICAgIHRoaXMuYXN0R2VuZXJpYyhhc3QucmlnaHQsIHJldEFycik7XG4gICAgICAgIHRoaXMucG9wU3RhdGUoJ2J1aWxkaW5nLWludGVnZXInKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdOdW1iZXIgJiBGbG9hdCc6XG4gICAgICBjYXNlICdGbG9hdCAmIE51bWJlcic6XG4gICAgICBjYXNlICdGbG9hdCAmIEZsb2F0JzpcbiAgICAgIGNhc2UgJ051bWJlciAmIE51bWJlcic6XG4gICAgICAgIHRoaXMucHVzaFN0YXRlKCdidWlsZGluZy1mbG9hdCcpO1xuICAgICAgICB0aGlzLmFzdEdlbmVyaWMoYXN0LmxlZnQsIHJldEFycik7XG4gICAgICAgIHJldEFyci5wdXNoKG9wZXJhdG9yTWFwW2FzdC5vcGVyYXRvcl0gfHwgYXN0Lm9wZXJhdG9yKTtcbiAgICAgICAgdGhpcy5hc3RHZW5lcmljKGFzdC5yaWdodCwgcmV0QXJyKTtcbiAgICAgICAgdGhpcy5wb3BTdGF0ZSgnYnVpbGRpbmctZmxvYXQnKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdMaXRlcmFsSW50ZWdlciAmIExpdGVyYWxJbnRlZ2VyJzpcbiAgICAgICAgaWYgKHRoaXMuaXNTdGF0ZSgnY2FzdGluZy10by1pbnRlZ2VyJykgfHwgdGhpcy5pc1N0YXRlKCdidWlsZGluZy1pbnRlZ2VyJykpIHtcbiAgICAgICAgICB0aGlzLnB1c2hTdGF0ZSgnYnVpbGRpbmctaW50ZWdlcicpO1xuICAgICAgICAgIHRoaXMuYXN0R2VuZXJpYyhhc3QubGVmdCwgcmV0QXJyKTtcbiAgICAgICAgICByZXRBcnIucHVzaChvcGVyYXRvck1hcFthc3Qub3BlcmF0b3JdIHx8IGFzdC5vcGVyYXRvcik7XG4gICAgICAgICAgdGhpcy5hc3RHZW5lcmljKGFzdC5yaWdodCwgcmV0QXJyKTtcbiAgICAgICAgICB0aGlzLnBvcFN0YXRlKCdidWlsZGluZy1pbnRlZ2VyJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5wdXNoU3RhdGUoJ2J1aWxkaW5nLWZsb2F0Jyk7XG4gICAgICAgICAgdGhpcy5jYXN0TGl0ZXJhbFRvRmxvYXQoYXN0LmxlZnQsIHJldEFycik7XG4gICAgICAgICAgcmV0QXJyLnB1c2gob3BlcmF0b3JNYXBbYXN0Lm9wZXJhdG9yXSB8fCBhc3Qub3BlcmF0b3IpO1xuICAgICAgICAgIHRoaXMuY2FzdExpdGVyYWxUb0Zsb2F0KGFzdC5yaWdodCwgcmV0QXJyKTtcbiAgICAgICAgICB0aGlzLnBvcFN0YXRlKCdidWlsZGluZy1mbG9hdCcpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdJbnRlZ2VyICYgRmxvYXQnOlxuICAgICAgY2FzZSAnSW50ZWdlciAmIE51bWJlcic6XG4gICAgICAgIGlmIChhc3Qub3BlcmF0b3IgPT09ICc+JyB8fCBhc3Qub3BlcmF0b3IgPT09ICc8JyAmJiBhc3QucmlnaHQudHlwZSA9PT0gJ0xpdGVyYWwnKSB7XG4gICAgICAgICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKGFzdC5yaWdodC52YWx1ZSkpIHtcbiAgICAgICAgICAgIHRoaXMucHVzaFN0YXRlKCdidWlsZGluZy1mbG9hdCcpO1xuICAgICAgICAgICAgdGhpcy5jYXN0VmFsdWVUb0Zsb2F0KGFzdC5sZWZ0LCByZXRBcnIpO1xuICAgICAgICAgICAgcmV0QXJyLnB1c2gob3BlcmF0b3JNYXBbYXN0Lm9wZXJhdG9yXSB8fCBhc3Qub3BlcmF0b3IpO1xuICAgICAgICAgICAgdGhpcy5hc3RHZW5lcmljKGFzdC5yaWdodCwgcmV0QXJyKTtcbiAgICAgICAgICAgIHRoaXMucG9wU3RhdGUoJ2J1aWxkaW5nLWZsb2F0Jyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wdXNoU3RhdGUoJ2J1aWxkaW5nLWludGVnZXInKTtcbiAgICAgICAgdGhpcy5hc3RHZW5lcmljKGFzdC5sZWZ0LCByZXRBcnIpO1xuICAgICAgICByZXRBcnIucHVzaChvcGVyYXRvck1hcFthc3Qub3BlcmF0b3JdIHx8IGFzdC5vcGVyYXRvcik7XG4gICAgICAgIHRoaXMucHVzaFN0YXRlKCdjYXN0aW5nLXRvLWludGVnZXInKTtcbiAgICAgICAgaWYgKGFzdC5yaWdodC50eXBlID09PSAnTGl0ZXJhbCcpIHtcbiAgICAgICAgICBjb25zdCBsaXRlcmFsUmVzdWx0ID0gW107XG4gICAgICAgICAgdGhpcy5hc3RHZW5lcmljKGFzdC5yaWdodCwgbGl0ZXJhbFJlc3VsdCk7XG4gICAgICAgICAgY29uc3QgbGl0ZXJhbFR5cGUgPSB0aGlzLmdldFR5cGUoYXN0LnJpZ2h0KTtcbiAgICAgICAgICBpZiAobGl0ZXJhbFR5cGUgPT09ICdJbnRlZ2VyJykge1xuICAgICAgICAgICAgcmV0QXJyLnB1c2gobGl0ZXJhbFJlc3VsdC5qb2luKCcnKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoYFVuaGFuZGxlZCBiaW5hcnkgZXhwcmVzc2lvbiB3aXRoIGxpdGVyYWxgLCBhc3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXRBcnIucHVzaCgnaW50KCcpO1xuICAgICAgICAgIHRoaXMuYXN0R2VuZXJpYyhhc3QucmlnaHQsIHJldEFycik7XG4gICAgICAgICAgcmV0QXJyLnB1c2goJyknKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBvcFN0YXRlKCdjYXN0aW5nLXRvLWludGVnZXInKTtcbiAgICAgICAgdGhpcy5wb3BTdGF0ZSgnYnVpbGRpbmctaW50ZWdlcicpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0ludGVnZXIgJiBMaXRlcmFsSW50ZWdlcic6XG4gICAgICAgIHRoaXMucHVzaFN0YXRlKCdidWlsZGluZy1pbnRlZ2VyJyk7XG4gICAgICAgIHRoaXMuYXN0R2VuZXJpYyhhc3QubGVmdCwgcmV0QXJyKTtcbiAgICAgICAgcmV0QXJyLnB1c2gob3BlcmF0b3JNYXBbYXN0Lm9wZXJhdG9yXSB8fCBhc3Qub3BlcmF0b3IpO1xuICAgICAgICB0aGlzLmNhc3RMaXRlcmFsVG9JbnRlZ2VyKGFzdC5yaWdodCwgcmV0QXJyKTtcbiAgICAgICAgdGhpcy5wb3BTdGF0ZSgnYnVpbGRpbmctaW50ZWdlcicpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnTnVtYmVyICYgSW50ZWdlcic6XG4gICAgICAgIHRoaXMucHVzaFN0YXRlKCdidWlsZGluZy1mbG9hdCcpO1xuICAgICAgICB0aGlzLmFzdEdlbmVyaWMoYXN0LmxlZnQsIHJldEFycik7XG4gICAgICAgIHJldEFyci5wdXNoKG9wZXJhdG9yTWFwW2FzdC5vcGVyYXRvcl0gfHwgYXN0Lm9wZXJhdG9yKTtcbiAgICAgICAgdGhpcy5jYXN0VmFsdWVUb0Zsb2F0KGFzdC5yaWdodCwgcmV0QXJyKTtcbiAgICAgICAgdGhpcy5wb3BTdGF0ZSgnYnVpbGRpbmctZmxvYXQnKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdGbG9hdCAmIExpdGVyYWxJbnRlZ2VyJzpcbiAgICAgIGNhc2UgJ051bWJlciAmIExpdGVyYWxJbnRlZ2VyJzpcbiAgICAgICAgdGhpcy5wdXNoU3RhdGUoJ2J1aWxkaW5nLWZsb2F0Jyk7XG4gICAgICAgIHRoaXMuYXN0R2VuZXJpYyhhc3QubGVmdCwgcmV0QXJyKTtcbiAgICAgICAgcmV0QXJyLnB1c2gob3BlcmF0b3JNYXBbYXN0Lm9wZXJhdG9yXSB8fCBhc3Qub3BlcmF0b3IpO1xuICAgICAgICB0aGlzLmNhc3RMaXRlcmFsVG9GbG9hdChhc3QucmlnaHQsIHJldEFycik7XG4gICAgICAgIHRoaXMucG9wU3RhdGUoJ2J1aWxkaW5nLWZsb2F0Jyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnTGl0ZXJhbEludGVnZXIgJiBGbG9hdCc6XG4gICAgICBjYXNlICdMaXRlcmFsSW50ZWdlciAmIE51bWJlcic6XG4gICAgICAgIGlmICh0aGlzLmlzU3RhdGUoJ2Nhc3RpbmctdG8taW50ZWdlcicpKSB7XG4gICAgICAgICAgdGhpcy5wdXNoU3RhdGUoJ2J1aWxkaW5nLWludGVnZXInKTtcbiAgICAgICAgICB0aGlzLmNhc3RMaXRlcmFsVG9JbnRlZ2VyKGFzdC5sZWZ0LCByZXRBcnIpO1xuICAgICAgICAgIHJldEFyci5wdXNoKG9wZXJhdG9yTWFwW2FzdC5vcGVyYXRvcl0gfHwgYXN0Lm9wZXJhdG9yKTtcbiAgICAgICAgICB0aGlzLmNhc3RWYWx1ZVRvSW50ZWdlcihhc3QucmlnaHQsIHJldEFycik7XG4gICAgICAgICAgdGhpcy5wb3BTdGF0ZSgnYnVpbGRpbmctaW50ZWdlcicpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucHVzaFN0YXRlKCdidWlsZGluZy1mbG9hdCcpO1xuICAgICAgICAgIHRoaXMuYXN0R2VuZXJpYyhhc3QubGVmdCwgcmV0QXJyKTtcbiAgICAgICAgICByZXRBcnIucHVzaChvcGVyYXRvck1hcFthc3Qub3BlcmF0b3JdIHx8IGFzdC5vcGVyYXRvcik7XG4gICAgICAgICAgdGhpcy5wdXNoU3RhdGUoJ2Nhc3RpbmctdG8tZmxvYXQnKTtcbiAgICAgICAgICB0aGlzLmFzdEdlbmVyaWMoYXN0LnJpZ2h0LCByZXRBcnIpO1xuICAgICAgICAgIHRoaXMucG9wU3RhdGUoJ2Nhc3RpbmctdG8tZmxvYXQnKTtcbiAgICAgICAgICB0aGlzLnBvcFN0YXRlKCdidWlsZGluZy1mbG9hdCcpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnTGl0ZXJhbEludGVnZXIgJiBJbnRlZ2VyJzpcbiAgICAgICAgdGhpcy5wdXNoU3RhdGUoJ2J1aWxkaW5nLWludGVnZXInKTtcbiAgICAgICAgdGhpcy5jYXN0TGl0ZXJhbFRvSW50ZWdlcihhc3QubGVmdCwgcmV0QXJyKTtcbiAgICAgICAgcmV0QXJyLnB1c2gob3BlcmF0b3JNYXBbYXN0Lm9wZXJhdG9yXSB8fCBhc3Qub3BlcmF0b3IpO1xuICAgICAgICB0aGlzLmFzdEdlbmVyaWMoYXN0LnJpZ2h0LCByZXRBcnIpO1xuICAgICAgICB0aGlzLnBvcFN0YXRlKCdidWlsZGluZy1pbnRlZ2VyJyk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdCb29sZWFuICYgQm9vbGVhbic6XG4gICAgICAgIHRoaXMucHVzaFN0YXRlKCdidWlsZGluZy1ib29sZWFuJyk7XG4gICAgICAgIHRoaXMuYXN0R2VuZXJpYyhhc3QubGVmdCwgcmV0QXJyKTtcbiAgICAgICAgcmV0QXJyLnB1c2gob3BlcmF0b3JNYXBbYXN0Lm9wZXJhdG9yXSB8fCBhc3Qub3BlcmF0b3IpO1xuICAgICAgICB0aGlzLmFzdEdlbmVyaWMoYXN0LnJpZ2h0LCByZXRBcnIpO1xuICAgICAgICB0aGlzLnBvcFN0YXRlKCdidWlsZGluZy1ib29sZWFuJyk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdGbG9hdCAmIEludGVnZXInOlxuICAgICAgICB0aGlzLnB1c2hTdGF0ZSgnYnVpbGRpbmctZmxvYXQnKTtcbiAgICAgICAgdGhpcy5hc3RHZW5lcmljKGFzdC5sZWZ0LCByZXRBcnIpO1xuICAgICAgICByZXRBcnIucHVzaChvcGVyYXRvck1hcFthc3Qub3BlcmF0b3JdIHx8IGFzdC5vcGVyYXRvcik7XG4gICAgICAgIHRoaXMuY2FzdFZhbHVlVG9GbG9hdChhc3QucmlnaHQsIHJldEFycik7XG4gICAgICAgIHRoaXMucG9wU3RhdGUoJ2J1aWxkaW5nLWZsb2F0Jyk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KGBVbmhhbmRsZWQgYmluYXJ5IGV4cHJlc3Npb24gYmV0d2VlbiAke2tleX1gLCBhc3QpO1xuICAgIH1cbiAgICByZXRBcnIucHVzaCgnKScpO1xuXG4gICAgcmV0dXJuIHJldEFycjtcbiAgfVxuXG4gIGNoZWNrQW5kVXBjb252ZXJ0T3BlcmF0b3IoYXN0LCByZXRBcnIpIHtcbiAgICBjb25zdCBiaXR3aXNlUmVzdWx0ID0gdGhpcy5jaGVja0FuZFVwY29udmVydEJpdHdpc2VPcGVyYXRvcnMoYXN0LCByZXRBcnIpO1xuICAgIGlmIChiaXR3aXNlUmVzdWx0KSB7XG4gICAgICByZXR1cm4gYml0d2lzZVJlc3VsdDtcbiAgICB9XG4gICAgY29uc3QgdXBjb252ZXJ0YWJsZU9wZXJhdG9ycyA9IHtcbiAgICAgICclJzogdGhpcy5maXhJbnRlZ2VyRGl2aXNpb25BY2N1cmFjeSA/ICdpbnRlZ2VyQ29ycmVjdGlvbk1vZHVsbycgOiAnbW9kdWxvJyxcbiAgICAgICcqKic6ICdwb3cnLFxuICAgIH07XG4gICAgY29uc3QgZm91bmRPcGVyYXRvciA9IHVwY29udmVydGFibGVPcGVyYXRvcnNbYXN0Lm9wZXJhdG9yXTtcbiAgICBpZiAoIWZvdW5kT3BlcmF0b3IpIHJldHVybiBudWxsO1xuICAgIHJldEFyci5wdXNoKGZvdW5kT3BlcmF0b3IpO1xuICAgIHJldEFyci5wdXNoKCcoJyk7XG4gICAgc3dpdGNoICh0aGlzLmdldFR5cGUoYXN0LmxlZnQpKSB7XG4gICAgICBjYXNlICdJbnRlZ2VyJzpcbiAgICAgICAgdGhpcy5jYXN0VmFsdWVUb0Zsb2F0KGFzdC5sZWZ0LCByZXRBcnIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0xpdGVyYWxJbnRlZ2VyJzpcbiAgICAgICAgdGhpcy5jYXN0TGl0ZXJhbFRvRmxvYXQoYXN0LmxlZnQsIHJldEFycik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhpcy5hc3RHZW5lcmljKGFzdC5sZWZ0LCByZXRBcnIpO1xuICAgIH1cbiAgICByZXRBcnIucHVzaCgnLCcpO1xuICAgIHN3aXRjaCAodGhpcy5nZXRUeXBlKGFzdC5yaWdodCkpIHtcbiAgICAgIGNhc2UgJ0ludGVnZXInOlxuICAgICAgICB0aGlzLmNhc3RWYWx1ZVRvRmxvYXQoYXN0LnJpZ2h0LCByZXRBcnIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0xpdGVyYWxJbnRlZ2VyJzpcbiAgICAgICAgdGhpcy5jYXN0TGl0ZXJhbFRvRmxvYXQoYXN0LnJpZ2h0LCByZXRBcnIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRoaXMuYXN0R2VuZXJpYyhhc3QucmlnaHQsIHJldEFycik7XG4gICAgfVxuICAgIHJldEFyci5wdXNoKCcpJyk7XG4gICAgcmV0dXJuIHJldEFycjtcbiAgfVxuXG4gIGNoZWNrQW5kVXBjb252ZXJ0Qml0d2lzZU9wZXJhdG9ycyhhc3QsIHJldEFycikge1xuICAgIGNvbnN0IHVwY29udmVydGFibGVPcGVyYXRvcnMgPSB7XG4gICAgICAnJic6ICdiaXR3aXNlQW5kJyxcbiAgICAgICd8JzogJ2JpdHdpc2VPcicsXG4gICAgICAnXic6ICdiaXR3aXNlWE9SJyxcbiAgICAgICc8PCc6ICdiaXR3aXNlWmVyb0ZpbGxMZWZ0U2hpZnQnLFxuICAgICAgJz4+JzogJ2JpdHdpc2VTaWduZWRSaWdodFNoaWZ0JyxcbiAgICAgICc+Pj4nOiAnYml0d2lzZVplcm9GaWxsUmlnaHRTaGlmdCcsXG4gICAgfTtcbiAgICBjb25zdCBmb3VuZE9wZXJhdG9yID0gdXBjb252ZXJ0YWJsZU9wZXJhdG9yc1thc3Qub3BlcmF0b3JdO1xuICAgIGlmICghZm91bmRPcGVyYXRvcikgcmV0dXJuIG51bGw7XG4gICAgcmV0QXJyLnB1c2goZm91bmRPcGVyYXRvcik7XG4gICAgcmV0QXJyLnB1c2goJygnKTtcbiAgICBjb25zdCBsZWZ0VHlwZSA9IHRoaXMuZ2V0VHlwZShhc3QubGVmdCk7XG4gICAgc3dpdGNoIChsZWZ0VHlwZSkge1xuICAgICAgY2FzZSAnTnVtYmVyJzpcbiAgICAgIGNhc2UgJ0Zsb2F0JzpcbiAgICAgICAgdGhpcy5jYXN0VmFsdWVUb0ludGVnZXIoYXN0LmxlZnQsIHJldEFycik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnTGl0ZXJhbEludGVnZXInOlxuICAgICAgICB0aGlzLmNhc3RMaXRlcmFsVG9JbnRlZ2VyKGFzdC5sZWZ0LCByZXRBcnIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRoaXMuYXN0R2VuZXJpYyhhc3QubGVmdCwgcmV0QXJyKTtcbiAgICB9XG4gICAgcmV0QXJyLnB1c2goJywnKTtcbiAgICBjb25zdCByaWdodFR5cGUgPSB0aGlzLmdldFR5cGUoYXN0LnJpZ2h0KTtcbiAgICBzd2l0Y2ggKHJpZ2h0VHlwZSkge1xuICAgICAgY2FzZSAnTnVtYmVyJzpcbiAgICAgIGNhc2UgJ0Zsb2F0JzpcbiAgICAgICAgdGhpcy5jYXN0VmFsdWVUb0ludGVnZXIoYXN0LnJpZ2h0LCByZXRBcnIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0xpdGVyYWxJbnRlZ2VyJzpcbiAgICAgICAgdGhpcy5jYXN0TGl0ZXJhbFRvSW50ZWdlcihhc3QucmlnaHQsIHJldEFycik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhpcy5hc3RHZW5lcmljKGFzdC5yaWdodCwgcmV0QXJyKTtcbiAgICB9XG4gICAgcmV0QXJyLnB1c2goJyknKTtcbiAgICByZXR1cm4gcmV0QXJyO1xuICB9XG5cbiAgY2hlY2tBbmRVcGNvbnZlcnRCaXR3aXNlVW5hcnkoYXN0LCByZXRBcnIpIHtcbiAgICBjb25zdCB1cGNvbnZlcnRhYmxlT3BlcmF0b3JzID0ge1xuICAgICAgJ34nOiAnYml0d2lzZU5vdCcsXG4gICAgfTtcbiAgICBjb25zdCBmb3VuZE9wZXJhdG9yID0gdXBjb252ZXJ0YWJsZU9wZXJhdG9yc1thc3Qub3BlcmF0b3JdO1xuICAgIGlmICghZm91bmRPcGVyYXRvcikgcmV0dXJuIG51bGw7XG4gICAgcmV0QXJyLnB1c2goZm91bmRPcGVyYXRvcik7XG4gICAgcmV0QXJyLnB1c2goJygnKTtcbiAgICBzd2l0Y2ggKHRoaXMuZ2V0VHlwZShhc3QuYXJndW1lbnQpKSB7XG4gICAgICBjYXNlICdOdW1iZXInOlxuICAgICAgY2FzZSAnRmxvYXQnOlxuICAgICAgICB0aGlzLmNhc3RWYWx1ZVRvSW50ZWdlcihhc3QuYXJndW1lbnQsIHJldEFycik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnTGl0ZXJhbEludGVnZXInOlxuICAgICAgICB0aGlzLmNhc3RMaXRlcmFsVG9JbnRlZ2VyKGFzdC5hcmd1bWVudCwgcmV0QXJyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aGlzLmFzdEdlbmVyaWMoYXN0LmFyZ3VtZW50LCByZXRBcnIpO1xuICAgIH1cbiAgICByZXRBcnIucHVzaCgnKScpO1xuICAgIHJldHVybiByZXRBcnI7XG4gIH1cblxuICBjYXN0TGl0ZXJhbFRvSW50ZWdlcihhc3QsIHJldEFycikge1xuICAgIHRoaXMucHVzaFN0YXRlKCdjYXN0aW5nLXRvLWludGVnZXInKTtcbiAgICB0aGlzLmFzdEdlbmVyaWMoYXN0LCByZXRBcnIpO1xuICAgIHRoaXMucG9wU3RhdGUoJ2Nhc3RpbmctdG8taW50ZWdlcicpO1xuICAgIHJldHVybiByZXRBcnI7XG4gIH1cblxuICBjYXN0TGl0ZXJhbFRvRmxvYXQoYXN0LCByZXRBcnIpIHtcbiAgICB0aGlzLnB1c2hTdGF0ZSgnY2FzdGluZy10by1mbG9hdCcpO1xuICAgIHRoaXMuYXN0R2VuZXJpYyhhc3QsIHJldEFycik7XG4gICAgdGhpcy5wb3BTdGF0ZSgnY2FzdGluZy10by1mbG9hdCcpO1xuICAgIHJldHVybiByZXRBcnI7XG4gIH1cblxuICBjYXN0VmFsdWVUb0ludGVnZXIoYXN0LCByZXRBcnIpIHtcbiAgICB0aGlzLnB1c2hTdGF0ZSgnY2FzdGluZy10by1pbnRlZ2VyJyk7XG4gICAgcmV0QXJyLnB1c2goJ2ludCgnKTtcbiAgICB0aGlzLmFzdEdlbmVyaWMoYXN0LCByZXRBcnIpO1xuICAgIHJldEFyci5wdXNoKCcpJyk7XG4gICAgdGhpcy5wb3BTdGF0ZSgnY2FzdGluZy10by1pbnRlZ2VyJyk7XG4gICAgcmV0dXJuIHJldEFycjtcbiAgfVxuXG4gIGNhc3RWYWx1ZVRvRmxvYXQoYXN0LCByZXRBcnIpIHtcbiAgICB0aGlzLnB1c2hTdGF0ZSgnY2FzdGluZy10by1mbG9hdCcpO1xuICAgIHJldEFyci5wdXNoKCdmbG9hdCgnKTtcbiAgICB0aGlzLmFzdEdlbmVyaWMoYXN0LCByZXRBcnIpO1xuICAgIHJldEFyci5wdXNoKCcpJyk7XG4gICAgdGhpcy5wb3BTdGF0ZSgnY2FzdGluZy10by1mbG9hdCcpO1xuICAgIHJldHVybiByZXRBcnI7XG4gIH1cblxuICBhc3RJZGVudGlmaWVyRXhwcmVzc2lvbihpZHROb2RlLCByZXRBcnIpIHtcbiAgICBpZiAoaWR0Tm9kZS50eXBlICE9PSAnSWRlbnRpZmllcicpIHtcbiAgICAgIHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoJ0lkZW50aWZpZXJFeHByZXNzaW9uIC0gbm90IGFuIElkZW50aWZpZXInLCBpZHROb2RlKTtcbiAgICB9XG5cbiAgICBjb25zdCB0eXBlID0gdGhpcy5nZXRUeXBlKGlkdE5vZGUpO1xuXG4gICAgY29uc3QgbmFtZSA9IHV0aWxzLnNhbml0aXplTmFtZShpZHROb2RlLm5hbWUpO1xuICAgIGlmIChpZHROb2RlLm5hbWUgPT09ICdJbmZpbml0eScpIHtcbiAgICAgIHJldEFyci5wdXNoKCczLjQwMjgyMzQ2NmUrMzgnKTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdCb29sZWFuJykge1xuICAgICAgaWYgKHRoaXMuYXJndW1lbnROYW1lcy5pbmRleE9mKG5hbWUpID4gLTEpIHtcbiAgICAgICAgcmV0QXJyLnB1c2goYGJvb2wodXNlcl8ke25hbWV9KWApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0QXJyLnB1c2goYHVzZXJfJHtuYW1lfWApO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXRBcnIucHVzaChgdXNlcl8ke25hbWV9YCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldEFycjtcbiAgfVxuXG4gIGFzdEZvclN0YXRlbWVudChmb3JOb2RlLCByZXRBcnIpIHtcbiAgICBpZiAoZm9yTm9kZS50eXBlICE9PSAnRm9yU3RhdGVtZW50Jykge1xuICAgICAgdGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dCgnSW52YWxpZCBmb3Igc3RhdGVtZW50JywgZm9yTm9kZSk7XG4gICAgfVxuXG4gICAgY29uc3QgaW5pdEFyciA9IFtdO1xuICAgIGNvbnN0IHRlc3RBcnIgPSBbXTtcbiAgICBjb25zdCB1cGRhdGVBcnIgPSBbXTtcbiAgICBjb25zdCBib2R5QXJyID0gW107XG4gICAgbGV0IGlzU2FmZSA9IG51bGw7XG5cbiAgICBpZiAoZm9yTm9kZS5pbml0KSB7XG4gICAgICBjb25zdCB7IGRlY2xhcmF0aW9ucyB9ID0gZm9yTm9kZS5pbml0O1xuICAgICAgaWYgKGRlY2xhcmF0aW9ucy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGlzU2FmZSA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgdGhpcy5hc3RHZW5lcmljKGZvck5vZGUuaW5pdCwgaW5pdEFycik7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRlY2xhcmF0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoZGVjbGFyYXRpb25zW2ldLmluaXQgJiYgZGVjbGFyYXRpb25zW2ldLmluaXQudHlwZSAhPT0gJ0xpdGVyYWwnKSB7XG4gICAgICAgICAgaXNTYWZlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaXNTYWZlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGZvck5vZGUudGVzdCkge1xuICAgICAgdGhpcy5hc3RHZW5lcmljKGZvck5vZGUudGVzdCwgdGVzdEFycik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlzU2FmZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChmb3JOb2RlLnVwZGF0ZSkge1xuICAgICAgdGhpcy5hc3RHZW5lcmljKGZvck5vZGUudXBkYXRlLCB1cGRhdGVBcnIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpc1NhZmUgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoZm9yTm9kZS5ib2R5KSB7XG4gICAgICB0aGlzLnB1c2hTdGF0ZSgnbG9vcC1ib2R5Jyk7XG4gICAgICB0aGlzLmFzdEdlbmVyaWMoZm9yTm9kZS5ib2R5LCBib2R5QXJyKTtcbiAgICAgIHRoaXMucG9wU3RhdGUoJ2xvb3AtYm9keScpO1xuICAgIH1cblxuICAgIGlmIChpc1NhZmUgPT09IG51bGwpIHtcbiAgICAgIGlzU2FmZSA9IHRoaXMuaXNTYWZlKGZvck5vZGUuaW5pdCkgJiYgdGhpcy5pc1NhZmUoZm9yTm9kZS50ZXN0KTtcbiAgICB9XG5cbiAgICBpZiAoaXNTYWZlKSB7XG4gICAgICBjb25zdCBpbml0U3RyaW5nID0gaW5pdEFyci5qb2luKCcnKTtcbiAgICAgIGNvbnN0IGluaXROZWVkc1NlbWlDb2xvbiA9IGluaXRTdHJpbmdbaW5pdFN0cmluZy5sZW5ndGggLSAxXSAhPT0gJzsnO1xuICAgICAgcmV0QXJyLnB1c2goYGZvciAoJHtpbml0U3RyaW5nfSR7aW5pdE5lZWRzU2VtaUNvbG9uID8gJzsnIDogJyd9JHt0ZXN0QXJyLmpvaW4oJycpfTske3VwZGF0ZUFyci5qb2luKCcnKX0pe1xcbmApO1xuICAgICAgcmV0QXJyLnB1c2goYm9keUFyci5qb2luKCcnKSk7XG4gICAgICByZXRBcnIucHVzaCgnfVxcbicpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBpVmFyaWFibGVOYW1lID0gdGhpcy5nZXRJbnRlcm5hbFZhcmlhYmxlTmFtZSgnc2FmZUknKTtcbiAgICAgIGlmIChpbml0QXJyLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0QXJyLnB1c2goaW5pdEFyci5qb2luKCcnKSwgJ1xcbicpO1xuICAgICAgfVxuICAgICAgcmV0QXJyLnB1c2goYGZvciAoaW50ICR7aVZhcmlhYmxlTmFtZX09MDske2lWYXJpYWJsZU5hbWV9PExPT1BfTUFYOyR7aVZhcmlhYmxlTmFtZX0rKyl7XFxuYCk7XG4gICAgICBpZiAodGVzdEFyci5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldEFyci5wdXNoKGBpZiAoISR7dGVzdEFyci5qb2luKCcnKX0pIGJyZWFrO1xcbmApO1xuICAgICAgfVxuICAgICAgcmV0QXJyLnB1c2goYm9keUFyci5qb2luKCcnKSk7XG4gICAgICByZXRBcnIucHVzaChgXFxuJHt1cGRhdGVBcnIuam9pbignJyl9O2ApO1xuICAgICAgcmV0QXJyLnB1c2goJ31cXG4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldEFycjtcbiAgfVxuXG4gIGFzdFdoaWxlU3RhdGVtZW50KHdoaWxlTm9kZSwgcmV0QXJyKSB7XG4gICAgaWYgKHdoaWxlTm9kZS50eXBlICE9PSAnV2hpbGVTdGF0ZW1lbnQnKSB7XG4gICAgICB0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KCdJbnZhbGlkIHdoaWxlIHN0YXRlbWVudCcsIHdoaWxlTm9kZSk7XG4gICAgfVxuXG4gICAgY29uc3QgaVZhcmlhYmxlTmFtZSA9IHRoaXMuZ2V0SW50ZXJuYWxWYXJpYWJsZU5hbWUoJ3NhZmVJJyk7XG4gICAgcmV0QXJyLnB1c2goYGZvciAoaW50ICR7aVZhcmlhYmxlTmFtZX09MDske2lWYXJpYWJsZU5hbWV9PExPT1BfTUFYOyR7aVZhcmlhYmxlTmFtZX0rKyl7XFxuYCk7XG4gICAgcmV0QXJyLnB1c2goJ2lmICghJyk7XG4gICAgdGhpcy5hc3RHZW5lcmljKHdoaWxlTm9kZS50ZXN0LCByZXRBcnIpO1xuICAgIHJldEFyci5wdXNoKCcpIGJyZWFrO1xcbicpO1xuICAgIHRoaXMuYXN0R2VuZXJpYyh3aGlsZU5vZGUuYm9keSwgcmV0QXJyKTtcbiAgICByZXRBcnIucHVzaCgnfVxcbicpO1xuXG4gICAgcmV0dXJuIHJldEFycjtcbiAgfVxuXG4gIGFzdERvV2hpbGVTdGF0ZW1lbnQoZG9XaGlsZU5vZGUsIHJldEFycikge1xuICAgIGlmIChkb1doaWxlTm9kZS50eXBlICE9PSAnRG9XaGlsZVN0YXRlbWVudCcpIHtcbiAgICAgIHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoJ0ludmFsaWQgd2hpbGUgc3RhdGVtZW50JywgZG9XaGlsZU5vZGUpO1xuICAgIH1cblxuICAgIGNvbnN0IGlWYXJpYWJsZU5hbWUgPSB0aGlzLmdldEludGVybmFsVmFyaWFibGVOYW1lKCdzYWZlSScpO1xuICAgIHJldEFyci5wdXNoKGBmb3IgKGludCAke2lWYXJpYWJsZU5hbWV9PTA7JHtpVmFyaWFibGVOYW1lfTxMT09QX01BWDske2lWYXJpYWJsZU5hbWV9Kyspe1xcbmApO1xuICAgIHRoaXMuYXN0R2VuZXJpYyhkb1doaWxlTm9kZS5ib2R5LCByZXRBcnIpO1xuICAgIHJldEFyci5wdXNoKCdpZiAoIScpO1xuICAgIHRoaXMuYXN0R2VuZXJpYyhkb1doaWxlTm9kZS50ZXN0LCByZXRBcnIpO1xuICAgIHJldEFyci5wdXNoKCcpIGJyZWFrO1xcbicpO1xuICAgIHJldEFyci5wdXNoKCd9XFxuJyk7XG5cbiAgICByZXR1cm4gcmV0QXJyO1xuICB9XG5cblxuICBhc3RBc3NpZ25tZW50RXhwcmVzc2lvbihhc3NOb2RlLCByZXRBcnIpIHtcbiAgICBpZiAoYXNzTm9kZS5vcGVyYXRvciA9PT0gJyU9Jykge1xuICAgICAgdGhpcy5hc3RHZW5lcmljKGFzc05vZGUubGVmdCwgcmV0QXJyKTtcbiAgICAgIHJldEFyci5wdXNoKCc9Jyk7XG4gICAgICByZXRBcnIucHVzaCgnbW9kKCcpO1xuICAgICAgdGhpcy5hc3RHZW5lcmljKGFzc05vZGUubGVmdCwgcmV0QXJyKTtcbiAgICAgIHJldEFyci5wdXNoKCcsJyk7XG4gICAgICB0aGlzLmFzdEdlbmVyaWMoYXNzTm9kZS5yaWdodCwgcmV0QXJyKTtcbiAgICAgIHJldEFyci5wdXNoKCcpJyk7XG4gICAgfSBlbHNlIGlmIChhc3NOb2RlLm9wZXJhdG9yID09PSAnKio9Jykge1xuICAgICAgdGhpcy5hc3RHZW5lcmljKGFzc05vZGUubGVmdCwgcmV0QXJyKTtcbiAgICAgIHJldEFyci5wdXNoKCc9Jyk7XG4gICAgICByZXRBcnIucHVzaCgncG93KCcpO1xuICAgICAgdGhpcy5hc3RHZW5lcmljKGFzc05vZGUubGVmdCwgcmV0QXJyKTtcbiAgICAgIHJldEFyci5wdXNoKCcsJyk7XG4gICAgICB0aGlzLmFzdEdlbmVyaWMoYXNzTm9kZS5yaWdodCwgcmV0QXJyKTtcbiAgICAgIHJldEFyci5wdXNoKCcpJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGxlZnRUeXBlID0gdGhpcy5nZXRUeXBlKGFzc05vZGUubGVmdCk7XG4gICAgICBjb25zdCByaWdodFR5cGUgPSB0aGlzLmdldFR5cGUoYXNzTm9kZS5yaWdodCk7XG4gICAgICB0aGlzLmFzdEdlbmVyaWMoYXNzTm9kZS5sZWZ0LCByZXRBcnIpO1xuICAgICAgcmV0QXJyLnB1c2goYXNzTm9kZS5vcGVyYXRvcik7XG4gICAgICBpZiAobGVmdFR5cGUgIT09ICdJbnRlZ2VyJyAmJiByaWdodFR5cGUgPT09ICdJbnRlZ2VyJykge1xuICAgICAgICByZXRBcnIucHVzaCgnZmxvYXQoJyk7XG4gICAgICAgIHRoaXMuYXN0R2VuZXJpYyhhc3NOb2RlLnJpZ2h0LCByZXRBcnIpO1xuICAgICAgICByZXRBcnIucHVzaCgnKScpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5hc3RHZW5lcmljKGFzc05vZGUucmlnaHQsIHJldEFycik7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmV0QXJyO1xuICAgIH1cbiAgfVxuXG4gIGFzdEJsb2NrU3RhdGVtZW50KGJOb2RlLCByZXRBcnIpIHtcbiAgICBpZiAodGhpcy5pc1N0YXRlKCdsb29wLWJvZHknKSkge1xuICAgICAgdGhpcy5wdXNoU3RhdGUoJ2Jsb2NrLWJvZHknKTsgXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJOb2RlLmJvZHkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5hc3RHZW5lcmljKGJOb2RlLmJvZHlbaV0sIHJldEFycik7XG4gICAgICB9XG4gICAgICB0aGlzLnBvcFN0YXRlKCdibG9jay1ib2R5Jyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldEFyci5wdXNoKCd7XFxuJyk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJOb2RlLmJvZHkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5hc3RHZW5lcmljKGJOb2RlLmJvZHlbaV0sIHJldEFycik7XG4gICAgICB9XG4gICAgICByZXRBcnIucHVzaCgnfVxcbicpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0QXJyO1xuICB9XG5cbiAgYXN0VmFyaWFibGVEZWNsYXJhdGlvbih2YXJEZWNOb2RlLCByZXRBcnIpIHtcbiAgICBjb25zdCBkZWNsYXJhdGlvbnMgPSB2YXJEZWNOb2RlLmRlY2xhcmF0aW9ucztcbiAgICBpZiAoIWRlY2xhcmF0aW9ucyB8fCAhZGVjbGFyYXRpb25zWzBdIHx8ICFkZWNsYXJhdGlvbnNbMF0uaW5pdCkge1xuICAgICAgdGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dCgnVW5leHBlY3RlZCBleHByZXNzaW9uJywgdmFyRGVjTm9kZSk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGxldCBsYXN0VHlwZSA9IG51bGw7XG4gICAgY29uc3QgZGVjbGFyYXRpb25TZXRzID0gW107XG4gICAgbGV0IGRlY2xhcmF0aW9uU2V0ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZWNsYXJhdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGRlY2xhcmF0aW9uID0gZGVjbGFyYXRpb25zW2ldO1xuICAgICAgY29uc3QgaW5pdCA9IGRlY2xhcmF0aW9uLmluaXQ7XG4gICAgICBjb25zdCBpbmZvID0gdGhpcy5nZXREZWNsYXJhdGlvbihkZWNsYXJhdGlvbi5pZCk7XG4gICAgICBjb25zdCBhY3R1YWxUeXBlID0gdGhpcy5nZXRUeXBlKGRlY2xhcmF0aW9uLmluaXQpO1xuICAgICAgbGV0IHR5cGUgPSBhY3R1YWxUeXBlO1xuICAgICAgaWYgKHR5cGUgPT09ICdMaXRlcmFsSW50ZWdlcicpIHtcbiAgICAgICAgaWYgKGluZm8uc3VnZ2VzdGVkVHlwZSA9PT0gJ0ludGVnZXInKSB7XG4gICAgICAgICAgdHlwZSA9ICdJbnRlZ2VyJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0eXBlID0gJ051bWJlcic7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IG1hcmt1cFR5cGUgPSB0eXBlTWFwW3R5cGVdO1xuICAgICAgaWYgKCFtYXJrdXBUeXBlKSB7XG4gICAgICAgIHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoYE1hcmt1cCB0eXBlICR7IHR5cGUgfSBub3QgaGFuZGxlZGAsIHZhckRlY05vZGUpO1xuICAgICAgfVxuICAgICAgY29uc3QgZGVjbGFyYXRpb25SZXN1bHQgPSBbXTtcbiAgICAgIGlmIChhY3R1YWxUeXBlID09PSAnSW50ZWdlcicgJiYgdHlwZSA9PT0gJ0ludGVnZXInKSB7XG4gICAgICAgIGluZm8udmFsdWVUeXBlID0gJ051bWJlcic7XG4gICAgICAgIGlmIChpID09PSAwIHx8IGxhc3RUeXBlID09PSBudWxsKSB7XG4gICAgICAgICAgZGVjbGFyYXRpb25SZXN1bHQucHVzaCgnZmxvYXQgJyk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSAhPT0gbGFzdFR5cGUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuaGFuZGxlZCBkZWNsYXJhdGlvbicpO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RUeXBlID0gdHlwZTtcbiAgICAgICAgZGVjbGFyYXRpb25SZXN1bHQucHVzaChgdXNlcl8ke3V0aWxzLnNhbml0aXplTmFtZShkZWNsYXJhdGlvbi5pZC5uYW1lKX09YCk7XG4gICAgICAgIGRlY2xhcmF0aW9uUmVzdWx0LnB1c2goJ2Zsb2F0KCcpO1xuICAgICAgICB0aGlzLmFzdEdlbmVyaWMoaW5pdCwgZGVjbGFyYXRpb25SZXN1bHQpO1xuICAgICAgICBkZWNsYXJhdGlvblJlc3VsdC5wdXNoKCcpJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbmZvLnZhbHVlVHlwZSA9IHR5cGU7XG4gICAgICAgIGlmIChpID09PSAwIHx8IGxhc3RUeXBlID09PSBudWxsKSB7XG4gICAgICAgICAgZGVjbGFyYXRpb25SZXN1bHQucHVzaChgJHttYXJrdXBUeXBlfSBgKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlICE9PSBsYXN0VHlwZSkge1xuICAgICAgICAgIGRlY2xhcmF0aW9uU2V0cy5wdXNoKGRlY2xhcmF0aW9uU2V0LmpvaW4oJywnKSk7XG4gICAgICAgICAgZGVjbGFyYXRpb25TZXQgPSBbXTtcbiAgICAgICAgICBkZWNsYXJhdGlvblJlc3VsdC5wdXNoKGAke21hcmt1cFR5cGV9IGApO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RUeXBlID0gdHlwZTtcbiAgICAgICAgZGVjbGFyYXRpb25SZXN1bHQucHVzaChgdXNlcl8ke3V0aWxzLnNhbml0aXplTmFtZShkZWNsYXJhdGlvbi5pZC5uYW1lKX09YCk7XG4gICAgICAgIGlmIChhY3R1YWxUeXBlID09PSAnTnVtYmVyJyAmJiB0eXBlID09PSAnSW50ZWdlcicpIHtcbiAgICAgICAgICBpZiAoaW5pdC5sZWZ0ICYmIGluaXQubGVmdC50eXBlID09PSAnTGl0ZXJhbCcpIHtcbiAgICAgICAgICAgIHRoaXMuYXN0R2VuZXJpYyhpbml0LCBkZWNsYXJhdGlvblJlc3VsdCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRlY2xhcmF0aW9uUmVzdWx0LnB1c2goJ2ludCgnKTtcbiAgICAgICAgICAgIHRoaXMuYXN0R2VuZXJpYyhpbml0LCBkZWNsYXJhdGlvblJlc3VsdCk7XG4gICAgICAgICAgICBkZWNsYXJhdGlvblJlc3VsdC5wdXNoKCcpJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGFjdHVhbFR5cGUgPT09ICdMaXRlcmFsSW50ZWdlcicgJiYgdHlwZSA9PT0gJ0ludGVnZXInKSB7XG4gICAgICAgICAgdGhpcy5jYXN0TGl0ZXJhbFRvSW50ZWdlcihpbml0LCBkZWNsYXJhdGlvblJlc3VsdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5hc3RHZW5lcmljKGluaXQsIGRlY2xhcmF0aW9uUmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZGVjbGFyYXRpb25TZXQucHVzaChkZWNsYXJhdGlvblJlc3VsdC5qb2luKCcnKSk7XG4gICAgfVxuXG4gICAgaWYgKGRlY2xhcmF0aW9uU2V0Lmxlbmd0aCA+IDApIHtcbiAgICAgIGRlY2xhcmF0aW9uU2V0cy5wdXNoKGRlY2xhcmF0aW9uU2V0LmpvaW4oJywnKSk7XG4gICAgfVxuXG4gICAgcmVzdWx0LnB1c2goZGVjbGFyYXRpb25TZXRzLmpvaW4oJzsnKSk7XG5cbiAgICByZXRBcnIucHVzaChyZXN1bHQuam9pbignJykpO1xuICAgIHJldEFyci5wdXNoKCc7Jyk7XG4gICAgcmV0dXJuIHJldEFycjtcbiAgfVxuXG4gIGFzdElmU3RhdGVtZW50KGlmTm9kZSwgcmV0QXJyKSB7XG4gICAgcmV0QXJyLnB1c2goJ2lmICgnKTtcbiAgICB0aGlzLmFzdEdlbmVyaWMoaWZOb2RlLnRlc3QsIHJldEFycik7XG4gICAgcmV0QXJyLnB1c2goJyknKTtcbiAgICBpZiAoaWZOb2RlLmNvbnNlcXVlbnQudHlwZSA9PT0gJ0Jsb2NrU3RhdGVtZW50Jykge1xuICAgICAgdGhpcy5hc3RHZW5lcmljKGlmTm9kZS5jb25zZXF1ZW50LCByZXRBcnIpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXRBcnIucHVzaCgnIHtcXG4nKTtcbiAgICAgIHRoaXMuYXN0R2VuZXJpYyhpZk5vZGUuY29uc2VxdWVudCwgcmV0QXJyKTtcbiAgICAgIHJldEFyci5wdXNoKCdcXG59XFxuJyk7XG4gICAgfVxuXG4gICAgaWYgKGlmTm9kZS5hbHRlcm5hdGUpIHtcbiAgICAgIHJldEFyci5wdXNoKCdlbHNlICcpO1xuICAgICAgaWYgKGlmTm9kZS5hbHRlcm5hdGUudHlwZSA9PT0gJ0Jsb2NrU3RhdGVtZW50JyB8fCBpZk5vZGUuYWx0ZXJuYXRlLnR5cGUgPT09ICdJZlN0YXRlbWVudCcpIHtcbiAgICAgICAgdGhpcy5hc3RHZW5lcmljKGlmTm9kZS5hbHRlcm5hdGUsIHJldEFycik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXRBcnIucHVzaCgnIHtcXG4nKTtcbiAgICAgICAgdGhpcy5hc3RHZW5lcmljKGlmTm9kZS5hbHRlcm5hdGUsIHJldEFycik7XG4gICAgICAgIHJldEFyci5wdXNoKCdcXG59XFxuJyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXRBcnI7XG4gIH1cblxuICBhc3RTd2l0Y2hTdGF0ZW1lbnQoYXN0LCByZXRBcnIpIHtcbiAgICBpZiAoYXN0LnR5cGUgIT09ICdTd2l0Y2hTdGF0ZW1lbnQnKSB7XG4gICAgICB0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KCdJbnZhbGlkIHN3aXRjaCBzdGF0ZW1lbnQnLCBhc3QpO1xuICAgIH1cbiAgICBjb25zdCB7IGRpc2NyaW1pbmFudCwgY2FzZXMgfSA9IGFzdDtcbiAgICBjb25zdCB0eXBlID0gdGhpcy5nZXRUeXBlKGRpc2NyaW1pbmFudCk7XG4gICAgY29uc3QgdmFyTmFtZSA9IGBzd2l0Y2hEaXNjcmltaW5hbnQke3RoaXMuYXN0S2V5KGFzdCwgJ18nKX1gO1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAnRmxvYXQnOlxuICAgICAgY2FzZSAnTnVtYmVyJzpcbiAgICAgICAgcmV0QXJyLnB1c2goYGZsb2F0ICR7dmFyTmFtZX0gPSBgKTtcbiAgICAgICAgdGhpcy5hc3RHZW5lcmljKGRpc2NyaW1pbmFudCwgcmV0QXJyKTtcbiAgICAgICAgcmV0QXJyLnB1c2goJztcXG4nKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdJbnRlZ2VyJzpcbiAgICAgICAgcmV0QXJyLnB1c2goYGludCAke3Zhck5hbWV9ID0gYCk7XG4gICAgICAgIHRoaXMuYXN0R2VuZXJpYyhkaXNjcmltaW5hbnQsIHJldEFycik7XG4gICAgICAgIHJldEFyci5wdXNoKCc7XFxuJyk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAoY2FzZXMubGVuZ3RoID09PSAxICYmICFjYXNlc1swXS50ZXN0KSB7XG4gICAgICB0aGlzLmFzdEdlbmVyaWMoY2FzZXNbMF0uY29uc2VxdWVudCwgcmV0QXJyKTtcbiAgICAgIHJldHVybiByZXRBcnI7XG4gICAgfVxuXG4gICAgbGV0IGZhbGxpbmdUaHJvdWdoID0gZmFsc2U7XG4gICAgbGV0IGRlZmF1bHRSZXN1bHQgPSBbXTtcbiAgICBsZXQgbW92aW5nRGVmYXVsdFRvRW5kID0gZmFsc2U7XG4gICAgbGV0IHBhc3RGaXJzdElmID0gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjYXNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCFjYXNlc1tpXS50ZXN0KSB7XG4gICAgICAgIGlmIChjYXNlcy5sZW5ndGggPiBpICsgMSkge1xuICAgICAgICAgIG1vdmluZ0RlZmF1bHRUb0VuZCA9IHRydWU7XG4gICAgICAgICAgdGhpcy5hc3RHZW5lcmljKGNhc2VzW2ldLmNvbnNlcXVlbnQsIGRlZmF1bHRSZXN1bHQpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldEFyci5wdXNoKCcgZWxzZSB7XFxuJyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpID09PSAwIHx8ICFwYXN0Rmlyc3RJZikge1xuICAgICAgICAgIHBhc3RGaXJzdElmID0gdHJ1ZTtcbiAgICAgICAgICByZXRBcnIucHVzaChgaWYgKCR7dmFyTmFtZX0gPT0gYCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGZhbGxpbmdUaHJvdWdoKSB7XG4gICAgICAgICAgICByZXRBcnIucHVzaChgJHt2YXJOYW1lfSA9PSBgKTtcbiAgICAgICAgICAgIGZhbGxpbmdUaHJvdWdoID0gZmFsc2U7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldEFyci5wdXNoKGAgZWxzZSBpZiAoJHt2YXJOYW1lfSA9PSBgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPT09ICdJbnRlZ2VyJykge1xuICAgICAgICAgIGNvbnN0IHRlc3RUeXBlID0gdGhpcy5nZXRUeXBlKGNhc2VzW2ldLnRlc3QpO1xuICAgICAgICAgIHN3aXRjaCAodGVzdFR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ051bWJlcic6XG4gICAgICAgICAgICBjYXNlICdGbG9hdCc6XG4gICAgICAgICAgICAgIHRoaXMuY2FzdFZhbHVlVG9JbnRlZ2VyKGNhc2VzW2ldLnRlc3QsIHJldEFycik7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnTGl0ZXJhbEludGVnZXInOlxuICAgICAgICAgICAgICB0aGlzLmNhc3RMaXRlcmFsVG9JbnRlZ2VyKGNhc2VzW2ldLnRlc3QsIHJldEFycik7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnRmxvYXQnKSB7XG4gICAgICAgICAgY29uc3QgdGVzdFR5cGUgPSB0aGlzLmdldFR5cGUoY2FzZXNbaV0udGVzdCk7XG4gICAgICAgICAgc3dpdGNoICh0ZXN0VHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnTGl0ZXJhbEludGVnZXInOlxuICAgICAgICAgICAgICB0aGlzLmNhc3RMaXRlcmFsVG9GbG9hdChjYXNlc1tpXS50ZXN0LCByZXRBcnIpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ0ludGVnZXInOlxuICAgICAgICAgICAgICB0aGlzLmNhc3RWYWx1ZVRvRmxvYXQoY2FzZXNbaV0udGVzdCwgcmV0QXJyKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndW5oYW5sZGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjYXNlc1tpXS5jb25zZXF1ZW50IHx8IGNhc2VzW2ldLmNvbnNlcXVlbnQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgZmFsbGluZ1Rocm91Z2ggPSB0cnVlO1xuICAgICAgICAgIHJldEFyci5wdXNoKCcgfHwgJyk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0QXJyLnB1c2goYCkge1xcbmApO1xuICAgICAgfVxuICAgICAgdGhpcy5hc3RHZW5lcmljKGNhc2VzW2ldLmNvbnNlcXVlbnQsIHJldEFycik7XG4gICAgICByZXRBcnIucHVzaCgnXFxufScpO1xuICAgIH1cbiAgICBpZiAobW92aW5nRGVmYXVsdFRvRW5kKSB7XG4gICAgICByZXRBcnIucHVzaCgnIGVsc2UgeycpO1xuICAgICAgcmV0QXJyLnB1c2goZGVmYXVsdFJlc3VsdC5qb2luKCcnKSk7XG4gICAgICByZXRBcnIucHVzaCgnfScpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0QXJyO1xuICB9XG5cbiAgYXN0VGhpc0V4cHJlc3Npb24odE5vZGUsIHJldEFycikge1xuICAgIHJldEFyci5wdXNoKCd0aGlzJyk7XG4gICAgcmV0dXJuIHJldEFycjtcbiAgfVxuXG4gIGFzdE1lbWJlckV4cHJlc3Npb24obU5vZGUsIHJldEFycikge1xuICAgIGNvbnN0IHtcbiAgICAgIHByb3BlcnR5LFxuICAgICAgbmFtZSxcbiAgICAgIHNpZ25hdHVyZSxcbiAgICAgIG9yaWdpbixcbiAgICAgIHR5cGUsXG4gICAgICB4UHJvcGVydHksXG4gICAgICB5UHJvcGVydHksXG4gICAgICB6UHJvcGVydHlcbiAgICB9ID0gdGhpcy5nZXRNZW1iZXJFeHByZXNzaW9uRGV0YWlscyhtTm9kZSk7XG4gICAgc3dpdGNoIChzaWduYXR1cmUpIHtcbiAgICAgIGNhc2UgJ3ZhbHVlLnRocmVhZC52YWx1ZSc6XG4gICAgICBjYXNlICd0aGlzLnRocmVhZC52YWx1ZSc6XG4gICAgICAgIGlmIChuYW1lICE9PSAneCcgJiYgbmFtZSAhPT0gJ3knICYmIG5hbWUgIT09ICd6Jykge1xuICAgICAgICAgIHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoJ1VuZXhwZWN0ZWQgZXhwcmVzc2lvbiwgZXhwZWN0ZWQgYHRoaXMudGhyZWFkLnhgLCBgdGhpcy50aHJlYWQueWAsIG9yIGB0aGlzLnRocmVhZC56YCcsIG1Ob2RlKTtcbiAgICAgICAgfVxuICAgICAgICByZXRBcnIucHVzaChgdGhyZWFkSWQuJHtuYW1lfWApO1xuICAgICAgICByZXR1cm4gcmV0QXJyO1xuICAgICAgY2FzZSAndGhpcy5vdXRwdXQudmFsdWUnOlxuICAgICAgICBpZiAodGhpcy5keW5hbWljT3V0cHV0KSB7XG4gICAgICAgICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICAgICAgICBjYXNlICd4JzpcbiAgICAgICAgICAgICAgaWYgKHRoaXMuaXNTdGF0ZSgnY2FzdGluZy10by1mbG9hdCcpKSB7XG4gICAgICAgICAgICAgICAgcmV0QXJyLnB1c2goJ2Zsb2F0KHVPdXRwdXREaW0ueCknKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXRBcnIucHVzaCgndU91dHB1dERpbS54Jyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd5JzpcbiAgICAgICAgICAgICAgaWYgKHRoaXMuaXNTdGF0ZSgnY2FzdGluZy10by1mbG9hdCcpKSB7XG4gICAgICAgICAgICAgICAgcmV0QXJyLnB1c2goJ2Zsb2F0KHVPdXRwdXREaW0ueSknKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXRBcnIucHVzaCgndU91dHB1dERpbS55Jyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd6JzpcbiAgICAgICAgICAgICAgaWYgKHRoaXMuaXNTdGF0ZSgnY2FzdGluZy10by1mbG9hdCcpKSB7XG4gICAgICAgICAgICAgICAgcmV0QXJyLnB1c2goJ2Zsb2F0KHVPdXRwdXREaW0ueiknKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXRBcnIucHVzaCgndU91dHB1dERpbS56Jyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICB0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KCdVbmV4cGVjdGVkIGV4cHJlc3Npb24nLCBtTm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgICAgICAgY2FzZSAneCc6XG4gICAgICAgICAgICAgIGlmICh0aGlzLmlzU3RhdGUoJ2Nhc3RpbmctdG8taW50ZWdlcicpKSB7XG4gICAgICAgICAgICAgICAgcmV0QXJyLnB1c2godGhpcy5vdXRwdXRbMF0pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldEFyci5wdXNoKHRoaXMub3V0cHV0WzBdLCAnLjAnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3knOlxuICAgICAgICAgICAgICBpZiAodGhpcy5pc1N0YXRlKCdjYXN0aW5nLXRvLWludGVnZXInKSkge1xuICAgICAgICAgICAgICAgIHJldEFyci5wdXNoKHRoaXMub3V0cHV0WzFdKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXRBcnIucHVzaCh0aGlzLm91dHB1dFsxXSwgJy4wJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd6JzpcbiAgICAgICAgICAgICAgaWYgKHRoaXMuaXNTdGF0ZSgnY2FzdGluZy10by1pbnRlZ2VyJykpIHtcbiAgICAgICAgICAgICAgICByZXRBcnIucHVzaCh0aGlzLm91dHB1dFsyXSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0QXJyLnB1c2godGhpcy5vdXRwdXRbMl0sICcuMCcpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgdGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dCgnVW5leHBlY3RlZCBleHByZXNzaW9uJywgbU5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0QXJyO1xuICAgICAgY2FzZSAndmFsdWUnOlxuICAgICAgICB0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KCdVbmV4cGVjdGVkIGV4cHJlc3Npb24nLCBtTm9kZSk7XG4gICAgICBjYXNlICd2YWx1ZVtdJzpcbiAgICAgIGNhc2UgJ3ZhbHVlW11bXSc6XG4gICAgICBjYXNlICd2YWx1ZVtdW11bXSc6XG4gICAgICBjYXNlICd2YWx1ZVtdW11bXVtdJzpcbiAgICAgIGNhc2UgJ3ZhbHVlLnZhbHVlJzpcbiAgICAgICAgaWYgKG9yaWdpbiA9PT0gJ01hdGgnKSB7XG4gICAgICAgICAgcmV0QXJyLnB1c2goTWF0aFtuYW1lXSk7XG4gICAgICAgICAgcmV0dXJuIHJldEFycjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjbGVhbk5hbWUgPSB1dGlscy5zYW5pdGl6ZU5hbWUobmFtZSk7XG4gICAgICAgIHN3aXRjaCAocHJvcGVydHkpIHtcbiAgICAgICAgICBjYXNlICdyJzpcbiAgICAgICAgICAgIHJldEFyci5wdXNoKGB1c2VyXyR7IGNsZWFuTmFtZSB9LnJgKTtcbiAgICAgICAgICAgIHJldHVybiByZXRBcnI7XG4gICAgICAgICAgY2FzZSAnZyc6XG4gICAgICAgICAgICByZXRBcnIucHVzaChgdXNlcl8keyBjbGVhbk5hbWUgfS5nYCk7XG4gICAgICAgICAgICByZXR1cm4gcmV0QXJyO1xuICAgICAgICAgIGNhc2UgJ2InOlxuICAgICAgICAgICAgcmV0QXJyLnB1c2goYHVzZXJfJHsgY2xlYW5OYW1lIH0uYmApO1xuICAgICAgICAgICAgcmV0dXJuIHJldEFycjtcbiAgICAgICAgICBjYXNlICdhJzpcbiAgICAgICAgICAgIHJldEFyci5wdXNoKGB1c2VyXyR7IGNsZWFuTmFtZSB9LmFgKTtcbiAgICAgICAgICAgIHJldHVybiByZXRBcnI7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0aGlzLmNvbnN0YW50cy52YWx1ZSc6XG4gICAgICAgIGlmICh0eXBlb2YgeFByb3BlcnR5ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnQXJyYXkoMiknOlxuICAgICAgICAgICAgY2FzZSAnQXJyYXkoMyknOlxuICAgICAgICAgICAgY2FzZSAnQXJyYXkoNCknOlxuICAgICAgICAgICAgICByZXRBcnIucHVzaChgY29uc3RhbnRzXyR7IHV0aWxzLnNhbml0aXplTmFtZShuYW1lKSB9YCk7XG4gICAgICAgICAgICAgIHJldHVybiByZXRBcnI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ3RoaXMuY29uc3RhbnRzLnZhbHVlW10nOlxuICAgICAgICBjYXNlICd0aGlzLmNvbnN0YW50cy52YWx1ZVtdW10nOlxuICAgICAgICBjYXNlICd0aGlzLmNvbnN0YW50cy52YWx1ZVtdW11bXSc6XG4gICAgICAgIGNhc2UgJ3RoaXMuY29uc3RhbnRzLnZhbHVlW11bXVtdW10nOlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdmbigpW10nOlxuICAgICAgICAgIHRoaXMuYXN0Q2FsbEV4cHJlc3Npb24obU5vZGUub2JqZWN0LCByZXRBcnIpO1xuICAgICAgICAgIHJldEFyci5wdXNoKCdbJyk7XG4gICAgICAgICAgcmV0QXJyLnB1c2godGhpcy5tZW1iZXJFeHByZXNzaW9uUHJvcGVydHlNYXJrdXAocHJvcGVydHkpKTtcbiAgICAgICAgICByZXRBcnIucHVzaCgnXScpO1xuICAgICAgICAgIHJldHVybiByZXRBcnI7XG4gICAgICAgIGNhc2UgJ2ZuKClbXVtdJzpcbiAgICAgICAgICB0aGlzLmFzdENhbGxFeHByZXNzaW9uKG1Ob2RlLm9iamVjdC5vYmplY3QsIHJldEFycik7XG4gICAgICAgICAgcmV0QXJyLnB1c2goJ1snKTtcbiAgICAgICAgICByZXRBcnIucHVzaCh0aGlzLm1lbWJlckV4cHJlc3Npb25Qcm9wZXJ0eU1hcmt1cChtTm9kZS5vYmplY3QucHJvcGVydHkpKTtcbiAgICAgICAgICByZXRBcnIucHVzaCgnXScpO1xuICAgICAgICAgIHJldEFyci5wdXNoKCdbJyk7XG4gICAgICAgICAgcmV0QXJyLnB1c2godGhpcy5tZW1iZXJFeHByZXNzaW9uUHJvcGVydHlNYXJrdXAobU5vZGUucHJvcGVydHkpKTtcbiAgICAgICAgICByZXRBcnIucHVzaCgnXScpO1xuICAgICAgICAgIHJldHVybiByZXRBcnI7XG4gICAgICAgIGNhc2UgJ1tdW10nOlxuICAgICAgICAgIHRoaXMuYXN0QXJyYXlFeHByZXNzaW9uKG1Ob2RlLm9iamVjdCwgcmV0QXJyKTtcbiAgICAgICAgICByZXRBcnIucHVzaCgnWycpO1xuICAgICAgICAgIHJldEFyci5wdXNoKHRoaXMubWVtYmVyRXhwcmVzc2lvblByb3BlcnR5TWFya3VwKHByb3BlcnR5KSk7XG4gICAgICAgICAgcmV0QXJyLnB1c2goJ10nKTtcbiAgICAgICAgICByZXR1cm4gcmV0QXJyO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoJ1VuZXhwZWN0ZWQgZXhwcmVzc2lvbicsIG1Ob2RlKTtcbiAgICB9XG5cbiAgICBpZiAobU5vZGUuY29tcHV0ZWQgPT09IGZhbHNlKSB7XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSAnTnVtYmVyJzpcbiAgICAgICAgY2FzZSAnSW50ZWdlcic6XG4gICAgICAgIGNhc2UgJ0Zsb2F0JzpcbiAgICAgICAgY2FzZSAnQm9vbGVhbic6XG4gICAgICAgICAgcmV0QXJyLnB1c2goYCR7b3JpZ2lufV8ke3V0aWxzLnNhbml0aXplTmFtZShuYW1lKX1gKTtcbiAgICAgICAgICByZXR1cm4gcmV0QXJyO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IG1hcmt1cE5hbWUgPSBgJHtvcmlnaW59XyR7dXRpbHMuc2FuaXRpemVOYW1lKG5hbWUpfWA7XG5cbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgJ0FycmF5KDIpJzpcbiAgICAgIGNhc2UgJ0FycmF5KDMpJzpcbiAgICAgIGNhc2UgJ0FycmF5KDQpJzpcbiAgICAgICAgdGhpcy5hc3RHZW5lcmljKG1Ob2RlLm9iamVjdCwgcmV0QXJyKTtcbiAgICAgICAgcmV0QXJyLnB1c2goJ1snKTtcbiAgICAgICAgcmV0QXJyLnB1c2godGhpcy5tZW1iZXJFeHByZXNzaW9uUHJvcGVydHlNYXJrdXAoeFByb3BlcnR5KSk7XG4gICAgICAgIHJldEFyci5wdXNoKCddJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnSFRNTEltYWdlQXJyYXknOlxuICAgICAgICByZXRBcnIucHVzaChgZ2V0SW1hZ2UzRCgkeyBtYXJrdXBOYW1lIH0sICR7IG1hcmt1cE5hbWUgfVNpemUsICR7IG1hcmt1cE5hbWUgfURpbSwgYCk7XG4gICAgICAgIHRoaXMubWVtYmVyRXhwcmVzc2lvblhZWih4UHJvcGVydHksIHlQcm9wZXJ0eSwgelByb3BlcnR5LCByZXRBcnIpO1xuICAgICAgICByZXRBcnIucHVzaCgnKScpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0FycmF5VGV4dHVyZSgxKSc6XG4gICAgICAgIHJldEFyci5wdXNoKGBnZXRGbG9hdEZyb21TYW1wbGVyMkQoJHsgbWFya3VwTmFtZSB9LCAkeyBtYXJrdXBOYW1lIH1TaXplLCAkeyBtYXJrdXBOYW1lIH1EaW0sIGApO1xuICAgICAgICB0aGlzLm1lbWJlckV4cHJlc3Npb25YWVooeFByb3BlcnR5LCB5UHJvcGVydHksIHpQcm9wZXJ0eSwgcmV0QXJyKTtcbiAgICAgICAgcmV0QXJyLnB1c2goJyknKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdBcnJheTFEKDIpJzpcbiAgICAgIGNhc2UgJ0FycmF5MkQoMiknOlxuICAgICAgY2FzZSAnQXJyYXkzRCgyKSc6XG4gICAgICAgIHJldEFyci5wdXNoKGBnZXRNZW1vcnlPcHRpbWl6ZWRWZWMyKCR7IG1hcmt1cE5hbWUgfSwgJHsgbWFya3VwTmFtZSB9U2l6ZSwgJHsgbWFya3VwTmFtZSB9RGltLCBgKTtcbiAgICAgICAgdGhpcy5tZW1iZXJFeHByZXNzaW9uWFlaKHhQcm9wZXJ0eSwgeVByb3BlcnR5LCB6UHJvcGVydHksIHJldEFycik7XG4gICAgICAgIHJldEFyci5wdXNoKCcpJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnQXJyYXlUZXh0dXJlKDIpJzpcbiAgICAgICAgcmV0QXJyLnB1c2goYGdldFZlYzJGcm9tU2FtcGxlcjJEKCR7IG1hcmt1cE5hbWUgfSwgJHsgbWFya3VwTmFtZSB9U2l6ZSwgJHsgbWFya3VwTmFtZSB9RGltLCBgKTtcbiAgICAgICAgdGhpcy5tZW1iZXJFeHByZXNzaW9uWFlaKHhQcm9wZXJ0eSwgeVByb3BlcnR5LCB6UHJvcGVydHksIHJldEFycik7XG4gICAgICAgIHJldEFyci5wdXNoKCcpJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnQXJyYXkxRCgzKSc6XG4gICAgICBjYXNlICdBcnJheTJEKDMpJzpcbiAgICAgIGNhc2UgJ0FycmF5M0QoMyknOlxuICAgICAgICByZXRBcnIucHVzaChgZ2V0TWVtb3J5T3B0aW1pemVkVmVjMygkeyBtYXJrdXBOYW1lIH0sICR7IG1hcmt1cE5hbWUgfVNpemUsICR7IG1hcmt1cE5hbWUgfURpbSwgYCk7XG4gICAgICAgIHRoaXMubWVtYmVyRXhwcmVzc2lvblhZWih4UHJvcGVydHksIHlQcm9wZXJ0eSwgelByb3BlcnR5LCByZXRBcnIpO1xuICAgICAgICByZXRBcnIucHVzaCgnKScpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0FycmF5VGV4dHVyZSgzKSc6XG4gICAgICAgIHJldEFyci5wdXNoKGBnZXRWZWMzRnJvbVNhbXBsZXIyRCgkeyBtYXJrdXBOYW1lIH0sICR7IG1hcmt1cE5hbWUgfVNpemUsICR7IG1hcmt1cE5hbWUgfURpbSwgYCk7XG4gICAgICAgIHRoaXMubWVtYmVyRXhwcmVzc2lvblhZWih4UHJvcGVydHksIHlQcm9wZXJ0eSwgelByb3BlcnR5LCByZXRBcnIpO1xuICAgICAgICByZXRBcnIucHVzaCgnKScpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0FycmF5MUQoNCknOlxuICAgICAgY2FzZSAnQXJyYXkyRCg0KSc6XG4gICAgICBjYXNlICdBcnJheTNEKDQpJzpcbiAgICAgICAgcmV0QXJyLnB1c2goYGdldE1lbW9yeU9wdGltaXplZFZlYzQoJHsgbWFya3VwTmFtZSB9LCAkeyBtYXJrdXBOYW1lIH1TaXplLCAkeyBtYXJrdXBOYW1lIH1EaW0sIGApO1xuICAgICAgICB0aGlzLm1lbWJlckV4cHJlc3Npb25YWVooeFByb3BlcnR5LCB5UHJvcGVydHksIHpQcm9wZXJ0eSwgcmV0QXJyKTtcbiAgICAgICAgcmV0QXJyLnB1c2goJyknKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdBcnJheVRleHR1cmUoNCknOlxuICAgICAgY2FzZSAnSFRNTENhbnZhcyc6XG4gICAgICBjYXNlICdPZmZzY3JlZW5DYW52YXMnOlxuICAgICAgY2FzZSAnSFRNTEltYWdlJzpcbiAgICAgIGNhc2UgJ0ltYWdlQml0bWFwJzpcbiAgICAgIGNhc2UgJ0ltYWdlRGF0YSc6XG4gICAgICBjYXNlICdIVE1MVmlkZW8nOlxuICAgICAgICByZXRBcnIucHVzaChgZ2V0VmVjNEZyb21TYW1wbGVyMkQoJHsgbWFya3VwTmFtZSB9LCAkeyBtYXJrdXBOYW1lIH1TaXplLCAkeyBtYXJrdXBOYW1lIH1EaW0sIGApO1xuICAgICAgICB0aGlzLm1lbWJlckV4cHJlc3Npb25YWVooeFByb3BlcnR5LCB5UHJvcGVydHksIHpQcm9wZXJ0eSwgcmV0QXJyKTtcbiAgICAgICAgcmV0QXJyLnB1c2goJyknKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdOdW1iZXJUZXh0dXJlJzpcbiAgICAgIGNhc2UgJ0FycmF5JzpcbiAgICAgIGNhc2UgJ0FycmF5MkQnOlxuICAgICAgY2FzZSAnQXJyYXkzRCc6XG4gICAgICBjYXNlICdBcnJheTREJzpcbiAgICAgIGNhc2UgJ0lucHV0JzpcbiAgICAgIGNhc2UgJ051bWJlcic6XG4gICAgICBjYXNlICdGbG9hdCc6XG4gICAgICBjYXNlICdJbnRlZ2VyJzpcbiAgICAgICAgaWYgKHRoaXMucHJlY2lzaW9uID09PSAnc2luZ2xlJykge1xuICAgICAgICAgIHJldEFyci5wdXNoKGBnZXRNZW1vcnlPcHRpbWl6ZWQzMigke21hcmt1cE5hbWV9LCAke21hcmt1cE5hbWV9U2l6ZSwgJHttYXJrdXBOYW1lfURpbSwgYCk7XG4gICAgICAgICAgdGhpcy5tZW1iZXJFeHByZXNzaW9uWFlaKHhQcm9wZXJ0eSwgeVByb3BlcnR5LCB6UHJvcGVydHksIHJldEFycik7XG4gICAgICAgICAgcmV0QXJyLnB1c2goJyknKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBiaXRSYXRpbyA9IChvcmlnaW4gPT09ICd1c2VyJyA/XG4gICAgICAgICAgICB0aGlzLmxvb2t1cEZ1bmN0aW9uQXJndW1lbnRCaXRSYXRpbyh0aGlzLm5hbWUsIG5hbWUpIDpcbiAgICAgICAgICAgIHRoaXMuY29uc3RhbnRCaXRSYXRpb3NbbmFtZV1cbiAgICAgICAgICApO1xuICAgICAgICAgIHN3aXRjaCAoYml0UmF0aW8pIHtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgcmV0QXJyLnB1c2goYGdldDgoJHttYXJrdXBOYW1lfSwgJHttYXJrdXBOYW1lfVNpemUsICR7bWFya3VwTmFtZX1EaW0sIGApO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgcmV0QXJyLnB1c2goYGdldDE2KCR7bWFya3VwTmFtZX0sICR7bWFya3VwTmFtZX1TaXplLCAke21hcmt1cE5hbWV9RGltLCBgKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIHJldEFyci5wdXNoKGBnZXQzMigke21hcmt1cE5hbWV9LCAke21hcmt1cE5hbWV9U2l6ZSwgJHttYXJrdXBOYW1lfURpbSwgYCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmhhbmRsZWQgYml0IHJhdGlvIG9mICR7Yml0UmF0aW99YCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMubWVtYmVyRXhwcmVzc2lvblhZWih4UHJvcGVydHksIHlQcm9wZXJ0eSwgelByb3BlcnR5LCByZXRBcnIpO1xuICAgICAgICAgIHJldEFyci5wdXNoKCcpJyk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdNZW1vcnlPcHRpbWl6ZWROdW1iZXJUZXh0dXJlJzpcbiAgICAgICAgcmV0QXJyLnB1c2goYGdldE1lbW9yeU9wdGltaXplZDMyKCR7IG1hcmt1cE5hbWUgfSwgJHsgbWFya3VwTmFtZSB9U2l6ZSwgJHsgbWFya3VwTmFtZSB9RGltLCBgKTtcbiAgICAgICAgdGhpcy5tZW1iZXJFeHByZXNzaW9uWFlaKHhQcm9wZXJ0eSwgeVByb3BlcnR5LCB6UHJvcGVydHksIHJldEFycik7XG4gICAgICAgIHJldEFyci5wdXNoKCcpJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnTWF0cml4KDIpJzpcbiAgICAgIGNhc2UgJ01hdHJpeCgzKSc6XG4gICAgICBjYXNlICdNYXRyaXgoNCknOlxuICAgICAgICByZXRBcnIucHVzaChgJHttYXJrdXBOYW1lfVske3RoaXMubWVtYmVyRXhwcmVzc2lvblByb3BlcnR5TWFya3VwKHlQcm9wZXJ0eSl9XWApO1xuICAgICAgICBpZiAoeVByb3BlcnR5KSB7XG4gICAgICAgICAgcmV0QXJyLnB1c2goYFske3RoaXMubWVtYmVyRXhwcmVzc2lvblByb3BlcnR5TWFya3VwKHhQcm9wZXJ0eSl9XWApO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmhhbmRsZWQgbWVtYmVyIGV4cHJlc3Npb24gXCIkeyB0eXBlIH1cImApO1xuICAgIH1cbiAgICByZXR1cm4gcmV0QXJyO1xuICB9XG5cbiAgYXN0Q2FsbEV4cHJlc3Npb24oYXN0LCByZXRBcnIpIHtcbiAgICBpZiAoIWFzdC5jYWxsZWUpIHtcbiAgICAgIHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoJ1Vua25vd24gQ2FsbEV4cHJlc3Npb24nLCBhc3QpO1xuICAgIH1cblxuICAgIGxldCBmdW5jdGlvbk5hbWUgPSBudWxsO1xuICAgIGNvbnN0IGlzTWF0aEZ1bmN0aW9uID0gdGhpcy5pc0FzdE1hdGhGdW5jdGlvbihhc3QpO1xuXG4gICAgaWYgKGlzTWF0aEZ1bmN0aW9uIHx8IChhc3QuY2FsbGVlLm9iamVjdCAmJiBhc3QuY2FsbGVlLm9iamVjdC50eXBlID09PSAnVGhpc0V4cHJlc3Npb24nKSkge1xuICAgICAgZnVuY3Rpb25OYW1lID0gYXN0LmNhbGxlZS5wcm9wZXJ0eS5uYW1lO1xuICAgIH1cbiAgICBlbHNlIGlmIChhc3QuY2FsbGVlLnR5cGUgPT09ICdTZXF1ZW5jZUV4cHJlc3Npb24nICYmIGFzdC5jYWxsZWUuZXhwcmVzc2lvbnNbMF0udHlwZSA9PT0gJ0xpdGVyYWwnICYmICFpc05hTihhc3QuY2FsbGVlLmV4cHJlc3Npb25zWzBdLnJhdykpIHtcbiAgICAgIGZ1bmN0aW9uTmFtZSA9IGFzdC5jYWxsZWUuZXhwcmVzc2lvbnNbMV0ucHJvcGVydHkubmFtZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZnVuY3Rpb25OYW1lID0gYXN0LmNhbGxlZS5uYW1lO1xuICAgIH1cblxuICAgIGlmICghZnVuY3Rpb25OYW1lKSB7XG4gICAgICB0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KGBVbmhhbmRsZWQgZnVuY3Rpb24sIGNvdWxkbid0IGZpbmQgbmFtZWAsIGFzdCk7XG4gICAgfVxuXG4gICAgc3dpdGNoIChmdW5jdGlvbk5hbWUpIHtcbiAgICAgIGNhc2UgJ3Bvdyc6XG4gICAgICAgIGZ1bmN0aW9uTmFtZSA9ICdfcG93JztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdyb3VuZCc6XG4gICAgICAgIGZ1bmN0aW9uTmFtZSA9ICdfcm91bmQnO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICBpZiAodGhpcy5jYWxsZWRGdW5jdGlvbnMuaW5kZXhPZihmdW5jdGlvbk5hbWUpIDwgMCkge1xuICAgICAgdGhpcy5jYWxsZWRGdW5jdGlvbnMucHVzaChmdW5jdGlvbk5hbWUpO1xuICAgIH1cblxuICAgIGlmIChmdW5jdGlvbk5hbWUgPT09ICdyYW5kb20nICYmIHRoaXMucGx1Z2lucyAmJiB0aGlzLnBsdWdpbnMubGVuZ3RoID4gMCkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnBsdWdpbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgcGx1Z2luID0gdGhpcy5wbHVnaW5zW2ldO1xuICAgICAgICBpZiAocGx1Z2luLmZ1bmN0aW9uTWF0Y2ggPT09ICdNYXRoLnJhbmRvbSgpJyAmJiBwbHVnaW4uZnVuY3Rpb25SZXBsYWNlKSB7XG4gICAgICAgICAgcmV0QXJyLnB1c2gocGx1Z2luLmZ1bmN0aW9uUmVwbGFjZSk7XG4gICAgICAgICAgcmV0dXJuIHJldEFycjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLm9uRnVuY3Rpb25DYWxsKSB7XG4gICAgICB0aGlzLm9uRnVuY3Rpb25DYWxsKHRoaXMubmFtZSwgZnVuY3Rpb25OYW1lLCBhc3QuYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICByZXRBcnIucHVzaChmdW5jdGlvbk5hbWUpO1xuXG4gICAgcmV0QXJyLnB1c2goJygnKTtcblxuICAgIGlmIChpc01hdGhGdW5jdGlvbikge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhc3QuYXJndW1lbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IGFyZ3VtZW50ID0gYXN0LmFyZ3VtZW50c1tpXTtcbiAgICAgICAgY29uc3QgYXJndW1lbnRUeXBlID0gdGhpcy5nZXRUeXBlKGFyZ3VtZW50KTtcbiAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgcmV0QXJyLnB1c2goJywgJyk7XG4gICAgICAgIH1cblxuICAgICAgICBzd2l0Y2ggKGFyZ3VtZW50VHlwZSkge1xuICAgICAgICAgIGNhc2UgJ0ludGVnZXInOlxuICAgICAgICAgICAgdGhpcy5jYXN0VmFsdWVUb0Zsb2F0KGFyZ3VtZW50LCByZXRBcnIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRoaXMuYXN0R2VuZXJpYyhhcmd1bWVudCwgcmV0QXJyKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHRhcmdldFR5cGVzID0gdGhpcy5sb29rdXBGdW5jdGlvbkFyZ3VtZW50VHlwZXMoZnVuY3Rpb25OYW1lKSB8fCBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXN0LmFyZ3VtZW50cy5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBhcmd1bWVudCA9IGFzdC5hcmd1bWVudHNbaV07XG4gICAgICAgIGxldCB0YXJnZXRUeXBlID0gdGFyZ2V0VHlwZXNbaV07XG4gICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgIHJldEFyci5wdXNoKCcsICcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFyZ3VtZW50VHlwZSA9IHRoaXMuZ2V0VHlwZShhcmd1bWVudCk7XG4gICAgICAgIGlmICghdGFyZ2V0VHlwZSkge1xuICAgICAgICAgIHRoaXMudHJpZ2dlckltcGx5QXJndW1lbnRUeXBlKGZ1bmN0aW9uTmFtZSwgaSwgYXJndW1lbnRUeXBlLCB0aGlzKTtcbiAgICAgICAgICB0YXJnZXRUeXBlID0gYXJndW1lbnRUeXBlO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAoYXJndW1lbnRUeXBlKSB7XG4gICAgICAgICAgY2FzZSAnQm9vbGVhbic6XG4gICAgICAgICAgICB0aGlzLmFzdEdlbmVyaWMoYXJndW1lbnQsIHJldEFycik7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICBjYXNlICdOdW1iZXInOlxuICAgICAgICAgIGNhc2UgJ0Zsb2F0JzpcbiAgICAgICAgICAgIGlmICh0YXJnZXRUeXBlID09PSAnSW50ZWdlcicpIHtcbiAgICAgICAgICAgICAgcmV0QXJyLnB1c2goJ2ludCgnKTtcbiAgICAgICAgICAgICAgdGhpcy5hc3RHZW5lcmljKGFyZ3VtZW50LCByZXRBcnIpO1xuICAgICAgICAgICAgICByZXRBcnIucHVzaCgnKScpO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGFyZ2V0VHlwZSA9PT0gJ051bWJlcicgfHwgdGFyZ2V0VHlwZSA9PT0gJ0Zsb2F0Jykge1xuICAgICAgICAgICAgICB0aGlzLmFzdEdlbmVyaWMoYXJndW1lbnQsIHJldEFycik7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0YXJnZXRUeXBlID09PSAnTGl0ZXJhbEludGVnZXInKSB7XG4gICAgICAgICAgICAgIHRoaXMuY2FzdExpdGVyYWxUb0Zsb2F0KGFyZ3VtZW50LCByZXRBcnIpO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ0ludGVnZXInOlxuICAgICAgICAgICAgaWYgKHRhcmdldFR5cGUgPT09ICdOdW1iZXInIHx8IHRhcmdldFR5cGUgPT09ICdGbG9hdCcpIHtcbiAgICAgICAgICAgICAgcmV0QXJyLnB1c2goJ2Zsb2F0KCcpO1xuICAgICAgICAgICAgICB0aGlzLmFzdEdlbmVyaWMoYXJndW1lbnQsIHJldEFycik7XG4gICAgICAgICAgICAgIHJldEFyci5wdXNoKCcpJyk7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0YXJnZXRUeXBlID09PSAnSW50ZWdlcicpIHtcbiAgICAgICAgICAgICAgdGhpcy5hc3RHZW5lcmljKGFyZ3VtZW50LCByZXRBcnIpO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ0xpdGVyYWxJbnRlZ2VyJzpcbiAgICAgICAgICAgIGlmICh0YXJnZXRUeXBlID09PSAnSW50ZWdlcicpIHtcbiAgICAgICAgICAgICAgdGhpcy5jYXN0TGl0ZXJhbFRvSW50ZWdlcihhcmd1bWVudCwgcmV0QXJyKTtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRhcmdldFR5cGUgPT09ICdOdW1iZXInIHx8IHRhcmdldFR5cGUgPT09ICdGbG9hdCcpIHtcbiAgICAgICAgICAgICAgdGhpcy5jYXN0TGl0ZXJhbFRvRmxvYXQoYXJndW1lbnQsIHJldEFycik7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0YXJnZXRUeXBlID09PSAnTGl0ZXJhbEludGVnZXInKSB7XG4gICAgICAgICAgICAgIHRoaXMuYXN0R2VuZXJpYyhhcmd1bWVudCwgcmV0QXJyKTtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdBcnJheSgyKSc6XG4gICAgICAgICAgY2FzZSAnQXJyYXkoMyknOlxuICAgICAgICAgIGNhc2UgJ0FycmF5KDQpJzpcbiAgICAgICAgICAgIGlmICh0YXJnZXRUeXBlID09PSBhcmd1bWVudFR5cGUpIHtcbiAgICAgICAgICAgICAgaWYgKGFyZ3VtZW50LnR5cGUgPT09ICdJZGVudGlmaWVyJykge1xuICAgICAgICAgICAgICAgIHJldEFyci5wdXNoKGB1c2VyXyR7dXRpbHMuc2FuaXRpemVOYW1lKGFyZ3VtZW50Lm5hbWUpfWApO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGFyZ3VtZW50LnR5cGUgPT09ICdBcnJheUV4cHJlc3Npb24nIHx8IGFyZ3VtZW50LnR5cGUgPT09ICdNZW1iZXJFeHByZXNzaW9uJyB8fCBhcmd1bWVudC50eXBlID09PSAnQ2FsbEV4cHJlc3Npb24nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hc3RHZW5lcmljKGFyZ3VtZW50LCByZXRBcnIpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoYFVuaGFuZGxlZCBhcmd1bWVudCB0eXBlICR7IGFyZ3VtZW50LnR5cGUgfWAsIGFzdCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdIVE1MQ2FudmFzJzpcbiAgICAgICAgICBjYXNlICdPZmZzY3JlZW5DYW52YXMnOlxuICAgICAgICAgIGNhc2UgJ0hUTUxJbWFnZSc6XG4gICAgICAgICAgY2FzZSAnSW1hZ2VCaXRtYXAnOlxuICAgICAgICAgIGNhc2UgJ0ltYWdlRGF0YSc6XG4gICAgICAgICAgY2FzZSAnSFRNTEltYWdlQXJyYXknOlxuICAgICAgICAgIGNhc2UgJ0hUTUxWaWRlbyc6XG4gICAgICAgICAgY2FzZSAnQXJyYXlUZXh0dXJlKDEpJzpcbiAgICAgICAgICBjYXNlICdBcnJheVRleHR1cmUoMiknOlxuICAgICAgICAgIGNhc2UgJ0FycmF5VGV4dHVyZSgzKSc6XG4gICAgICAgICAgY2FzZSAnQXJyYXlUZXh0dXJlKDQpJzpcbiAgICAgICAgICBjYXNlICdBcnJheSc6XG4gICAgICAgICAgY2FzZSAnSW5wdXQnOlxuICAgICAgICAgICAgaWYgKHRhcmdldFR5cGUgPT09IGFyZ3VtZW50VHlwZSkge1xuICAgICAgICAgICAgICBpZiAoYXJndW1lbnQudHlwZSAhPT0gJ0lkZW50aWZpZXInKSB0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KGBVbmhhbmRsZWQgYXJndW1lbnQgdHlwZSAkeyBhcmd1bWVudC50eXBlIH1gLCBhc3QpO1xuICAgICAgICAgICAgICB0aGlzLnRyaWdnZXJJbXBseUFyZ3VtZW50Qml0UmF0aW8odGhpcy5uYW1lLCBhcmd1bWVudC5uYW1lLCBmdW5jdGlvbk5hbWUsIGkpO1xuICAgICAgICAgICAgICBjb25zdCBuYW1lID0gdXRpbHMuc2FuaXRpemVOYW1lKGFyZ3VtZW50Lm5hbWUpO1xuICAgICAgICAgICAgICByZXRBcnIucHVzaChgdXNlcl8ke25hbWV9LHVzZXJfJHtuYW1lfVNpemUsdXNlcl8ke25hbWV9RGltYCk7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dChgVW5oYW5kbGVkIGFyZ3VtZW50IGNvbWJpbmF0aW9uIG9mICR7IGFyZ3VtZW50VHlwZSB9IGFuZCAkeyB0YXJnZXRUeXBlIH0gZm9yIGFyZ3VtZW50IG5hbWVkIFwiJHsgYXJndW1lbnQubmFtZSB9XCJgLCBhc3QpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXRBcnIucHVzaCgnKScpO1xuXG4gICAgcmV0dXJuIHJldEFycjtcbiAgfVxuXG4gIGFzdEFycmF5RXhwcmVzc2lvbihhcnJOb2RlLCByZXRBcnIpIHtcbiAgICBjb25zdCByZXR1cm5UeXBlID0gdGhpcy5nZXRUeXBlKGFyck5vZGUpO1xuXG4gICAgY29uc3QgYXJyTGVuID0gYXJyTm9kZS5lbGVtZW50cy5sZW5ndGg7XG5cbiAgICBzd2l0Y2ggKHJldHVyblR5cGUpIHtcbiAgICAgIGNhc2UgJ01hdHJpeCgyKSc6XG4gICAgICBjYXNlICdNYXRyaXgoMyknOlxuICAgICAgY2FzZSAnTWF0cml4KDQpJzpcbiAgICAgICAgcmV0QXJyLnB1c2goYG1hdCR7YXJyTGVufShgKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXRBcnIucHVzaChgdmVjJHthcnJMZW59KGApO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyckxlbjsgKytpKSB7XG4gICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgcmV0QXJyLnB1c2goJywgJyk7XG4gICAgICB9XG4gICAgICBjb25zdCBzdWJOb2RlID0gYXJyTm9kZS5lbGVtZW50c1tpXTtcbiAgICAgIHRoaXMuYXN0R2VuZXJpYyhzdWJOb2RlLCByZXRBcnIpXG4gICAgfVxuICAgIHJldEFyci5wdXNoKCcpJyk7XG5cbiAgICByZXR1cm4gcmV0QXJyO1xuICB9XG5cbiAgbWVtYmVyRXhwcmVzc2lvblhZWih4LCB5LCB6LCByZXRBcnIpIHtcbiAgICBpZiAoeikge1xuICAgICAgcmV0QXJyLnB1c2godGhpcy5tZW1iZXJFeHByZXNzaW9uUHJvcGVydHlNYXJrdXAoeiksICcsICcpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXRBcnIucHVzaCgnMCwgJyk7XG4gICAgfVxuICAgIGlmICh5KSB7XG4gICAgICByZXRBcnIucHVzaCh0aGlzLm1lbWJlckV4cHJlc3Npb25Qcm9wZXJ0eU1hcmt1cCh5KSwgJywgJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldEFyci5wdXNoKCcwLCAnKTtcbiAgICB9XG4gICAgcmV0QXJyLnB1c2godGhpcy5tZW1iZXJFeHByZXNzaW9uUHJvcGVydHlNYXJrdXAoeCkpO1xuICAgIHJldHVybiByZXRBcnI7XG4gIH1cblxuICBtZW1iZXJFeHByZXNzaW9uUHJvcGVydHlNYXJrdXAocHJvcGVydHkpIHtcbiAgICBpZiAoIXByb3BlcnR5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb3BlcnR5IG5vdCBzZXQnKTtcbiAgICB9XG4gICAgY29uc3QgdHlwZSA9IHRoaXMuZ2V0VHlwZShwcm9wZXJ0eSk7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlICdOdW1iZXInOlxuICAgICAgY2FzZSAnRmxvYXQnOlxuICAgICAgICB0aGlzLmNhc3RWYWx1ZVRvSW50ZWdlcihwcm9wZXJ0eSwgcmVzdWx0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdMaXRlcmFsSW50ZWdlcic6XG4gICAgICAgIHRoaXMuY2FzdExpdGVyYWxUb0ludGVnZXIocHJvcGVydHksIHJlc3VsdCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhpcy5hc3RHZW5lcmljKHByb3BlcnR5LCByZXN1bHQpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0LmpvaW4oJycpO1xuICB9XG59XG5cbmNvbnN0IHR5cGVNYXAgPSB7XG4gICdBcnJheSc6ICdzYW1wbGVyMkQnLFxuICAnQXJyYXkoMiknOiAndmVjMicsXG4gICdBcnJheSgzKSc6ICd2ZWMzJyxcbiAgJ0FycmF5KDQpJzogJ3ZlYzQnLFxuICAnTWF0cml4KDIpJzogJ21hdDInLFxuICAnTWF0cml4KDMpJzogJ21hdDMnLFxuICAnTWF0cml4KDQpJzogJ21hdDQnLFxuICAnQXJyYXkyRCc6ICdzYW1wbGVyMkQnLFxuICAnQXJyYXkzRCc6ICdzYW1wbGVyMkQnLFxuICAnQm9vbGVhbic6ICdib29sJyxcbiAgJ0Zsb2F0JzogJ2Zsb2F0JyxcbiAgJ0lucHV0JzogJ3NhbXBsZXIyRCcsXG4gICdJbnRlZ2VyJzogJ2ludCcsXG4gICdOdW1iZXInOiAnZmxvYXQnLFxuICAnTGl0ZXJhbEludGVnZXInOiAnZmxvYXQnLFxuICAnTnVtYmVyVGV4dHVyZSc6ICdzYW1wbGVyMkQnLFxuICAnTWVtb3J5T3B0aW1pemVkTnVtYmVyVGV4dHVyZSc6ICdzYW1wbGVyMkQnLFxuICAnQXJyYXlUZXh0dXJlKDEpJzogJ3NhbXBsZXIyRCcsXG4gICdBcnJheVRleHR1cmUoMiknOiAnc2FtcGxlcjJEJyxcbiAgJ0FycmF5VGV4dHVyZSgzKSc6ICdzYW1wbGVyMkQnLFxuICAnQXJyYXlUZXh0dXJlKDQpJzogJ3NhbXBsZXIyRCcsXG4gICdIVE1MVmlkZW8nOiAnc2FtcGxlcjJEJyxcbiAgJ0hUTUxDYW52YXMnOiAnc2FtcGxlcjJEJyxcbiAgJ09mZnNjcmVlbkNhbnZhcyc6ICdzYW1wbGVyMkQnLFxuICAnSFRNTEltYWdlJzogJ3NhbXBsZXIyRCcsXG4gICdJbWFnZUJpdG1hcCc6ICdzYW1wbGVyMkQnLFxuICAnSW1hZ2VEYXRhJzogJ3NhbXBsZXIyRCcsXG4gICdIVE1MSW1hZ2VBcnJheSc6ICdzYW1wbGVyMkRBcnJheScsXG59O1xuXG5jb25zdCBvcGVyYXRvck1hcCA9IHtcbiAgJz09PSc6ICc9PScsXG4gICchPT0nOiAnIT0nXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViR0xGdW5jdGlvbk5vZGVcbn07XG59LHtcIi4uLy4uL3V0aWxzXCI6MTE0LFwiLi4vZnVuY3Rpb24tbm9kZVwiOjEwfV0sMzk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyBXZWJHTEtlcm5lbFZhbHVlQm9vbGVhbiB9ID0gcmVxdWlyZSgnLi9rZXJuZWwtdmFsdWUvYm9vbGVhbicpO1xuY29uc3QgeyBXZWJHTEtlcm5lbFZhbHVlRmxvYXQgfSA9IHJlcXVpcmUoJy4va2VybmVsLXZhbHVlL2Zsb2F0Jyk7XG5jb25zdCB7IFdlYkdMS2VybmVsVmFsdWVJbnRlZ2VyIH0gPSByZXF1aXJlKCcuL2tlcm5lbC12YWx1ZS9pbnRlZ2VyJyk7XG5cbmNvbnN0IHsgV2ViR0xLZXJuZWxWYWx1ZUhUTUxJbWFnZSB9ID0gcmVxdWlyZSgnLi9rZXJuZWwtdmFsdWUvaHRtbC1pbWFnZScpO1xuY29uc3QgeyBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY0hUTUxJbWFnZSB9ID0gcmVxdWlyZSgnLi9rZXJuZWwtdmFsdWUvZHluYW1pYy1odG1sLWltYWdlJyk7XG5cbmNvbnN0IHsgV2ViR0xLZXJuZWxWYWx1ZUhUTUxWaWRlbyB9ID0gcmVxdWlyZSgnLi9rZXJuZWwtdmFsdWUvaHRtbC12aWRlbycpO1xuY29uc3QgeyBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY0hUTUxWaWRlbyB9ID0gcmVxdWlyZSgnLi9rZXJuZWwtdmFsdWUvZHluYW1pYy1odG1sLXZpZGVvJyk7XG5cbmNvbnN0IHsgV2ViR0xLZXJuZWxWYWx1ZVNpbmdsZUlucHV0IH0gPSByZXF1aXJlKCcuL2tlcm5lbC12YWx1ZS9zaW5nbGUtaW5wdXQnKTtcbmNvbnN0IHsgV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNTaW5nbGVJbnB1dCB9ID0gcmVxdWlyZSgnLi9rZXJuZWwtdmFsdWUvZHluYW1pYy1zaW5nbGUtaW5wdXQnKTtcblxuY29uc3QgeyBXZWJHTEtlcm5lbFZhbHVlVW5zaWduZWRJbnB1dCB9ID0gcmVxdWlyZSgnLi9rZXJuZWwtdmFsdWUvdW5zaWduZWQtaW5wdXQnKTtcbmNvbnN0IHsgV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNVbnNpZ25lZElucHV0IH0gPSByZXF1aXJlKCcuL2tlcm5lbC12YWx1ZS9keW5hbWljLXVuc2lnbmVkLWlucHV0Jyk7XG5cbmNvbnN0IHsgV2ViR0xLZXJuZWxWYWx1ZU1lbW9yeU9wdGltaXplZE51bWJlclRleHR1cmUgfSA9IHJlcXVpcmUoJy4va2VybmVsLXZhbHVlL21lbW9yeS1vcHRpbWl6ZWQtbnVtYmVyLXRleHR1cmUnKTtcbmNvbnN0IHsgV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNNZW1vcnlPcHRpbWl6ZWROdW1iZXJUZXh0dXJlIH0gPSByZXF1aXJlKCcuL2tlcm5lbC12YWx1ZS9keW5hbWljLW1lbW9yeS1vcHRpbWl6ZWQtbnVtYmVyLXRleHR1cmUnKTtcblxuY29uc3QgeyBXZWJHTEtlcm5lbFZhbHVlTnVtYmVyVGV4dHVyZSB9ID0gcmVxdWlyZSgnLi9rZXJuZWwtdmFsdWUvbnVtYmVyLXRleHR1cmUnKTtcbmNvbnN0IHsgV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNOdW1iZXJUZXh0dXJlIH0gPSByZXF1aXJlKCcuL2tlcm5lbC12YWx1ZS9keW5hbWljLW51bWJlci10ZXh0dXJlJyk7XG5cbmNvbnN0IHsgV2ViR0xLZXJuZWxWYWx1ZVNpbmdsZUFycmF5IH0gPSByZXF1aXJlKCcuL2tlcm5lbC12YWx1ZS9zaW5nbGUtYXJyYXknKTtcbmNvbnN0IHsgV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNTaW5nbGVBcnJheSB9ID0gcmVxdWlyZSgnLi9rZXJuZWwtdmFsdWUvZHluYW1pYy1zaW5nbGUtYXJyYXknKTtcblxuY29uc3QgeyBXZWJHTEtlcm5lbFZhbHVlU2luZ2xlQXJyYXkxREkgfSA9IHJlcXVpcmUoJy4va2VybmVsLXZhbHVlL3NpbmdsZS1hcnJheTFkLWknKTtcbmNvbnN0IHsgV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNTaW5nbGVBcnJheTFESSB9ID0gcmVxdWlyZSgnLi9rZXJuZWwtdmFsdWUvZHluYW1pYy1zaW5nbGUtYXJyYXkxZC1pJyk7XG5cbmNvbnN0IHsgV2ViR0xLZXJuZWxWYWx1ZVNpbmdsZUFycmF5MkRJIH0gPSByZXF1aXJlKCcuL2tlcm5lbC12YWx1ZS9zaW5nbGUtYXJyYXkyZC1pJyk7XG5jb25zdCB7IFdlYkdMS2VybmVsVmFsdWVEeW5hbWljU2luZ2xlQXJyYXkyREkgfSA9IHJlcXVpcmUoJy4va2VybmVsLXZhbHVlL2R5bmFtaWMtc2luZ2xlLWFycmF5MmQtaScpO1xuXG5jb25zdCB7IFdlYkdMS2VybmVsVmFsdWVTaW5nbGVBcnJheTNESSB9ID0gcmVxdWlyZSgnLi9rZXJuZWwtdmFsdWUvc2luZ2xlLWFycmF5M2QtaScpO1xuY29uc3QgeyBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY1NpbmdsZUFycmF5M0RJIH0gPSByZXF1aXJlKCcuL2tlcm5lbC12YWx1ZS9keW5hbWljLXNpbmdsZS1hcnJheTNkLWknKTtcblxuY29uc3QgeyBXZWJHTEtlcm5lbFZhbHVlQXJyYXkyIH0gPSByZXF1aXJlKCcuL2tlcm5lbC12YWx1ZS9hcnJheTInKTtcbmNvbnN0IHsgV2ViR0xLZXJuZWxWYWx1ZUFycmF5MyB9ID0gcmVxdWlyZSgnLi9rZXJuZWwtdmFsdWUvYXJyYXkzJyk7XG5jb25zdCB7IFdlYkdMS2VybmVsVmFsdWVBcnJheTQgfSA9IHJlcXVpcmUoJy4va2VybmVsLXZhbHVlL2FycmF5NCcpO1xuXG5jb25zdCB7IFdlYkdMS2VybmVsVmFsdWVVbnNpZ25lZEFycmF5IH0gPSByZXF1aXJlKCcuL2tlcm5lbC12YWx1ZS91bnNpZ25lZC1hcnJheScpO1xuY29uc3QgeyBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY1Vuc2lnbmVkQXJyYXkgfSA9IHJlcXVpcmUoJy4va2VybmVsLXZhbHVlL2R5bmFtaWMtdW5zaWduZWQtYXJyYXknKTtcblxuY29uc3Qga2VybmVsVmFsdWVNYXBzID0ge1xuICB1bnNpZ25lZDoge1xuICAgIGR5bmFtaWM6IHtcbiAgICAgICdCb29sZWFuJzogV2ViR0xLZXJuZWxWYWx1ZUJvb2xlYW4sXG4gICAgICAnSW50ZWdlcic6IFdlYkdMS2VybmVsVmFsdWVJbnRlZ2VyLFxuICAgICAgJ0Zsb2F0JzogV2ViR0xLZXJuZWxWYWx1ZUZsb2F0LFxuICAgICAgJ0FycmF5JzogV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNVbnNpZ25lZEFycmF5LFxuICAgICAgJ0FycmF5KDIpJzogV2ViR0xLZXJuZWxWYWx1ZUFycmF5MixcbiAgICAgICdBcnJheSgzKSc6IFdlYkdMS2VybmVsVmFsdWVBcnJheTMsXG4gICAgICAnQXJyYXkoNCknOiBXZWJHTEtlcm5lbFZhbHVlQXJyYXk0LFxuICAgICAgJ0FycmF5MUQoMiknOiBmYWxzZSxcbiAgICAgICdBcnJheTFEKDMpJzogZmFsc2UsXG4gICAgICAnQXJyYXkxRCg0KSc6IGZhbHNlLFxuICAgICAgJ0FycmF5MkQoMiknOiBmYWxzZSxcbiAgICAgICdBcnJheTJEKDMpJzogZmFsc2UsXG4gICAgICAnQXJyYXkyRCg0KSc6IGZhbHNlLFxuICAgICAgJ0FycmF5M0QoMiknOiBmYWxzZSxcbiAgICAgICdBcnJheTNEKDMpJzogZmFsc2UsXG4gICAgICAnQXJyYXkzRCg0KSc6IGZhbHNlLFxuICAgICAgJ0lucHV0JzogV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNVbnNpZ25lZElucHV0LFxuICAgICAgJ051bWJlclRleHR1cmUnOiBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY051bWJlclRleHR1cmUsXG4gICAgICAnQXJyYXlUZXh0dXJlKDEpJzogV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNOdW1iZXJUZXh0dXJlLFxuICAgICAgJ0FycmF5VGV4dHVyZSgyKSc6IFdlYkdMS2VybmVsVmFsdWVEeW5hbWljTnVtYmVyVGV4dHVyZSxcbiAgICAgICdBcnJheVRleHR1cmUoMyknOiBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY051bWJlclRleHR1cmUsXG4gICAgICAnQXJyYXlUZXh0dXJlKDQpJzogV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNOdW1iZXJUZXh0dXJlLFxuICAgICAgJ01lbW9yeU9wdGltaXplZE51bWJlclRleHR1cmUnOiBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY01lbW9yeU9wdGltaXplZE51bWJlclRleHR1cmUsXG4gICAgICAnSFRNTENhbnZhcyc6IFdlYkdMS2VybmVsVmFsdWVEeW5hbWljSFRNTEltYWdlLFxuICAgICAgJ09mZnNjcmVlbkNhbnZhcyc6IFdlYkdMS2VybmVsVmFsdWVEeW5hbWljSFRNTEltYWdlLFxuICAgICAgJ0hUTUxJbWFnZSc6IFdlYkdMS2VybmVsVmFsdWVEeW5hbWljSFRNTEltYWdlLFxuICAgICAgJ0ltYWdlQml0bWFwJzogV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNIVE1MSW1hZ2UsXG4gICAgICAnSW1hZ2VEYXRhJzogV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNIVE1MSW1hZ2UsXG4gICAgICAnSFRNTEltYWdlQXJyYXknOiBmYWxzZSxcbiAgICAgICdIVE1MVmlkZW8nOiBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY0hUTUxWaWRlbyxcbiAgICB9LFxuICAgIHN0YXRpYzoge1xuICAgICAgJ0Jvb2xlYW4nOiBXZWJHTEtlcm5lbFZhbHVlQm9vbGVhbixcbiAgICAgICdGbG9hdCc6IFdlYkdMS2VybmVsVmFsdWVGbG9hdCxcbiAgICAgICdJbnRlZ2VyJzogV2ViR0xLZXJuZWxWYWx1ZUludGVnZXIsXG4gICAgICAnQXJyYXknOiBXZWJHTEtlcm5lbFZhbHVlVW5zaWduZWRBcnJheSxcbiAgICAgICdBcnJheSgyKSc6IFdlYkdMS2VybmVsVmFsdWVBcnJheTIsXG4gICAgICAnQXJyYXkoMyknOiBXZWJHTEtlcm5lbFZhbHVlQXJyYXkzLFxuICAgICAgJ0FycmF5KDQpJzogV2ViR0xLZXJuZWxWYWx1ZUFycmF5NCxcbiAgICAgICdBcnJheTFEKDIpJzogZmFsc2UsXG4gICAgICAnQXJyYXkxRCgzKSc6IGZhbHNlLFxuICAgICAgJ0FycmF5MUQoNCknOiBmYWxzZSxcbiAgICAgICdBcnJheTJEKDIpJzogZmFsc2UsXG4gICAgICAnQXJyYXkyRCgzKSc6IGZhbHNlLFxuICAgICAgJ0FycmF5MkQoNCknOiBmYWxzZSxcbiAgICAgICdBcnJheTNEKDIpJzogZmFsc2UsXG4gICAgICAnQXJyYXkzRCgzKSc6IGZhbHNlLFxuICAgICAgJ0FycmF5M0QoNCknOiBmYWxzZSxcbiAgICAgICdJbnB1dCc6IFdlYkdMS2VybmVsVmFsdWVVbnNpZ25lZElucHV0LFxuICAgICAgJ051bWJlclRleHR1cmUnOiBXZWJHTEtlcm5lbFZhbHVlTnVtYmVyVGV4dHVyZSxcbiAgICAgICdBcnJheVRleHR1cmUoMSknOiBXZWJHTEtlcm5lbFZhbHVlTnVtYmVyVGV4dHVyZSxcbiAgICAgICdBcnJheVRleHR1cmUoMiknOiBXZWJHTEtlcm5lbFZhbHVlTnVtYmVyVGV4dHVyZSxcbiAgICAgICdBcnJheVRleHR1cmUoMyknOiBXZWJHTEtlcm5lbFZhbHVlTnVtYmVyVGV4dHVyZSxcbiAgICAgICdBcnJheVRleHR1cmUoNCknOiBXZWJHTEtlcm5lbFZhbHVlTnVtYmVyVGV4dHVyZSxcbiAgICAgICdNZW1vcnlPcHRpbWl6ZWROdW1iZXJUZXh0dXJlJzogV2ViR0xLZXJuZWxWYWx1ZU1lbW9yeU9wdGltaXplZE51bWJlclRleHR1cmUsXG4gICAgICAnSFRNTENhbnZhcyc6IFdlYkdMS2VybmVsVmFsdWVIVE1MSW1hZ2UsXG4gICAgICAnT2Zmc2NyZWVuQ2FudmFzJzogV2ViR0xLZXJuZWxWYWx1ZUhUTUxJbWFnZSxcbiAgICAgICdIVE1MSW1hZ2UnOiBXZWJHTEtlcm5lbFZhbHVlSFRNTEltYWdlLFxuICAgICAgJ0ltYWdlQml0bWFwJzogV2ViR0xLZXJuZWxWYWx1ZUhUTUxJbWFnZSxcbiAgICAgICdJbWFnZURhdGEnOiBXZWJHTEtlcm5lbFZhbHVlSFRNTEltYWdlLFxuICAgICAgJ0hUTUxJbWFnZUFycmF5JzogZmFsc2UsXG4gICAgICAnSFRNTFZpZGVvJzogV2ViR0xLZXJuZWxWYWx1ZUhUTUxWaWRlbyxcbiAgICB9XG4gIH0sXG4gIHNpbmdsZToge1xuICAgIGR5bmFtaWM6IHtcbiAgICAgICdCb29sZWFuJzogV2ViR0xLZXJuZWxWYWx1ZUJvb2xlYW4sXG4gICAgICAnSW50ZWdlcic6IFdlYkdMS2VybmVsVmFsdWVJbnRlZ2VyLFxuICAgICAgJ0Zsb2F0JzogV2ViR0xLZXJuZWxWYWx1ZUZsb2F0LFxuICAgICAgJ0FycmF5JzogV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNTaW5nbGVBcnJheSxcbiAgICAgICdBcnJheSgyKSc6IFdlYkdMS2VybmVsVmFsdWVBcnJheTIsXG4gICAgICAnQXJyYXkoMyknOiBXZWJHTEtlcm5lbFZhbHVlQXJyYXkzLFxuICAgICAgJ0FycmF5KDQpJzogV2ViR0xLZXJuZWxWYWx1ZUFycmF5NCxcbiAgICAgICdBcnJheTFEKDIpJzogV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNTaW5nbGVBcnJheTFESSxcbiAgICAgICdBcnJheTFEKDMpJzogV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNTaW5nbGVBcnJheTFESSxcbiAgICAgICdBcnJheTFEKDQpJzogV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNTaW5nbGVBcnJheTFESSxcbiAgICAgICdBcnJheTJEKDIpJzogV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNTaW5nbGVBcnJheTJESSxcbiAgICAgICdBcnJheTJEKDMpJzogV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNTaW5nbGVBcnJheTJESSxcbiAgICAgICdBcnJheTJEKDQpJzogV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNTaW5nbGVBcnJheTJESSxcbiAgICAgICdBcnJheTNEKDIpJzogV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNTaW5nbGVBcnJheTNESSxcbiAgICAgICdBcnJheTNEKDMpJzogV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNTaW5nbGVBcnJheTNESSxcbiAgICAgICdBcnJheTNEKDQpJzogV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNTaW5nbGVBcnJheTNESSxcbiAgICAgICdJbnB1dCc6IFdlYkdMS2VybmVsVmFsdWVEeW5hbWljU2luZ2xlSW5wdXQsXG4gICAgICAnTnVtYmVyVGV4dHVyZSc6IFdlYkdMS2VybmVsVmFsdWVEeW5hbWljTnVtYmVyVGV4dHVyZSxcbiAgICAgICdBcnJheVRleHR1cmUoMSknOiBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY051bWJlclRleHR1cmUsXG4gICAgICAnQXJyYXlUZXh0dXJlKDIpJzogV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNOdW1iZXJUZXh0dXJlLFxuICAgICAgJ0FycmF5VGV4dHVyZSgzKSc6IFdlYkdMS2VybmVsVmFsdWVEeW5hbWljTnVtYmVyVGV4dHVyZSxcbiAgICAgICdBcnJheVRleHR1cmUoNCknOiBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY051bWJlclRleHR1cmUsXG4gICAgICAnTWVtb3J5T3B0aW1pemVkTnVtYmVyVGV4dHVyZSc6IFdlYkdMS2VybmVsVmFsdWVEeW5hbWljTWVtb3J5T3B0aW1pemVkTnVtYmVyVGV4dHVyZSxcbiAgICAgICdIVE1MQ2FudmFzJzogV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNIVE1MSW1hZ2UsXG4gICAgICAnT2Zmc2NyZWVuQ2FudmFzJzogV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNIVE1MSW1hZ2UsXG4gICAgICAnSFRNTEltYWdlJzogV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNIVE1MSW1hZ2UsXG4gICAgICAnSW1hZ2VCaXRtYXAnOiBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY0hUTUxJbWFnZSxcbiAgICAgICdJbWFnZURhdGEnOiBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY0hUTUxJbWFnZSxcbiAgICAgICdIVE1MSW1hZ2VBcnJheSc6IGZhbHNlLFxuICAgICAgJ0hUTUxWaWRlbyc6IFdlYkdMS2VybmVsVmFsdWVEeW5hbWljSFRNTFZpZGVvLFxuICAgIH0sXG4gICAgc3RhdGljOiB7XG4gICAgICAnQm9vbGVhbic6IFdlYkdMS2VybmVsVmFsdWVCb29sZWFuLFxuICAgICAgJ0Zsb2F0JzogV2ViR0xLZXJuZWxWYWx1ZUZsb2F0LFxuICAgICAgJ0ludGVnZXInOiBXZWJHTEtlcm5lbFZhbHVlSW50ZWdlcixcbiAgICAgICdBcnJheSc6IFdlYkdMS2VybmVsVmFsdWVTaW5nbGVBcnJheSxcbiAgICAgICdBcnJheSgyKSc6IFdlYkdMS2VybmVsVmFsdWVBcnJheTIsXG4gICAgICAnQXJyYXkoMyknOiBXZWJHTEtlcm5lbFZhbHVlQXJyYXkzLFxuICAgICAgJ0FycmF5KDQpJzogV2ViR0xLZXJuZWxWYWx1ZUFycmF5NCxcbiAgICAgICdBcnJheTFEKDIpJzogV2ViR0xLZXJuZWxWYWx1ZVNpbmdsZUFycmF5MURJLFxuICAgICAgJ0FycmF5MUQoMyknOiBXZWJHTEtlcm5lbFZhbHVlU2luZ2xlQXJyYXkxREksXG4gICAgICAnQXJyYXkxRCg0KSc6IFdlYkdMS2VybmVsVmFsdWVTaW5nbGVBcnJheTFESSxcbiAgICAgICdBcnJheTJEKDIpJzogV2ViR0xLZXJuZWxWYWx1ZVNpbmdsZUFycmF5MkRJLFxuICAgICAgJ0FycmF5MkQoMyknOiBXZWJHTEtlcm5lbFZhbHVlU2luZ2xlQXJyYXkyREksXG4gICAgICAnQXJyYXkyRCg0KSc6IFdlYkdMS2VybmVsVmFsdWVTaW5nbGVBcnJheTJESSxcbiAgICAgICdBcnJheTNEKDIpJzogV2ViR0xLZXJuZWxWYWx1ZVNpbmdsZUFycmF5M0RJLFxuICAgICAgJ0FycmF5M0QoMyknOiBXZWJHTEtlcm5lbFZhbHVlU2luZ2xlQXJyYXkzREksXG4gICAgICAnQXJyYXkzRCg0KSc6IFdlYkdMS2VybmVsVmFsdWVTaW5nbGVBcnJheTNESSxcbiAgICAgICdJbnB1dCc6IFdlYkdMS2VybmVsVmFsdWVTaW5nbGVJbnB1dCxcbiAgICAgICdOdW1iZXJUZXh0dXJlJzogV2ViR0xLZXJuZWxWYWx1ZU51bWJlclRleHR1cmUsXG4gICAgICAnQXJyYXlUZXh0dXJlKDEpJzogV2ViR0xLZXJuZWxWYWx1ZU51bWJlclRleHR1cmUsXG4gICAgICAnQXJyYXlUZXh0dXJlKDIpJzogV2ViR0xLZXJuZWxWYWx1ZU51bWJlclRleHR1cmUsXG4gICAgICAnQXJyYXlUZXh0dXJlKDMpJzogV2ViR0xLZXJuZWxWYWx1ZU51bWJlclRleHR1cmUsXG4gICAgICAnQXJyYXlUZXh0dXJlKDQpJzogV2ViR0xLZXJuZWxWYWx1ZU51bWJlclRleHR1cmUsXG4gICAgICAnTWVtb3J5T3B0aW1pemVkTnVtYmVyVGV4dHVyZSc6IFdlYkdMS2VybmVsVmFsdWVNZW1vcnlPcHRpbWl6ZWROdW1iZXJUZXh0dXJlLFxuICAgICAgJ0hUTUxDYW52YXMnOiBXZWJHTEtlcm5lbFZhbHVlSFRNTEltYWdlLFxuICAgICAgJ09mZnNjcmVlbkNhbnZhcyc6IFdlYkdMS2VybmVsVmFsdWVIVE1MSW1hZ2UsXG4gICAgICAnSFRNTEltYWdlJzogV2ViR0xLZXJuZWxWYWx1ZUhUTUxJbWFnZSxcbiAgICAgICdJbWFnZUJpdG1hcCc6IFdlYkdMS2VybmVsVmFsdWVIVE1MSW1hZ2UsXG4gICAgICAnSW1hZ2VEYXRhJzogV2ViR0xLZXJuZWxWYWx1ZUhUTUxJbWFnZSxcbiAgICAgICdIVE1MSW1hZ2VBcnJheSc6IGZhbHNlLFxuICAgICAgJ0hUTUxWaWRlbyc6IFdlYkdMS2VybmVsVmFsdWVIVE1MVmlkZW8sXG4gICAgfVxuICB9LFxufTtcblxuZnVuY3Rpb24gbG9va3VwS2VybmVsVmFsdWVUeXBlKHR5cGUsIGR5bmFtaWMsIHByZWNpc2lvbiwgdmFsdWUpIHtcbiAgaWYgKCF0eXBlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd0eXBlIG1pc3NpbmcnKTtcbiAgfVxuICBpZiAoIWR5bmFtaWMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2R5bmFtaWMgbWlzc2luZycpO1xuICB9XG4gIGlmICghcHJlY2lzaW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcmVjaXNpb24gbWlzc2luZycpO1xuICB9XG4gIGlmICh2YWx1ZS50eXBlKSB7XG4gICAgdHlwZSA9IHZhbHVlLnR5cGU7XG4gIH1cbiAgY29uc3QgdHlwZXMgPSBrZXJuZWxWYWx1ZU1hcHNbcHJlY2lzaW9uXVtkeW5hbWljXTtcbiAgaWYgKHR5cGVzW3R5cGVdID09PSBmYWxzZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9IGVsc2UgaWYgKHR5cGVzW3R5cGVdID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBmaW5kIGEgS2VybmVsVmFsdWUgZm9yICR7IHR5cGUgfWApO1xuICB9XG4gIHJldHVybiB0eXBlc1t0eXBlXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGxvb2t1cEtlcm5lbFZhbHVlVHlwZSxcbiAga2VybmVsVmFsdWVNYXBzLFxufTtcbn0se1wiLi9rZXJuZWwtdmFsdWUvYXJyYXkyXCI6NDEsXCIuL2tlcm5lbC12YWx1ZS9hcnJheTNcIjo0MixcIi4va2VybmVsLXZhbHVlL2FycmF5NFwiOjQzLFwiLi9rZXJuZWwtdmFsdWUvYm9vbGVhblwiOjQ0LFwiLi9rZXJuZWwtdmFsdWUvZHluYW1pYy1odG1sLWltYWdlXCI6NDUsXCIuL2tlcm5lbC12YWx1ZS9keW5hbWljLWh0bWwtdmlkZW9cIjo0NixcIi4va2VybmVsLXZhbHVlL2R5bmFtaWMtbWVtb3J5LW9wdGltaXplZC1udW1iZXItdGV4dHVyZVwiOjQ3LFwiLi9rZXJuZWwtdmFsdWUvZHluYW1pYy1udW1iZXItdGV4dHVyZVwiOjQ4LFwiLi9rZXJuZWwtdmFsdWUvZHluYW1pYy1zaW5nbGUtYXJyYXlcIjo0OSxcIi4va2VybmVsLXZhbHVlL2R5bmFtaWMtc2luZ2xlLWFycmF5MWQtaVwiOjUwLFwiLi9rZXJuZWwtdmFsdWUvZHluYW1pYy1zaW5nbGUtYXJyYXkyZC1pXCI6NTEsXCIuL2tlcm5lbC12YWx1ZS9keW5hbWljLXNpbmdsZS1hcnJheTNkLWlcIjo1MixcIi4va2VybmVsLXZhbHVlL2R5bmFtaWMtc2luZ2xlLWlucHV0XCI6NTMsXCIuL2tlcm5lbC12YWx1ZS9keW5hbWljLXVuc2lnbmVkLWFycmF5XCI6NTQsXCIuL2tlcm5lbC12YWx1ZS9keW5hbWljLXVuc2lnbmVkLWlucHV0XCI6NTUsXCIuL2tlcm5lbC12YWx1ZS9mbG9hdFwiOjU2LFwiLi9rZXJuZWwtdmFsdWUvaHRtbC1pbWFnZVwiOjU3LFwiLi9rZXJuZWwtdmFsdWUvaHRtbC12aWRlb1wiOjU4LFwiLi9rZXJuZWwtdmFsdWUvaW50ZWdlclwiOjYwLFwiLi9rZXJuZWwtdmFsdWUvbWVtb3J5LW9wdGltaXplZC1udW1iZXItdGV4dHVyZVwiOjYxLFwiLi9rZXJuZWwtdmFsdWUvbnVtYmVyLXRleHR1cmVcIjo2MixcIi4va2VybmVsLXZhbHVlL3NpbmdsZS1hcnJheVwiOjYzLFwiLi9rZXJuZWwtdmFsdWUvc2luZ2xlLWFycmF5MWQtaVwiOjY0LFwiLi9rZXJuZWwtdmFsdWUvc2luZ2xlLWFycmF5MmQtaVwiOjY1LFwiLi9rZXJuZWwtdmFsdWUvc2luZ2xlLWFycmF5M2QtaVwiOjY2LFwiLi9rZXJuZWwtdmFsdWUvc2luZ2xlLWlucHV0XCI6NjcsXCIuL2tlcm5lbC12YWx1ZS91bnNpZ25lZC1hcnJheVwiOjY4LFwiLi9rZXJuZWwtdmFsdWUvdW5zaWduZWQtaW5wdXRcIjo2OX1dLDQwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgV2ViR0xLZXJuZWxWYWx1ZSB9ID0gcmVxdWlyZSgnLi9pbmRleCcpO1xuY29uc3QgeyBJbnB1dCB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vaW5wdXQnKTtcblxuY2xhc3MgV2ViR0xLZXJuZWxBcnJheSBleHRlbmRzIFdlYkdMS2VybmVsVmFsdWUge1xuICBjaGVja1NpemUod2lkdGgsIGhlaWdodCkge1xuICAgIGlmICghdGhpcy5rZXJuZWwudmFsaWRhdGUpIHJldHVybjtcbiAgICBjb25zdCB7IG1heFRleHR1cmVTaXplIH0gPSB0aGlzLmtlcm5lbC5jb25zdHJ1Y3Rvci5mZWF0dXJlcztcbiAgICBpZiAod2lkdGggPiBtYXhUZXh0dXJlU2l6ZSB8fCBoZWlnaHQgPiBtYXhUZXh0dXJlU2l6ZSkge1xuICAgICAgaWYgKHdpZHRoID4gaGVpZ2h0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQXJndW1lbnQgdGV4dHVyZSB3aWR0aCBvZiAke3dpZHRofSBsYXJnZXIgdGhhbiBtYXhpbXVtIHNpemUgb2YgJHttYXhUZXh0dXJlU2l6ZX0gZm9yIHlvdXIgR1BVYCk7XG4gICAgICB9IGVsc2UgaWYgKHdpZHRoIDwgaGVpZ2h0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQXJndW1lbnQgdGV4dHVyZSBoZWlnaHQgb2YgJHtoZWlnaHR9IGxhcmdlciB0aGFuIG1heGltdW0gc2l6ZSBvZiAke21heFRleHR1cmVTaXplfSBmb3IgeW91ciBHUFVgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQXJndW1lbnQgdGV4dHVyZSBoZWlnaHQgYW5kIHdpZHRoIG9mICR7aGVpZ2h0fSBsYXJnZXIgdGhhbiBtYXhpbXVtIHNpemUgb2YgJHttYXhUZXh0dXJlU2l6ZX0gZm9yIHlvdXIgR1BVYCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgc2V0dXAoKSB7XG4gICAgdGhpcy5yZXF1ZXN0VGV4dHVyZSgpO1xuICAgIHRoaXMuc2V0dXBUZXh0dXJlKCk7XG4gICAgdGhpcy5kZWZpbmVUZXh0dXJlKCk7XG4gIH1cblxuICByZXF1ZXN0VGV4dHVyZSgpIHtcbiAgICB0aGlzLnRleHR1cmUgPSB0aGlzLm9uUmVxdWVzdFRleHR1cmUoKTtcbiAgfVxuXG4gIGRlZmluZVRleHR1cmUoKSB7XG4gICAgY29uc3QgeyBjb250ZXh0OiBnbCB9ID0gdGhpcztcbiAgICBnbC5hY3RpdmVUZXh0dXJlKHRoaXMuY29udGV4dEhhbmRsZSk7XG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy50ZXh0dXJlKTtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFKTtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFKTtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTkVBUkVTVCk7XG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLk5FQVJFU1QpO1xuICB9XG5cbiAgc2V0dXBUZXh0dXJlKCkge1xuICAgIHRoaXMuY29udGV4dEhhbmRsZSA9IHRoaXMub25SZXF1ZXN0Q29udGV4dEhhbmRsZSgpO1xuICAgIHRoaXMuaW5kZXggPSB0aGlzLm9uUmVxdWVzdEluZGV4KCk7XG4gICAgdGhpcy5kaW1lbnNpb25zSWQgPSB0aGlzLmlkICsgJ0RpbSc7XG4gICAgdGhpcy5zaXplSWQgPSB0aGlzLmlkICsgJ1NpemUnO1xuICB9XG5cbiAgZ2V0Qml0UmF0aW8odmFsdWUpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZVswXSkpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldEJpdFJhdGlvKHZhbHVlWzBdKTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlLmNvbnN0cnVjdG9yID09PSBJbnB1dCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0Qml0UmF0aW8odmFsdWUudmFsdWUpO1xuICAgIH1cbiAgICBzd2l0Y2ggKHZhbHVlLmNvbnN0cnVjdG9yKSB7XG4gICAgICBjYXNlIFVpbnQ4Q2xhbXBlZEFycmF5OlxuICAgICAgY2FzZSBVaW50OEFycmF5OlxuICAgICAgY2FzZSBJbnQ4QXJyYXk6XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgY2FzZSBVaW50MTZBcnJheTpcbiAgICAgIGNhc2UgSW50MTZBcnJheTpcbiAgICAgICAgcmV0dXJuIDI7XG4gICAgICBjYXNlIEZsb2F0MzJBcnJheTpcbiAgICAgIGNhc2UgSW50MzJBcnJheTpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiA0O1xuICAgIH1cbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMucHJldkFyZykge1xuICAgICAgdGhpcy5wcmV2QXJnLmRlbGV0ZSgpO1xuICAgIH1cbiAgICB0aGlzLmNvbnRleHQuZGVsZXRlVGV4dHVyZSh0aGlzLnRleHR1cmUpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBXZWJHTEtlcm5lbEFycmF5XG59O1xufSx7XCIuLi8uLi8uLi9pbnB1dFwiOjExMCxcIi4vaW5kZXhcIjo1OX1dLDQxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgV2ViR0xLZXJuZWxWYWx1ZSB9ID0gcmVxdWlyZSgnLi9pbmRleCcpO1xuXG5jbGFzcyBXZWJHTEtlcm5lbFZhbHVlQXJyYXkyIGV4dGVuZHMgV2ViR0xLZXJuZWxWYWx1ZSB7XG4gIGNvbnN0cnVjdG9yKHZhbHVlLCBzZXR0aW5ncykge1xuICAgIHN1cGVyKHZhbHVlLCBzZXR0aW5ncyk7XG4gICAgdGhpcy51cGxvYWRWYWx1ZSA9IHZhbHVlO1xuICB9XG4gIGdldFNvdXJjZSh2YWx1ZSkge1xuICAgIGlmICh0aGlzLm9yaWdpbiA9PT0gJ2NvbnN0YW50cycpIHtcbiAgICAgIHJldHVybiBgY29uc3QgdmVjMiAke3RoaXMuaWR9ID0gdmVjMigke3ZhbHVlWzBdfSwke3ZhbHVlWzFdfSk7XFxuYDtcbiAgICB9XG4gICAgcmV0dXJuIGB1bmlmb3JtIHZlYzIgJHt0aGlzLmlkfTtcXG5gO1xuICB9XG5cbiAgZ2V0U3RyaW5nVmFsdWVIYW5kbGVyKCkge1xuICAgIGlmICh0aGlzLm9yaWdpbiA9PT0gJ2NvbnN0YW50cycpIHJldHVybiAnJztcbiAgICByZXR1cm4gYGNvbnN0IHVwbG9hZFZhbHVlXyR7dGhpcy5uYW1lfSA9ICR7dGhpcy52YXJOYW1lfTtcXG5gO1xuICB9XG5cbiAgdXBkYXRlVmFsdWUodmFsdWUpIHtcbiAgICBpZiAodGhpcy5vcmlnaW4gPT09ICdjb25zdGFudHMnKSByZXR1cm47XG4gICAgdGhpcy5rZXJuZWwuc2V0VW5pZm9ybTJmdih0aGlzLmlkLCB0aGlzLnVwbG9hZFZhbHVlID0gdmFsdWUpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBXZWJHTEtlcm5lbFZhbHVlQXJyYXkyXG59O1xufSx7XCIuL2luZGV4XCI6NTl9XSw0MjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IFdlYkdMS2VybmVsVmFsdWUgfSA9IHJlcXVpcmUoJy4vaW5kZXgnKTtcblxuY2xhc3MgV2ViR0xLZXJuZWxWYWx1ZUFycmF5MyBleHRlbmRzIFdlYkdMS2VybmVsVmFsdWUge1xuICBjb25zdHJ1Y3Rvcih2YWx1ZSwgc2V0dGluZ3MpIHtcbiAgICBzdXBlcih2YWx1ZSwgc2V0dGluZ3MpO1xuICAgIHRoaXMudXBsb2FkVmFsdWUgPSB2YWx1ZTtcbiAgfVxuICBnZXRTb3VyY2UodmFsdWUpIHtcbiAgICBpZiAodGhpcy5vcmlnaW4gPT09ICdjb25zdGFudHMnKSB7XG4gICAgICByZXR1cm4gYGNvbnN0IHZlYzMgJHt0aGlzLmlkfSA9IHZlYzMoJHt2YWx1ZVswXX0sJHt2YWx1ZVsxXX0sJHt2YWx1ZVsyXX0pO1xcbmA7XG4gICAgfVxuICAgIHJldHVybiBgdW5pZm9ybSB2ZWMzICR7dGhpcy5pZH07XFxuYDtcbiAgfVxuXG4gIGdldFN0cmluZ1ZhbHVlSGFuZGxlcigpIHtcbiAgICBpZiAodGhpcy5vcmlnaW4gPT09ICdjb25zdGFudHMnKSByZXR1cm4gJyc7XG4gICAgcmV0dXJuIGBjb25zdCB1cGxvYWRWYWx1ZV8ke3RoaXMubmFtZX0gPSAke3RoaXMudmFyTmFtZX07XFxuYDtcbiAgfVxuXG4gIHVwZGF0ZVZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMub3JpZ2luID09PSAnY29uc3RhbnRzJykgcmV0dXJuO1xuICAgIHRoaXMua2VybmVsLnNldFVuaWZvcm0zZnYodGhpcy5pZCwgdGhpcy51cGxvYWRWYWx1ZSA9IHZhbHVlKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViR0xLZXJuZWxWYWx1ZUFycmF5M1xufTtcbn0se1wiLi9pbmRleFwiOjU5fV0sNDM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyBXZWJHTEtlcm5lbFZhbHVlIH0gPSByZXF1aXJlKCcuL2luZGV4Jyk7XG5cbmNsYXNzIFdlYkdMS2VybmVsVmFsdWVBcnJheTQgZXh0ZW5kcyBXZWJHTEtlcm5lbFZhbHVlIHtcbiAgY29uc3RydWN0b3IodmFsdWUsIHNldHRpbmdzKSB7XG4gICAgc3VwZXIodmFsdWUsIHNldHRpbmdzKTtcbiAgICB0aGlzLnVwbG9hZFZhbHVlID0gdmFsdWU7XG4gIH1cbiAgZ2V0U291cmNlKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMub3JpZ2luID09PSAnY29uc3RhbnRzJykge1xuICAgICAgcmV0dXJuIGBjb25zdCB2ZWM0ICR7dGhpcy5pZH0gPSB2ZWM0KCR7dmFsdWVbMF19LCR7dmFsdWVbMV19LCR7dmFsdWVbMl19LCR7dmFsdWVbM119KTtcXG5gO1xuICAgIH1cbiAgICByZXR1cm4gYHVuaWZvcm0gdmVjNCAke3RoaXMuaWR9O1xcbmA7XG4gIH1cblxuICBnZXRTdHJpbmdWYWx1ZUhhbmRsZXIoKSB7XG4gICAgaWYgKHRoaXMub3JpZ2luID09PSAnY29uc3RhbnRzJykgcmV0dXJuICcnO1xuICAgIHJldHVybiBgY29uc3QgdXBsb2FkVmFsdWVfJHt0aGlzLm5hbWV9ID0gJHt0aGlzLnZhck5hbWV9O1xcbmA7XG4gIH1cblxuICB1cGRhdGVWYWx1ZSh2YWx1ZSkge1xuICAgIGlmICh0aGlzLm9yaWdpbiA9PT0gJ2NvbnN0YW50cycpIHJldHVybjtcbiAgICB0aGlzLmtlcm5lbC5zZXRVbmlmb3JtNGZ2KHRoaXMuaWQsIHRoaXMudXBsb2FkVmFsdWUgPSB2YWx1ZSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFdlYkdMS2VybmVsVmFsdWVBcnJheTRcbn07XG59LHtcIi4vaW5kZXhcIjo1OX1dLDQ0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzJyk7XG5jb25zdCB7IFdlYkdMS2VybmVsVmFsdWUgfSA9IHJlcXVpcmUoJy4vaW5kZXgnKTtcblxuY2xhc3MgV2ViR0xLZXJuZWxWYWx1ZUJvb2xlYW4gZXh0ZW5kcyBXZWJHTEtlcm5lbFZhbHVlIHtcbiAgY29uc3RydWN0b3IodmFsdWUsIHNldHRpbmdzKSB7XG4gICAgc3VwZXIodmFsdWUsIHNldHRpbmdzKTtcbiAgICB0aGlzLnVwbG9hZFZhbHVlID0gdmFsdWU7XG4gIH1cbiAgZ2V0U291cmNlKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMub3JpZ2luID09PSAnY29uc3RhbnRzJykge1xuICAgICAgcmV0dXJuIGBjb25zdCBib29sICR7dGhpcy5pZH0gPSAke3ZhbHVlfTtcXG5gO1xuICAgIH1cbiAgICByZXR1cm4gYHVuaWZvcm0gYm9vbCAke3RoaXMuaWR9O1xcbmA7XG4gIH1cblxuICBnZXRTdHJpbmdWYWx1ZUhhbmRsZXIoKSB7XG4gICAgcmV0dXJuIGBjb25zdCB1cGxvYWRWYWx1ZV8ke3RoaXMubmFtZX0gPSAke3RoaXMudmFyTmFtZX07XFxuYDtcbiAgfVxuXG4gIHVwZGF0ZVZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMub3JpZ2luID09PSAnY29uc3RhbnRzJykgcmV0dXJuO1xuICAgIHRoaXMua2VybmVsLnNldFVuaWZvcm0xaSh0aGlzLmlkLCB0aGlzLnVwbG9hZFZhbHVlID0gdmFsdWUpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBXZWJHTEtlcm5lbFZhbHVlQm9vbGVhblxufTtcbn0se1wiLi4vLi4vLi4vdXRpbHNcIjoxMTQsXCIuL2luZGV4XCI6NTl9XSw0NTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xuY29uc3QgeyBXZWJHTEtlcm5lbFZhbHVlSFRNTEltYWdlIH0gPSByZXF1aXJlKCcuL2h0bWwtaW1hZ2UnKTtcblxuY2xhc3MgV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNIVE1MSW1hZ2UgZXh0ZW5kcyBXZWJHTEtlcm5lbFZhbHVlSFRNTEltYWdlIHtcbiAgZ2V0U291cmNlKCkge1xuICAgIHJldHVybiB1dGlscy5saW5lc1RvU3RyaW5nKFtcbiAgICAgIGB1bmlmb3JtIHNhbXBsZXIyRCAke3RoaXMuaWR9YCxcbiAgICAgIGB1bmlmb3JtIGl2ZWMyICR7dGhpcy5zaXplSWR9YCxcbiAgICAgIGB1bmlmb3JtIGl2ZWMzICR7dGhpcy5kaW1lbnNpb25zSWR9YCxcbiAgICBdKTtcbiAgfVxuXG4gIHVwZGF0ZVZhbHVlKHZhbHVlKSB7XG4gICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSB2YWx1ZTtcbiAgICB0aGlzLmNoZWNrU2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICB0aGlzLmRpbWVuc2lvbnMgPSBbd2lkdGgsIGhlaWdodCwgMV07XG4gICAgdGhpcy50ZXh0dXJlU2l6ZSA9IFt3aWR0aCwgaGVpZ2h0XTtcbiAgICB0aGlzLmtlcm5lbC5zZXRVbmlmb3JtM2l2KHRoaXMuZGltZW5zaW9uc0lkLCB0aGlzLmRpbWVuc2lvbnMpO1xuICAgIHRoaXMua2VybmVsLnNldFVuaWZvcm0yaXYodGhpcy5zaXplSWQsIHRoaXMudGV4dHVyZVNpemUpO1xuICAgIHN1cGVyLnVwZGF0ZVZhbHVlKHZhbHVlKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNIVE1MSW1hZ2Vcbn07XG59LHtcIi4uLy4uLy4uL3V0aWxzXCI6MTE0LFwiLi9odG1sLWltYWdlXCI6NTd9XSw0NjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IFdlYkdMS2VybmVsVmFsdWVEeW5hbWljSFRNTEltYWdlIH0gPSByZXF1aXJlKCcuL2R5bmFtaWMtaHRtbC1pbWFnZScpO1xuXG5jbGFzcyBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY0hUTUxWaWRlbyBleHRlbmRzIFdlYkdMS2VybmVsVmFsdWVEeW5hbWljSFRNTEltYWdlIHt9XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY0hUTUxWaWRlb1xufTtcbn0se1wiLi9keW5hbWljLWh0bWwtaW1hZ2VcIjo0NX1dLDQ3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzJyk7XG5jb25zdCB7IFdlYkdMS2VybmVsVmFsdWVNZW1vcnlPcHRpbWl6ZWROdW1iZXJUZXh0dXJlIH0gPSByZXF1aXJlKCcuL21lbW9yeS1vcHRpbWl6ZWQtbnVtYmVyLXRleHR1cmUnKTtcblxuY2xhc3MgV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNNZW1vcnlPcHRpbWl6ZWROdW1iZXJUZXh0dXJlIGV4dGVuZHMgV2ViR0xLZXJuZWxWYWx1ZU1lbW9yeU9wdGltaXplZE51bWJlclRleHR1cmUge1xuICBnZXRTb3VyY2UoKSB7XG4gICAgcmV0dXJuIHV0aWxzLmxpbmVzVG9TdHJpbmcoW1xuICAgICAgYHVuaWZvcm0gc2FtcGxlcjJEICR7dGhpcy5pZH1gLFxuICAgICAgYHVuaWZvcm0gaXZlYzIgJHt0aGlzLnNpemVJZH1gLFxuICAgICAgYHVuaWZvcm0gaXZlYzMgJHt0aGlzLmRpbWVuc2lvbnNJZH1gLFxuICAgIF0pO1xuICB9XG5cbiAgdXBkYXRlVmFsdWUoaW5wdXRUZXh0dXJlKSB7XG4gICAgdGhpcy5kaW1lbnNpb25zID0gaW5wdXRUZXh0dXJlLmRpbWVuc2lvbnM7XG4gICAgdGhpcy5jaGVja1NpemUoaW5wdXRUZXh0dXJlLnNpemVbMF0sIGlucHV0VGV4dHVyZS5zaXplWzFdKTtcbiAgICB0aGlzLnRleHR1cmVTaXplID0gaW5wdXRUZXh0dXJlLnNpemU7XG4gICAgdGhpcy5rZXJuZWwuc2V0VW5pZm9ybTNpdih0aGlzLmRpbWVuc2lvbnNJZCwgdGhpcy5kaW1lbnNpb25zKTtcbiAgICB0aGlzLmtlcm5lbC5zZXRVbmlmb3JtMml2KHRoaXMuc2l6ZUlkLCB0aGlzLnRleHR1cmVTaXplKTtcbiAgICBzdXBlci51cGRhdGVWYWx1ZShpbnB1dFRleHR1cmUpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY01lbW9yeU9wdGltaXplZE51bWJlclRleHR1cmVcbn07XG59LHtcIi4uLy4uLy4uL3V0aWxzXCI6MTE0LFwiLi9tZW1vcnktb3B0aW1pemVkLW51bWJlci10ZXh0dXJlXCI6NjF9XSw0ODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xuY29uc3QgeyBXZWJHTEtlcm5lbFZhbHVlTnVtYmVyVGV4dHVyZSB9ID0gcmVxdWlyZSgnLi9udW1iZXItdGV4dHVyZScpO1xuXG5jbGFzcyBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY051bWJlclRleHR1cmUgZXh0ZW5kcyBXZWJHTEtlcm5lbFZhbHVlTnVtYmVyVGV4dHVyZSB7XG4gIGdldFNvdXJjZSgpIHtcbiAgICByZXR1cm4gdXRpbHMubGluZXNUb1N0cmluZyhbXG4gICAgICBgdW5pZm9ybSBzYW1wbGVyMkQgJHt0aGlzLmlkfWAsXG4gICAgICBgdW5pZm9ybSBpdmVjMiAke3RoaXMuc2l6ZUlkfWAsXG4gICAgICBgdW5pZm9ybSBpdmVjMyAke3RoaXMuZGltZW5zaW9uc0lkfWAsXG4gICAgXSk7XG4gIH1cblxuICB1cGRhdGVWYWx1ZSh2YWx1ZSkge1xuICAgIHRoaXMuZGltZW5zaW9ucyA9IHZhbHVlLmRpbWVuc2lvbnM7XG4gICAgdGhpcy5jaGVja1NpemUodmFsdWUuc2l6ZVswXSwgdmFsdWUuc2l6ZVsxXSk7XG4gICAgdGhpcy50ZXh0dXJlU2l6ZSA9IHZhbHVlLnNpemU7XG4gICAgdGhpcy5rZXJuZWwuc2V0VW5pZm9ybTNpdih0aGlzLmRpbWVuc2lvbnNJZCwgdGhpcy5kaW1lbnNpb25zKTtcbiAgICB0aGlzLmtlcm5lbC5zZXRVbmlmb3JtMml2KHRoaXMuc2l6ZUlkLCB0aGlzLnRleHR1cmVTaXplKTtcbiAgICBzdXBlci51cGRhdGVWYWx1ZSh2YWx1ZSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFdlYkdMS2VybmVsVmFsdWVEeW5hbWljTnVtYmVyVGV4dHVyZVxufTtcbn0se1wiLi4vLi4vLi4vdXRpbHNcIjoxMTQsXCIuL251bWJlci10ZXh0dXJlXCI6NjJ9XSw0OTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xuY29uc3QgeyBXZWJHTEtlcm5lbFZhbHVlU2luZ2xlQXJyYXkgfSA9IHJlcXVpcmUoJy4vc2luZ2xlLWFycmF5Jyk7XG5cbmNsYXNzIFdlYkdMS2VybmVsVmFsdWVEeW5hbWljU2luZ2xlQXJyYXkgZXh0ZW5kcyBXZWJHTEtlcm5lbFZhbHVlU2luZ2xlQXJyYXkge1xuICBnZXRTb3VyY2UoKSB7XG4gICAgcmV0dXJuIHV0aWxzLmxpbmVzVG9TdHJpbmcoW1xuICAgICAgYHVuaWZvcm0gc2FtcGxlcjJEICR7dGhpcy5pZH1gLFxuICAgICAgYHVuaWZvcm0gaXZlYzIgJHt0aGlzLnNpemVJZH1gLFxuICAgICAgYHVuaWZvcm0gaXZlYzMgJHt0aGlzLmRpbWVuc2lvbnNJZH1gLFxuICAgIF0pO1xuICB9XG5cbiAgdXBkYXRlVmFsdWUodmFsdWUpIHtcbiAgICB0aGlzLmRpbWVuc2lvbnMgPSB1dGlscy5nZXREaW1lbnNpb25zKHZhbHVlLCB0cnVlKTtcbiAgICB0aGlzLnRleHR1cmVTaXplID0gdXRpbHMuZ2V0TWVtb3J5T3B0aW1pemVkRmxvYXRUZXh0dXJlU2l6ZSh0aGlzLmRpbWVuc2lvbnMsIHRoaXMuYml0UmF0aW8pO1xuICAgIHRoaXMudXBsb2FkQXJyYXlMZW5ndGggPSB0aGlzLnRleHR1cmVTaXplWzBdICogdGhpcy50ZXh0dXJlU2l6ZVsxXSAqIHRoaXMuYml0UmF0aW87XG4gICAgdGhpcy5jaGVja1NpemUodGhpcy50ZXh0dXJlU2l6ZVswXSwgdGhpcy50ZXh0dXJlU2l6ZVsxXSk7XG4gICAgdGhpcy51cGxvYWRWYWx1ZSA9IG5ldyBGbG9hdDMyQXJyYXkodGhpcy51cGxvYWRBcnJheUxlbmd0aCk7XG4gICAgdGhpcy5rZXJuZWwuc2V0VW5pZm9ybTNpdih0aGlzLmRpbWVuc2lvbnNJZCwgdGhpcy5kaW1lbnNpb25zKTtcbiAgICB0aGlzLmtlcm5lbC5zZXRVbmlmb3JtMml2KHRoaXMuc2l6ZUlkLCB0aGlzLnRleHR1cmVTaXplKTtcbiAgICBzdXBlci51cGRhdGVWYWx1ZSh2YWx1ZSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFdlYkdMS2VybmVsVmFsdWVEeW5hbWljU2luZ2xlQXJyYXlcbn07XG59LHtcIi4uLy4uLy4uL3V0aWxzXCI6MTE0LFwiLi9zaW5nbGUtYXJyYXlcIjo2M31dLDUwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzJyk7XG5jb25zdCB7IFdlYkdMS2VybmVsVmFsdWVTaW5nbGVBcnJheTFESSB9ID0gcmVxdWlyZSgnLi9zaW5nbGUtYXJyYXkxZC1pJyk7XG5cbmNsYXNzIFdlYkdMS2VybmVsVmFsdWVEeW5hbWljU2luZ2xlQXJyYXkxREkgZXh0ZW5kcyBXZWJHTEtlcm5lbFZhbHVlU2luZ2xlQXJyYXkxREkge1xuICBnZXRTb3VyY2UoKSB7XG4gICAgcmV0dXJuIHV0aWxzLmxpbmVzVG9TdHJpbmcoW1xuICAgICAgYHVuaWZvcm0gc2FtcGxlcjJEICR7dGhpcy5pZH1gLFxuICAgICAgYHVuaWZvcm0gaXZlYzIgJHt0aGlzLnNpemVJZH1gLFxuICAgICAgYHVuaWZvcm0gaXZlYzMgJHt0aGlzLmRpbWVuc2lvbnNJZH1gLFxuICAgIF0pO1xuICB9XG5cbiAgdXBkYXRlVmFsdWUodmFsdWUpIHtcbiAgICB0aGlzLnNldFNoYXBlKHZhbHVlKTtcbiAgICB0aGlzLmtlcm5lbC5zZXRVbmlmb3JtM2l2KHRoaXMuZGltZW5zaW9uc0lkLCB0aGlzLmRpbWVuc2lvbnMpO1xuICAgIHRoaXMua2VybmVsLnNldFVuaWZvcm0yaXYodGhpcy5zaXplSWQsIHRoaXMudGV4dHVyZVNpemUpO1xuICAgIHN1cGVyLnVwZGF0ZVZhbHVlKHZhbHVlKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNTaW5nbGVBcnJheTFESVxufTtcbn0se1wiLi4vLi4vLi4vdXRpbHNcIjoxMTQsXCIuL3NpbmdsZS1hcnJheTFkLWlcIjo2NH1dLDUxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzJyk7XG5jb25zdCB7IFdlYkdMS2VybmVsVmFsdWVTaW5nbGVBcnJheTJESSB9ID0gcmVxdWlyZSgnLi9zaW5nbGUtYXJyYXkyZC1pJyk7XG5cbmNsYXNzIFdlYkdMS2VybmVsVmFsdWVEeW5hbWljU2luZ2xlQXJyYXkyREkgZXh0ZW5kcyBXZWJHTEtlcm5lbFZhbHVlU2luZ2xlQXJyYXkyREkge1xuICBnZXRTb3VyY2UoKSB7XG4gICAgcmV0dXJuIHV0aWxzLmxpbmVzVG9TdHJpbmcoW1xuICAgICAgYHVuaWZvcm0gc2FtcGxlcjJEICR7dGhpcy5pZH1gLFxuICAgICAgYHVuaWZvcm0gaXZlYzIgJHt0aGlzLnNpemVJZH1gLFxuICAgICAgYHVuaWZvcm0gaXZlYzMgJHt0aGlzLmRpbWVuc2lvbnNJZH1gLFxuICAgIF0pO1xuICB9XG5cbiAgdXBkYXRlVmFsdWUodmFsdWUpIHtcbiAgICB0aGlzLnNldFNoYXBlKHZhbHVlKTtcbiAgICB0aGlzLmtlcm5lbC5zZXRVbmlmb3JtM2l2KHRoaXMuZGltZW5zaW9uc0lkLCB0aGlzLmRpbWVuc2lvbnMpO1xuICAgIHRoaXMua2VybmVsLnNldFVuaWZvcm0yaXYodGhpcy5zaXplSWQsIHRoaXMudGV4dHVyZVNpemUpO1xuICAgIHN1cGVyLnVwZGF0ZVZhbHVlKHZhbHVlKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNTaW5nbGVBcnJheTJESVxufTtcbn0se1wiLi4vLi4vLi4vdXRpbHNcIjoxMTQsXCIuL3NpbmdsZS1hcnJheTJkLWlcIjo2NX1dLDUyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzJyk7XG5jb25zdCB7IFdlYkdMS2VybmVsVmFsdWVTaW5nbGVBcnJheTNESSB9ID0gcmVxdWlyZSgnLi9zaW5nbGUtYXJyYXkzZC1pJyk7XG5cbmNsYXNzIFdlYkdMS2VybmVsVmFsdWVEeW5hbWljU2luZ2xlQXJyYXkzREkgZXh0ZW5kcyBXZWJHTEtlcm5lbFZhbHVlU2luZ2xlQXJyYXkzREkge1xuICBnZXRTb3VyY2UoKSB7XG4gICAgcmV0dXJuIHV0aWxzLmxpbmVzVG9TdHJpbmcoW1xuICAgICAgYHVuaWZvcm0gc2FtcGxlcjJEICR7dGhpcy5pZH1gLFxuICAgICAgYHVuaWZvcm0gaXZlYzIgJHt0aGlzLnNpemVJZH1gLFxuICAgICAgYHVuaWZvcm0gaXZlYzMgJHt0aGlzLmRpbWVuc2lvbnNJZH1gLFxuICAgIF0pO1xuICB9XG5cbiAgdXBkYXRlVmFsdWUodmFsdWUpIHtcbiAgICB0aGlzLnNldFNoYXBlKHZhbHVlKTtcbiAgICB0aGlzLmtlcm5lbC5zZXRVbmlmb3JtM2l2KHRoaXMuZGltZW5zaW9uc0lkLCB0aGlzLmRpbWVuc2lvbnMpO1xuICAgIHRoaXMua2VybmVsLnNldFVuaWZvcm0yaXYodGhpcy5zaXplSWQsIHRoaXMudGV4dHVyZVNpemUpO1xuICAgIHN1cGVyLnVwZGF0ZVZhbHVlKHZhbHVlKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNTaW5nbGVBcnJheTNESVxufTtcbn0se1wiLi4vLi4vLi4vdXRpbHNcIjoxMTQsXCIuL3NpbmdsZS1hcnJheTNkLWlcIjo2Nn1dLDUzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzJyk7XG5jb25zdCB7IFdlYkdMS2VybmVsVmFsdWVTaW5nbGVJbnB1dCB9ID0gcmVxdWlyZSgnLi9zaW5nbGUtaW5wdXQnKTtcblxuY2xhc3MgV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNTaW5nbGVJbnB1dCBleHRlbmRzIFdlYkdMS2VybmVsVmFsdWVTaW5nbGVJbnB1dCB7XG4gIGdldFNvdXJjZSgpIHtcbiAgICByZXR1cm4gdXRpbHMubGluZXNUb1N0cmluZyhbXG4gICAgICBgdW5pZm9ybSBzYW1wbGVyMkQgJHt0aGlzLmlkfWAsXG4gICAgICBgdW5pZm9ybSBpdmVjMiAke3RoaXMuc2l6ZUlkfWAsXG4gICAgICBgdW5pZm9ybSBpdmVjMyAke3RoaXMuZGltZW5zaW9uc0lkfWAsXG4gICAgXSk7XG4gIH1cblxuICB1cGRhdGVWYWx1ZSh2YWx1ZSkge1xuICAgIGxldCBbdywgaCwgZF0gPSB2YWx1ZS5zaXplO1xuICAgIHRoaXMuZGltZW5zaW9ucyA9IG5ldyBJbnQzMkFycmF5KFt3IHx8IDEsIGggfHwgMSwgZCB8fCAxXSk7XG4gICAgdGhpcy50ZXh0dXJlU2l6ZSA9IHV0aWxzLmdldE1lbW9yeU9wdGltaXplZEZsb2F0VGV4dHVyZVNpemUodGhpcy5kaW1lbnNpb25zLCB0aGlzLmJpdFJhdGlvKTtcbiAgICB0aGlzLnVwbG9hZEFycmF5TGVuZ3RoID0gdGhpcy50ZXh0dXJlU2l6ZVswXSAqIHRoaXMudGV4dHVyZVNpemVbMV0gKiB0aGlzLmJpdFJhdGlvO1xuICAgIHRoaXMuY2hlY2tTaXplKHRoaXMudGV4dHVyZVNpemVbMF0sIHRoaXMudGV4dHVyZVNpemVbMV0pO1xuICAgIHRoaXMudXBsb2FkVmFsdWUgPSBuZXcgRmxvYXQzMkFycmF5KHRoaXMudXBsb2FkQXJyYXlMZW5ndGgpO1xuICAgIHRoaXMua2VybmVsLnNldFVuaWZvcm0zaXYodGhpcy5kaW1lbnNpb25zSWQsIHRoaXMuZGltZW5zaW9ucyk7XG4gICAgdGhpcy5rZXJuZWwuc2V0VW5pZm9ybTJpdih0aGlzLnNpemVJZCwgdGhpcy50ZXh0dXJlU2l6ZSk7XG4gICAgc3VwZXIudXBkYXRlVmFsdWUodmFsdWUpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY1NpbmdsZUlucHV0XG59O1xufSx7XCIuLi8uLi8uLi91dGlsc1wiOjExNCxcIi4vc2luZ2xlLWlucHV0XCI6Njd9XSw1NDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xuY29uc3QgeyBXZWJHTEtlcm5lbFZhbHVlVW5zaWduZWRBcnJheSB9ID0gcmVxdWlyZSgnLi91bnNpZ25lZC1hcnJheScpO1xuXG5jbGFzcyBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY1Vuc2lnbmVkQXJyYXkgZXh0ZW5kcyBXZWJHTEtlcm5lbFZhbHVlVW5zaWduZWRBcnJheSB7XG4gIGdldFNvdXJjZSgpIHtcbiAgICByZXR1cm4gdXRpbHMubGluZXNUb1N0cmluZyhbXG4gICAgICBgdW5pZm9ybSBzYW1wbGVyMkQgJHt0aGlzLmlkfWAsXG4gICAgICBgdW5pZm9ybSBpdmVjMiAke3RoaXMuc2l6ZUlkfWAsXG4gICAgICBgdW5pZm9ybSBpdmVjMyAke3RoaXMuZGltZW5zaW9uc0lkfWAsXG4gICAgXSk7XG4gIH1cblxuICB1cGRhdGVWYWx1ZSh2YWx1ZSkge1xuICAgIHRoaXMuZGltZW5zaW9ucyA9IHV0aWxzLmdldERpbWVuc2lvbnModmFsdWUsIHRydWUpO1xuICAgIHRoaXMudGV4dHVyZVNpemUgPSB1dGlscy5nZXRNZW1vcnlPcHRpbWl6ZWRQYWNrZWRUZXh0dXJlU2l6ZSh0aGlzLmRpbWVuc2lvbnMsIHRoaXMuYml0UmF0aW8pO1xuICAgIHRoaXMudXBsb2FkQXJyYXlMZW5ndGggPSB0aGlzLnRleHR1cmVTaXplWzBdICogdGhpcy50ZXh0dXJlU2l6ZVsxXSAqICg0IC8gdGhpcy5iaXRSYXRpbyk7XG4gICAgdGhpcy5jaGVja1NpemUodGhpcy50ZXh0dXJlU2l6ZVswXSwgdGhpcy50ZXh0dXJlU2l6ZVsxXSk7XG4gICAgY29uc3QgVHlwZSA9IHRoaXMuZ2V0VHJhbnNmZXJBcnJheVR5cGUodmFsdWUpO1xuICAgIHRoaXMucHJlVXBsb2FkVmFsdWUgPSBuZXcgVHlwZSh0aGlzLnVwbG9hZEFycmF5TGVuZ3RoKTtcbiAgICB0aGlzLnVwbG9hZFZhbHVlID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5wcmVVcGxvYWRWYWx1ZS5idWZmZXIpO1xuICAgIHRoaXMua2VybmVsLnNldFVuaWZvcm0zaXYodGhpcy5kaW1lbnNpb25zSWQsIHRoaXMuZGltZW5zaW9ucyk7XG4gICAgdGhpcy5rZXJuZWwuc2V0VW5pZm9ybTJpdih0aGlzLnNpemVJZCwgdGhpcy50ZXh0dXJlU2l6ZSk7XG4gICAgc3VwZXIudXBkYXRlVmFsdWUodmFsdWUpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY1Vuc2lnbmVkQXJyYXlcbn07XG59LHtcIi4uLy4uLy4uL3V0aWxzXCI6MTE0LFwiLi91bnNpZ25lZC1hcnJheVwiOjY4fV0sNTU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHsgV2ViR0xLZXJuZWxWYWx1ZVVuc2lnbmVkSW5wdXQgfSA9IHJlcXVpcmUoJy4vdW5zaWduZWQtaW5wdXQnKTtcblxuY2xhc3MgV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNVbnNpZ25lZElucHV0IGV4dGVuZHMgV2ViR0xLZXJuZWxWYWx1ZVVuc2lnbmVkSW5wdXQge1xuICBnZXRTb3VyY2UoKSB7XG4gICAgcmV0dXJuIHV0aWxzLmxpbmVzVG9TdHJpbmcoW1xuICAgICAgYHVuaWZvcm0gc2FtcGxlcjJEICR7dGhpcy5pZH1gLFxuICAgICAgYHVuaWZvcm0gaXZlYzIgJHt0aGlzLnNpemVJZH1gLFxuICAgICAgYHVuaWZvcm0gaXZlYzMgJHt0aGlzLmRpbWVuc2lvbnNJZH1gLFxuICAgIF0pO1xuICB9XG5cbiAgdXBkYXRlVmFsdWUodmFsdWUpIHtcbiAgICBsZXQgW3csIGgsIGRdID0gdmFsdWUuc2l6ZTtcbiAgICB0aGlzLmRpbWVuc2lvbnMgPSBuZXcgSW50MzJBcnJheShbdyB8fCAxLCBoIHx8IDEsIGQgfHwgMV0pO1xuICAgIHRoaXMudGV4dHVyZVNpemUgPSB1dGlscy5nZXRNZW1vcnlPcHRpbWl6ZWRQYWNrZWRUZXh0dXJlU2l6ZSh0aGlzLmRpbWVuc2lvbnMsIHRoaXMuYml0UmF0aW8pO1xuICAgIHRoaXMudXBsb2FkQXJyYXlMZW5ndGggPSB0aGlzLnRleHR1cmVTaXplWzBdICogdGhpcy50ZXh0dXJlU2l6ZVsxXSAqICg0IC8gdGhpcy5iaXRSYXRpbyk7XG4gICAgdGhpcy5jaGVja1NpemUodGhpcy50ZXh0dXJlU2l6ZVswXSwgdGhpcy50ZXh0dXJlU2l6ZVsxXSk7XG4gICAgY29uc3QgVHlwZSA9IHRoaXMuZ2V0VHJhbnNmZXJBcnJheVR5cGUodmFsdWUudmFsdWUpO1xuICAgIHRoaXMucHJlVXBsb2FkVmFsdWUgPSBuZXcgVHlwZSh0aGlzLnVwbG9hZEFycmF5TGVuZ3RoKTtcbiAgICB0aGlzLnVwbG9hZFZhbHVlID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5wcmVVcGxvYWRWYWx1ZS5idWZmZXIpO1xuICAgIHRoaXMua2VybmVsLnNldFVuaWZvcm0zaXYodGhpcy5kaW1lbnNpb25zSWQsIHRoaXMuZGltZW5zaW9ucyk7XG4gICAgdGhpcy5rZXJuZWwuc2V0VW5pZm9ybTJpdih0aGlzLnNpemVJZCwgdGhpcy50ZXh0dXJlU2l6ZSk7XG4gICAgc3VwZXIudXBkYXRlVmFsdWUodmFsdWUpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY1Vuc2lnbmVkSW5wdXRcbn07XG59LHtcIi4uLy4uLy4uL3V0aWxzXCI6MTE0LFwiLi91bnNpZ25lZC1pbnB1dFwiOjY5fV0sNTY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHsgV2ViR0xLZXJuZWxWYWx1ZSB9ID0gcmVxdWlyZSgnLi9pbmRleCcpO1xuXG5jbGFzcyBXZWJHTEtlcm5lbFZhbHVlRmxvYXQgZXh0ZW5kcyBXZWJHTEtlcm5lbFZhbHVlIHtcbiAgY29uc3RydWN0b3IodmFsdWUsIHNldHRpbmdzKSB7XG4gICAgc3VwZXIodmFsdWUsIHNldHRpbmdzKTtcbiAgICB0aGlzLnVwbG9hZFZhbHVlID0gdmFsdWU7XG4gIH1cbiAgZ2V0U3RyaW5nVmFsdWVIYW5kbGVyKCkge1xuICAgIHJldHVybiBgY29uc3QgdXBsb2FkVmFsdWVfJHt0aGlzLm5hbWV9ID0gJHt0aGlzLnZhck5hbWV9O1xcbmA7XG4gIH1cbiAgZ2V0U291cmNlKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMub3JpZ2luID09PSAnY29uc3RhbnRzJykge1xuICAgICAgaWYgKE51bWJlci5pc0ludGVnZXIodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBgY29uc3QgZmxvYXQgJHt0aGlzLmlkfSA9ICR7dmFsdWV9LjA7XFxuYDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBgY29uc3QgZmxvYXQgJHt0aGlzLmlkfSA9ICR7dmFsdWV9O1xcbmA7XG4gICAgfVxuICAgIHJldHVybiBgdW5pZm9ybSBmbG9hdCAke3RoaXMuaWR9O1xcbmA7XG4gIH1cblxuICB1cGRhdGVWYWx1ZSh2YWx1ZSkge1xuICAgIGlmICh0aGlzLm9yaWdpbiA9PT0gJ2NvbnN0YW50cycpIHJldHVybjtcbiAgICB0aGlzLmtlcm5lbC5zZXRVbmlmb3JtMWYodGhpcy5pZCwgdGhpcy51cGxvYWRWYWx1ZSA9IHZhbHVlKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViR0xLZXJuZWxWYWx1ZUZsb2F0XG59O1xufSx7XCIuLi8uLi8uLi91dGlsc1wiOjExNCxcIi4vaW5kZXhcIjo1OX1dLDU3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzJyk7XG5jb25zdCB7IFdlYkdMS2VybmVsQXJyYXkgfSA9IHJlcXVpcmUoJy4vYXJyYXknKTtcblxuY2xhc3MgV2ViR0xLZXJuZWxWYWx1ZUhUTUxJbWFnZSBleHRlbmRzIFdlYkdMS2VybmVsQXJyYXkge1xuICBjb25zdHJ1Y3Rvcih2YWx1ZSwgc2V0dGluZ3MpIHtcbiAgICBzdXBlcih2YWx1ZSwgc2V0dGluZ3MpO1xuICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gdmFsdWU7XG4gICAgdGhpcy5jaGVja1NpemUod2lkdGgsIGhlaWdodCk7XG4gICAgdGhpcy5kaW1lbnNpb25zID0gW3dpZHRoLCBoZWlnaHQsIDFdO1xuICAgIHRoaXMudGV4dHVyZVNpemUgPSBbd2lkdGgsIGhlaWdodF07XG4gICAgdGhpcy51cGxvYWRWYWx1ZSA9IHZhbHVlO1xuICB9XG5cbiAgZ2V0U3RyaW5nVmFsdWVIYW5kbGVyKCkge1xuICAgIHJldHVybiBgY29uc3QgdXBsb2FkVmFsdWVfJHt0aGlzLm5hbWV9ID0gJHt0aGlzLnZhck5hbWV9O1xcbmA7XG4gIH1cblxuICBnZXRTb3VyY2UoKSB7XG4gICAgcmV0dXJuIHV0aWxzLmxpbmVzVG9TdHJpbmcoW1xuICAgICAgYHVuaWZvcm0gc2FtcGxlcjJEICR7dGhpcy5pZH1gLFxuICAgICAgYGl2ZWMyICR7dGhpcy5zaXplSWR9ID0gaXZlYzIoJHt0aGlzLnRleHR1cmVTaXplWzBdfSwgJHt0aGlzLnRleHR1cmVTaXplWzFdfSlgLFxuICAgICAgYGl2ZWMzICR7dGhpcy5kaW1lbnNpb25zSWR9ID0gaXZlYzMoJHt0aGlzLmRpbWVuc2lvbnNbMF19LCAke3RoaXMuZGltZW5zaW9uc1sxXX0sICR7dGhpcy5kaW1lbnNpb25zWzJdfSlgLFxuICAgIF0pO1xuICB9XG5cbiAgdXBkYXRlVmFsdWUoaW5wdXRJbWFnZSkge1xuICAgIGlmIChpbnB1dEltYWdlLmNvbnN0cnVjdG9yICE9PSB0aGlzLmluaXRpYWxWYWx1ZUNvbnN0cnVjdG9yKSB7XG4gICAgICB0aGlzLm9uVXBkYXRlVmFsdWVNaXNtYXRjaChpbnB1dEltYWdlLmNvbnN0cnVjdG9yKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgeyBjb250ZXh0OiBnbCB9ID0gdGhpcztcbiAgICBnbC5hY3RpdmVUZXh0dXJlKHRoaXMuY29udGV4dEhhbmRsZSk7XG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy50ZXh0dXJlKTtcbiAgICBnbC5waXhlbFN0b3JlaShnbC5VTlBBQ0tfRkxJUF9ZX1dFQkdMLCB0cnVlKTtcbiAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIHRoaXMudXBsb2FkVmFsdWUgPSBpbnB1dEltYWdlKTtcbiAgICB0aGlzLmtlcm5lbC5zZXRVbmlmb3JtMWkodGhpcy5pZCwgdGhpcy5pbmRleCk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFdlYkdMS2VybmVsVmFsdWVIVE1MSW1hZ2Vcbn07XG59LHtcIi4uLy4uLy4uL3V0aWxzXCI6MTE0LFwiLi9hcnJheVwiOjQwfV0sNTg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyBXZWJHTEtlcm5lbFZhbHVlSFRNTEltYWdlIH0gPSByZXF1aXJlKCcuL2h0bWwtaW1hZ2UnKTtcblxuY2xhc3MgV2ViR0xLZXJuZWxWYWx1ZUhUTUxWaWRlbyBleHRlbmRzIFdlYkdMS2VybmVsVmFsdWVIVE1MSW1hZ2Uge31cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFdlYkdMS2VybmVsVmFsdWVIVE1MVmlkZW9cbn07XG59LHtcIi4vaHRtbC1pbWFnZVwiOjU3fV0sNTk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHsgS2VybmVsVmFsdWUgfSA9IHJlcXVpcmUoJy4uLy4uL2tlcm5lbC12YWx1ZScpO1xuXG5jbGFzcyBXZWJHTEtlcm5lbFZhbHVlIGV4dGVuZHMgS2VybmVsVmFsdWUge1xuICBjb25zdHJ1Y3Rvcih2YWx1ZSwgc2V0dGluZ3MpIHtcbiAgICBzdXBlcih2YWx1ZSwgc2V0dGluZ3MpO1xuICAgIHRoaXMuZGltZW5zaW9uc0lkID0gbnVsbDtcbiAgICB0aGlzLnNpemVJZCA9IG51bGw7XG4gICAgdGhpcy5pbml0aWFsVmFsdWVDb25zdHJ1Y3RvciA9IHZhbHVlLmNvbnN0cnVjdG9yO1xuICAgIHRoaXMub25SZXF1ZXN0VGV4dHVyZSA9IHNldHRpbmdzLm9uUmVxdWVzdFRleHR1cmU7XG4gICAgdGhpcy5vblJlcXVlc3RJbmRleCA9IHNldHRpbmdzLm9uUmVxdWVzdEluZGV4O1xuICAgIHRoaXMudXBsb2FkVmFsdWUgPSBudWxsO1xuICAgIHRoaXMudGV4dHVyZVNpemUgPSBudWxsO1xuICAgIHRoaXMuYml0UmF0aW8gPSBudWxsO1xuICAgIHRoaXMucHJldkFyZyA9IG51bGw7XG4gIH1cblxuICBnZXQgaWQoKSB7XG4gICAgcmV0dXJuIGAke3RoaXMub3JpZ2lufV8ke3V0aWxzLnNhbml0aXplTmFtZSh0aGlzLm5hbWUpfWA7XG4gIH1cblxuICBzZXR1cCgpIHt9XG5cbiAgZ2V0VHJhbnNmZXJBcnJheVR5cGUodmFsdWUpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZVswXSkpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFRyYW5zZmVyQXJyYXlUeXBlKHZhbHVlWzBdKTtcbiAgICB9XG4gICAgc3dpdGNoICh2YWx1ZS5jb25zdHJ1Y3Rvcikge1xuICAgICAgY2FzZSBBcnJheTpcbiAgICAgIGNhc2UgSW50MzJBcnJheTpcbiAgICAgIGNhc2UgSW50MTZBcnJheTpcbiAgICAgIGNhc2UgSW50OEFycmF5OlxuICAgICAgICByZXR1cm4gRmxvYXQzMkFycmF5O1xuICAgICAgY2FzZSBVaW50OENsYW1wZWRBcnJheTpcbiAgICAgIGNhc2UgVWludDhBcnJheTpcbiAgICAgIGNhc2UgVWludDE2QXJyYXk6XG4gICAgICBjYXNlIFVpbnQzMkFycmF5OlxuICAgICAgY2FzZSBGbG9hdDMyQXJyYXk6XG4gICAgICBjYXNlIEZsb2F0NjRBcnJheTpcbiAgICAgICAgcmV0dXJuIHZhbHVlLmNvbnN0cnVjdG9yO1xuICAgIH1cbiAgICBjb25zb2xlLndhcm4oJ1VuZmFtaWxpYXIgY29uc3RydWN0b3IgdHlwZS4gIFdpbGwgZ28gYWhlYWQgYW5kIHVzZSwgYnV0IGxpa2xleSB0aGlzIG1heSByZXN1bHQgaW4gYSB0cmFuc2ZlciBvZiB6ZXJvcycpO1xuICAgIHJldHVybiB2YWx1ZS5jb25zdHJ1Y3RvcjtcbiAgfVxuXG4gIGdldFN0cmluZ1ZhbHVlSGFuZGxlcigpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFwiZ2V0U3RyaW5nVmFsdWVIYW5kbGVyXCIgbm90IGltcGxlbWVudGVkIG9uICR7dGhpcy5jb25zdHJ1Y3Rvci5uYW1lfWApO1xuICB9XG5cbiAgZ2V0VmFyaWFibGVQcmVjaXNpb25TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMua2VybmVsLmdldFZhcmlhYmxlUHJlY2lzaW9uU3RyaW5nKHRoaXMudGV4dHVyZVNpemUgfHwgdW5kZWZpbmVkLCB0aGlzLnRhY3RpYyB8fCB1bmRlZmluZWQpO1xuICB9XG5cbiAgZGVzdHJveSgpIHt9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBXZWJHTEtlcm5lbFZhbHVlXG59O1xufSx7XCIuLi8uLi8uLi91dGlsc1wiOjExNCxcIi4uLy4uL2tlcm5lbC12YWx1ZVwiOjM1fV0sNjA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHsgV2ViR0xLZXJuZWxWYWx1ZSB9ID0gcmVxdWlyZSgnLi9pbmRleCcpO1xuXG5jbGFzcyBXZWJHTEtlcm5lbFZhbHVlSW50ZWdlciBleHRlbmRzIFdlYkdMS2VybmVsVmFsdWUge1xuICBjb25zdHJ1Y3Rvcih2YWx1ZSwgc2V0dGluZ3MpIHtcbiAgICBzdXBlcih2YWx1ZSwgc2V0dGluZ3MpO1xuICAgIHRoaXMudXBsb2FkVmFsdWUgPSB2YWx1ZTtcbiAgfVxuICBnZXRTdHJpbmdWYWx1ZUhhbmRsZXIoKSB7XG4gICAgcmV0dXJuIGBjb25zdCB1cGxvYWRWYWx1ZV8ke3RoaXMubmFtZX0gPSAke3RoaXMudmFyTmFtZX07XFxuYDtcbiAgfVxuICBnZXRTb3VyY2UodmFsdWUpIHtcbiAgICBpZiAodGhpcy5vcmlnaW4gPT09ICdjb25zdGFudHMnKSB7XG4gICAgICByZXR1cm4gYGNvbnN0IGludCAke3RoaXMuaWR9ID0gJHsgcGFyc2VJbnQodmFsdWUpIH07XFxuYDtcbiAgICB9XG4gICAgcmV0dXJuIGB1bmlmb3JtIGludCAke3RoaXMuaWR9O1xcbmA7XG4gIH1cblxuICB1cGRhdGVWYWx1ZSh2YWx1ZSkge1xuICAgIGlmICh0aGlzLm9yaWdpbiA9PT0gJ2NvbnN0YW50cycpIHJldHVybjtcbiAgICB0aGlzLmtlcm5lbC5zZXRVbmlmb3JtMWkodGhpcy5pZCwgdGhpcy51cGxvYWRWYWx1ZSA9IHZhbHVlKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViR0xLZXJuZWxWYWx1ZUludGVnZXJcbn07XG59LHtcIi4uLy4uLy4uL3V0aWxzXCI6MTE0LFwiLi9pbmRleFwiOjU5fV0sNjE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHsgV2ViR0xLZXJuZWxBcnJheSB9ID0gcmVxdWlyZSgnLi9hcnJheScpO1xuXG5jb25zdCBzYW1lRXJyb3IgPSBgU291cmNlIGFuZCBkZXN0aW5hdGlvbiB0ZXh0dXJlcyBhcmUgdGhlIHNhbWUuICBVc2UgaW1tdXRhYmxlID0gdHJ1ZSBhbmQgbWFudWFsbHkgY2xlYW51cCBrZXJuZWwgb3V0cHV0IHRleHR1cmUgbWVtb3J5IHdpdGggdGV4dHVyZS5kZWxldGUoKWA7XG5cbmNsYXNzIFdlYkdMS2VybmVsVmFsdWVNZW1vcnlPcHRpbWl6ZWROdW1iZXJUZXh0dXJlIGV4dGVuZHMgV2ViR0xLZXJuZWxBcnJheSB7XG4gIGNvbnN0cnVjdG9yKHZhbHVlLCBzZXR0aW5ncykge1xuICAgIHN1cGVyKHZhbHVlLCBzZXR0aW5ncyk7XG4gICAgY29uc3QgW3dpZHRoLCBoZWlnaHRdID0gdmFsdWUuc2l6ZTtcbiAgICB0aGlzLmNoZWNrU2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICB0aGlzLmRpbWVuc2lvbnMgPSB2YWx1ZS5kaW1lbnNpb25zO1xuICAgIHRoaXMudGV4dHVyZVNpemUgPSB2YWx1ZS5zaXplO1xuICAgIHRoaXMudXBsb2FkVmFsdWUgPSB2YWx1ZS50ZXh0dXJlO1xuICAgIHRoaXMuZm9yY2VVcGxvYWRFYWNoUnVuID0gdHJ1ZTtcbiAgfVxuXG4gIHNldHVwKCkge1xuICAgIHRoaXMuc2V0dXBUZXh0dXJlKCk7XG4gIH1cblxuICBnZXRTdHJpbmdWYWx1ZUhhbmRsZXIoKSB7XG4gICAgcmV0dXJuIGBjb25zdCB1cGxvYWRWYWx1ZV8ke3RoaXMubmFtZX0gPSAke3RoaXMudmFyTmFtZX0udGV4dHVyZTtcXG5gO1xuICB9XG5cbiAgZ2V0U291cmNlKCkge1xuICAgIHJldHVybiB1dGlscy5saW5lc1RvU3RyaW5nKFtcbiAgICAgIGB1bmlmb3JtIHNhbXBsZXIyRCAke3RoaXMuaWR9YCxcbiAgICAgIGBpdmVjMiAke3RoaXMuc2l6ZUlkfSA9IGl2ZWMyKCR7dGhpcy50ZXh0dXJlU2l6ZVswXX0sICR7dGhpcy50ZXh0dXJlU2l6ZVsxXX0pYCxcbiAgICAgIGBpdmVjMyAke3RoaXMuZGltZW5zaW9uc0lkfSA9IGl2ZWMzKCR7dGhpcy5kaW1lbnNpb25zWzBdfSwgJHt0aGlzLmRpbWVuc2lvbnNbMV19LCAke3RoaXMuZGltZW5zaW9uc1syXX0pYCxcbiAgICBdKTtcbiAgfVxuXG4gIHVwZGF0ZVZhbHVlKGlucHV0VGV4dHVyZSkge1xuICAgIGlmIChpbnB1dFRleHR1cmUuY29uc3RydWN0b3IgIT09IHRoaXMuaW5pdGlhbFZhbHVlQ29uc3RydWN0b3IpIHtcbiAgICAgIHRoaXMub25VcGRhdGVWYWx1ZU1pc21hdGNoKGlucHV0VGV4dHVyZS5jb25zdHJ1Y3Rvcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLmNoZWNrQ29udGV4dCAmJiBpbnB1dFRleHR1cmUuY29udGV4dCAhPT0gdGhpcy5jb250ZXh0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFZhbHVlICR7dGhpcy5uYW1lfSAoJHt0aGlzLnR5cGV9KSBtdXN0IGJlIGZyb20gc2FtZSBjb250ZXh0YCk7XG4gICAgfVxuXG4gICAgY29uc3QgeyBrZXJuZWwsIGNvbnRleHQ6IGdsIH0gPSB0aGlzO1xuICAgIGlmIChrZXJuZWwucGlwZWxpbmUpIHtcbiAgICAgIGlmIChrZXJuZWwuaW1tdXRhYmxlKSB7XG4gICAgICAgIGtlcm5lbC51cGRhdGVUZXh0dXJlQXJndW1lbnRSZWZzKHRoaXMsIGlucHV0VGV4dHVyZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoa2VybmVsLnRleHR1cmUgJiYga2VybmVsLnRleHR1cmUudGV4dHVyZSA9PT0gaW5wdXRUZXh0dXJlLnRleHR1cmUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3Ioc2FtZUVycm9yKTtcbiAgICAgICAgfSBlbHNlIGlmIChrZXJuZWwubWFwcGVkVGV4dHVyZXMpIHtcbiAgICAgICAgICBjb25zdCB7IG1hcHBlZFRleHR1cmVzIH0gPSBrZXJuZWw7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXBwZWRUZXh0dXJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKG1hcHBlZFRleHR1cmVzW2ldLnRleHR1cmUgPT09IGlucHV0VGV4dHVyZS50ZXh0dXJlKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihzYW1lRXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGdsLmFjdGl2ZVRleHR1cmUodGhpcy5jb250ZXh0SGFuZGxlKTtcbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0aGlzLnVwbG9hZFZhbHVlID0gaW5wdXRUZXh0dXJlLnRleHR1cmUpO1xuICAgIHRoaXMua2VybmVsLnNldFVuaWZvcm0xaSh0aGlzLmlkLCB0aGlzLmluZGV4KTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViR0xLZXJuZWxWYWx1ZU1lbW9yeU9wdGltaXplZE51bWJlclRleHR1cmUsXG4gIHNhbWVFcnJvclxufTtcbn0se1wiLi4vLi4vLi4vdXRpbHNcIjoxMTQsXCIuL2FycmF5XCI6NDB9XSw2MjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xuY29uc3QgeyBXZWJHTEtlcm5lbEFycmF5IH0gPSByZXF1aXJlKCcuL2FycmF5Jyk7XG5jb25zdCB7IHNhbWVFcnJvciB9ID0gcmVxdWlyZSgnLi9tZW1vcnktb3B0aW1pemVkLW51bWJlci10ZXh0dXJlJyk7XG5cbmNsYXNzIFdlYkdMS2VybmVsVmFsdWVOdW1iZXJUZXh0dXJlIGV4dGVuZHMgV2ViR0xLZXJuZWxBcnJheSB7XG4gIGNvbnN0cnVjdG9yKHZhbHVlLCBzZXR0aW5ncykge1xuICAgIHN1cGVyKHZhbHVlLCBzZXR0aW5ncyk7XG4gICAgY29uc3QgW3dpZHRoLCBoZWlnaHRdID0gdmFsdWUuc2l6ZTtcbiAgICB0aGlzLmNoZWNrU2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICBjb25zdCB7IHNpemU6IHRleHR1cmVTaXplLCBkaW1lbnNpb25zIH0gPSB2YWx1ZTtcbiAgICB0aGlzLmJpdFJhdGlvID0gdGhpcy5nZXRCaXRSYXRpbyh2YWx1ZSk7XG4gICAgdGhpcy5kaW1lbnNpb25zID0gZGltZW5zaW9ucztcbiAgICB0aGlzLnRleHR1cmVTaXplID0gdGV4dHVyZVNpemU7XG4gICAgdGhpcy51cGxvYWRWYWx1ZSA9IHZhbHVlLnRleHR1cmU7XG4gICAgdGhpcy5mb3JjZVVwbG9hZEVhY2hSdW4gPSB0cnVlO1xuICB9XG5cbiAgc2V0dXAoKSB7XG4gICAgdGhpcy5zZXR1cFRleHR1cmUoKTtcbiAgfVxuXG4gIGdldFN0cmluZ1ZhbHVlSGFuZGxlcigpIHtcbiAgICByZXR1cm4gYGNvbnN0IHVwbG9hZFZhbHVlXyR7dGhpcy5uYW1lfSA9ICR7dGhpcy52YXJOYW1lfS50ZXh0dXJlO1xcbmA7XG4gIH1cblxuICBnZXRTb3VyY2UoKSB7XG4gICAgcmV0dXJuIHV0aWxzLmxpbmVzVG9TdHJpbmcoW1xuICAgICAgYHVuaWZvcm0gc2FtcGxlcjJEICR7dGhpcy5pZH1gLFxuICAgICAgYGl2ZWMyICR7dGhpcy5zaXplSWR9ID0gaXZlYzIoJHt0aGlzLnRleHR1cmVTaXplWzBdfSwgJHt0aGlzLnRleHR1cmVTaXplWzFdfSlgLFxuICAgICAgYGl2ZWMzICR7dGhpcy5kaW1lbnNpb25zSWR9ID0gaXZlYzMoJHt0aGlzLmRpbWVuc2lvbnNbMF19LCAke3RoaXMuZGltZW5zaW9uc1sxXX0sICR7dGhpcy5kaW1lbnNpb25zWzJdfSlgLFxuICAgIF0pO1xuICB9XG5cbiAgdXBkYXRlVmFsdWUoaW5wdXRUZXh0dXJlKSB7XG4gICAgaWYgKGlucHV0VGV4dHVyZS5jb25zdHJ1Y3RvciAhPT0gdGhpcy5pbml0aWFsVmFsdWVDb25zdHJ1Y3Rvcikge1xuICAgICAgdGhpcy5vblVwZGF0ZVZhbHVlTWlzbWF0Y2goaW5wdXRUZXh0dXJlLmNvbnN0cnVjdG9yKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuY2hlY2tDb250ZXh0ICYmIGlucHV0VGV4dHVyZS5jb250ZXh0ICE9PSB0aGlzLmNvbnRleHQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVmFsdWUgJHt0aGlzLm5hbWV9ICgke3RoaXMudHlwZX0pIG11c3QgYmUgZnJvbSBzYW1lIGNvbnRleHRgKTtcbiAgICB9XG5cbiAgICBjb25zdCB7IGtlcm5lbCwgY29udGV4dDogZ2wgfSA9IHRoaXM7XG4gICAgaWYgKGtlcm5lbC5waXBlbGluZSkge1xuICAgICAgaWYgKGtlcm5lbC5pbW11dGFibGUpIHtcbiAgICAgICAga2VybmVsLnVwZGF0ZVRleHR1cmVBcmd1bWVudFJlZnModGhpcywgaW5wdXRUZXh0dXJlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChrZXJuZWwudGV4dHVyZSAmJiBrZXJuZWwudGV4dHVyZS50ZXh0dXJlID09PSBpbnB1dFRleHR1cmUudGV4dHVyZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihzYW1lRXJyb3IpO1xuICAgICAgICB9IGVsc2UgaWYgKGtlcm5lbC5tYXBwZWRUZXh0dXJlcykge1xuICAgICAgICAgIGNvbnN0IHsgbWFwcGVkVGV4dHVyZXMgfSA9IGtlcm5lbDtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1hcHBlZFRleHR1cmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAobWFwcGVkVGV4dHVyZXNbaV0udGV4dHVyZSA9PT0gaW5wdXRUZXh0dXJlLnRleHR1cmUpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHNhbWVFcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZ2wuYWN0aXZlVGV4dHVyZSh0aGlzLmNvbnRleHRIYW5kbGUpO1xuICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMudXBsb2FkVmFsdWUgPSBpbnB1dFRleHR1cmUudGV4dHVyZSk7XG4gICAgdGhpcy5rZXJuZWwuc2V0VW5pZm9ybTFpKHRoaXMuaWQsIHRoaXMuaW5kZXgpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBXZWJHTEtlcm5lbFZhbHVlTnVtYmVyVGV4dHVyZVxufTtcbn0se1wiLi4vLi4vLi4vdXRpbHNcIjoxMTQsXCIuL2FycmF5XCI6NDAsXCIuL21lbW9yeS1vcHRpbWl6ZWQtbnVtYmVyLXRleHR1cmVcIjo2MX1dLDYzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzJyk7XG5jb25zdCB7IFdlYkdMS2VybmVsQXJyYXkgfSA9IHJlcXVpcmUoJy4vYXJyYXknKTtcblxuY2xhc3MgV2ViR0xLZXJuZWxWYWx1ZVNpbmdsZUFycmF5IGV4dGVuZHMgV2ViR0xLZXJuZWxBcnJheSB7XG4gIGNvbnN0cnVjdG9yKHZhbHVlLCBzZXR0aW5ncykge1xuICAgIHN1cGVyKHZhbHVlLCBzZXR0aW5ncyk7XG4gICAgdGhpcy5iaXRSYXRpbyA9IDQ7XG4gICAgdGhpcy5kaW1lbnNpb25zID0gdXRpbHMuZ2V0RGltZW5zaW9ucyh2YWx1ZSwgdHJ1ZSk7XG4gICAgdGhpcy50ZXh0dXJlU2l6ZSA9IHV0aWxzLmdldE1lbW9yeU9wdGltaXplZEZsb2F0VGV4dHVyZVNpemUodGhpcy5kaW1lbnNpb25zLCB0aGlzLmJpdFJhdGlvKTtcbiAgICB0aGlzLnVwbG9hZEFycmF5TGVuZ3RoID0gdGhpcy50ZXh0dXJlU2l6ZVswXSAqIHRoaXMudGV4dHVyZVNpemVbMV0gKiB0aGlzLmJpdFJhdGlvO1xuICAgIHRoaXMuY2hlY2tTaXplKHRoaXMudGV4dHVyZVNpemVbMF0sIHRoaXMudGV4dHVyZVNpemVbMV0pO1xuICAgIHRoaXMudXBsb2FkVmFsdWUgPSBuZXcgRmxvYXQzMkFycmF5KHRoaXMudXBsb2FkQXJyYXlMZW5ndGgpO1xuICB9XG5cbiAgZ2V0U3RyaW5nVmFsdWVIYW5kbGVyKCkge1xuICAgIHJldHVybiB1dGlscy5saW5lc1RvU3RyaW5nKFtcbiAgICAgIGBjb25zdCB1cGxvYWRWYWx1ZV8ke3RoaXMubmFtZX0gPSBuZXcgRmxvYXQzMkFycmF5KCR7dGhpcy51cGxvYWRBcnJheUxlbmd0aH0pYCxcbiAgICAgIGBmbGF0dGVuVG8oJHt0aGlzLnZhck5hbWV9LCB1cGxvYWRWYWx1ZV8ke3RoaXMubmFtZX0pYCxcbiAgICBdKTtcbiAgfVxuXG4gIGdldFNvdXJjZSgpIHtcbiAgICByZXR1cm4gdXRpbHMubGluZXNUb1N0cmluZyhbXG4gICAgICBgdW5pZm9ybSBzYW1wbGVyMkQgJHt0aGlzLmlkfWAsXG4gICAgICBgaXZlYzIgJHt0aGlzLnNpemVJZH0gPSBpdmVjMigke3RoaXMudGV4dHVyZVNpemVbMF19LCAke3RoaXMudGV4dHVyZVNpemVbMV19KWAsXG4gICAgICBgaXZlYzMgJHt0aGlzLmRpbWVuc2lvbnNJZH0gPSBpdmVjMygke3RoaXMuZGltZW5zaW9uc1swXX0sICR7dGhpcy5kaW1lbnNpb25zWzFdfSwgJHt0aGlzLmRpbWVuc2lvbnNbMl19KWAsXG4gICAgXSk7XG4gIH1cblxuICB1cGRhdGVWYWx1ZSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZS5jb25zdHJ1Y3RvciAhPT0gdGhpcy5pbml0aWFsVmFsdWVDb25zdHJ1Y3Rvcikge1xuICAgICAgdGhpcy5vblVwZGF0ZVZhbHVlTWlzbWF0Y2godmFsdWUuY29uc3RydWN0b3IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7IGNvbnRleHQ6IGdsIH0gPSB0aGlzO1xuICAgIHV0aWxzLmZsYXR0ZW5Ubyh2YWx1ZSwgdGhpcy51cGxvYWRWYWx1ZSk7XG4gICAgZ2wuYWN0aXZlVGV4dHVyZSh0aGlzLmNvbnRleHRIYW5kbGUpO1xuICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMudGV4dHVyZSk7XG4gICAgZ2wucGl4ZWxTdG9yZWkoZ2wuVU5QQUNLX0ZMSVBfWV9XRUJHTCwgZmFsc2UpO1xuICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgdGhpcy50ZXh0dXJlU2l6ZVswXSwgdGhpcy50ZXh0dXJlU2l6ZVsxXSwgMCwgZ2wuUkdCQSwgZ2wuRkxPQVQsIHRoaXMudXBsb2FkVmFsdWUpO1xuICAgIHRoaXMua2VybmVsLnNldFVuaWZvcm0xaSh0aGlzLmlkLCB0aGlzLmluZGV4KTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViR0xLZXJuZWxWYWx1ZVNpbmdsZUFycmF5XG59O1xufSx7XCIuLi8uLi8uLi91dGlsc1wiOjExNCxcIi4vYXJyYXlcIjo0MH1dLDY0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzJyk7XG5jb25zdCB7IFdlYkdMS2VybmVsQXJyYXkgfSA9IHJlcXVpcmUoJy4vYXJyYXknKTtcblxuY2xhc3MgV2ViR0xLZXJuZWxWYWx1ZVNpbmdsZUFycmF5MURJIGV4dGVuZHMgV2ViR0xLZXJuZWxBcnJheSB7XG4gIGNvbnN0cnVjdG9yKHZhbHVlLCBzZXR0aW5ncykge1xuICAgIHN1cGVyKHZhbHVlLCBzZXR0aW5ncyk7XG4gICAgdGhpcy5iaXRSYXRpbyA9IDQ7XG4gICAgdGhpcy5zZXRTaGFwZSh2YWx1ZSk7XG4gIH1cblxuICBzZXRTaGFwZSh2YWx1ZSkge1xuICAgIGNvbnN0IHZhbHVlRGltZW5zaW9ucyA9IHV0aWxzLmdldERpbWVuc2lvbnModmFsdWUsIHRydWUpO1xuICAgIHRoaXMudGV4dHVyZVNpemUgPSB1dGlscy5nZXRNZW1vcnlPcHRpbWl6ZWRGbG9hdFRleHR1cmVTaXplKHZhbHVlRGltZW5zaW9ucywgdGhpcy5iaXRSYXRpbyk7XG4gICAgdGhpcy5kaW1lbnNpb25zID0gbmV3IEludDMyQXJyYXkoW3ZhbHVlRGltZW5zaW9uc1sxXSwgMSwgMV0pO1xuICAgIHRoaXMudXBsb2FkQXJyYXlMZW5ndGggPSB0aGlzLnRleHR1cmVTaXplWzBdICogdGhpcy50ZXh0dXJlU2l6ZVsxXSAqIHRoaXMuYml0UmF0aW87XG4gICAgdGhpcy5jaGVja1NpemUodGhpcy50ZXh0dXJlU2l6ZVswXSwgdGhpcy50ZXh0dXJlU2l6ZVsxXSk7XG4gICAgdGhpcy51cGxvYWRWYWx1ZSA9IG5ldyBGbG9hdDMyQXJyYXkodGhpcy51cGxvYWRBcnJheUxlbmd0aCk7XG4gIH1cblxuICBnZXRTdHJpbmdWYWx1ZUhhbmRsZXIoKSB7XG4gICAgcmV0dXJuIHV0aWxzLmxpbmVzVG9TdHJpbmcoW1xuICAgICAgYGNvbnN0IHVwbG9hZFZhbHVlXyR7dGhpcy5uYW1lfSA9IG5ldyBGbG9hdDMyQXJyYXkoJHt0aGlzLnVwbG9hZEFycmF5TGVuZ3RofSlgLFxuICAgICAgYGZsYXR0ZW5Ubygke3RoaXMudmFyTmFtZX0sIHVwbG9hZFZhbHVlXyR7dGhpcy5uYW1lfSlgLFxuICAgIF0pO1xuICB9XG5cbiAgZ2V0U291cmNlKCkge1xuICAgIHJldHVybiB1dGlscy5saW5lc1RvU3RyaW5nKFtcbiAgICAgIGB1bmlmb3JtIHNhbXBsZXIyRCAke3RoaXMuaWR9YCxcbiAgICAgIGBpdmVjMiAke3RoaXMuc2l6ZUlkfSA9IGl2ZWMyKCR7dGhpcy50ZXh0dXJlU2l6ZVswXX0sICR7dGhpcy50ZXh0dXJlU2l6ZVsxXX0pYCxcbiAgICAgIGBpdmVjMyAke3RoaXMuZGltZW5zaW9uc0lkfSA9IGl2ZWMzKCR7dGhpcy5kaW1lbnNpb25zWzBdfSwgJHt0aGlzLmRpbWVuc2lvbnNbMV19LCAke3RoaXMuZGltZW5zaW9uc1syXX0pYCxcbiAgICBdKTtcbiAgfVxuXG4gIHVwZGF0ZVZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlLmNvbnN0cnVjdG9yICE9PSB0aGlzLmluaXRpYWxWYWx1ZUNvbnN0cnVjdG9yKSB7XG4gICAgICB0aGlzLm9uVXBkYXRlVmFsdWVNaXNtYXRjaCh2YWx1ZS5jb25zdHJ1Y3Rvcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHsgY29udGV4dDogZ2wgfSA9IHRoaXM7XG4gICAgdXRpbHMuZmxhdHRlbjJkQXJyYXlUbyh2YWx1ZSwgdGhpcy51cGxvYWRWYWx1ZSk7XG4gICAgZ2wuYWN0aXZlVGV4dHVyZSh0aGlzLmNvbnRleHRIYW5kbGUpO1xuICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMudGV4dHVyZSk7XG4gICAgZ2wucGl4ZWxTdG9yZWkoZ2wuVU5QQUNLX0ZMSVBfWV9XRUJHTCwgZmFsc2UpO1xuICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgdGhpcy50ZXh0dXJlU2l6ZVswXSwgdGhpcy50ZXh0dXJlU2l6ZVsxXSwgMCwgZ2wuUkdCQSwgZ2wuRkxPQVQsIHRoaXMudXBsb2FkVmFsdWUpO1xuICAgIHRoaXMua2VybmVsLnNldFVuaWZvcm0xaSh0aGlzLmlkLCB0aGlzLmluZGV4KTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViR0xLZXJuZWxWYWx1ZVNpbmdsZUFycmF5MURJXG59O1xufSx7XCIuLi8uLi8uLi91dGlsc1wiOjExNCxcIi4vYXJyYXlcIjo0MH1dLDY1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzJyk7XG5jb25zdCB7IFdlYkdMS2VybmVsQXJyYXkgfSA9IHJlcXVpcmUoJy4vYXJyYXknKTtcblxuY2xhc3MgV2ViR0xLZXJuZWxWYWx1ZVNpbmdsZUFycmF5MkRJIGV4dGVuZHMgV2ViR0xLZXJuZWxBcnJheSB7XG4gIGNvbnN0cnVjdG9yKHZhbHVlLCBzZXR0aW5ncykge1xuICAgIHN1cGVyKHZhbHVlLCBzZXR0aW5ncyk7XG4gICAgdGhpcy5iaXRSYXRpbyA9IDQ7XG4gICAgdGhpcy5zZXRTaGFwZSh2YWx1ZSk7XG4gIH1cblxuICBzZXRTaGFwZSh2YWx1ZSkge1xuICAgIGNvbnN0IHZhbHVlRGltZW5zaW9ucyA9IHV0aWxzLmdldERpbWVuc2lvbnModmFsdWUsIHRydWUpO1xuICAgIHRoaXMudGV4dHVyZVNpemUgPSB1dGlscy5nZXRNZW1vcnlPcHRpbWl6ZWRGbG9hdFRleHR1cmVTaXplKHZhbHVlRGltZW5zaW9ucywgdGhpcy5iaXRSYXRpbyk7XG4gICAgdGhpcy5kaW1lbnNpb25zID0gbmV3IEludDMyQXJyYXkoW3ZhbHVlRGltZW5zaW9uc1sxXSwgdmFsdWVEaW1lbnNpb25zWzJdLCAxXSk7XG4gICAgdGhpcy51cGxvYWRBcnJheUxlbmd0aCA9IHRoaXMudGV4dHVyZVNpemVbMF0gKiB0aGlzLnRleHR1cmVTaXplWzFdICogdGhpcy5iaXRSYXRpbztcbiAgICB0aGlzLmNoZWNrU2l6ZSh0aGlzLnRleHR1cmVTaXplWzBdLCB0aGlzLnRleHR1cmVTaXplWzFdKTtcbiAgICB0aGlzLnVwbG9hZFZhbHVlID0gbmV3IEZsb2F0MzJBcnJheSh0aGlzLnVwbG9hZEFycmF5TGVuZ3RoKTtcbiAgfVxuXG4gIGdldFN0cmluZ1ZhbHVlSGFuZGxlcigpIHtcbiAgICByZXR1cm4gdXRpbHMubGluZXNUb1N0cmluZyhbXG4gICAgICBgY29uc3QgdXBsb2FkVmFsdWVfJHt0aGlzLm5hbWV9ID0gbmV3IEZsb2F0MzJBcnJheSgke3RoaXMudXBsb2FkQXJyYXlMZW5ndGh9KWAsXG4gICAgICBgZmxhdHRlblRvKCR7dGhpcy52YXJOYW1lfSwgdXBsb2FkVmFsdWVfJHt0aGlzLm5hbWV9KWAsXG4gICAgXSk7XG4gIH1cblxuICBnZXRTb3VyY2UoKSB7XG4gICAgcmV0dXJuIHV0aWxzLmxpbmVzVG9TdHJpbmcoW1xuICAgICAgYHVuaWZvcm0gc2FtcGxlcjJEICR7dGhpcy5pZH1gLFxuICAgICAgYGl2ZWMyICR7dGhpcy5zaXplSWR9ID0gaXZlYzIoJHt0aGlzLnRleHR1cmVTaXplWzBdfSwgJHt0aGlzLnRleHR1cmVTaXplWzFdfSlgLFxuICAgICAgYGl2ZWMzICR7dGhpcy5kaW1lbnNpb25zSWR9ID0gaXZlYzMoJHt0aGlzLmRpbWVuc2lvbnNbMF19LCAke3RoaXMuZGltZW5zaW9uc1sxXX0sICR7dGhpcy5kaW1lbnNpb25zWzJdfSlgLFxuICAgIF0pO1xuICB9XG5cbiAgdXBkYXRlVmFsdWUodmFsdWUpIHtcbiAgICBpZiAodmFsdWUuY29uc3RydWN0b3IgIT09IHRoaXMuaW5pdGlhbFZhbHVlQ29uc3RydWN0b3IpIHtcbiAgICAgIHRoaXMub25VcGRhdGVWYWx1ZU1pc21hdGNoKHZhbHVlLmNvbnN0cnVjdG9yKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgeyBjb250ZXh0OiBnbCB9ID0gdGhpcztcbiAgICB1dGlscy5mbGF0dGVuM2RBcnJheVRvKHZhbHVlLCB0aGlzLnVwbG9hZFZhbHVlKTtcbiAgICBnbC5hY3RpdmVUZXh0dXJlKHRoaXMuY29udGV4dEhhbmRsZSk7XG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy50ZXh0dXJlKTtcbiAgICBnbC5waXhlbFN0b3JlaShnbC5VTlBBQ0tfRkxJUF9ZX1dFQkdMLCBmYWxzZSk7XG4gICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCB0aGlzLnRleHR1cmVTaXplWzBdLCB0aGlzLnRleHR1cmVTaXplWzFdLCAwLCBnbC5SR0JBLCBnbC5GTE9BVCwgdGhpcy51cGxvYWRWYWx1ZSk7XG4gICAgdGhpcy5rZXJuZWwuc2V0VW5pZm9ybTFpKHRoaXMuaWQsIHRoaXMuaW5kZXgpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBXZWJHTEtlcm5lbFZhbHVlU2luZ2xlQXJyYXkyRElcbn07XG59LHtcIi4uLy4uLy4uL3V0aWxzXCI6MTE0LFwiLi9hcnJheVwiOjQwfV0sNjY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHsgV2ViR0xLZXJuZWxBcnJheSB9ID0gcmVxdWlyZSgnLi9hcnJheScpO1xuXG5jbGFzcyBXZWJHTEtlcm5lbFZhbHVlU2luZ2xlQXJyYXkzREkgZXh0ZW5kcyBXZWJHTEtlcm5lbEFycmF5IHtcbiAgY29uc3RydWN0b3IodmFsdWUsIHNldHRpbmdzKSB7XG4gICAgc3VwZXIodmFsdWUsIHNldHRpbmdzKTtcbiAgICB0aGlzLmJpdFJhdGlvID0gNDtcbiAgICB0aGlzLnNldFNoYXBlKHZhbHVlKTtcbiAgfVxuXG4gIHNldFNoYXBlKHZhbHVlKSB7XG4gICAgY29uc3QgdmFsdWVEaW1lbnNpb25zID0gdXRpbHMuZ2V0RGltZW5zaW9ucyh2YWx1ZSwgdHJ1ZSk7XG4gICAgdGhpcy50ZXh0dXJlU2l6ZSA9IHV0aWxzLmdldE1lbW9yeU9wdGltaXplZEZsb2F0VGV4dHVyZVNpemUodmFsdWVEaW1lbnNpb25zLCB0aGlzLmJpdFJhdGlvKTtcbiAgICB0aGlzLmRpbWVuc2lvbnMgPSBuZXcgSW50MzJBcnJheShbdmFsdWVEaW1lbnNpb25zWzFdLCB2YWx1ZURpbWVuc2lvbnNbMl0sIHZhbHVlRGltZW5zaW9uc1szXV0pO1xuICAgIHRoaXMudXBsb2FkQXJyYXlMZW5ndGggPSB0aGlzLnRleHR1cmVTaXplWzBdICogdGhpcy50ZXh0dXJlU2l6ZVsxXSAqIHRoaXMuYml0UmF0aW87XG4gICAgdGhpcy5jaGVja1NpemUodGhpcy50ZXh0dXJlU2l6ZVswXSwgdGhpcy50ZXh0dXJlU2l6ZVsxXSk7XG4gICAgdGhpcy51cGxvYWRWYWx1ZSA9IG5ldyBGbG9hdDMyQXJyYXkodGhpcy51cGxvYWRBcnJheUxlbmd0aCk7XG4gIH1cblxuICBnZXRTdHJpbmdWYWx1ZUhhbmRsZXIoKSB7XG4gICAgcmV0dXJuIHV0aWxzLmxpbmVzVG9TdHJpbmcoW1xuICAgICAgYGNvbnN0IHVwbG9hZFZhbHVlXyR7dGhpcy5uYW1lfSA9IG5ldyBGbG9hdDMyQXJyYXkoJHt0aGlzLnVwbG9hZEFycmF5TGVuZ3RofSlgLFxuICAgICAgYGZsYXR0ZW5Ubygke3RoaXMudmFyTmFtZX0sIHVwbG9hZFZhbHVlXyR7dGhpcy5uYW1lfSlgLFxuICAgIF0pO1xuICB9XG5cbiAgZ2V0U291cmNlKCkge1xuICAgIHJldHVybiB1dGlscy5saW5lc1RvU3RyaW5nKFtcbiAgICAgIGB1bmlmb3JtIHNhbXBsZXIyRCAke3RoaXMuaWR9YCxcbiAgICAgIGBpdmVjMiAke3RoaXMuc2l6ZUlkfSA9IGl2ZWMyKCR7dGhpcy50ZXh0dXJlU2l6ZVswXX0sICR7dGhpcy50ZXh0dXJlU2l6ZVsxXX0pYCxcbiAgICAgIGBpdmVjMyAke3RoaXMuZGltZW5zaW9uc0lkfSA9IGl2ZWMzKCR7dGhpcy5kaW1lbnNpb25zWzBdfSwgJHt0aGlzLmRpbWVuc2lvbnNbMV19LCAke3RoaXMuZGltZW5zaW9uc1syXX0pYCxcbiAgICBdKTtcbiAgfVxuXG4gIHVwZGF0ZVZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlLmNvbnN0cnVjdG9yICE9PSB0aGlzLmluaXRpYWxWYWx1ZUNvbnN0cnVjdG9yKSB7XG4gICAgICB0aGlzLm9uVXBkYXRlVmFsdWVNaXNtYXRjaCh2YWx1ZS5jb25zdHJ1Y3Rvcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHsgY29udGV4dDogZ2wgfSA9IHRoaXM7XG4gICAgdXRpbHMuZmxhdHRlbjRkQXJyYXlUbyh2YWx1ZSwgdGhpcy51cGxvYWRWYWx1ZSk7XG4gICAgZ2wuYWN0aXZlVGV4dHVyZSh0aGlzLmNvbnRleHRIYW5kbGUpO1xuICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMudGV4dHVyZSk7XG4gICAgZ2wucGl4ZWxTdG9yZWkoZ2wuVU5QQUNLX0ZMSVBfWV9XRUJHTCwgZmFsc2UpO1xuICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgdGhpcy50ZXh0dXJlU2l6ZVswXSwgdGhpcy50ZXh0dXJlU2l6ZVsxXSwgMCwgZ2wuUkdCQSwgZ2wuRkxPQVQsIHRoaXMudXBsb2FkVmFsdWUpO1xuICAgIHRoaXMua2VybmVsLnNldFVuaWZvcm0xaSh0aGlzLmlkLCB0aGlzLmluZGV4KTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViR0xLZXJuZWxWYWx1ZVNpbmdsZUFycmF5M0RJXG59O1xufSx7XCIuLi8uLi8uLi91dGlsc1wiOjExNCxcIi4vYXJyYXlcIjo0MH1dLDY3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzJyk7XG5jb25zdCB7IFdlYkdMS2VybmVsQXJyYXkgfSA9IHJlcXVpcmUoJy4vYXJyYXknKTtcblxuY2xhc3MgV2ViR0xLZXJuZWxWYWx1ZVNpbmdsZUlucHV0IGV4dGVuZHMgV2ViR0xLZXJuZWxBcnJheSB7XG4gIGNvbnN0cnVjdG9yKHZhbHVlLCBzZXR0aW5ncykge1xuICAgIHN1cGVyKHZhbHVlLCBzZXR0aW5ncyk7XG4gICAgdGhpcy5iaXRSYXRpbyA9IDQ7XG4gICAgbGV0IFt3LCBoLCBkXSA9IHZhbHVlLnNpemU7XG4gICAgdGhpcy5kaW1lbnNpb25zID0gbmV3IEludDMyQXJyYXkoW3cgfHwgMSwgaCB8fCAxLCBkIHx8IDFdKTtcbiAgICB0aGlzLnRleHR1cmVTaXplID0gdXRpbHMuZ2V0TWVtb3J5T3B0aW1pemVkRmxvYXRUZXh0dXJlU2l6ZSh0aGlzLmRpbWVuc2lvbnMsIHRoaXMuYml0UmF0aW8pO1xuICAgIHRoaXMudXBsb2FkQXJyYXlMZW5ndGggPSB0aGlzLnRleHR1cmVTaXplWzBdICogdGhpcy50ZXh0dXJlU2l6ZVsxXSAqIHRoaXMuYml0UmF0aW87XG4gICAgdGhpcy5jaGVja1NpemUodGhpcy50ZXh0dXJlU2l6ZVswXSwgdGhpcy50ZXh0dXJlU2l6ZVsxXSk7XG4gICAgdGhpcy51cGxvYWRWYWx1ZSA9IG5ldyBGbG9hdDMyQXJyYXkodGhpcy51cGxvYWRBcnJheUxlbmd0aCk7XG4gIH1cblxuICBnZXRTdHJpbmdWYWx1ZUhhbmRsZXIoKSB7XG4gICAgcmV0dXJuIHV0aWxzLmxpbmVzVG9TdHJpbmcoW1xuICAgICAgYGNvbnN0IHVwbG9hZFZhbHVlXyR7dGhpcy5uYW1lfSA9IG5ldyBGbG9hdDMyQXJyYXkoJHt0aGlzLnVwbG9hZEFycmF5TGVuZ3RofSlgLFxuICAgICAgYGZsYXR0ZW5Ubygke3RoaXMudmFyTmFtZX0udmFsdWUsIHVwbG9hZFZhbHVlXyR7dGhpcy5uYW1lfSlgLFxuICAgIF0pO1xuICB9XG5cbiAgZ2V0U291cmNlKCkge1xuICAgIHJldHVybiB1dGlscy5saW5lc1RvU3RyaW5nKFtcbiAgICAgIGB1bmlmb3JtIHNhbXBsZXIyRCAke3RoaXMuaWR9YCxcbiAgICAgIGBpdmVjMiAke3RoaXMuc2l6ZUlkfSA9IGl2ZWMyKCR7dGhpcy50ZXh0dXJlU2l6ZVswXX0sICR7dGhpcy50ZXh0dXJlU2l6ZVsxXX0pYCxcbiAgICAgIGBpdmVjMyAke3RoaXMuZGltZW5zaW9uc0lkfSA9IGl2ZWMzKCR7dGhpcy5kaW1lbnNpb25zWzBdfSwgJHt0aGlzLmRpbWVuc2lvbnNbMV19LCAke3RoaXMuZGltZW5zaW9uc1syXX0pYCxcbiAgICBdKTtcbiAgfVxuXG4gIHVwZGF0ZVZhbHVlKGlucHV0KSB7XG4gICAgaWYgKGlucHV0LmNvbnN0cnVjdG9yICE9PSB0aGlzLmluaXRpYWxWYWx1ZUNvbnN0cnVjdG9yKSB7XG4gICAgICB0aGlzLm9uVXBkYXRlVmFsdWVNaXNtYXRjaChpbnB1dC5jb25zdHJ1Y3Rvcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHsgY29udGV4dDogZ2wgfSA9IHRoaXM7XG4gICAgdXRpbHMuZmxhdHRlblRvKGlucHV0LnZhbHVlLCB0aGlzLnVwbG9hZFZhbHVlKTtcbiAgICBnbC5hY3RpdmVUZXh0dXJlKHRoaXMuY29udGV4dEhhbmRsZSk7XG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy50ZXh0dXJlKTtcbiAgICBnbC5waXhlbFN0b3JlaShnbC5VTlBBQ0tfRkxJUF9ZX1dFQkdMLCBmYWxzZSk7XG4gICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCB0aGlzLnRleHR1cmVTaXplWzBdLCB0aGlzLnRleHR1cmVTaXplWzFdLCAwLCBnbC5SR0JBLCBnbC5GTE9BVCwgdGhpcy51cGxvYWRWYWx1ZSk7XG4gICAgdGhpcy5rZXJuZWwuc2V0VW5pZm9ybTFpKHRoaXMuaWQsIHRoaXMuaW5kZXgpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBXZWJHTEtlcm5lbFZhbHVlU2luZ2xlSW5wdXRcbn07XG59LHtcIi4uLy4uLy4uL3V0aWxzXCI6MTE0LFwiLi9hcnJheVwiOjQwfV0sNjg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHsgV2ViR0xLZXJuZWxBcnJheSB9ID0gcmVxdWlyZSgnLi9hcnJheScpO1xuXG5jbGFzcyBXZWJHTEtlcm5lbFZhbHVlVW5zaWduZWRBcnJheSBleHRlbmRzIFdlYkdMS2VybmVsQXJyYXkge1xuICBjb25zdHJ1Y3Rvcih2YWx1ZSwgc2V0dGluZ3MpIHtcbiAgICBzdXBlcih2YWx1ZSwgc2V0dGluZ3MpO1xuICAgIHRoaXMuYml0UmF0aW8gPSB0aGlzLmdldEJpdFJhdGlvKHZhbHVlKTtcbiAgICB0aGlzLmRpbWVuc2lvbnMgPSB1dGlscy5nZXREaW1lbnNpb25zKHZhbHVlLCB0cnVlKTtcbiAgICB0aGlzLnRleHR1cmVTaXplID0gdXRpbHMuZ2V0TWVtb3J5T3B0aW1pemVkUGFja2VkVGV4dHVyZVNpemUodGhpcy5kaW1lbnNpb25zLCB0aGlzLmJpdFJhdGlvKTtcbiAgICB0aGlzLnVwbG9hZEFycmF5TGVuZ3RoID0gdGhpcy50ZXh0dXJlU2l6ZVswXSAqIHRoaXMudGV4dHVyZVNpemVbMV0gKiAoNCAvIHRoaXMuYml0UmF0aW8pO1xuICAgIHRoaXMuY2hlY2tTaXplKHRoaXMudGV4dHVyZVNpemVbMF0sIHRoaXMudGV4dHVyZVNpemVbMV0pO1xuICAgIHRoaXMuVHJhbnNlckFycmF5VHlwZSA9IHRoaXMuZ2V0VHJhbnNmZXJBcnJheVR5cGUodmFsdWUpO1xuICAgIHRoaXMucHJlVXBsb2FkVmFsdWUgPSBuZXcgdGhpcy5UcmFuc2VyQXJyYXlUeXBlKHRoaXMudXBsb2FkQXJyYXlMZW5ndGgpO1xuICAgIHRoaXMudXBsb2FkVmFsdWUgPSBuZXcgVWludDhBcnJheSh0aGlzLnByZVVwbG9hZFZhbHVlLmJ1ZmZlcik7XG4gIH1cblxuICBnZXRTdHJpbmdWYWx1ZUhhbmRsZXIoKSB7XG4gICAgcmV0dXJuIHV0aWxzLmxpbmVzVG9TdHJpbmcoW1xuICAgICAgYGNvbnN0IHByZVVwbG9hZFZhbHVlXyR7dGhpcy5uYW1lfSA9IG5ldyAke3RoaXMuVHJhbnNlckFycmF5VHlwZS5uYW1lfSgke3RoaXMudXBsb2FkQXJyYXlMZW5ndGh9KWAsXG4gICAgICBgY29uc3QgdXBsb2FkVmFsdWVfJHt0aGlzLm5hbWV9ID0gbmV3IFVpbnQ4QXJyYXkocHJlVXBsb2FkVmFsdWVfJHt0aGlzLm5hbWV9LmJ1ZmZlcilgLFxuICAgICAgYGZsYXR0ZW5Ubygke3RoaXMudmFyTmFtZX0sIHByZVVwbG9hZFZhbHVlXyR7dGhpcy5uYW1lfSlgLFxuICAgIF0pO1xuICB9XG5cbiAgZ2V0U291cmNlKCkge1xuICAgIHJldHVybiB1dGlscy5saW5lc1RvU3RyaW5nKFtcbiAgICAgIGB1bmlmb3JtIHNhbXBsZXIyRCAke3RoaXMuaWR9YCxcbiAgICAgIGBpdmVjMiAke3RoaXMuc2l6ZUlkfSA9IGl2ZWMyKCR7dGhpcy50ZXh0dXJlU2l6ZVswXX0sICR7dGhpcy50ZXh0dXJlU2l6ZVsxXX0pYCxcbiAgICAgIGBpdmVjMyAke3RoaXMuZGltZW5zaW9uc0lkfSA9IGl2ZWMzKCR7dGhpcy5kaW1lbnNpb25zWzBdfSwgJHt0aGlzLmRpbWVuc2lvbnNbMV19LCAke3RoaXMuZGltZW5zaW9uc1syXX0pYCxcbiAgICBdKTtcbiAgfVxuXG4gIHVwZGF0ZVZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlLmNvbnN0cnVjdG9yICE9PSB0aGlzLmluaXRpYWxWYWx1ZUNvbnN0cnVjdG9yKSB7XG4gICAgICB0aGlzLm9uVXBkYXRlVmFsdWVNaXNtYXRjaCh2YWx1ZS5jb25zdHJ1Y3Rvcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHsgY29udGV4dDogZ2wgfSA9IHRoaXM7XG4gICAgdXRpbHMuZmxhdHRlblRvKHZhbHVlLCB0aGlzLnByZVVwbG9hZFZhbHVlKTtcbiAgICBnbC5hY3RpdmVUZXh0dXJlKHRoaXMuY29udGV4dEhhbmRsZSk7XG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy50ZXh0dXJlKTtcbiAgICBnbC5waXhlbFN0b3JlaShnbC5VTlBBQ0tfRkxJUF9ZX1dFQkdMLCBmYWxzZSk7XG4gICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCB0aGlzLnRleHR1cmVTaXplWzBdLCB0aGlzLnRleHR1cmVTaXplWzFdLCAwLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCB0aGlzLnVwbG9hZFZhbHVlKTtcbiAgICB0aGlzLmtlcm5lbC5zZXRVbmlmb3JtMWkodGhpcy5pZCwgdGhpcy5pbmRleCk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFdlYkdMS2VybmVsVmFsdWVVbnNpZ25lZEFycmF5XG59O1xufSx7XCIuLi8uLi8uLi91dGlsc1wiOjExNCxcIi4vYXJyYXlcIjo0MH1dLDY5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzJyk7XG5jb25zdCB7IFdlYkdMS2VybmVsQXJyYXkgfSA9IHJlcXVpcmUoJy4vYXJyYXknKTtcblxuY2xhc3MgV2ViR0xLZXJuZWxWYWx1ZVVuc2lnbmVkSW5wdXQgZXh0ZW5kcyBXZWJHTEtlcm5lbEFycmF5IHtcbiAgY29uc3RydWN0b3IodmFsdWUsIHNldHRpbmdzKSB7XG4gICAgc3VwZXIodmFsdWUsIHNldHRpbmdzKTtcbiAgICB0aGlzLmJpdFJhdGlvID0gdGhpcy5nZXRCaXRSYXRpbyh2YWx1ZSk7XG4gICAgY29uc3QgW3csIGgsIGRdID0gdmFsdWUuc2l6ZTtcbiAgICB0aGlzLmRpbWVuc2lvbnMgPSBuZXcgSW50MzJBcnJheShbdyB8fCAxLCBoIHx8IDEsIGQgfHwgMV0pO1xuICAgIHRoaXMudGV4dHVyZVNpemUgPSB1dGlscy5nZXRNZW1vcnlPcHRpbWl6ZWRQYWNrZWRUZXh0dXJlU2l6ZSh0aGlzLmRpbWVuc2lvbnMsIHRoaXMuYml0UmF0aW8pO1xuICAgIHRoaXMudXBsb2FkQXJyYXlMZW5ndGggPSB0aGlzLnRleHR1cmVTaXplWzBdICogdGhpcy50ZXh0dXJlU2l6ZVsxXSAqICg0IC8gdGhpcy5iaXRSYXRpbyk7XG4gICAgdGhpcy5jaGVja1NpemUodGhpcy50ZXh0dXJlU2l6ZVswXSwgdGhpcy50ZXh0dXJlU2l6ZVsxXSk7XG4gICAgdGhpcy5UcmFuc2VyQXJyYXlUeXBlID0gdGhpcy5nZXRUcmFuc2ZlckFycmF5VHlwZSh2YWx1ZS52YWx1ZSk7XG4gICAgdGhpcy5wcmVVcGxvYWRWYWx1ZSA9IG5ldyB0aGlzLlRyYW5zZXJBcnJheVR5cGUodGhpcy51cGxvYWRBcnJheUxlbmd0aCk7XG4gICAgdGhpcy51cGxvYWRWYWx1ZSA9IG5ldyBVaW50OEFycmF5KHRoaXMucHJlVXBsb2FkVmFsdWUuYnVmZmVyKTtcbiAgfVxuXG4gIGdldFN0cmluZ1ZhbHVlSGFuZGxlcigpIHtcbiAgICByZXR1cm4gdXRpbHMubGluZXNUb1N0cmluZyhbXG4gICAgICBgY29uc3QgcHJlVXBsb2FkVmFsdWVfJHt0aGlzLm5hbWV9ID0gbmV3ICR7dGhpcy5UcmFuc2VyQXJyYXlUeXBlLm5hbWV9KCR7dGhpcy51cGxvYWRBcnJheUxlbmd0aH0pYCxcbiAgICAgIGBjb25zdCB1cGxvYWRWYWx1ZV8ke3RoaXMubmFtZX0gPSBuZXcgVWludDhBcnJheShwcmVVcGxvYWRWYWx1ZV8ke3RoaXMubmFtZX0uYnVmZmVyKWAsXG4gICAgICBgZmxhdHRlblRvKCR7dGhpcy52YXJOYW1lfS52YWx1ZSwgcHJlVXBsb2FkVmFsdWVfJHt0aGlzLm5hbWV9KWAsXG4gICAgXSk7XG4gIH1cblxuICBnZXRTb3VyY2UoKSB7XG4gICAgcmV0dXJuIHV0aWxzLmxpbmVzVG9TdHJpbmcoW1xuICAgICAgYHVuaWZvcm0gc2FtcGxlcjJEICR7dGhpcy5pZH1gLFxuICAgICAgYGl2ZWMyICR7dGhpcy5zaXplSWR9ID0gaXZlYzIoJHt0aGlzLnRleHR1cmVTaXplWzBdfSwgJHt0aGlzLnRleHR1cmVTaXplWzFdfSlgLFxuICAgICAgYGl2ZWMzICR7dGhpcy5kaW1lbnNpb25zSWR9ID0gaXZlYzMoJHt0aGlzLmRpbWVuc2lvbnNbMF19LCAke3RoaXMuZGltZW5zaW9uc1sxXX0sICR7dGhpcy5kaW1lbnNpb25zWzJdfSlgLFxuICAgIF0pO1xuICB9XG5cbiAgdXBkYXRlVmFsdWUoaW5wdXQpIHtcbiAgICBpZiAoaW5wdXQuY29uc3RydWN0b3IgIT09IHRoaXMuaW5pdGlhbFZhbHVlQ29uc3RydWN0b3IpIHtcbiAgICAgIHRoaXMub25VcGRhdGVWYWx1ZU1pc21hdGNoKHZhbHVlLmNvbnN0cnVjdG9yKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgeyBjb250ZXh0OiBnbCB9ID0gdGhpcztcbiAgICB1dGlscy5mbGF0dGVuVG8oaW5wdXQudmFsdWUsIHRoaXMucHJlVXBsb2FkVmFsdWUpO1xuICAgIGdsLmFjdGl2ZVRleHR1cmUodGhpcy5jb250ZXh0SGFuZGxlKTtcbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0aGlzLnRleHR1cmUpO1xuICAgIGdsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19GTElQX1lfV0VCR0wsIGZhbHNlKTtcbiAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIHRoaXMudGV4dHVyZVNpemVbMF0sIHRoaXMudGV4dHVyZVNpemVbMV0sIDAsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIHRoaXMudXBsb2FkVmFsdWUpO1xuICAgIHRoaXMua2VybmVsLnNldFVuaWZvcm0xaSh0aGlzLmlkLCB0aGlzLmluZGV4KTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViR0xLZXJuZWxWYWx1ZVVuc2lnbmVkSW5wdXRcbn07XG59LHtcIi4uLy4uLy4uL3V0aWxzXCI6MTE0LFwiLi9hcnJheVwiOjQwfV0sNzA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyBHTEtlcm5lbCB9ID0gcmVxdWlyZSgnLi4vZ2wva2VybmVsJyk7XG5jb25zdCB7IEZ1bmN0aW9uQnVpbGRlciB9ID0gcmVxdWlyZSgnLi4vZnVuY3Rpb24tYnVpbGRlcicpO1xuY29uc3QgeyBXZWJHTEZ1bmN0aW9uTm9kZSB9ID0gcmVxdWlyZSgnLi9mdW5jdGlvbi1ub2RlJyk7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi8uLi91dGlscycpO1xuY29uc3QgbXJ1ZCA9IHJlcXVpcmUoJy4uLy4uL3BsdWdpbnMvbWF0aC1yYW5kb20tdW5pZm9ybWx5LWRpc3RyaWJ1dGVkJyk7XG5jb25zdCB7IGZyYWdtZW50U2hhZGVyIH0gPSByZXF1aXJlKCcuL2ZyYWdtZW50LXNoYWRlcicpO1xuY29uc3QgeyB2ZXJ0ZXhTaGFkZXIgfSA9IHJlcXVpcmUoJy4vdmVydGV4LXNoYWRlcicpO1xuY29uc3QgeyBnbEtlcm5lbFN0cmluZyB9ID0gcmVxdWlyZSgnLi4vZ2wva2VybmVsLXN0cmluZycpO1xuY29uc3QgeyBsb29rdXBLZXJuZWxWYWx1ZVR5cGUgfSA9IHJlcXVpcmUoJy4va2VybmVsLXZhbHVlLW1hcHMnKTtcblxubGV0IGlzU3VwcG9ydGVkID0gbnVsbDtcbmxldCB0ZXN0Q2FudmFzID0gbnVsbDtcbmxldCB0ZXN0Q29udGV4dCA9IG51bGw7XG5sZXQgdGVzdEV4dGVuc2lvbnMgPSBudWxsO1xubGV0IGZlYXR1cmVzID0gbnVsbDtcblxuY29uc3QgcGx1Z2lucyA9IFttcnVkXTtcbmNvbnN0IGNhbnZhc2VzID0gW107XG5jb25zdCBtYXhUZXhTaXplcyA9IHt9O1xuXG5cbmNsYXNzIFdlYkdMS2VybmVsIGV4dGVuZHMgR0xLZXJuZWwge1xuICBzdGF0aWMgZ2V0IGlzU3VwcG9ydGVkKCkge1xuICAgIGlmIChpc1N1cHBvcnRlZCAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGlzU3VwcG9ydGVkO1xuICAgIH1cbiAgICB0aGlzLnNldHVwRmVhdHVyZUNoZWNrcygpO1xuICAgIGlzU3VwcG9ydGVkID0gdGhpcy5pc0NvbnRleHRNYXRjaCh0ZXN0Q29udGV4dCk7XG4gICAgcmV0dXJuIGlzU3VwcG9ydGVkO1xuICB9XG5cbiAgc3RhdGljIHNldHVwRmVhdHVyZUNoZWNrcygpIHtcbiAgICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdGVzdENhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIE9mZnNjcmVlbkNhbnZhcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRlc3RDYW52YXMgPSBuZXcgT2Zmc2NyZWVuQ2FudmFzKDAsIDApO1xuICAgIH1cbiAgICBpZiAoIXRlc3RDYW52YXMpIHJldHVybjtcbiAgICB0ZXN0Q29udGV4dCA9IHRlc3RDYW52YXMuZ2V0Q29udGV4dCgnd2ViZ2wnKSB8fCB0ZXN0Q2FudmFzLmdldENvbnRleHQoJ2V4cGVyaW1lbnRhbC13ZWJnbCcpO1xuICAgIGlmICghdGVzdENvbnRleHQgfHwgIXRlc3RDb250ZXh0LmdldEV4dGVuc2lvbikgcmV0dXJuO1xuICAgIHRlc3RFeHRlbnNpb25zID0ge1xuICAgICAgT0VTX3RleHR1cmVfZmxvYXQ6IHRlc3RDb250ZXh0LmdldEV4dGVuc2lvbignT0VTX3RleHR1cmVfZmxvYXQnKSxcbiAgICAgIE9FU190ZXh0dXJlX2Zsb2F0X2xpbmVhcjogdGVzdENvbnRleHQuZ2V0RXh0ZW5zaW9uKCdPRVNfdGV4dHVyZV9mbG9hdF9saW5lYXInKSxcbiAgICAgIE9FU19lbGVtZW50X2luZGV4X3VpbnQ6IHRlc3RDb250ZXh0LmdldEV4dGVuc2lvbignT0VTX2VsZW1lbnRfaW5kZXhfdWludCcpLFxuICAgICAgV0VCR0xfZHJhd19idWZmZXJzOiB0ZXN0Q29udGV4dC5nZXRFeHRlbnNpb24oJ1dFQkdMX2RyYXdfYnVmZmVycycpLFxuICAgIH07XG4gICAgZmVhdHVyZXMgPSB0aGlzLmdldEZlYXR1cmVzKCk7XG4gIH1cblxuICBzdGF0aWMgaXNDb250ZXh0TWF0Y2goY29udGV4dCkge1xuICAgIGlmICh0eXBlb2YgV2ViR0xSZW5kZXJpbmdDb250ZXh0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIGNvbnRleHQgaW5zdGFuY2VvZiBXZWJHTFJlbmRlcmluZ0NvbnRleHQ7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHN0YXRpYyBnZXRJc1RleHR1cmVGbG9hdCgpIHtcbiAgICByZXR1cm4gQm9vbGVhbih0ZXN0RXh0ZW5zaW9ucy5PRVNfdGV4dHVyZV9mbG9hdCk7XG4gIH1cblxuICBzdGF0aWMgZ2V0SXNEcmF3QnVmZmVycygpIHtcbiAgICByZXR1cm4gQm9vbGVhbih0ZXN0RXh0ZW5zaW9ucy5XRUJHTF9kcmF3X2J1ZmZlcnMpO1xuICB9XG5cbiAgc3RhdGljIGdldENoYW5uZWxDb3VudCgpIHtcbiAgICByZXR1cm4gdGVzdEV4dGVuc2lvbnMuV0VCR0xfZHJhd19idWZmZXJzID9cbiAgICAgIHRlc3RDb250ZXh0LmdldFBhcmFtZXRlcih0ZXN0RXh0ZW5zaW9ucy5XRUJHTF9kcmF3X2J1ZmZlcnMuTUFYX0RSQVdfQlVGRkVSU19XRUJHTCkgOlxuICAgICAgMTtcbiAgfVxuXG4gIHN0YXRpYyBnZXRNYXhUZXh0dXJlU2l6ZSgpIHtcbiAgICByZXR1cm4gdGVzdENvbnRleHQuZ2V0UGFyYW1ldGVyKHRlc3RDb250ZXh0Lk1BWF9URVhUVVJFX1NJWkUpO1xuICB9XG5cbiAgc3RhdGljIGxvb2t1cEtlcm5lbFZhbHVlVHlwZSh0eXBlLCBkeW5hbWljLCBwcmVjaXNpb24sIHZhbHVlKSB7XG4gICAgcmV0dXJuIGxvb2t1cEtlcm5lbFZhbHVlVHlwZSh0eXBlLCBkeW5hbWljLCBwcmVjaXNpb24sIHZhbHVlKTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgdGVzdENhbnZhcygpIHtcbiAgICByZXR1cm4gdGVzdENhbnZhcztcbiAgfVxuXG4gIHN0YXRpYyBnZXQgdGVzdENvbnRleHQoKSB7XG4gICAgcmV0dXJuIHRlc3RDb250ZXh0O1xuICB9XG5cbiAgc3RhdGljIGdldCBmZWF0dXJlcygpIHtcbiAgICByZXR1cm4gZmVhdHVyZXM7XG4gIH1cblxuICBzdGF0aWMgZ2V0IGZyYWdtZW50U2hhZGVyKCkge1xuICAgIHJldHVybiBmcmFnbWVudFNoYWRlcjtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgdmVydGV4U2hhZGVyKCkge1xuICAgIHJldHVybiB2ZXJ0ZXhTaGFkZXI7XG4gIH1cblxuICBjb25zdHJ1Y3Rvcihzb3VyY2UsIHNldHRpbmdzKSB7XG4gICAgc3VwZXIoc291cmNlLCBzZXR0aW5ncyk7XG4gICAgdGhpcy5wcm9ncmFtID0gbnVsbDtcbiAgICB0aGlzLnBpcGVsaW5lID0gc2V0dGluZ3MucGlwZWxpbmU7XG4gICAgdGhpcy5lbmRpYW5uZXNzID0gdXRpbHMuc3lzdGVtRW5kaWFubmVzcygpO1xuICAgIHRoaXMuZXh0ZW5zaW9ucyA9IHt9O1xuICAgIHRoaXMuYXJndW1lbnRUZXh0dXJlQ291bnQgPSAwO1xuICAgIHRoaXMuY29uc3RhbnRUZXh0dXJlQ291bnQgPSAwO1xuICAgIHRoaXMuZnJhZ1NoYWRlciA9IG51bGw7XG4gICAgdGhpcy52ZXJ0U2hhZGVyID0gbnVsbDtcbiAgICB0aGlzLmRyYXdCdWZmZXJzTWFwID0gbnVsbDtcblxuICAgIHRoaXMubWF4VGV4U2l6ZSA9IG51bGw7XG4gICAgdGhpcy5vblJlcXVlc3RTd2l0Y2hLZXJuZWwgPSBudWxsO1xuXG4gICAgdGhpcy50ZXh0dXJlID0gbnVsbDtcbiAgICB0aGlzLm1hcHBlZFRleHR1cmVzID0gbnVsbDtcbiAgICB0aGlzLm1lcmdlU2V0dGluZ3Moc291cmNlLnNldHRpbmdzIHx8IHNldHRpbmdzKTtcblxuICAgIHRoaXMudGhyZWFkRGltID0gbnVsbDtcbiAgICB0aGlzLmZyYW1lYnVmZmVyID0gbnVsbDtcbiAgICB0aGlzLmJ1ZmZlciA9IG51bGw7XG5cbiAgICB0aGlzLnRleHR1cmVDYWNoZSA9IFtdO1xuICAgIHRoaXMucHJvZ3JhbVVuaWZvcm1Mb2NhdGlvbkNhY2hlID0ge307XG4gICAgdGhpcy51bmlmb3JtMWZDYWNoZSA9IHt9O1xuICAgIHRoaXMudW5pZm9ybTFpQ2FjaGUgPSB7fTtcbiAgICB0aGlzLnVuaWZvcm0yZkNhY2hlID0ge307XG4gICAgdGhpcy51bmlmb3JtMmZ2Q2FjaGUgPSB7fTtcbiAgICB0aGlzLnVuaWZvcm0yaXZDYWNoZSA9IHt9O1xuICAgIHRoaXMudW5pZm9ybTNmdkNhY2hlID0ge307XG4gICAgdGhpcy51bmlmb3JtM2l2Q2FjaGUgPSB7fTtcbiAgICB0aGlzLnVuaWZvcm00ZnZDYWNoZSA9IHt9O1xuICAgIHRoaXMudW5pZm9ybTRpdkNhY2hlID0ge307XG4gIH1cblxuICBpbml0Q2FudmFzKCkge1xuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgIGNhbnZhcy53aWR0aCA9IDI7XG4gICAgICBjYW52YXMuaGVpZ2h0ID0gMjtcbiAgICAgIHJldHVybiBjYW52YXM7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgT2Zmc2NyZWVuQ2FudmFzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIG5ldyBPZmZzY3JlZW5DYW52YXMoMCwgMCk7XG4gICAgfVxuICB9XG5cbiAgaW5pdENvbnRleHQoKSB7XG4gICAgY29uc3Qgc2V0dGluZ3MgPSB7XG4gICAgICBhbHBoYTogZmFsc2UsXG4gICAgICBkZXB0aDogZmFsc2UsXG4gICAgICBhbnRpYWxpYXM6IGZhbHNlXG4gICAgfTtcbiAgICByZXR1cm4gdGhpcy5jYW52YXMuZ2V0Q29udGV4dCgnd2ViZ2wnLCBzZXR0aW5ncykgfHwgdGhpcy5jYW52YXMuZ2V0Q29udGV4dCgnZXhwZXJpbWVudGFsLXdlYmdsJywgc2V0dGluZ3MpO1xuICB9XG5cbiAgaW5pdFBsdWdpbnMoc2V0dGluZ3MpIHtcbiAgICBjb25zdCBwbHVnaW5zVG9Vc2UgPSBbXTtcbiAgICBjb25zdCB7IHNvdXJjZSB9ID0gdGhpcztcbiAgICBpZiAodHlwZW9mIHNvdXJjZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGx1Z2lucy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBwbHVnaW4gPSBwbHVnaW5zW2ldO1xuICAgICAgICBpZiAoc291cmNlLm1hdGNoKHBsdWdpbi5mdW5jdGlvbk1hdGNoKSkge1xuICAgICAgICAgIHBsdWdpbnNUb1VzZS5wdXNoKHBsdWdpbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBzb3VyY2UgPT09ICdvYmplY3QnKSB7XG4gICAgICBpZiAoc2V0dGluZ3MucGx1Z2luTmFtZXMpIHsgXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGx1Z2lucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IHBsdWdpbiA9IHBsdWdpbnNbaV07XG4gICAgICAgICAgY29uc3QgdXNlUGx1Z2luID0gc2V0dGluZ3MucGx1Z2luTmFtZXMuc29tZShwbHVnaW5OYW1lID0+IHBsdWdpbk5hbWUgPT09IHBsdWdpbi5uYW1lKTtcbiAgICAgICAgICBpZiAodXNlUGx1Z2luKSB7XG4gICAgICAgICAgICBwbHVnaW5zVG9Vc2UucHVzaChwbHVnaW4pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcGx1Z2luc1RvVXNlO1xuICB9XG5cbiAgaW5pdEV4dGVuc2lvbnMoKSB7XG4gICAgdGhpcy5leHRlbnNpb25zID0ge1xuICAgICAgT0VTX3RleHR1cmVfZmxvYXQ6IHRoaXMuY29udGV4dC5nZXRFeHRlbnNpb24oJ09FU190ZXh0dXJlX2Zsb2F0JyksXG4gICAgICBPRVNfdGV4dHVyZV9mbG9hdF9saW5lYXI6IHRoaXMuY29udGV4dC5nZXRFeHRlbnNpb24oJ09FU190ZXh0dXJlX2Zsb2F0X2xpbmVhcicpLFxuICAgICAgT0VTX2VsZW1lbnRfaW5kZXhfdWludDogdGhpcy5jb250ZXh0LmdldEV4dGVuc2lvbignT0VTX2VsZW1lbnRfaW5kZXhfdWludCcpLFxuICAgICAgV0VCR0xfZHJhd19idWZmZXJzOiB0aGlzLmNvbnRleHQuZ2V0RXh0ZW5zaW9uKCdXRUJHTF9kcmF3X2J1ZmZlcnMnKSxcbiAgICAgIFdFQkdMX2NvbG9yX2J1ZmZlcl9mbG9hdDogdGhpcy5jb250ZXh0LmdldEV4dGVuc2lvbignV0VCR0xfY29sb3JfYnVmZmVyX2Zsb2F0JyksXG4gICAgfTtcbiAgfVxuXG4gIHZhbGlkYXRlU2V0dGluZ3MoYXJncykge1xuICAgIGlmICghdGhpcy52YWxpZGF0ZSkge1xuICAgICAgdGhpcy50ZXhTaXplID0gdXRpbHMuZ2V0S2VybmVsVGV4dHVyZVNpemUoe1xuICAgICAgICBvcHRpbWl6ZUZsb2F0TWVtb3J5OiB0aGlzLm9wdGltaXplRmxvYXRNZW1vcnksXG4gICAgICAgIHByZWNpc2lvbjogdGhpcy5wcmVjaXNpb24sXG4gICAgICB9LCB0aGlzLm91dHB1dCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgeyBmZWF0dXJlcyB9ID0gdGhpcy5jb25zdHJ1Y3RvcjtcblxuICAgIGlmICh0aGlzLm9wdGltaXplRmxvYXRNZW1vcnkgPT09IHRydWUgJiYgIWZlYXR1cmVzLmlzVGV4dHVyZUZsb2F0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Zsb2F0IHRleHR1cmVzIGFyZSBub3Qgc3VwcG9ydGVkJyk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnByZWNpc2lvbiA9PT0gJ3NpbmdsZScgJiYgIWZlYXR1cmVzLmlzRmxvYXRSZWFkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NpbmdsZSBwcmVjaXNpb24gbm90IHN1cHBvcnRlZCcpO1xuICAgIH0gZWxzZSBpZiAoIXRoaXMuZ3JhcGhpY2FsICYmIHRoaXMucHJlY2lzaW9uID09PSBudWxsICYmIGZlYXR1cmVzLmlzVGV4dHVyZUZsb2F0KSB7XG4gICAgICB0aGlzLnByZWNpc2lvbiA9IGZlYXR1cmVzLmlzRmxvYXRSZWFkID8gJ3NpbmdsZScgOiAndW5zaWduZWQnO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnN1Yktlcm5lbHMgJiYgdGhpcy5zdWJLZXJuZWxzLmxlbmd0aCA+IDAgJiYgIXRoaXMuZXh0ZW5zaW9ucy5XRUJHTF9kcmF3X2J1ZmZlcnMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY291bGQgbm90IGluc3RhbnRpYXRlIGRyYXcgYnVmZmVycyBleHRlbnNpb24nKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5maXhJbnRlZ2VyRGl2aXNpb25BY2N1cmFjeSA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5maXhJbnRlZ2VyRGl2aXNpb25BY2N1cmFjeSA9ICFmZWF0dXJlcy5pc0ludGVnZXJEaXZpc2lvbkFjY3VyYXRlO1xuICAgIH0gZWxzZSBpZiAodGhpcy5maXhJbnRlZ2VyRGl2aXNpb25BY2N1cmFjeSAmJiBmZWF0dXJlcy5pc0ludGVnZXJEaXZpc2lvbkFjY3VyYXRlKSB7XG4gICAgICB0aGlzLmZpeEludGVnZXJEaXZpc2lvbkFjY3VyYWN5ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdGhpcy5jaGVja091dHB1dCgpO1xuXG4gICAgaWYgKCF0aGlzLm91dHB1dCB8fCB0aGlzLm91dHB1dC5sZW5ndGggPT09IDApIHtcbiAgICAgIGlmIChhcmdzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0F1dG8gb3V0cHV0IG9ubHkgc3VwcG9ydGVkIGZvciBrZXJuZWxzIHdpdGggb25seSBvbmUgaW5wdXQnKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgYXJnVHlwZSA9IHV0aWxzLmdldFZhcmlhYmxlVHlwZShhcmdzWzBdLCB0aGlzLnN0cmljdEludGVnZXJzKTtcbiAgICAgIHN3aXRjaCAoYXJnVHlwZSkge1xuICAgICAgICBjYXNlICdBcnJheSc6XG4gICAgICAgICAgdGhpcy5vdXRwdXQgPSB1dGlscy5nZXREaW1lbnNpb25zKGFyZ1R5cGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdOdW1iZXJUZXh0dXJlJzpcbiAgICAgICAgY2FzZSAnTWVtb3J5T3B0aW1pemVkTnVtYmVyVGV4dHVyZSc6XG4gICAgICAgIGNhc2UgJ0FycmF5VGV4dHVyZSgxKSc6XG4gICAgICAgIGNhc2UgJ0FycmF5VGV4dHVyZSgyKSc6XG4gICAgICAgIGNhc2UgJ0FycmF5VGV4dHVyZSgzKSc6XG4gICAgICAgIGNhc2UgJ0FycmF5VGV4dHVyZSg0KSc6XG4gICAgICAgICAgdGhpcy5vdXRwdXQgPSBhcmdzWzBdLm91dHB1dDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0F1dG8gb3V0cHV0IG5vdCBzdXBwb3J0ZWQgZm9yIGlucHV0IHR5cGU6ICcgKyBhcmdUeXBlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5ncmFwaGljYWwpIHtcbiAgICAgIGlmICh0aGlzLm91dHB1dC5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPdXRwdXQgbXVzdCBoYXZlIDIgZGltZW5zaW9ucyBvbiBncmFwaGljYWwgbW9kZScpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5wcmVjaXNpb24gPT09ICdwcmVjaXNpb24nKSB7XG4gICAgICAgIHRoaXMucHJlY2lzaW9uID0gJ3Vuc2lnbmVkJztcbiAgICAgICAgY29uc29sZS53YXJuKCdDYW5ub3QgdXNlIGdyYXBoaWNhbCBtb2RlIGFuZCBzaW5nbGUgcHJlY2lzaW9uIGF0IHRoZSBzYW1lIHRpbWUnKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy50ZXhTaXplID0gdXRpbHMuY2xvbmUodGhpcy5vdXRwdXQpO1xuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSBpZiAodGhpcy5wcmVjaXNpb24gPT09IG51bGwgJiYgZmVhdHVyZXMuaXNUZXh0dXJlRmxvYXQpIHtcbiAgICAgIHRoaXMucHJlY2lzaW9uID0gJ3NpbmdsZSc7XG4gICAgfVxuXG4gICAgdGhpcy50ZXhTaXplID0gdXRpbHMuZ2V0S2VybmVsVGV4dHVyZVNpemUoe1xuICAgICAgb3B0aW1pemVGbG9hdE1lbW9yeTogdGhpcy5vcHRpbWl6ZUZsb2F0TWVtb3J5LFxuICAgICAgcHJlY2lzaW9uOiB0aGlzLnByZWNpc2lvbixcbiAgICB9LCB0aGlzLm91dHB1dCk7XG5cbiAgICB0aGlzLmNoZWNrVGV4dHVyZVNpemUoKTtcbiAgfVxuXG4gIHVwZGF0ZU1heFRleFNpemUoKSB7XG4gICAgY29uc3QgeyB0ZXhTaXplLCBjYW52YXMgfSA9IHRoaXM7XG4gICAgaWYgKHRoaXMubWF4VGV4U2l6ZSA9PT0gbnVsbCkge1xuICAgICAgbGV0IGNhbnZhc0luZGV4ID0gY2FudmFzZXMuaW5kZXhPZihjYW52YXMpO1xuICAgICAgaWYgKGNhbnZhc0luZGV4ID09PSAtMSkge1xuICAgICAgICBjYW52YXNJbmRleCA9IGNhbnZhc2VzLmxlbmd0aDtcbiAgICAgICAgY2FudmFzZXMucHVzaChjYW52YXMpO1xuICAgICAgICBtYXhUZXhTaXplc1tjYW52YXNJbmRleF0gPSBbdGV4U2l6ZVswXSwgdGV4U2l6ZVsxXV07XG4gICAgICB9XG4gICAgICB0aGlzLm1heFRleFNpemUgPSBtYXhUZXhTaXplc1tjYW52YXNJbmRleF07XG4gICAgfVxuICAgIGlmICh0aGlzLm1heFRleFNpemVbMF0gPCB0ZXhTaXplWzBdKSB7XG4gICAgICB0aGlzLm1heFRleFNpemVbMF0gPSB0ZXhTaXplWzBdO1xuICAgIH1cbiAgICBpZiAodGhpcy5tYXhUZXhTaXplWzFdIDwgdGV4U2l6ZVsxXSkge1xuICAgICAgdGhpcy5tYXhUZXhTaXplWzFdID0gdGV4U2l6ZVsxXTtcbiAgICB9XG4gIH1cblxuICBzZXR1cEFyZ3VtZW50cyhhcmdzKSB7XG4gICAgdGhpcy5rZXJuZWxBcmd1bWVudHMgPSBbXTtcbiAgICB0aGlzLmFyZ3VtZW50VGV4dHVyZUNvdW50ID0gMDtcbiAgICBjb25zdCBuZWVkc0FyZ3VtZW50VHlwZXMgPSB0aGlzLmFyZ3VtZW50VHlwZXMgPT09IG51bGw7XG4gICAgaWYgKG5lZWRzQXJndW1lbnRUeXBlcykge1xuICAgICAgdGhpcy5hcmd1bWVudFR5cGVzID0gW107XG4gICAgfVxuICAgIHRoaXMuYXJndW1lbnRTaXplcyA9IFtdO1xuICAgIHRoaXMuYXJndW1lbnRCaXRSYXRpb3MgPSBbXTtcblxuICAgIGlmIChhcmdzLmxlbmd0aCA8IHRoaXMuYXJndW1lbnROYW1lcy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbm90IGVub3VnaCBhcmd1bWVudHMgZm9yIGtlcm5lbCcpO1xuICAgIH0gZWxzZSBpZiAoYXJncy5sZW5ndGggPiB0aGlzLmFyZ3VtZW50TmFtZXMubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RvbyBtYW55IGFyZ3VtZW50cyBmb3Iga2VybmVsJyk7XG4gICAgfVxuXG4gICAgY29uc3QgeyBjb250ZXh0OiBnbCB9ID0gdGhpcztcbiAgICBsZXQgdGV4dHVyZUluZGV4ZXMgPSAwO1xuXG4gICAgY29uc3Qgb25SZXF1ZXN0VGV4dHVyZSA9ICgpID0+IHtcbiAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVRleHR1cmUoKTtcbiAgICB9O1xuICAgIGNvbnN0IG9uUmVxdWVzdEluZGV4ID0gKCkgPT4ge1xuICAgICAgcmV0dXJuIHRoaXMuY29uc3RhbnRUZXh0dXJlQ291bnQgKyB0ZXh0dXJlSW5kZXhlcysrO1xuICAgIH07XG4gICAgY29uc3Qgb25VcGRhdGVWYWx1ZU1pc21hdGNoID0gKGNvbnN0cnVjdG9yKSA9PiB7XG4gICAgICB0aGlzLnN3aXRjaEtlcm5lbHMoe1xuICAgICAgICB0eXBlOiAnYXJndW1lbnRNaXNtYXRjaCcsXG4gICAgICAgIG5lZWRlZDogY29uc3RydWN0b3JcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3Qgb25SZXF1ZXN0Q29udGV4dEhhbmRsZSA9ICgpID0+IHtcbiAgICAgIHJldHVybiBnbC5URVhUVVJFMCArIHRoaXMuY29uc3RhbnRUZXh0dXJlQ291bnQgKyB0aGlzLmFyZ3VtZW50VGV4dHVyZUNvdW50Kys7XG4gICAgfTtcblxuICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBhcmdzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgY29uc3QgdmFsdWUgPSBhcmdzW2luZGV4XTtcbiAgICAgIGNvbnN0IG5hbWUgPSB0aGlzLmFyZ3VtZW50TmFtZXNbaW5kZXhdO1xuICAgICAgbGV0IHR5cGU7XG4gICAgICBpZiAobmVlZHNBcmd1bWVudFR5cGVzKSB7XG4gICAgICAgIHR5cGUgPSB1dGlscy5nZXRWYXJpYWJsZVR5cGUodmFsdWUsIHRoaXMuc3RyaWN0SW50ZWdlcnMpO1xuICAgICAgICB0aGlzLmFyZ3VtZW50VHlwZXMucHVzaCh0eXBlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHR5cGUgPSB0aGlzLmFyZ3VtZW50VHlwZXNbaW5kZXhdO1xuICAgICAgfVxuICAgICAgY29uc3QgS2VybmVsVmFsdWUgPSB0aGlzLmNvbnN0cnVjdG9yLmxvb2t1cEtlcm5lbFZhbHVlVHlwZSh0eXBlLCB0aGlzLmR5bmFtaWNBcmd1bWVudHMgPyAnZHluYW1pYycgOiAnc3RhdGljJywgdGhpcy5wcmVjaXNpb24sIGFyZ3NbaW5kZXhdKTtcbiAgICAgIGlmIChLZXJuZWxWYWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0RmFsbGJhY2soYXJncyk7XG4gICAgICB9XG4gICAgICBjb25zdCBrZXJuZWxBcmd1bWVudCA9IG5ldyBLZXJuZWxWYWx1ZSh2YWx1ZSwge1xuICAgICAgICBuYW1lLFxuICAgICAgICB0eXBlLFxuICAgICAgICB0YWN0aWM6IHRoaXMudGFjdGljLFxuICAgICAgICBvcmlnaW46ICd1c2VyJyxcbiAgICAgICAgY29udGV4dDogZ2wsXG4gICAgICAgIGNoZWNrQ29udGV4dDogdGhpcy5jaGVja0NvbnRleHQsXG4gICAgICAgIGtlcm5lbDogdGhpcyxcbiAgICAgICAgc3RyaWN0SW50ZWdlcnM6IHRoaXMuc3RyaWN0SW50ZWdlcnMsXG4gICAgICAgIG9uUmVxdWVzdFRleHR1cmUsXG4gICAgICAgIG9uUmVxdWVzdEluZGV4LFxuICAgICAgICBvblVwZGF0ZVZhbHVlTWlzbWF0Y2gsXG4gICAgICAgIG9uUmVxdWVzdENvbnRleHRIYW5kbGUsXG4gICAgICB9KTtcbiAgICAgIHRoaXMua2VybmVsQXJndW1lbnRzLnB1c2goa2VybmVsQXJndW1lbnQpO1xuICAgICAga2VybmVsQXJndW1lbnQuc2V0dXAoKTtcbiAgICAgIHRoaXMuYXJndW1lbnRTaXplcy5wdXNoKGtlcm5lbEFyZ3VtZW50LnRleHR1cmVTaXplKTtcbiAgICAgIHRoaXMuYXJndW1lbnRCaXRSYXRpb3NbaW5kZXhdID0ga2VybmVsQXJndW1lbnQuYml0UmF0aW87XG4gICAgfVxuICB9XG5cbiAgY3JlYXRlVGV4dHVyZSgpIHtcbiAgICBjb25zdCB0ZXh0dXJlID0gdGhpcy5jb250ZXh0LmNyZWF0ZVRleHR1cmUoKTtcbiAgICB0aGlzLnRleHR1cmVDYWNoZS5wdXNoKHRleHR1cmUpO1xuICAgIHJldHVybiB0ZXh0dXJlO1xuICB9XG5cbiAgc2V0dXBDb25zdGFudHMoYXJncykge1xuICAgIGNvbnN0IHsgY29udGV4dDogZ2wgfSA9IHRoaXM7XG4gICAgdGhpcy5rZXJuZWxDb25zdGFudHMgPSBbXTtcbiAgICB0aGlzLmZvcmNlVXBsb2FkS2VybmVsQ29uc3RhbnRzID0gW107XG4gICAgbGV0IG5lZWRzQ29uc3RhbnRUeXBlcyA9IHRoaXMuY29uc3RhbnRUeXBlcyA9PT0gbnVsbDtcbiAgICBpZiAobmVlZHNDb25zdGFudFR5cGVzKSB7XG4gICAgICB0aGlzLmNvbnN0YW50VHlwZXMgPSB7fTtcbiAgICB9XG4gICAgdGhpcy5jb25zdGFudEJpdFJhdGlvcyA9IHt9O1xuICAgIGxldCB0ZXh0dXJlSW5kZXhlcyA9IDA7XG4gICAgZm9yIChjb25zdCBuYW1lIGluIHRoaXMuY29uc3RhbnRzKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuY29uc3RhbnRzW25hbWVdO1xuICAgICAgbGV0IHR5cGU7XG4gICAgICBpZiAobmVlZHNDb25zdGFudFR5cGVzKSB7XG4gICAgICAgIHR5cGUgPSB1dGlscy5nZXRWYXJpYWJsZVR5cGUodmFsdWUsIHRoaXMuc3RyaWN0SW50ZWdlcnMpO1xuICAgICAgICB0aGlzLmNvbnN0YW50VHlwZXNbbmFtZV0gPSB0eXBlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHlwZSA9IHRoaXMuY29uc3RhbnRUeXBlc1tuYW1lXTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IEtlcm5lbFZhbHVlID0gdGhpcy5jb25zdHJ1Y3Rvci5sb29rdXBLZXJuZWxWYWx1ZVR5cGUodHlwZSwgJ3N0YXRpYycsIHRoaXMucHJlY2lzaW9uLCB2YWx1ZSk7XG4gICAgICBpZiAoS2VybmVsVmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdEZhbGxiYWNrKGFyZ3MpO1xuICAgICAgfVxuICAgICAgY29uc3Qga2VybmVsVmFsdWUgPSBuZXcgS2VybmVsVmFsdWUodmFsdWUsIHtcbiAgICAgICAgbmFtZSxcbiAgICAgICAgdHlwZSxcbiAgICAgICAgdGFjdGljOiB0aGlzLnRhY3RpYyxcbiAgICAgICAgb3JpZ2luOiAnY29uc3RhbnRzJyxcbiAgICAgICAgY29udGV4dDogdGhpcy5jb250ZXh0LFxuICAgICAgICBjaGVja0NvbnRleHQ6IHRoaXMuY2hlY2tDb250ZXh0LFxuICAgICAgICBrZXJuZWw6IHRoaXMsXG4gICAgICAgIHN0cmljdEludGVnZXJzOiB0aGlzLnN0cmljdEludGVnZXJzLFxuICAgICAgICBvblJlcXVlc3RUZXh0dXJlOiAoKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlVGV4dHVyZSgpO1xuICAgICAgICB9LFxuICAgICAgICBvblJlcXVlc3RJbmRleDogKCkgPT4ge1xuICAgICAgICAgIHJldHVybiB0ZXh0dXJlSW5kZXhlcysrO1xuICAgICAgICB9LFxuICAgICAgICBvblJlcXVlc3RDb250ZXh0SGFuZGxlOiAoKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIGdsLlRFWFRVUkUwICsgdGhpcy5jb25zdGFudFRleHR1cmVDb3VudCsrO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRoaXMuY29uc3RhbnRCaXRSYXRpb3NbbmFtZV0gPSBrZXJuZWxWYWx1ZS5iaXRSYXRpbztcbiAgICAgIHRoaXMua2VybmVsQ29uc3RhbnRzLnB1c2goa2VybmVsVmFsdWUpO1xuICAgICAga2VybmVsVmFsdWUuc2V0dXAoKTtcbiAgICAgIGlmIChrZXJuZWxWYWx1ZS5mb3JjZVVwbG9hZEVhY2hSdW4pIHtcbiAgICAgICAgdGhpcy5mb3JjZVVwbG9hZEtlcm5lbENvbnN0YW50cy5wdXNoKGtlcm5lbFZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBidWlsZCgpIHtcbiAgICBpZiAodGhpcy5idWlsdCkgcmV0dXJuO1xuICAgIHRoaXMuaW5pdEV4dGVuc2lvbnMoKTtcbiAgICB0aGlzLnZhbGlkYXRlU2V0dGluZ3MoYXJndW1lbnRzKTtcbiAgICB0aGlzLnNldHVwQ29uc3RhbnRzKGFyZ3VtZW50cyk7XG4gICAgaWYgKHRoaXMuZmFsbGJhY2tSZXF1ZXN0ZWQpIHJldHVybjtcbiAgICB0aGlzLnNldHVwQXJndW1lbnRzKGFyZ3VtZW50cyk7XG4gICAgaWYgKHRoaXMuZmFsbGJhY2tSZXF1ZXN0ZWQpIHJldHVybjtcbiAgICB0aGlzLnVwZGF0ZU1heFRleFNpemUoKTtcbiAgICB0aGlzLnRyYW5zbGF0ZVNvdXJjZSgpO1xuICAgIGNvbnN0IGZhaWx1cmVSZXN1bHQgPSB0aGlzLnBpY2tSZW5kZXJTdHJhdGVneShhcmd1bWVudHMpO1xuICAgIGlmIChmYWlsdXJlUmVzdWx0KSB7XG4gICAgICByZXR1cm4gZmFpbHVyZVJlc3VsdDtcbiAgICB9XG4gICAgY29uc3QgeyB0ZXhTaXplLCBjb250ZXh0OiBnbCwgY2FudmFzIH0gPSB0aGlzO1xuICAgIGdsLmVuYWJsZShnbC5TQ0lTU09SX1RFU1QpO1xuICAgIGlmICh0aGlzLnBpcGVsaW5lICYmIHRoaXMucHJlY2lzaW9uID09PSAnc2luZ2xlJykge1xuICAgICAgZ2wudmlld3BvcnQoMCwgMCwgdGhpcy5tYXhUZXhTaXplWzBdLCB0aGlzLm1heFRleFNpemVbMV0pO1xuICAgICAgY2FudmFzLndpZHRoID0gdGhpcy5tYXhUZXhTaXplWzBdO1xuICAgICAgY2FudmFzLmhlaWdodCA9IHRoaXMubWF4VGV4U2l6ZVsxXTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2wudmlld3BvcnQoMCwgMCwgdGhpcy5tYXhUZXhTaXplWzBdLCB0aGlzLm1heFRleFNpemVbMV0pO1xuICAgICAgY2FudmFzLndpZHRoID0gdGhpcy5tYXhUZXhTaXplWzBdO1xuICAgICAgY2FudmFzLmhlaWdodCA9IHRoaXMubWF4VGV4U2l6ZVsxXTtcbiAgICB9XG4gICAgY29uc3QgdGhyZWFkRGltID0gdGhpcy50aHJlYWREaW0gPSBBcnJheS5mcm9tKHRoaXMub3V0cHV0KTtcbiAgICB3aGlsZSAodGhyZWFkRGltLmxlbmd0aCA8IDMpIHtcbiAgICAgIHRocmVhZERpbS5wdXNoKDEpO1xuICAgIH1cblxuICAgIGNvbnN0IGNvbXBpbGVkVmVydGV4U2hhZGVyID0gdGhpcy5nZXRWZXJ0ZXhTaGFkZXIoYXJndW1lbnRzKTtcbiAgICBjb25zdCB2ZXJ0U2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKGdsLlZFUlRFWF9TSEFERVIpO1xuICAgIGdsLnNoYWRlclNvdXJjZSh2ZXJ0U2hhZGVyLCBjb21waWxlZFZlcnRleFNoYWRlcik7XG4gICAgZ2wuY29tcGlsZVNoYWRlcih2ZXJ0U2hhZGVyKTtcbiAgICB0aGlzLnZlcnRTaGFkZXIgPSB2ZXJ0U2hhZGVyO1xuXG4gICAgY29uc3QgY29tcGlsZWRGcmFnbWVudFNoYWRlciA9IHRoaXMuZ2V0RnJhZ21lbnRTaGFkZXIoYXJndW1lbnRzKTtcbiAgICBjb25zdCBmcmFnU2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKGdsLkZSQUdNRU5UX1NIQURFUik7XG4gICAgZ2wuc2hhZGVyU291cmNlKGZyYWdTaGFkZXIsIGNvbXBpbGVkRnJhZ21lbnRTaGFkZXIpO1xuICAgIGdsLmNvbXBpbGVTaGFkZXIoZnJhZ1NoYWRlcik7XG4gICAgdGhpcy5mcmFnU2hhZGVyID0gZnJhZ1NoYWRlcjtcblxuICAgIGlmICh0aGlzLmRlYnVnKSB7XG4gICAgICBjb25zb2xlLmxvZygnR0xTTCBTaGFkZXIgT3V0cHV0OicpO1xuICAgICAgY29uc29sZS5sb2coY29tcGlsZWRGcmFnbWVudFNoYWRlcik7XG4gICAgfVxuXG4gICAgaWYgKCFnbC5nZXRTaGFkZXJQYXJhbWV0ZXIodmVydFNoYWRlciwgZ2wuQ09NUElMRV9TVEFUVVMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Vycm9yIGNvbXBpbGluZyB2ZXJ0ZXggc2hhZGVyOiAnICsgZ2wuZ2V0U2hhZGVySW5mb0xvZyh2ZXJ0U2hhZGVyKSk7XG4gICAgfVxuICAgIGlmICghZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKGZyYWdTaGFkZXIsIGdsLkNPTVBJTEVfU1RBVFVTKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFcnJvciBjb21waWxpbmcgZnJhZ21lbnQgc2hhZGVyOiAnICsgZ2wuZ2V0U2hhZGVySW5mb0xvZyhmcmFnU2hhZGVyKSk7XG4gICAgfVxuXG4gICAgY29uc3QgcHJvZ3JhbSA9IHRoaXMucHJvZ3JhbSA9IGdsLmNyZWF0ZVByb2dyYW0oKTtcbiAgICBnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgdmVydFNoYWRlcik7XG4gICAgZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIGZyYWdTaGFkZXIpO1xuICAgIGdsLmxpbmtQcm9ncmFtKHByb2dyYW0pO1xuICAgIHRoaXMuZnJhbWVidWZmZXIgPSBnbC5jcmVhdGVGcmFtZWJ1ZmZlcigpO1xuICAgIHRoaXMuZnJhbWVidWZmZXIud2lkdGggPSB0ZXhTaXplWzBdO1xuICAgIHRoaXMuZnJhbWVidWZmZXIuaGVpZ2h0ID0gdGV4U2l6ZVsxXTtcbiAgICB0aGlzLnJhd1ZhbHVlRnJhbWVidWZmZXJzID0ge307XG5cbiAgICBjb25zdCB2ZXJ0aWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkoWy0xLCAtMSxcbiAgICAgIDEsIC0xLCAtMSwgMSxcbiAgICAgIDEsIDFcbiAgICBdKTtcbiAgICBjb25zdCB0ZXhDb29yZHMgPSBuZXcgRmxvYXQzMkFycmF5KFtcbiAgICAgIDAsIDAsXG4gICAgICAxLCAwLFxuICAgICAgMCwgMSxcbiAgICAgIDEsIDFcbiAgICBdKTtcblxuICAgIGNvbnN0IHRleENvb3JkT2Zmc2V0ID0gdmVydGljZXMuYnl0ZUxlbmd0aDtcblxuICAgIGxldCBidWZmZXIgPSB0aGlzLmJ1ZmZlcjtcbiAgICBpZiAoIWJ1ZmZlcikge1xuICAgICAgYnVmZmVyID0gdGhpcy5idWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcbiAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXIpO1xuICAgICAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIHZlcnRpY2VzLmJ5dGVMZW5ndGggKyB0ZXhDb29yZHMuYnl0ZUxlbmd0aCwgZ2wuU1RBVElDX0RSQVcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgYnVmZmVyKTtcbiAgICB9XG5cbiAgICBnbC5idWZmZXJTdWJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgMCwgdmVydGljZXMpO1xuICAgIGdsLmJ1ZmZlclN1YkRhdGEoZ2wuQVJSQVlfQlVGRkVSLCB0ZXhDb29yZE9mZnNldCwgdGV4Q29vcmRzKTtcblxuICAgIGNvbnN0IGFQb3NMb2MgPSBnbC5nZXRBdHRyaWJMb2NhdGlvbih0aGlzLnByb2dyYW0sICdhUG9zJyk7XG4gICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoYVBvc0xvYyk7XG4gICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihhUG9zTG9jLCAyLCBnbC5GTE9BVCwgZmFsc2UsIDAsIDApO1xuICAgIGNvbnN0IGFUZXhDb29yZExvYyA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHRoaXMucHJvZ3JhbSwgJ2FUZXhDb29yZCcpO1xuICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGFUZXhDb29yZExvYyk7XG4gICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihhVGV4Q29vcmRMb2MsIDIsIGdsLkZMT0FULCBmYWxzZSwgMCwgdGV4Q29vcmRPZmZzZXQpO1xuICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgdGhpcy5mcmFtZWJ1ZmZlcik7XG5cbiAgICBsZXQgaSA9IDA7XG4gICAgZ2wudXNlUHJvZ3JhbSh0aGlzLnByb2dyYW0pO1xuICAgIGZvciAobGV0IHAgaW4gdGhpcy5jb25zdGFudHMpIHtcbiAgICAgIHRoaXMua2VybmVsQ29uc3RhbnRzW2krK10udXBkYXRlVmFsdWUodGhpcy5jb25zdGFudHNbcF0pO1xuICAgIH1cblxuICAgIHRoaXMuX3NldHVwT3V0cHV0VGV4dHVyZSgpO1xuICAgIGlmIChcbiAgICAgIHRoaXMuc3ViS2VybmVscyAhPT0gbnVsbCAmJlxuICAgICAgdGhpcy5zdWJLZXJuZWxzLmxlbmd0aCA+IDBcbiAgICApIHtcbiAgICAgIHRoaXMuX21hcHBlZFRleHR1cmVTd2l0Y2hlZCA9IHt9O1xuICAgICAgdGhpcy5fc2V0dXBTdWJPdXRwdXRUZXh0dXJlcygpO1xuICAgIH1cbiAgICB0aGlzLmJ1aWxkU2lnbmF0dXJlKGFyZ3VtZW50cyk7XG4gICAgdGhpcy5idWlsdCA9IHRydWU7XG4gIH1cblxuICB0cmFuc2xhdGVTb3VyY2UoKSB7XG4gICAgY29uc3QgZnVuY3Rpb25CdWlsZGVyID0gRnVuY3Rpb25CdWlsZGVyLmZyb21LZXJuZWwodGhpcywgV2ViR0xGdW5jdGlvbk5vZGUsIHtcbiAgICAgIGZpeEludGVnZXJEaXZpc2lvbkFjY3VyYWN5OiB0aGlzLmZpeEludGVnZXJEaXZpc2lvbkFjY3VyYWN5XG4gICAgfSk7XG4gICAgdGhpcy50cmFuc2xhdGVkU291cmNlID0gZnVuY3Rpb25CdWlsZGVyLmdldFByb3RvdHlwZVN0cmluZygna2VybmVsJyk7XG4gICAgdGhpcy5zZXR1cFJldHVyblR5cGVzKGZ1bmN0aW9uQnVpbGRlcik7XG4gIH1cblxuICBzZXR1cFJldHVyblR5cGVzKGZ1bmN0aW9uQnVpbGRlcikge1xuICAgIGlmICghdGhpcy5ncmFwaGljYWwgJiYgIXRoaXMucmV0dXJuVHlwZSkge1xuICAgICAgdGhpcy5yZXR1cm5UeXBlID0gZnVuY3Rpb25CdWlsZGVyLmdldEtlcm5lbFJlc3VsdFR5cGUoKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5zdWJLZXJuZWxzICYmIHRoaXMuc3ViS2VybmVscy5sZW5ndGggPiAwKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc3ViS2VybmVscy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBzdWJLZXJuZWwgPSB0aGlzLnN1Yktlcm5lbHNbaV07XG4gICAgICAgIGlmICghc3ViS2VybmVsLnJldHVyblR5cGUpIHtcbiAgICAgICAgICBzdWJLZXJuZWwucmV0dXJuVHlwZSA9IGZ1bmN0aW9uQnVpbGRlci5nZXRTdWJLZXJuZWxSZXN1bHRUeXBlKGkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcnVuKCkge1xuICAgIGNvbnN0IHsga2VybmVsQXJndW1lbnRzLCB0ZXhTaXplLCBmb3JjZVVwbG9hZEtlcm5lbENvbnN0YW50cywgY29udGV4dDogZ2wgfSA9IHRoaXM7XG5cbiAgICBnbC51c2VQcm9ncmFtKHRoaXMucHJvZ3JhbSk7XG4gICAgZ2wuc2Npc3NvcigwLCAwLCB0ZXhTaXplWzBdLCB0ZXhTaXplWzFdKTtcbiAgICBpZiAodGhpcy5keW5hbWljT3V0cHV0KSB7XG4gICAgICB0aGlzLnNldFVuaWZvcm0zaXYoJ3VPdXRwdXREaW0nLCBuZXcgSW50MzJBcnJheSh0aGlzLnRocmVhZERpbSkpO1xuICAgICAgdGhpcy5zZXRVbmlmb3JtMml2KCd1VGV4U2l6ZScsIHRleFNpemUpO1xuICAgIH1cblxuICAgIHRoaXMuc2V0VW5pZm9ybTJmKCdyYXRpbycsIHRleFNpemVbMF0gLyB0aGlzLm1heFRleFNpemVbMF0sIHRleFNpemVbMV0gLyB0aGlzLm1heFRleFNpemVbMV0pO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmb3JjZVVwbG9hZEtlcm5lbENvbnN0YW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgY29uc3RhbnQgPSBmb3JjZVVwbG9hZEtlcm5lbENvbnN0YW50c1tpXTtcbiAgICAgIGNvbnN0YW50LnVwZGF0ZVZhbHVlKHRoaXMuY29uc3RhbnRzW2NvbnN0YW50Lm5hbWVdKTtcbiAgICAgIGlmICh0aGlzLnN3aXRjaGluZ0tlcm5lbHMpIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXJuZWxBcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGtlcm5lbEFyZ3VtZW50c1tpXS51cGRhdGVWYWx1ZShhcmd1bWVudHNbaV0pO1xuICAgICAgaWYgKHRoaXMuc3dpdGNoaW5nS2VybmVscykgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnBsdWdpbnMpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5wbHVnaW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHBsdWdpbiA9IHRoaXMucGx1Z2luc1tpXTtcbiAgICAgICAgaWYgKHBsdWdpbi5vbkJlZm9yZVJ1bikge1xuICAgICAgICAgIHBsdWdpbi5vbkJlZm9yZVJ1bih0aGlzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLmdyYXBoaWNhbCkge1xuICAgICAgaWYgKHRoaXMucGlwZWxpbmUpIHtcbiAgICAgICAgZ2wuYmluZFJlbmRlcmJ1ZmZlcihnbC5SRU5ERVJCVUZGRVIsIG51bGwpO1xuICAgICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIHRoaXMuZnJhbWVidWZmZXIpO1xuICAgICAgICBpZiAodGhpcy5pbW11dGFibGUpIHtcbiAgICAgICAgICB0aGlzLl9yZXBsYWNlT3V0cHV0VGV4dHVyZSgpO1xuICAgICAgICB9XG4gICAgICAgIGdsLmRyYXdBcnJheXMoZ2wuVFJJQU5HTEVfU1RSSVAsIDAsIDQpO1xuICAgICAgICByZXR1cm4gdGhpcy5pbW11dGFibGUgPyB0aGlzLnRleHR1cmUuY2xvbmUoKSA6IHRoaXMudGV4dHVyZTtcbiAgICAgIH1cbiAgICAgIGdsLmJpbmRSZW5kZXJidWZmZXIoZ2wuUkVOREVSQlVGRkVSLCBudWxsKTtcbiAgICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgbnVsbCk7XG4gICAgICBnbC5kcmF3QXJyYXlzKGdsLlRSSUFOR0xFX1NUUklQLCAwLCA0KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIHRoaXMuZnJhbWVidWZmZXIpO1xuICAgIGlmICh0aGlzLmltbXV0YWJsZSkge1xuICAgICAgdGhpcy5fcmVwbGFjZU91dHB1dFRleHR1cmUoKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5zdWJLZXJuZWxzICE9PSBudWxsKSB7XG4gICAgICBpZiAodGhpcy5pbW11dGFibGUpIHtcbiAgICAgICAgdGhpcy5fcmVwbGFjZVN1Yk91dHB1dFRleHR1cmVzKCk7XG4gICAgICB9XG4gICAgICB0aGlzLmRyYXdCdWZmZXJzKCk7XG4gICAgfVxuXG4gICAgZ2wuZHJhd0FycmF5cyhnbC5UUklBTkdMRV9TVFJJUCwgMCwgNCk7XG4gIH1cblxuICBkcmF3QnVmZmVycygpIHtcbiAgICB0aGlzLmV4dGVuc2lvbnMuV0VCR0xfZHJhd19idWZmZXJzLmRyYXdCdWZmZXJzV0VCR0wodGhpcy5kcmF3QnVmZmVyc01hcCk7XG4gIH1cblxuICBnZXRJbnRlcm5hbEZvcm1hdCgpIHtcbiAgICByZXR1cm4gdGhpcy5jb250ZXh0LlJHQkE7XG4gIH1cbiAgZ2V0VGV4dHVyZUZvcm1hdCgpIHtcbiAgICBjb25zdCB7IGNvbnRleHQ6IGdsIH0gPSB0aGlzO1xuICAgIHN3aXRjaCAodGhpcy5nZXRJbnRlcm5hbEZvcm1hdCgpKSB7XG4gICAgICBjYXNlIGdsLlJHQkE6XG4gICAgICAgIHJldHVybiBnbC5SR0JBO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGludGVybmFsIGZvcm1hdCcpO1xuICAgIH1cbiAgfVxuXG4gIF9yZXBsYWNlT3V0cHV0VGV4dHVyZSgpIHtcbiAgICBpZiAodGhpcy50ZXh0dXJlLmJlZm9yZU11dGF0ZSgpIHx8IHRoaXMuX3RleHR1cmVTd2l0Y2hlZCkge1xuICAgICAgY29uc3QgZ2wgPSB0aGlzLmNvbnRleHQ7XG4gICAgICBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChnbC5GUkFNRUJVRkZFUiwgZ2wuQ09MT1JfQVRUQUNITUVOVDAsIGdsLlRFWFRVUkVfMkQsIHRoaXMudGV4dHVyZS50ZXh0dXJlLCAwKTtcbiAgICAgIHRoaXMuX3RleHR1cmVTd2l0Y2hlZCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIF9zZXR1cE91dHB1dFRleHR1cmUoKSB7XG4gICAgY29uc3QgZ2wgPSB0aGlzLmNvbnRleHQ7XG4gICAgY29uc3QgdGV4U2l6ZSA9IHRoaXMudGV4U2l6ZTtcbiAgICBpZiAodGhpcy50ZXh0dXJlKSB7XG4gICAgICBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChnbC5GUkFNRUJVRkZFUiwgZ2wuQ09MT1JfQVRUQUNITUVOVDAsIGdsLlRFWFRVUkVfMkQsIHRoaXMudGV4dHVyZS50ZXh0dXJlLCAwKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdGV4dHVyZSA9IHRoaXMuY3JlYXRlVGV4dHVyZSgpO1xuICAgIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTAgKyB0aGlzLmNvbnN0YW50VGV4dHVyZUNvdW50ICsgdGhpcy5hcmd1bWVudFRleHR1cmVDb3VudCk7XG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSk7XG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLk5FQVJFU1QpO1xuICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5ORUFSRVNUKTtcbiAgICBjb25zdCBmb3JtYXQgPSB0aGlzLmdldEludGVybmFsRm9ybWF0KCk7XG4gICAgaWYgKHRoaXMucHJlY2lzaW9uID09PSAnc2luZ2xlJykge1xuICAgICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBmb3JtYXQsIHRleFNpemVbMF0sIHRleFNpemVbMV0sIDAsIGdsLlJHQkEsIGdsLkZMT0FULCBudWxsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBmb3JtYXQsIHRleFNpemVbMF0sIHRleFNpemVbMV0sIDAsIGZvcm1hdCwgZ2wuVU5TSUdORURfQllURSwgbnVsbCk7XG4gICAgfVxuICAgIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGdsLkZSQU1FQlVGRkVSLCBnbC5DT0xPUl9BVFRBQ0hNRU5UMCwgZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSwgMCk7XG4gICAgdGhpcy50ZXh0dXJlID0gbmV3IHRoaXMuVGV4dHVyZUNvbnN0cnVjdG9yKHtcbiAgICAgIHRleHR1cmUsXG4gICAgICBzaXplOiB0ZXhTaXplLFxuICAgICAgZGltZW5zaW9uczogdGhpcy50aHJlYWREaW0sXG4gICAgICBvdXRwdXQ6IHRoaXMub3V0cHV0LFxuICAgICAgY29udGV4dDogdGhpcy5jb250ZXh0LFxuICAgICAgaW50ZXJuYWxGb3JtYXQ6IHRoaXMuZ2V0SW50ZXJuYWxGb3JtYXQoKSxcbiAgICAgIHRleHR1cmVGb3JtYXQ6IHRoaXMuZ2V0VGV4dHVyZUZvcm1hdCgpLFxuICAgICAga2VybmVsOiB0aGlzLFxuICAgIH0pO1xuICB9XG5cbiAgX3JlcGxhY2VTdWJPdXRwdXRUZXh0dXJlcygpIHtcbiAgICBjb25zdCBnbCA9IHRoaXMuY29udGV4dDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubWFwcGVkVGV4dHVyZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IG1hcHBlZFRleHR1cmUgPSB0aGlzLm1hcHBlZFRleHR1cmVzW2ldO1xuICAgICAgaWYgKG1hcHBlZFRleHR1cmUuYmVmb3JlTXV0YXRlKCkgfHwgdGhpcy5fbWFwcGVkVGV4dHVyZVN3aXRjaGVkW2ldKSB7XG4gICAgICAgIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGdsLkZSQU1FQlVGRkVSLCBnbC5DT0xPUl9BVFRBQ0hNRU5UMCArIGkgKyAxLCBnbC5URVhUVVJFXzJELCBtYXBwZWRUZXh0dXJlLnRleHR1cmUsIDApO1xuICAgICAgICB0aGlzLl9tYXBwZWRUZXh0dXJlU3dpdGNoZWRbaV0gPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBfc2V0dXBTdWJPdXRwdXRUZXh0dXJlcygpIHtcbiAgICBjb25zdCBnbCA9IHRoaXMuY29udGV4dDtcbiAgICBpZiAodGhpcy5tYXBwZWRUZXh0dXJlcykge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnN1Yktlcm5lbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoZ2wuRlJBTUVCVUZGRVIsIGdsLkNPTE9SX0FUVEFDSE1FTlQwICsgaSArIDEsIGdsLlRFWFRVUkVfMkQsIHRoaXMubWFwcGVkVGV4dHVyZXNbaV0udGV4dHVyZSwgMCk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHRleFNpemUgPSB0aGlzLnRleFNpemU7XG4gICAgdGhpcy5kcmF3QnVmZmVyc01hcCA9IFtnbC5DT0xPUl9BVFRBQ0hNRU5UMF07XG4gICAgdGhpcy5tYXBwZWRUZXh0dXJlcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zdWJLZXJuZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCB0ZXh0dXJlID0gdGhpcy5jcmVhdGVUZXh0dXJlKCk7XG4gICAgICB0aGlzLmRyYXdCdWZmZXJzTWFwLnB1c2goZ2wuQ09MT1JfQVRUQUNITUVOVDAgKyBpICsgMSk7XG4gICAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwICsgdGhpcy5jb25zdGFudFRleHR1cmVDb3VudCArIHRoaXMuYXJndW1lbnRUZXh0dXJlQ291bnQgKyBpKTtcbiAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmUpO1xuICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFKTtcbiAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5ORUFSRVNUKTtcbiAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5ORUFSRVNUKTtcbiAgICAgIGlmICh0aGlzLnByZWNpc2lvbiA9PT0gJ3NpbmdsZScpIHtcbiAgICAgICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCB0ZXhTaXplWzBdLCB0ZXhTaXplWzFdLCAwLCBnbC5SR0JBLCBnbC5GTE9BVCwgbnVsbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIHRleFNpemVbMF0sIHRleFNpemVbMV0sIDAsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIG51bGwpO1xuICAgICAgfVxuICAgICAgZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoZ2wuRlJBTUVCVUZGRVIsIGdsLkNPTE9SX0FUVEFDSE1FTlQwICsgaSArIDEsIGdsLlRFWFRVUkVfMkQsIHRleHR1cmUsIDApO1xuXG4gICAgICB0aGlzLm1hcHBlZFRleHR1cmVzLnB1c2gobmV3IHRoaXMuVGV4dHVyZUNvbnN0cnVjdG9yKHtcbiAgICAgICAgdGV4dHVyZSxcbiAgICAgICAgc2l6ZTogdGV4U2l6ZSxcbiAgICAgICAgZGltZW5zaW9uczogdGhpcy50aHJlYWREaW0sXG4gICAgICAgIG91dHB1dDogdGhpcy5vdXRwdXQsXG4gICAgICAgIGNvbnRleHQ6IHRoaXMuY29udGV4dCxcbiAgICAgICAgaW50ZXJuYWxGb3JtYXQ6IHRoaXMuZ2V0SW50ZXJuYWxGb3JtYXQoKSxcbiAgICAgICAgdGV4dHVyZUZvcm1hdDogdGhpcy5nZXRUZXh0dXJlRm9ybWF0KCksXG4gICAgICAgIGtlcm5lbDogdGhpcyxcbiAgICAgIH0pKTtcbiAgICB9XG4gIH1cblxuICBzZXRVbmlmb3JtMWYobmFtZSwgdmFsdWUpIHtcbiAgICBpZiAodGhpcy51bmlmb3JtMWZDYWNoZS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgY29uc3QgY2FjaGUgPSB0aGlzLnVuaWZvcm0xZkNhY2hlW25hbWVdO1xuICAgICAgaWYgKHZhbHVlID09PSBjYWNoZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMudW5pZm9ybTFmQ2FjaGVbbmFtZV0gPSB2YWx1ZTtcbiAgICBjb25zdCBsb2MgPSB0aGlzLmdldFVuaWZvcm1Mb2NhdGlvbihuYW1lKTtcbiAgICB0aGlzLmNvbnRleHQudW5pZm9ybTFmKGxvYywgdmFsdWUpO1xuICB9XG5cbiAgc2V0VW5pZm9ybTFpKG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKHRoaXMudW5pZm9ybTFpQ2FjaGUuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgIGNvbnN0IGNhY2hlID0gdGhpcy51bmlmb3JtMWlDYWNoZVtuYW1lXTtcbiAgICAgIGlmICh2YWx1ZSA9PT0gY2FjaGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnVuaWZvcm0xaUNhY2hlW25hbWVdID0gdmFsdWU7XG4gICAgY29uc3QgbG9jID0gdGhpcy5nZXRVbmlmb3JtTG9jYXRpb24obmFtZSk7XG4gICAgdGhpcy5jb250ZXh0LnVuaWZvcm0xaShsb2MsIHZhbHVlKTtcbiAgfVxuXG4gIHNldFVuaWZvcm0yZihuYW1lLCB2YWx1ZTEsIHZhbHVlMikge1xuICAgIGlmICh0aGlzLnVuaWZvcm0yZkNhY2hlLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICBjb25zdCBjYWNoZSA9IHRoaXMudW5pZm9ybTJmQ2FjaGVbbmFtZV07XG4gICAgICBpZiAoXG4gICAgICAgIHZhbHVlMSA9PT0gY2FjaGVbMF0gJiZcbiAgICAgICAgdmFsdWUyID09PSBjYWNoZVsxXVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy51bmlmb3JtMmZDYWNoZVtuYW1lXSA9IFt2YWx1ZTEsIHZhbHVlMl07XG4gICAgY29uc3QgbG9jID0gdGhpcy5nZXRVbmlmb3JtTG9jYXRpb24obmFtZSk7XG4gICAgdGhpcy5jb250ZXh0LnVuaWZvcm0yZihsb2MsIHZhbHVlMSwgdmFsdWUyKTtcbiAgfVxuXG4gIHNldFVuaWZvcm0yZnYobmFtZSwgdmFsdWUpIHtcbiAgICBpZiAodGhpcy51bmlmb3JtMmZ2Q2FjaGUuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgIGNvbnN0IGNhY2hlID0gdGhpcy51bmlmb3JtMmZ2Q2FjaGVbbmFtZV07XG4gICAgICBpZiAoXG4gICAgICAgIHZhbHVlWzBdID09PSBjYWNoZVswXSAmJlxuICAgICAgICB2YWx1ZVsxXSA9PT0gY2FjaGVbMV1cbiAgICAgICkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMudW5pZm9ybTJmdkNhY2hlW25hbWVdID0gdmFsdWU7XG4gICAgY29uc3QgbG9jID0gdGhpcy5nZXRVbmlmb3JtTG9jYXRpb24obmFtZSk7XG4gICAgdGhpcy5jb250ZXh0LnVuaWZvcm0yZnYobG9jLCB2YWx1ZSk7XG4gIH1cblxuICBzZXRVbmlmb3JtMml2KG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKHRoaXMudW5pZm9ybTJpdkNhY2hlLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICBjb25zdCBjYWNoZSA9IHRoaXMudW5pZm9ybTJpdkNhY2hlW25hbWVdO1xuICAgICAgaWYgKFxuICAgICAgICB2YWx1ZVswXSA9PT0gY2FjaGVbMF0gJiZcbiAgICAgICAgdmFsdWVbMV0gPT09IGNhY2hlWzFdXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnVuaWZvcm0yaXZDYWNoZVtuYW1lXSA9IHZhbHVlO1xuICAgIGNvbnN0IGxvYyA9IHRoaXMuZ2V0VW5pZm9ybUxvY2F0aW9uKG5hbWUpO1xuICAgIHRoaXMuY29udGV4dC51bmlmb3JtMml2KGxvYywgdmFsdWUpO1xuICB9XG5cbiAgc2V0VW5pZm9ybTNmdihuYW1lLCB2YWx1ZSkge1xuICAgIGlmICh0aGlzLnVuaWZvcm0zZnZDYWNoZS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgY29uc3QgY2FjaGUgPSB0aGlzLnVuaWZvcm0zZnZDYWNoZVtuYW1lXTtcbiAgICAgIGlmIChcbiAgICAgICAgdmFsdWVbMF0gPT09IGNhY2hlWzBdICYmXG4gICAgICAgIHZhbHVlWzFdID09PSBjYWNoZVsxXSAmJlxuICAgICAgICB2YWx1ZVsyXSA9PT0gY2FjaGVbMl1cbiAgICAgICkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMudW5pZm9ybTNmdkNhY2hlW25hbWVdID0gdmFsdWU7XG4gICAgY29uc3QgbG9jID0gdGhpcy5nZXRVbmlmb3JtTG9jYXRpb24obmFtZSk7XG4gICAgdGhpcy5jb250ZXh0LnVuaWZvcm0zZnYobG9jLCB2YWx1ZSk7XG4gIH1cblxuICBzZXRVbmlmb3JtM2l2KG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKHRoaXMudW5pZm9ybTNpdkNhY2hlLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICBjb25zdCBjYWNoZSA9IHRoaXMudW5pZm9ybTNpdkNhY2hlW25hbWVdO1xuICAgICAgaWYgKFxuICAgICAgICB2YWx1ZVswXSA9PT0gY2FjaGVbMF0gJiZcbiAgICAgICAgdmFsdWVbMV0gPT09IGNhY2hlWzFdICYmXG4gICAgICAgIHZhbHVlWzJdID09PSBjYWNoZVsyXVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy51bmlmb3JtM2l2Q2FjaGVbbmFtZV0gPSB2YWx1ZTtcbiAgICBjb25zdCBsb2MgPSB0aGlzLmdldFVuaWZvcm1Mb2NhdGlvbihuYW1lKTtcbiAgICB0aGlzLmNvbnRleHQudW5pZm9ybTNpdihsb2MsIHZhbHVlKTtcbiAgfVxuXG4gIHNldFVuaWZvcm00ZnYobmFtZSwgdmFsdWUpIHtcbiAgICBpZiAodGhpcy51bmlmb3JtNGZ2Q2FjaGUuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgIGNvbnN0IGNhY2hlID0gdGhpcy51bmlmb3JtNGZ2Q2FjaGVbbmFtZV07XG4gICAgICBpZiAoXG4gICAgICAgIHZhbHVlWzBdID09PSBjYWNoZVswXSAmJlxuICAgICAgICB2YWx1ZVsxXSA9PT0gY2FjaGVbMV0gJiZcbiAgICAgICAgdmFsdWVbMl0gPT09IGNhY2hlWzJdICYmXG4gICAgICAgIHZhbHVlWzNdID09PSBjYWNoZVszXVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy51bmlmb3JtNGZ2Q2FjaGVbbmFtZV0gPSB2YWx1ZTtcbiAgICBjb25zdCBsb2MgPSB0aGlzLmdldFVuaWZvcm1Mb2NhdGlvbihuYW1lKTtcbiAgICB0aGlzLmNvbnRleHQudW5pZm9ybTRmdihsb2MsIHZhbHVlKTtcbiAgfVxuXG4gIHNldFVuaWZvcm00aXYobmFtZSwgdmFsdWUpIHtcbiAgICBpZiAodGhpcy51bmlmb3JtNGl2Q2FjaGUuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgIGNvbnN0IGNhY2hlID0gdGhpcy51bmlmb3JtNGl2Q2FjaGVbbmFtZV07XG4gICAgICBpZiAoXG4gICAgICAgIHZhbHVlWzBdID09PSBjYWNoZVswXSAmJlxuICAgICAgICB2YWx1ZVsxXSA9PT0gY2FjaGVbMV0gJiZcbiAgICAgICAgdmFsdWVbMl0gPT09IGNhY2hlWzJdICYmXG4gICAgICAgIHZhbHVlWzNdID09PSBjYWNoZVszXVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy51bmlmb3JtNGl2Q2FjaGVbbmFtZV0gPSB2YWx1ZTtcbiAgICBjb25zdCBsb2MgPSB0aGlzLmdldFVuaWZvcm1Mb2NhdGlvbihuYW1lKTtcbiAgICB0aGlzLmNvbnRleHQudW5pZm9ybTRpdihsb2MsIHZhbHVlKTtcbiAgfVxuXG4gIGdldFVuaWZvcm1Mb2NhdGlvbihuYW1lKSB7XG4gICAgaWYgKHRoaXMucHJvZ3JhbVVuaWZvcm1Mb2NhdGlvbkNhY2hlLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICByZXR1cm4gdGhpcy5wcm9ncmFtVW5pZm9ybUxvY2F0aW9uQ2FjaGVbbmFtZV07XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnByb2dyYW1Vbmlmb3JtTG9jYXRpb25DYWNoZVtuYW1lXSA9IHRoaXMuY29udGV4dC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5wcm9ncmFtLCBuYW1lKTtcbiAgfVxuXG4gIF9nZXRGcmFnU2hhZGVyQXJ0aWZhY3RNYXAoYXJncykge1xuICAgIHJldHVybiB7XG4gICAgICBIRUFERVI6IHRoaXMuX2dldEhlYWRlclN0cmluZygpLFxuICAgICAgTE9PUF9NQVg6IHRoaXMuX2dldExvb3BNYXhTdHJpbmcoKSxcbiAgICAgIFBMVUdJTlM6IHRoaXMuX2dldFBsdWdpbnNTdHJpbmcoKSxcbiAgICAgIENPTlNUQU5UUzogdGhpcy5fZ2V0Q29uc3RhbnRzU3RyaW5nKCksXG4gICAgICBERUNPREUzMl9FTkRJQU5ORVNTOiB0aGlzLl9nZXREZWNvZGUzMkVuZGlhbm5lc3NTdHJpbmcoKSxcbiAgICAgIEVOQ09ERTMyX0VORElBTk5FU1M6IHRoaXMuX2dldEVuY29kZTMyRW5kaWFubmVzc1N0cmluZygpLFxuICAgICAgRElWSURFX1dJVEhfSU5URUdFUl9DSEVDSzogdGhpcy5fZ2V0RGl2aWRlV2l0aEludGVnZXJDaGVja1N0cmluZygpLFxuICAgICAgSU5KRUNURURfTkFUSVZFOiB0aGlzLl9nZXRJbmplY3RlZE5hdGl2ZSgpLFxuICAgICAgTUFJTl9DT05TVEFOVFM6IHRoaXMuX2dldE1haW5Db25zdGFudHNTdHJpbmcoKSxcbiAgICAgIE1BSU5fQVJHVU1FTlRTOiB0aGlzLl9nZXRNYWluQXJndW1lbnRzU3RyaW5nKGFyZ3MpLFxuICAgICAgS0VSTkVMOiB0aGlzLmdldEtlcm5lbFN0cmluZygpLFxuICAgICAgTUFJTl9SRVNVTFQ6IHRoaXMuZ2V0TWFpblJlc3VsdFN0cmluZygpLFxuICAgICAgRkxPQVRfVEFDVElDX0RFQ0xBUkFUSU9OOiB0aGlzLmdldEZsb2F0VGFjdGljRGVjbGFyYXRpb24oKSxcbiAgICAgIElOVF9UQUNUSUNfREVDTEFSQVRJT046IHRoaXMuZ2V0SW50VGFjdGljRGVjbGFyYXRpb24oKSxcbiAgICAgIFNBTVBMRVJfMkRfVEFDVElDX0RFQ0xBUkFUSU9OOiB0aGlzLmdldFNhbXBsZXIyRFRhY3RpY0RlY2xhcmF0aW9uKCksXG4gICAgICBTQU1QTEVSXzJEX0FSUkFZX1RBQ1RJQ19ERUNMQVJBVElPTjogdGhpcy5nZXRTYW1wbGVyMkRBcnJheVRhY3RpY0RlY2xhcmF0aW9uKCksXG4gICAgfTtcbiAgfVxuXG4gIF9nZXRWZXJ0U2hhZGVyQXJ0aWZhY3RNYXAoYXJncykge1xuICAgIHJldHVybiB7XG4gICAgICBGTE9BVF9UQUNUSUNfREVDTEFSQVRJT046IHRoaXMuZ2V0RmxvYXRUYWN0aWNEZWNsYXJhdGlvbigpLFxuICAgICAgSU5UX1RBQ1RJQ19ERUNMQVJBVElPTjogdGhpcy5nZXRJbnRUYWN0aWNEZWNsYXJhdGlvbigpLFxuICAgICAgU0FNUExFUl8yRF9UQUNUSUNfREVDTEFSQVRJT046IHRoaXMuZ2V0U2FtcGxlcjJEVGFjdGljRGVjbGFyYXRpb24oKSxcbiAgICAgIFNBTVBMRVJfMkRfQVJSQVlfVEFDVElDX0RFQ0xBUkFUSU9OOiB0aGlzLmdldFNhbXBsZXIyREFycmF5VGFjdGljRGVjbGFyYXRpb24oKSxcbiAgICB9O1xuICB9XG5cbiAgX2dldEhlYWRlclN0cmluZygpIHtcbiAgICByZXR1cm4gKFxuICAgICAgdGhpcy5zdWJLZXJuZWxzICE9PSBudWxsID9cbiAgICAgICcjZXh0ZW5zaW9uIEdMX0VYVF9kcmF3X2J1ZmZlcnMgOiByZXF1aXJlXFxuJyA6XG4gICAgICAnJ1xuICAgICk7XG4gIH1cblxuICBfZ2V0TG9vcE1heFN0cmluZygpIHtcbiAgICByZXR1cm4gKFxuICAgICAgdGhpcy5sb29wTWF4SXRlcmF0aW9ucyA/XG4gICAgICBgICR7cGFyc2VJbnQodGhpcy5sb29wTWF4SXRlcmF0aW9ucyl9O1xcbmAgOlxuICAgICAgJyAxMDAwO1xcbidcbiAgICApO1xuICB9XG5cbiAgX2dldFBsdWdpbnNTdHJpbmcoKSB7XG4gICAgaWYgKCF0aGlzLnBsdWdpbnMpIHJldHVybiAnXFxuJztcbiAgICByZXR1cm4gdGhpcy5wbHVnaW5zLm1hcChwbHVnaW4gPT4gcGx1Z2luLnNvdXJjZSAmJiB0aGlzLnNvdXJjZS5tYXRjaChwbHVnaW4uZnVuY3Rpb25NYXRjaCkgPyBwbHVnaW4uc291cmNlIDogJycpLmpvaW4oJ1xcbicpO1xuICB9XG5cbiAgX2dldENvbnN0YW50c1N0cmluZygpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBjb25zdCB7IHRocmVhZERpbSwgdGV4U2l6ZSB9ID0gdGhpcztcbiAgICBpZiAodGhpcy5keW5hbWljT3V0cHV0KSB7XG4gICAgICByZXN1bHQucHVzaChcbiAgICAgICAgJ3VuaWZvcm0gaXZlYzMgdU91dHB1dERpbScsXG4gICAgICAgICd1bmlmb3JtIGl2ZWMyIHVUZXhTaXplJ1xuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0LnB1c2goXG4gICAgICAgIGBpdmVjMyB1T3V0cHV0RGltID0gaXZlYzMoJHt0aHJlYWREaW1bMF19LCAke3RocmVhZERpbVsxXX0sICR7dGhyZWFkRGltWzJdfSlgLFxuICAgICAgICBgaXZlYzIgdVRleFNpemUgPSBpdmVjMigke3RleFNpemVbMF19LCAke3RleFNpemVbMV19KWBcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB1dGlscy5saW5lc1RvU3RyaW5nKHJlc3VsdCk7XG4gIH1cblxuICBfZ2V0VGV4dHVyZUNvb3JkaW5hdGUoKSB7XG4gICAgY29uc3Qgc3ViS2VybmVscyA9IHRoaXMuc3ViS2VybmVscztcbiAgICBpZiAoc3ViS2VybmVscyA9PT0gbnVsbCB8fCBzdWJLZXJuZWxzLmxlbmd0aCA8IDEpIHtcbiAgICAgIHJldHVybiAndmFyeWluZyB2ZWMyIHZUZXhDb29yZDtcXG4nO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gJ291dCB2ZWMyIHZUZXhDb29yZDtcXG4nO1xuICAgIH1cbiAgfVxuXG4gIF9nZXREZWNvZGUzMkVuZGlhbm5lc3NTdHJpbmcoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIHRoaXMuZW5kaWFubmVzcyA9PT0gJ0xFJyA/XG4gICAgICAnJyA6XG4gICAgICAnICB0ZXhlbC5yZ2JhID0gdGV4ZWwuYWJncjtcXG4nXG4gICAgKTtcbiAgfVxuXG4gIF9nZXRFbmNvZGUzMkVuZGlhbm5lc3NTdHJpbmcoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIHRoaXMuZW5kaWFubmVzcyA9PT0gJ0xFJyA/XG4gICAgICAnJyA6XG4gICAgICAnICB0ZXhlbC5yZ2JhID0gdGV4ZWwuYWJncjtcXG4nXG4gICAgKTtcbiAgfVxuXG4gIF9nZXREaXZpZGVXaXRoSW50ZWdlckNoZWNrU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLmZpeEludGVnZXJEaXZpc2lvbkFjY3VyYWN5ID9cbiAgICAgIGBmbG9hdCBkaXZXaXRoSW50Q2hlY2soZmxvYXQgeCwgZmxvYXQgeSkge1xuICBpZiAoZmxvb3IoeCkgPT0geCAmJiBmbG9vcih5KSA9PSB5ICYmIGludGVnZXJNb2QoeCwgeSkgPT0gMC4wKSB7XG4gICAgcmV0dXJuIGZsb2F0KGludCh4KSAvIGludCh5KSk7XG4gIH1cbiAgcmV0dXJuIHggLyB5O1xufVxuXG5mbG9hdCBpbnRlZ2VyQ29ycmVjdGlvbk1vZHVsbyhmbG9hdCBudW1iZXIsIGZsb2F0IGRpdmlzb3IpIHtcbiAgaWYgKG51bWJlciA8IDAuMCkge1xuICAgIG51bWJlciA9IGFicyhudW1iZXIpO1xuICAgIGlmIChkaXZpc29yIDwgMC4wKSB7XG4gICAgICBkaXZpc29yID0gYWJzKGRpdmlzb3IpO1xuICAgIH1cbiAgICByZXR1cm4gLShudW1iZXIgLSAoZGl2aXNvciAqIGZsb29yKGRpdldpdGhJbnRDaGVjayhudW1iZXIsIGRpdmlzb3IpKSkpO1xuICB9XG4gIGlmIChkaXZpc29yIDwgMC4wKSB7XG4gICAgZGl2aXNvciA9IGFicyhkaXZpc29yKTtcbiAgfVxuICByZXR1cm4gbnVtYmVyIC0gKGRpdmlzb3IgKiBmbG9vcihkaXZXaXRoSW50Q2hlY2sobnVtYmVyLCBkaXZpc29yKSkpO1xufWAgOlxuICAgICAgJyc7XG4gIH1cblxuICBfZ2V0TWFpbkFyZ3VtZW50c1N0cmluZyhhcmdzKSB7XG4gICAgY29uc3QgcmVzdWx0cyA9IFtdO1xuICAgIGNvbnN0IHsgYXJndW1lbnROYW1lcyB9ID0gdGhpcztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3VtZW50TmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHJlc3VsdHMucHVzaCh0aGlzLmtlcm5lbEFyZ3VtZW50c1tpXS5nZXRTb3VyY2UoYXJnc1tpXSkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0cy5qb2luKCcnKTtcbiAgfVxuXG4gIF9nZXRJbmplY3RlZE5hdGl2ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5pbmplY3RlZE5hdGl2ZSB8fCAnJztcbiAgfVxuXG4gIF9nZXRNYWluQ29uc3RhbnRzU3RyaW5nKCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGNvbnN0IHsgY29uc3RhbnRzIH0gPSB0aGlzO1xuICAgIGlmIChjb25zdGFudHMpIHtcbiAgICAgIGxldCBpID0gMDtcbiAgICAgIGZvciAoY29uc3QgbmFtZSBpbiBjb25zdGFudHMpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbnN0YW50cy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkgY29udGludWU7XG4gICAgICAgIHJlc3VsdC5wdXNoKHRoaXMua2VybmVsQ29uc3RhbnRzW2krK10uZ2V0U291cmNlKHRoaXMuY29uc3RhbnRzW25hbWVdKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQuam9pbignJyk7XG4gIH1cblxuICBnZXRSYXdWYWx1ZUZyYW1lYnVmZmVyKHdpZHRoLCBoZWlnaHQpIHtcbiAgICBpZiAoIXRoaXMucmF3VmFsdWVGcmFtZWJ1ZmZlcnNbd2lkdGhdKSB7XG4gICAgICB0aGlzLnJhd1ZhbHVlRnJhbWVidWZmZXJzW3dpZHRoXSA9IHt9O1xuICAgIH1cbiAgICBpZiAoIXRoaXMucmF3VmFsdWVGcmFtZWJ1ZmZlcnNbd2lkdGhdW2hlaWdodF0pIHtcbiAgICAgIGNvbnN0IGZyYW1lYnVmZmVyID0gdGhpcy5jb250ZXh0LmNyZWF0ZUZyYW1lYnVmZmVyKCk7XG4gICAgICBmcmFtZWJ1ZmZlci53aWR0aCA9IHdpZHRoO1xuICAgICAgZnJhbWVidWZmZXIuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgdGhpcy5yYXdWYWx1ZUZyYW1lYnVmZmVyc1t3aWR0aF1baGVpZ2h0XSA9IGZyYW1lYnVmZmVyO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5yYXdWYWx1ZUZyYW1lYnVmZmVyc1t3aWR0aF1baGVpZ2h0XTtcbiAgfVxuXG4gIGdldEtlcm5lbFJlc3VsdERlY2xhcmF0aW9uKCkge1xuICAgIHN3aXRjaCAodGhpcy5yZXR1cm5UeXBlKSB7XG4gICAgICBjYXNlICdBcnJheSgyKSc6XG4gICAgICAgIHJldHVybiAndmVjMiBrZXJuZWxSZXN1bHQnO1xuICAgICAgY2FzZSAnQXJyYXkoMyknOlxuICAgICAgICByZXR1cm4gJ3ZlYzMga2VybmVsUmVzdWx0JztcbiAgICAgIGNhc2UgJ0FycmF5KDQpJzpcbiAgICAgICAgcmV0dXJuICd2ZWM0IGtlcm5lbFJlc3VsdCc7XG4gICAgICBjYXNlICdMaXRlcmFsSW50ZWdlcic6XG4gICAgICBjYXNlICdGbG9hdCc6XG4gICAgICBjYXNlICdOdW1iZXInOlxuICAgICAgY2FzZSAnSW50ZWdlcic6XG4gICAgICAgIHJldHVybiAnZmxvYXQga2VybmVsUmVzdWx0JztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmICh0aGlzLmdyYXBoaWNhbCkge1xuICAgICAgICAgIHJldHVybiAnZmxvYXQga2VybmVsUmVzdWx0JztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHVucmVjb2duaXplZCBvdXRwdXQgdHlwZSBcIiR7IHRoaXMucmV0dXJuVHlwZSB9XCJgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgfVxuICBnZXRLZXJuZWxTdHJpbmcoKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW3RoaXMuZ2V0S2VybmVsUmVzdWx0RGVjbGFyYXRpb24oKV07XG4gICAgY29uc3QgeyBzdWJLZXJuZWxzIH0gPSB0aGlzO1xuICAgIGlmIChzdWJLZXJuZWxzICE9PSBudWxsKSB7XG4gICAgICBzd2l0Y2ggKHRoaXMucmV0dXJuVHlwZSkge1xuICAgICAgICBjYXNlICdOdW1iZXInOlxuICAgICAgICBjYXNlICdGbG9hdCc6XG4gICAgICAgIGNhc2UgJ0ludGVnZXInOlxuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3ViS2VybmVscy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgc3ViS2VybmVsID0gc3ViS2VybmVsc1tpXTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKFxuICAgICAgICAgICAgICBzdWJLZXJuZWwucmV0dXJuVHlwZSA9PT0gJ0ludGVnZXInID9cbiAgICAgICAgICAgICAgYGludCBzdWJLZXJuZWxSZXN1bHRfJHsgc3ViS2VybmVsLm5hbWUgfSA9IDBgIDpcbiAgICAgICAgICAgICAgYGZsb2F0IHN1Yktlcm5lbFJlc3VsdF8keyBzdWJLZXJuZWwubmFtZSB9ID0gMC4wYFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ0FycmF5KDIpJzpcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN1Yktlcm5lbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKFxuICAgICAgICAgICAgICBgdmVjMiBzdWJLZXJuZWxSZXN1bHRfJHsgc3ViS2VybmVsc1tpXS5uYW1lIH1gXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnQXJyYXkoMyknOlxuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3ViS2VybmVscy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goXG4gICAgICAgICAgICAgIGB2ZWMzIHN1Yktlcm5lbFJlc3VsdF8keyBzdWJLZXJuZWxzW2ldLm5hbWUgfWBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdBcnJheSg0KSc6XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdWJLZXJuZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChcbiAgICAgICAgICAgICAgYHZlYzQgc3ViS2VybmVsUmVzdWx0XyR7IHN1Yktlcm5lbHNbaV0ubmFtZSB9YFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHV0aWxzLmxpbmVzVG9TdHJpbmcocmVzdWx0KSArIHRoaXMudHJhbnNsYXRlZFNvdXJjZTtcbiAgfVxuXG4gIGdldE1haW5SZXN1bHRHcmFwaGljYWwoKSB7XG4gICAgcmV0dXJuIHV0aWxzLmxpbmVzVG9TdHJpbmcoW1xuICAgICAgJyAgdGhyZWFkSWQgPSBpbmRleFRvM0QoaW5kZXgsIHVPdXRwdXREaW0pJyxcbiAgICAgICcgIGtlcm5lbCgpJyxcbiAgICAgICcgIGdsX0ZyYWdDb2xvciA9IGFjdHVhbENvbG9yJyxcbiAgICBdKTtcbiAgfVxuXG4gIGdldE1haW5SZXN1bHRQYWNrZWRQaXhlbHMoKSB7XG4gICAgc3dpdGNoICh0aGlzLnJldHVyblR5cGUpIHtcbiAgICAgIGNhc2UgJ0xpdGVyYWxJbnRlZ2VyJzpcbiAgICAgIGNhc2UgJ051bWJlcic6XG4gICAgICBjYXNlICdJbnRlZ2VyJzpcbiAgICAgIGNhc2UgJ0Zsb2F0JzpcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TWFpblJlc3VsdEtlcm5lbFBhY2tlZFBpeGVscygpICtcbiAgICAgICAgICB0aGlzLmdldE1haW5SZXN1bHRTdWJLZXJuZWxQYWNrZWRQaXhlbHMoKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgcGFja2VkIG91dHB1dCBvbmx5IHVzYWJsZSB3aXRoIE51bWJlcnMsIFwiJHt0aGlzLnJldHVyblR5cGV9XCIgc3BlY2lmaWVkYCk7XG4gICAgfVxuICB9XG5cbiAgZ2V0TWFpblJlc3VsdEtlcm5lbFBhY2tlZFBpeGVscygpIHtcbiAgICByZXR1cm4gdXRpbHMubGluZXNUb1N0cmluZyhbXG4gICAgICAnICB0aHJlYWRJZCA9IGluZGV4VG8zRChpbmRleCwgdU91dHB1dERpbSknLFxuICAgICAgJyAga2VybmVsKCknLFxuICAgICAgYCAgZ2xfRnJhZ0RhdGFbMF0gPSAke3RoaXMudXNlTGVnYWN5RW5jb2RlciA/ICdsZWdhY3lFbmNvZGUzMicgOiAnZW5jb2RlMzInfShrZXJuZWxSZXN1bHQpYFxuICAgIF0pO1xuICB9XG5cbiAgZ2V0TWFpblJlc3VsdFN1Yktlcm5lbFBhY2tlZFBpeGVscygpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBpZiAoIXRoaXMuc3ViS2VybmVscykgcmV0dXJuICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zdWJLZXJuZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBzdWJLZXJuZWwgPSB0aGlzLnN1Yktlcm5lbHNbaV07XG4gICAgICBpZiAoc3ViS2VybmVsLnJldHVyblR5cGUgPT09ICdJbnRlZ2VyJykge1xuICAgICAgICByZXN1bHQucHVzaChcbiAgICAgICAgICBgICBnbF9GcmFnRGF0YVske2kgKyAxfV0gPSAke3RoaXMudXNlTGVnYWN5RW5jb2RlciA/ICdsZWdhY3lFbmNvZGUzMicgOiAnZW5jb2RlMzInfShmbG9hdChzdWJLZXJuZWxSZXN1bHRfJHt0aGlzLnN1Yktlcm5lbHNbaV0ubmFtZX0pKWBcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKFxuICAgICAgICAgIGAgIGdsX0ZyYWdEYXRhWyR7aSArIDF9XSA9ICR7dGhpcy51c2VMZWdhY3lFbmNvZGVyID8gJ2xlZ2FjeUVuY29kZTMyJyA6ICdlbmNvZGUzMid9KHN1Yktlcm5lbFJlc3VsdF8ke3RoaXMuc3ViS2VybmVsc1tpXS5uYW1lfSlgXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1dGlscy5saW5lc1RvU3RyaW5nKHJlc3VsdCk7XG4gIH1cblxuICBnZXRNYWluUmVzdWx0TWVtb3J5T3B0aW1pemVkRmxvYXRzKCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtcbiAgICAgICcgIGluZGV4ICo9IDQnLFxuICAgIF07XG5cbiAgICBzd2l0Y2ggKHRoaXMucmV0dXJuVHlwZSkge1xuICAgICAgY2FzZSAnTnVtYmVyJzpcbiAgICAgIGNhc2UgJ0ludGVnZXInOlxuICAgICAgY2FzZSAnRmxvYXQnOlxuICAgICAgICBjb25zdCBjaGFubmVscyA9IFsncicsICdnJywgJ2InLCAnYSddO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoYW5uZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgY2hhbm5lbCA9IGNoYW5uZWxzW2ldO1xuICAgICAgICAgIHRoaXMuZ2V0TWFpblJlc3VsdEtlcm5lbE1lbW9yeU9wdGltaXplZEZsb2F0cyhyZXN1bHQsIGNoYW5uZWwpO1xuICAgICAgICAgIHRoaXMuZ2V0TWFpblJlc3VsdFN1Yktlcm5lbE1lbW9yeU9wdGltaXplZEZsb2F0cyhyZXN1bHQsIGNoYW5uZWwpO1xuICAgICAgICAgIGlmIChpICsgMSA8IGNoYW5uZWxzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goJyAgaW5kZXggKz0gMScpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgb3B0aW1pemVkIG91dHB1dCBvbmx5IHVzYWJsZSB3aXRoIE51bWJlcnMsICR7dGhpcy5yZXR1cm5UeXBlfSBzcGVjaWZpZWRgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdXRpbHMubGluZXNUb1N0cmluZyhyZXN1bHQpO1xuICB9XG5cbiAgZ2V0TWFpblJlc3VsdEtlcm5lbE1lbW9yeU9wdGltaXplZEZsb2F0cyhyZXN1bHQsIGNoYW5uZWwpIHtcbiAgICByZXN1bHQucHVzaChcbiAgICAgICcgIHRocmVhZElkID0gaW5kZXhUbzNEKGluZGV4LCB1T3V0cHV0RGltKScsXG4gICAgICAnICBrZXJuZWwoKScsXG4gICAgICBgICBnbF9GcmFnRGF0YVswXS4ke2NoYW5uZWx9ID0ga2VybmVsUmVzdWx0YFxuICAgICk7XG4gIH1cblxuICBnZXRNYWluUmVzdWx0U3ViS2VybmVsTWVtb3J5T3B0aW1pemVkRmxvYXRzKHJlc3VsdCwgY2hhbm5lbCkge1xuICAgIGlmICghdGhpcy5zdWJLZXJuZWxzKSByZXR1cm4gcmVzdWx0O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zdWJLZXJuZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBzdWJLZXJuZWwgPSB0aGlzLnN1Yktlcm5lbHNbaV07XG4gICAgICBpZiAoc3ViS2VybmVsLnJldHVyblR5cGUgPT09ICdJbnRlZ2VyJykge1xuICAgICAgICByZXN1bHQucHVzaChcbiAgICAgICAgICBgICBnbF9GcmFnRGF0YVske2kgKyAxfV0uJHtjaGFubmVsfSA9IGZsb2F0KHN1Yktlcm5lbFJlc3VsdF8ke3RoaXMuc3ViS2VybmVsc1tpXS5uYW1lfSlgXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQucHVzaChcbiAgICAgICAgICBgICBnbF9GcmFnRGF0YVske2kgKyAxfV0uJHtjaGFubmVsfSA9IHN1Yktlcm5lbFJlc3VsdF8ke3RoaXMuc3ViS2VybmVsc1tpXS5uYW1lfWBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBnZXRNYWluUmVzdWx0S2VybmVsTnVtYmVyVGV4dHVyZSgpIHtcbiAgICByZXR1cm4gW1xuICAgICAgJyAgdGhyZWFkSWQgPSBpbmRleFRvM0QoaW5kZXgsIHVPdXRwdXREaW0pJyxcbiAgICAgICcgIGtlcm5lbCgpJyxcbiAgICAgICcgIGdsX0ZyYWdEYXRhWzBdWzBdID0ga2VybmVsUmVzdWx0JyxcbiAgICBdO1xuICB9XG5cbiAgZ2V0TWFpblJlc3VsdFN1Yktlcm5lbE51bWJlclRleHR1cmUoKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgaWYgKCF0aGlzLnN1Yktlcm5lbHMpIHJldHVybiByZXN1bHQ7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnN1Yktlcm5lbHMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGNvbnN0IHN1Yktlcm5lbCA9IHRoaXMuc3ViS2VybmVsc1tpXTtcbiAgICAgIGlmIChzdWJLZXJuZWwucmV0dXJuVHlwZSA9PT0gJ0ludGVnZXInKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKFxuICAgICAgICAgIGAgIGdsX0ZyYWdEYXRhWyR7aSArIDF9XVswXSA9IGZsb2F0KHN1Yktlcm5lbFJlc3VsdF8ke3N1Yktlcm5lbC5uYW1lfSlgXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQucHVzaChcbiAgICAgICAgICBgICBnbF9GcmFnRGF0YVske2kgKyAxfV1bMF0gPSBzdWJLZXJuZWxSZXN1bHRfJHtzdWJLZXJuZWwubmFtZX1gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBnZXRNYWluUmVzdWx0S2VybmVsQXJyYXkyVGV4dHVyZSgpIHtcbiAgICByZXR1cm4gW1xuICAgICAgJyAgdGhyZWFkSWQgPSBpbmRleFRvM0QoaW5kZXgsIHVPdXRwdXREaW0pJyxcbiAgICAgICcgIGtlcm5lbCgpJyxcbiAgICAgICcgIGdsX0ZyYWdEYXRhWzBdWzBdID0ga2VybmVsUmVzdWx0WzBdJyxcbiAgICAgICcgIGdsX0ZyYWdEYXRhWzBdWzFdID0ga2VybmVsUmVzdWx0WzFdJyxcbiAgICBdO1xuICB9XG5cbiAgZ2V0TWFpblJlc3VsdFN1Yktlcm5lbEFycmF5MlRleHR1cmUoKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgaWYgKCF0aGlzLnN1Yktlcm5lbHMpIHJldHVybiByZXN1bHQ7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnN1Yktlcm5lbHMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHJlc3VsdC5wdXNoKFxuICAgICAgICBgICBnbF9GcmFnRGF0YVske2kgKyAxfV1bMF0gPSBzdWJLZXJuZWxSZXN1bHRfJHt0aGlzLnN1Yktlcm5lbHNbaV0ubmFtZX1bMF1gLFxuICAgICAgICBgICBnbF9GcmFnRGF0YVske2kgKyAxfV1bMV0gPSBzdWJLZXJuZWxSZXN1bHRfJHt0aGlzLnN1Yktlcm5lbHNbaV0ubmFtZX1bMV1gXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZ2V0TWFpblJlc3VsdEtlcm5lbEFycmF5M1RleHR1cmUoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICcgIHRocmVhZElkID0gaW5kZXhUbzNEKGluZGV4LCB1T3V0cHV0RGltKScsXG4gICAgICAnICBrZXJuZWwoKScsXG4gICAgICAnICBnbF9GcmFnRGF0YVswXVswXSA9IGtlcm5lbFJlc3VsdFswXScsXG4gICAgICAnICBnbF9GcmFnRGF0YVswXVsxXSA9IGtlcm5lbFJlc3VsdFsxXScsXG4gICAgICAnICBnbF9GcmFnRGF0YVswXVsyXSA9IGtlcm5lbFJlc3VsdFsyXScsXG4gICAgXTtcbiAgfVxuXG4gIGdldE1haW5SZXN1bHRTdWJLZXJuZWxBcnJheTNUZXh0dXJlKCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGlmICghdGhpcy5zdWJLZXJuZWxzKSByZXR1cm4gcmVzdWx0O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zdWJLZXJuZWxzLmxlbmd0aDsgKytpKSB7XG4gICAgICByZXN1bHQucHVzaChcbiAgICAgICAgYCAgZ2xfRnJhZ0RhdGFbJHtpICsgMX1dWzBdID0gc3ViS2VybmVsUmVzdWx0XyR7dGhpcy5zdWJLZXJuZWxzW2ldLm5hbWV9WzBdYCxcbiAgICAgICAgYCAgZ2xfRnJhZ0RhdGFbJHtpICsgMX1dWzFdID0gc3ViS2VybmVsUmVzdWx0XyR7dGhpcy5zdWJLZXJuZWxzW2ldLm5hbWV9WzFdYCxcbiAgICAgICAgYCAgZ2xfRnJhZ0RhdGFbJHtpICsgMX1dWzJdID0gc3ViS2VybmVsUmVzdWx0XyR7dGhpcy5zdWJLZXJuZWxzW2ldLm5hbWV9WzJdYFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGdldE1haW5SZXN1bHRLZXJuZWxBcnJheTRUZXh0dXJlKCkge1xuICAgIHJldHVybiBbXG4gICAgICAnICB0aHJlYWRJZCA9IGluZGV4VG8zRChpbmRleCwgdU91dHB1dERpbSknLFxuICAgICAgJyAga2VybmVsKCknLFxuICAgICAgJyAgZ2xfRnJhZ0RhdGFbMF0gPSBrZXJuZWxSZXN1bHQnLFxuICAgIF07XG4gIH1cblxuICBnZXRNYWluUmVzdWx0U3ViS2VybmVsQXJyYXk0VGV4dHVyZSgpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBpZiAoIXRoaXMuc3ViS2VybmVscykgcmV0dXJuIHJlc3VsdDtcbiAgICBzd2l0Y2ggKHRoaXMucmV0dXJuVHlwZSkge1xuICAgICAgY2FzZSAnTnVtYmVyJzpcbiAgICAgIGNhc2UgJ0Zsb2F0JzpcbiAgICAgIGNhc2UgJ0ludGVnZXInOlxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc3ViS2VybmVscy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGNvbnN0IHN1Yktlcm5lbCA9IHRoaXMuc3ViS2VybmVsc1tpXTtcbiAgICAgICAgICBpZiAoc3ViS2VybmVsLnJldHVyblR5cGUgPT09ICdJbnRlZ2VyJykge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goXG4gICAgICAgICAgICAgIGAgIGdsX0ZyYWdEYXRhWyR7aSArIDF9XSA9IGZsb2F0KHN1Yktlcm5lbFJlc3VsdF8ke3RoaXMuc3ViS2VybmVsc1tpXS5uYW1lfSlgXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChcbiAgICAgICAgICAgICAgYCAgZ2xfRnJhZ0RhdGFbJHtpICsgMX1dID0gc3ViS2VybmVsUmVzdWx0XyR7dGhpcy5zdWJLZXJuZWxzW2ldLm5hbWV9YFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdBcnJheSgyKSc6XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zdWJLZXJuZWxzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goXG4gICAgICAgICAgICBgICBnbF9GcmFnRGF0YVske2kgKyAxfV1bMF0gPSBzdWJLZXJuZWxSZXN1bHRfJHt0aGlzLnN1Yktlcm5lbHNbaV0ubmFtZX1bMF1gLFxuICAgICAgICAgICAgYCAgZ2xfRnJhZ0RhdGFbJHtpICsgMX1dWzFdID0gc3ViS2VybmVsUmVzdWx0XyR7dGhpcy5zdWJLZXJuZWxzW2ldLm5hbWV9WzFdYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdBcnJheSgzKSc6XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zdWJLZXJuZWxzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goXG4gICAgICAgICAgICBgICBnbF9GcmFnRGF0YVske2kgKyAxfV1bMF0gPSBzdWJLZXJuZWxSZXN1bHRfJHt0aGlzLnN1Yktlcm5lbHNbaV0ubmFtZX1bMF1gLFxuICAgICAgICAgICAgYCAgZ2xfRnJhZ0RhdGFbJHtpICsgMX1dWzFdID0gc3ViS2VybmVsUmVzdWx0XyR7dGhpcy5zdWJLZXJuZWxzW2ldLm5hbWV9WzFdYCxcbiAgICAgICAgICAgIGAgIGdsX0ZyYWdEYXRhWyR7aSArIDF9XVsyXSA9IHN1Yktlcm5lbFJlc3VsdF8ke3RoaXMuc3ViS2VybmVsc1tpXS5uYW1lfVsyXWBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnQXJyYXkoNCknOlxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc3ViS2VybmVscy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKFxuICAgICAgICAgICAgYCAgZ2xfRnJhZ0RhdGFbJHtpICsgMX1dWzBdID0gc3ViS2VybmVsUmVzdWx0XyR7dGhpcy5zdWJLZXJuZWxzW2ldLm5hbWV9WzBdYCxcbiAgICAgICAgICAgIGAgIGdsX0ZyYWdEYXRhWyR7aSArIDF9XVsxXSA9IHN1Yktlcm5lbFJlc3VsdF8ke3RoaXMuc3ViS2VybmVsc1tpXS5uYW1lfVsxXWAsXG4gICAgICAgICAgICBgICBnbF9GcmFnRGF0YVske2kgKyAxfV1bMl0gPSBzdWJLZXJuZWxSZXN1bHRfJHt0aGlzLnN1Yktlcm5lbHNbaV0ubmFtZX1bMl1gLFxuICAgICAgICAgICAgYCAgZ2xfRnJhZ0RhdGFbJHtpICsgMX1dWzNdID0gc3ViS2VybmVsUmVzdWx0XyR7dGhpcy5zdWJLZXJuZWxzW2ldLm5hbWV9WzNdYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHJlcGxhY2VBcnRpZmFjdHMoc3JjLCBtYXApIHtcbiAgICByZXR1cm4gc3JjLnJlcGxhY2UoL1sgXSpfXyhbQS1aXStbMC05XSooW19dP1tBLVpdKlswLTldPykqKV9fO1xcbi9nLCAobWF0Y2gsIGFydGlmYWN0KSA9PiB7XG4gICAgICBpZiAobWFwLmhhc093blByb3BlcnR5KGFydGlmYWN0KSkge1xuICAgICAgICByZXR1cm4gbWFwW2FydGlmYWN0XTtcbiAgICAgIH1cbiAgICAgIHRocm93IGB1bmhhbmRsZWQgYXJ0aWZhY3QgJHthcnRpZmFjdH1gO1xuICAgIH0pO1xuICB9XG5cbiAgZ2V0RnJhZ21lbnRTaGFkZXIoYXJncykge1xuICAgIGlmICh0aGlzLmNvbXBpbGVkRnJhZ21lbnRTaGFkZXIgIT09IG51bGwpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVkRnJhZ21lbnRTaGFkZXI7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNvbXBpbGVkRnJhZ21lbnRTaGFkZXIgPSB0aGlzLnJlcGxhY2VBcnRpZmFjdHModGhpcy5jb25zdHJ1Y3Rvci5mcmFnbWVudFNoYWRlciwgdGhpcy5fZ2V0RnJhZ1NoYWRlckFydGlmYWN0TWFwKGFyZ3MpKTtcbiAgfVxuXG4gIGdldFZlcnRleFNoYWRlcihhcmdzKSB7XG4gICAgaWYgKHRoaXMuY29tcGlsZWRWZXJ0ZXhTaGFkZXIgIT09IG51bGwpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVkVmVydGV4U2hhZGVyO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jb21waWxlZFZlcnRleFNoYWRlciA9IHRoaXMucmVwbGFjZUFydGlmYWN0cyh0aGlzLmNvbnN0cnVjdG9yLnZlcnRleFNoYWRlciwgdGhpcy5fZ2V0VmVydFNoYWRlckFydGlmYWN0TWFwKGFyZ3MpKTtcbiAgfVxuXG4gIHRvU3RyaW5nKCkge1xuICAgIGNvbnN0IHNldHVwQ29udGV4dFN0cmluZyA9IHV0aWxzLmxpbmVzVG9TdHJpbmcoW1xuICAgICAgYGNvbnN0IGdsID0gY29udGV4dGAsXG4gICAgXSk7XG4gICAgcmV0dXJuIGdsS2VybmVsU3RyaW5nKHRoaXMuY29uc3RydWN0b3IsIGFyZ3VtZW50cywgdGhpcywgc2V0dXBDb250ZXh0U3RyaW5nKTtcbiAgfVxuXG4gIGRlc3Ryb3kocmVtb3ZlQ2FudmFzUmVmZXJlbmNlcykge1xuICAgIGlmICghdGhpcy5jb250ZXh0KSByZXR1cm47XG4gICAgaWYgKHRoaXMuYnVmZmVyKSB7XG4gICAgICB0aGlzLmNvbnRleHQuZGVsZXRlQnVmZmVyKHRoaXMuYnVmZmVyKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuZnJhbWVidWZmZXIpIHtcbiAgICAgIHRoaXMuY29udGV4dC5kZWxldGVGcmFtZWJ1ZmZlcih0aGlzLmZyYW1lYnVmZmVyKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCB3aWR0aCBpbiB0aGlzLnJhd1ZhbHVlRnJhbWVidWZmZXJzKSB7XG4gICAgICBmb3IgKGNvbnN0IGhlaWdodCBpbiB0aGlzLnJhd1ZhbHVlRnJhbWVidWZmZXJzW3dpZHRoXSkge1xuICAgICAgICB0aGlzLmNvbnRleHQuZGVsZXRlRnJhbWVidWZmZXIodGhpcy5yYXdWYWx1ZUZyYW1lYnVmZmVyc1t3aWR0aF1baGVpZ2h0XSk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnJhd1ZhbHVlRnJhbWVidWZmZXJzW3dpZHRoXVtoZWlnaHRdO1xuICAgICAgfVxuICAgICAgZGVsZXRlIHRoaXMucmF3VmFsdWVGcmFtZWJ1ZmZlcnNbd2lkdGhdO1xuICAgIH1cbiAgICBpZiAodGhpcy52ZXJ0U2hhZGVyKSB7XG4gICAgICB0aGlzLmNvbnRleHQuZGVsZXRlU2hhZGVyKHRoaXMudmVydFNoYWRlcik7XG4gICAgfVxuICAgIGlmICh0aGlzLmZyYWdTaGFkZXIpIHtcbiAgICAgIHRoaXMuY29udGV4dC5kZWxldGVTaGFkZXIodGhpcy5mcmFnU2hhZGVyKTtcbiAgICB9XG4gICAgaWYgKHRoaXMucHJvZ3JhbSkge1xuICAgICAgdGhpcy5jb250ZXh0LmRlbGV0ZVByb2dyYW0odGhpcy5wcm9ncmFtKTtcbiAgICB9XG4gICAgaWYgKHRoaXMudGV4dHVyZSkge1xuICAgICAgdGhpcy50ZXh0dXJlLmRlbGV0ZSgpO1xuICAgICAgY29uc3QgdGV4dHVyZUNhY2hlSW5kZXggPSB0aGlzLnRleHR1cmVDYWNoZS5pbmRleE9mKHRoaXMudGV4dHVyZS50ZXh0dXJlKTtcbiAgICAgIGlmICh0ZXh0dXJlQ2FjaGVJbmRleCA+IC0xKSB7XG4gICAgICAgIHRoaXMudGV4dHVyZUNhY2hlLnNwbGljZSh0ZXh0dXJlQ2FjaGVJbmRleCwgMSk7XG4gICAgICB9XG4gICAgICB0aGlzLnRleHR1cmUgPSBudWxsO1xuICAgIH1cbiAgICBpZiAodGhpcy5tYXBwZWRUZXh0dXJlcyAmJiB0aGlzLm1hcHBlZFRleHR1cmVzLmxlbmd0aCkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm1hcHBlZFRleHR1cmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IG1hcHBlZFRleHR1cmUgPSB0aGlzLm1hcHBlZFRleHR1cmVzW2ldO1xuICAgICAgICBtYXBwZWRUZXh0dXJlLmRlbGV0ZSgpO1xuICAgICAgICBjb25zdCB0ZXh0dXJlQ2FjaGVJbmRleCA9IHRoaXMudGV4dHVyZUNhY2hlLmluZGV4T2YobWFwcGVkVGV4dHVyZS50ZXh0dXJlKTtcbiAgICAgICAgaWYgKHRleHR1cmVDYWNoZUluZGV4ID4gLTEpIHtcbiAgICAgICAgICB0aGlzLnRleHR1cmVDYWNoZS5zcGxpY2UodGV4dHVyZUNhY2hlSW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLm1hcHBlZFRleHR1cmVzID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKHRoaXMua2VybmVsQXJndW1lbnRzKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMua2VybmVsQXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMua2VybmVsQXJndW1lbnRzW2ldLmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMua2VybmVsQ29uc3RhbnRzKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMua2VybmVsQ29uc3RhbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMua2VybmVsQ29uc3RhbnRzW2ldLmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICB9XG4gICAgd2hpbGUgKHRoaXMudGV4dHVyZUNhY2hlLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IHRleHR1cmUgPSB0aGlzLnRleHR1cmVDYWNoZS5wb3AoKTtcbiAgICAgIHRoaXMuY29udGV4dC5kZWxldGVUZXh0dXJlKHRleHR1cmUpO1xuICAgIH1cbiAgICBpZiAocmVtb3ZlQ2FudmFzUmVmZXJlbmNlcykge1xuICAgICAgY29uc3QgaWR4ID0gY2FudmFzZXMuaW5kZXhPZih0aGlzLmNhbnZhcyk7XG4gICAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgICAgY2FudmFzZXNbaWR4XSA9IG51bGw7XG4gICAgICAgIG1heFRleFNpemVzW2lkeF0gPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmRlc3Ryb3lFeHRlbnNpb25zKCk7XG4gICAgZGVsZXRlIHRoaXMuY29udGV4dDtcbiAgICBkZWxldGUgdGhpcy5jYW52YXM7XG4gICAgaWYgKCF0aGlzLmdwdSkgcmV0dXJuO1xuICAgIGNvbnN0IGkgPSB0aGlzLmdwdS5rZXJuZWxzLmluZGV4T2YodGhpcyk7XG4gICAgaWYgKGkgPT09IC0xKSByZXR1cm47XG4gICAgdGhpcy5ncHUua2VybmVscy5zcGxpY2UoaSwgMSk7XG4gIH1cblxuICBkZXN0cm95RXh0ZW5zaW9ucygpIHtcbiAgICB0aGlzLmV4dGVuc2lvbnMuT0VTX3RleHR1cmVfZmxvYXQgPSBudWxsO1xuICAgIHRoaXMuZXh0ZW5zaW9ucy5PRVNfdGV4dHVyZV9mbG9hdF9saW5lYXIgPSBudWxsO1xuICAgIHRoaXMuZXh0ZW5zaW9ucy5PRVNfZWxlbWVudF9pbmRleF91aW50ID0gbnVsbDtcbiAgICB0aGlzLmV4dGVuc2lvbnMuV0VCR0xfZHJhd19idWZmZXJzID0gbnVsbDtcbiAgfVxuXG4gIHN0YXRpYyBkZXN0cm95Q29udGV4dChjb250ZXh0KSB7XG4gICAgY29uc3QgZXh0ZW5zaW9uID0gY29udGV4dC5nZXRFeHRlbnNpb24oJ1dFQkdMX2xvc2VfY29udGV4dCcpO1xuICAgIGlmIChleHRlbnNpb24pIHtcbiAgICAgIGV4dGVuc2lvbi5sb3NlQ29udGV4dCgpO1xuICAgIH1cbiAgfVxuXG4gIHRvSlNPTigpIHtcbiAgICBjb25zdCBqc29uID0gc3VwZXIudG9KU09OKCk7XG4gICAganNvbi5mdW5jdGlvbk5vZGVzID0gRnVuY3Rpb25CdWlsZGVyLmZyb21LZXJuZWwodGhpcywgV2ViR0xGdW5jdGlvbk5vZGUpLnRvSlNPTigpO1xuICAgIGpzb24uc2V0dGluZ3MudGhyZWFkRGltID0gdGhpcy50aHJlYWREaW07XG4gICAgcmV0dXJuIGpzb247XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFdlYkdMS2VybmVsXG59O1xufSx7XCIuLi8uLi9wbHVnaW5zL21hdGgtcmFuZG9tLXVuaWZvcm1seS1kaXN0cmlidXRlZFwiOjExMixcIi4uLy4uL3V0aWxzXCI6MTE0LFwiLi4vZnVuY3Rpb24tYnVpbGRlclwiOjksXCIuLi9nbC9rZXJuZWxcIjoxMyxcIi4uL2dsL2tlcm5lbC1zdHJpbmdcIjoxMixcIi4vZnJhZ21lbnQtc2hhZGVyXCI6MzcsXCIuL2Z1bmN0aW9uLW5vZGVcIjozOCxcIi4va2VybmVsLXZhbHVlLW1hcHNcIjozOSxcIi4vdmVydGV4LXNoYWRlclwiOjcxfV0sNzE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgdmVydGV4U2hhZGVyID0gYF9fRkxPQVRfVEFDVElDX0RFQ0xBUkFUSU9OX187XG5fX0lOVF9UQUNUSUNfREVDTEFSQVRJT05fXztcbl9fU0FNUExFUl8yRF9UQUNUSUNfREVDTEFSQVRJT05fXztcblxuYXR0cmlidXRlIHZlYzIgYVBvcztcbmF0dHJpYnV0ZSB2ZWMyIGFUZXhDb29yZDtcblxudmFyeWluZyB2ZWMyIHZUZXhDb29yZDtcbnVuaWZvcm0gdmVjMiByYXRpbztcblxudm9pZCBtYWluKHZvaWQpIHtcbiAgZ2xfUG9zaXRpb24gPSB2ZWM0KChhUG9zICsgdmVjMigxKSkgKiByYXRpbyArIHZlYzIoLTEpLCAwLCAxKTtcbiAgdlRleENvb3JkID0gYVRleENvb3JkO1xufWA7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICB2ZXJ0ZXhTaGFkZXJcbn07XG59LHt9XSw3MjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCBmcmFnbWVudFNoYWRlciA9IGAjdmVyc2lvbiAzMDAgZXNcbl9fSEVBREVSX187XG5fX0ZMT0FUX1RBQ1RJQ19ERUNMQVJBVElPTl9fO1xuX19JTlRfVEFDVElDX0RFQ0xBUkFUSU9OX187XG5fX1NBTVBMRVJfMkRfVEFDVElDX0RFQ0xBUkFUSU9OX187XG5fX1NBTVBMRVJfMkRfQVJSQVlfVEFDVElDX0RFQ0xBUkFUSU9OX187XG5cbmNvbnN0IGludCBMT09QX01BWCA9IF9fTE9PUF9NQVhfXztcblxuX19QTFVHSU5TX187XG5fX0NPTlNUQU5UU19fO1xuXG5pbiB2ZWMyIHZUZXhDb29yZDtcblxuZmxvYXQgYXRhbjIoZmxvYXQgdjEsIGZsb2F0IHYyKSB7XG4gIGlmICh2MSA9PSAwLjAgfHwgdjIgPT0gMC4wKSByZXR1cm4gMC4wO1xuICByZXR1cm4gYXRhbih2MSAvIHYyKTtcbn1cblxuZmxvYXQgY2JydChmbG9hdCB4KSB7XG4gIGlmICh4ID49IDAuMCkge1xuICAgIHJldHVybiBwb3coeCwgMS4wIC8gMy4wKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gLXBvdyh4LCAxLjAgLyAzLjApO1xuICB9XG59XG5cbmZsb2F0IGV4cG0xKGZsb2F0IHgpIHtcbiAgcmV0dXJuIHBvdygke01hdGguRX0sIHgpIC0gMS4wOyBcbn1cblxuZmxvYXQgZnJvdW5kKGhpZ2hwIGZsb2F0IHgpIHtcbiAgcmV0dXJuIHg7XG59XG5cbmZsb2F0IGltdWwoZmxvYXQgdjEsIGZsb2F0IHYyKSB7XG4gIHJldHVybiBmbG9hdChpbnQodjEpICogaW50KHYyKSk7XG59XG5cbmZsb2F0IGxvZzEwKGZsb2F0IHgpIHtcbiAgcmV0dXJuIGxvZzIoeCkgKiAoMS4wIC8gbG9nMigxMC4wKSk7XG59XG5cbmZsb2F0IGxvZzFwKGZsb2F0IHgpIHtcbiAgcmV0dXJuIGxvZygxLjAgKyB4KTtcbn1cblxuZmxvYXQgX3BvdyhmbG9hdCB2MSwgZmxvYXQgdjIpIHtcbiAgaWYgKHYyID09IDAuMCkgcmV0dXJuIDEuMDtcbiAgcmV0dXJuIHBvdyh2MSwgdjIpO1xufVxuXG5mbG9hdCBfcm91bmQoZmxvYXQgeCkge1xuICByZXR1cm4gZmxvb3IoeCArIDAuNSk7XG59XG5cblxuY29uc3QgaW50IEJJVF9DT1VOVCA9IDMyO1xuaW50IG1vZGkoaW50IHgsIGludCB5KSB7XG4gIHJldHVybiB4IC0geSAqICh4IC8geSk7XG59XG5cbmludCBiaXR3aXNlT3IoaW50IGEsIGludCBiKSB7XG4gIGludCByZXN1bHQgPSAwO1xuICBpbnQgbiA9IDE7XG4gIFxuICBmb3IgKGludCBpID0gMDsgaSA8IEJJVF9DT1VOVDsgaSsrKSB7XG4gICAgaWYgKChtb2RpKGEsIDIpID09IDEpIHx8IChtb2RpKGIsIDIpID09IDEpKSB7XG4gICAgICByZXN1bHQgKz0gbjtcbiAgICB9XG4gICAgYSA9IGEgLyAyO1xuICAgIGIgPSBiIC8gMjtcbiAgICBuID0gbiAqIDI7XG4gICAgaWYoIShhID4gMCB8fCBiID4gMCkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuaW50IGJpdHdpc2VYT1IoaW50IGEsIGludCBiKSB7XG4gIGludCByZXN1bHQgPSAwO1xuICBpbnQgbiA9IDE7XG4gIFxuICBmb3IgKGludCBpID0gMDsgaSA8IEJJVF9DT1VOVDsgaSsrKSB7XG4gICAgaWYgKChtb2RpKGEsIDIpID09IDEpICE9IChtb2RpKGIsIDIpID09IDEpKSB7XG4gICAgICByZXN1bHQgKz0gbjtcbiAgICB9XG4gICAgYSA9IGEgLyAyO1xuICAgIGIgPSBiIC8gMjtcbiAgICBuID0gbiAqIDI7XG4gICAgaWYoIShhID4gMCB8fCBiID4gMCkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuaW50IGJpdHdpc2VBbmQoaW50IGEsIGludCBiKSB7XG4gIGludCByZXN1bHQgPSAwO1xuICBpbnQgbiA9IDE7XG4gIGZvciAoaW50IGkgPSAwOyBpIDwgQklUX0NPVU5UOyBpKyspIHtcbiAgICBpZiAoKG1vZGkoYSwgMikgPT0gMSkgJiYgKG1vZGkoYiwgMikgPT0gMSkpIHtcbiAgICAgIHJlc3VsdCArPSBuO1xuICAgIH1cbiAgICBhID0gYSAvIDI7XG4gICAgYiA9IGIgLyAyO1xuICAgIG4gPSBuICogMjtcbiAgICBpZighKGEgPiAwICYmIGIgPiAwKSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5pbnQgYml0d2lzZU5vdChpbnQgYSkge1xuICBpbnQgcmVzdWx0ID0gMDtcbiAgaW50IG4gPSAxO1xuICBcbiAgZm9yIChpbnQgaSA9IDA7IGkgPCBCSVRfQ09VTlQ7IGkrKykge1xuICAgIGlmIChtb2RpKGEsIDIpID09IDApIHtcbiAgICAgIHJlc3VsdCArPSBuOyAgICBcbiAgICB9XG4gICAgYSA9IGEgLyAyO1xuICAgIG4gPSBuICogMjtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuaW50IGJpdHdpc2VaZXJvRmlsbExlZnRTaGlmdChpbnQgbiwgaW50IHNoaWZ0KSB7XG4gIGludCBtYXhCeXRlcyA9IEJJVF9DT1VOVDtcbiAgZm9yIChpbnQgaSA9IDA7IGkgPCBCSVRfQ09VTlQ7IGkrKykge1xuICAgIGlmIChtYXhCeXRlcyA+PSBuKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgbWF4Qnl0ZXMgKj0gMjtcbiAgfVxuICBmb3IgKGludCBpID0gMDsgaSA8IEJJVF9DT1VOVDsgaSsrKSB7XG4gICAgaWYgKGkgPj0gc2hpZnQpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBuICo9IDI7XG4gIH1cblxuICBpbnQgcmVzdWx0ID0gMDtcbiAgaW50IGJ5dGVWYWwgPSAxO1xuICBmb3IgKGludCBpID0gMDsgaSA8IEJJVF9DT1VOVDsgaSsrKSB7XG4gICAgaWYgKGkgPj0gbWF4Qnl0ZXMpIGJyZWFrO1xuICAgIGlmIChtb2RpKG4sIDIpID4gMCkgeyByZXN1bHQgKz0gYnl0ZVZhbDsgfVxuICAgIG4gPSBpbnQobiAvIDIpO1xuICAgIGJ5dGVWYWwgKj0gMjtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5pbnQgYml0d2lzZVNpZ25lZFJpZ2h0U2hpZnQoaW50IG51bSwgaW50IHNoaWZ0cykge1xuICByZXR1cm4gaW50KGZsb29yKGZsb2F0KG51bSkgLyBwb3coMi4wLCBmbG9hdChzaGlmdHMpKSkpO1xufVxuXG5pbnQgYml0d2lzZVplcm9GaWxsUmlnaHRTaGlmdChpbnQgbiwgaW50IHNoaWZ0KSB7XG4gIGludCBtYXhCeXRlcyA9IEJJVF9DT1VOVDtcbiAgZm9yIChpbnQgaSA9IDA7IGkgPCBCSVRfQ09VTlQ7IGkrKykge1xuICAgIGlmIChtYXhCeXRlcyA+PSBuKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgbWF4Qnl0ZXMgKj0gMjtcbiAgfVxuICBmb3IgKGludCBpID0gMDsgaSA8IEJJVF9DT1VOVDsgaSsrKSB7XG4gICAgaWYgKGkgPj0gc2hpZnQpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBuIC89IDI7XG4gIH1cbiAgaW50IHJlc3VsdCA9IDA7XG4gIGludCBieXRlVmFsID0gMTtcbiAgZm9yIChpbnQgaSA9IDA7IGkgPCBCSVRfQ09VTlQ7IGkrKykge1xuICAgIGlmIChpID49IG1heEJ5dGVzKSBicmVhaztcbiAgICBpZiAobW9kaShuLCAyKSA+IDApIHsgcmVzdWx0ICs9IGJ5dGVWYWw7IH1cbiAgICBuID0gaW50KG4gLyAyKTtcbiAgICBieXRlVmFsICo9IDI7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxudmVjMiBpbnRlZ2VyTW9kKHZlYzIgeCwgZmxvYXQgeSkge1xuICB2ZWMyIHJlcyA9IGZsb29yKG1vZCh4LCB5KSk7XG4gIHJldHVybiByZXMgKiBzdGVwKDEuMCAtIGZsb29yKHkpLCAtcmVzKTtcbn1cblxudmVjMyBpbnRlZ2VyTW9kKHZlYzMgeCwgZmxvYXQgeSkge1xuICB2ZWMzIHJlcyA9IGZsb29yKG1vZCh4LCB5KSk7XG4gIHJldHVybiByZXMgKiBzdGVwKDEuMCAtIGZsb29yKHkpLCAtcmVzKTtcbn1cblxudmVjNCBpbnRlZ2VyTW9kKHZlYzQgeCwgdmVjNCB5KSB7XG4gIHZlYzQgcmVzID0gZmxvb3IobW9kKHgsIHkpKTtcbiAgcmV0dXJuIHJlcyAqIHN0ZXAoMS4wIC0gZmxvb3IoeSksIC1yZXMpO1xufVxuXG5mbG9hdCBpbnRlZ2VyTW9kKGZsb2F0IHgsIGZsb2F0IHkpIHtcbiAgZmxvYXQgcmVzID0gZmxvb3IobW9kKHgsIHkpKTtcbiAgcmV0dXJuIHJlcyAqIChyZXMgPiBmbG9vcih5KSAtIDEuMCA/IDAuMCA6IDEuMCk7XG59XG5cbmludCBpbnRlZ2VyTW9kKGludCB4LCBpbnQgeSkge1xuICByZXR1cm4geCAtICh5ICogaW50KHgveSkpO1xufVxuXG5fX0RJVklERV9XSVRIX0lOVEVHRVJfQ0hFQ0tfXztcblxuLy8gSGVyZSBiZSBkcmFnb25zIVxuLy8gRE8gTk9UIE9QVElNSVpFIFRISVMgQ09ERVxuLy8gWU9VIFdJTEwgQlJFQUsgU09NRVRISU5HIE9OIFNPTUVCT0RZXFwnUyBNQUNISU5FXG4vLyBMRUFWRSBJVCBBUyBJVCBJUywgTEVTVCBZT1UgV0FTVEUgWU9VUiBPV04gVElNRVxuY29uc3QgdmVjMiBNQUdJQ19WRUMgPSB2ZWMyKDEuMCwgLTI1Ni4wKTtcbmNvbnN0IHZlYzQgU0NBTEVfRkFDVE9SID0gdmVjNCgxLjAsIDI1Ni4wLCA2NTUzNi4wLCAwLjApO1xuY29uc3QgdmVjNCBTQ0FMRV9GQUNUT1JfSU5WID0gdmVjNCgxLjAsIDAuMDAzOTA2MjUsIDAuMDAwMDE1MjU4Nzg5MDYyNSwgMC4wKTsgLy8gMSwgMS8yNTYsIDEvNjU1MzZcbmZsb2F0IGRlY29kZTMyKHZlYzQgdGV4ZWwpIHtcbiAgX19ERUNPREUzMl9FTkRJQU5ORVNTX187XG4gIHRleGVsICo9IDI1NS4wO1xuICB2ZWMyIGd0ZTEyODtcbiAgZ3RlMTI4LnggPSB0ZXhlbC5iID49IDEyOC4wID8gMS4wIDogMC4wO1xuICBndGUxMjgueSA9IHRleGVsLmEgPj0gMTI4LjAgPyAxLjAgOiAwLjA7XG4gIGZsb2F0IGV4cG9uZW50ID0gMi4wICogdGV4ZWwuYSAtIDEyNy4wICsgZG90KGd0ZTEyOCwgTUFHSUNfVkVDKTtcbiAgZmxvYXQgcmVzID0gZXhwMihyb3VuZChleHBvbmVudCkpO1xuICB0ZXhlbC5iID0gdGV4ZWwuYiAtIDEyOC4wICogZ3RlMTI4Lng7XG4gIHJlcyA9IGRvdCh0ZXhlbCwgU0NBTEVfRkFDVE9SKSAqIGV4cDIocm91bmQoZXhwb25lbnQtMjMuMCkpICsgcmVzO1xuICByZXMgKj0gZ3RlMTI4LnkgKiAtMi4wICsgMS4wO1xuICByZXR1cm4gcmVzO1xufVxuXG5mbG9hdCBkZWNvZGUxNih2ZWM0IHRleGVsLCBpbnQgaW5kZXgpIHtcbiAgaW50IGNoYW5uZWwgPSBpbnRlZ2VyTW9kKGluZGV4LCAyKTtcbiAgcmV0dXJuIHRleGVsW2NoYW5uZWwqMl0gKiAyNTUuMCArIHRleGVsW2NoYW5uZWwqMiArIDFdICogNjUyODAuMDtcbn1cblxuZmxvYXQgZGVjb2RlOCh2ZWM0IHRleGVsLCBpbnQgaW5kZXgpIHtcbiAgaW50IGNoYW5uZWwgPSBpbnRlZ2VyTW9kKGluZGV4LCA0KTtcbiAgcmV0dXJuIHRleGVsW2NoYW5uZWxdICogMjU1LjA7XG59XG5cbnZlYzQgbGVnYWN5RW5jb2RlMzIoZmxvYXQgZikge1xuICBmbG9hdCBGID0gYWJzKGYpO1xuICBmbG9hdCBzaWduID0gZiA8IDAuMCA/IDEuMCA6IDAuMDtcbiAgZmxvYXQgZXhwb25lbnQgPSBmbG9vcihsb2cyKEYpKTtcbiAgZmxvYXQgbWFudGlzc2EgPSAoZXhwMigtZXhwb25lbnQpICogRik7XG4gIC8vIGV4cG9uZW50ICs9IGZsb29yKGxvZzIobWFudGlzc2EpKTtcbiAgdmVjNCB0ZXhlbCA9IHZlYzQoRiAqIGV4cDIoMjMuMC1leHBvbmVudCkpICogU0NBTEVfRkFDVE9SX0lOVjtcbiAgdGV4ZWwucmcgPSBpbnRlZ2VyTW9kKHRleGVsLnJnLCAyNTYuMCk7XG4gIHRleGVsLmIgPSBpbnRlZ2VyTW9kKHRleGVsLmIsIDEyOC4wKTtcbiAgdGV4ZWwuYSA9IGV4cG9uZW50KjAuNSArIDYzLjU7XG4gIHRleGVsLmJhICs9IHZlYzIoaW50ZWdlck1vZChleHBvbmVudCsxMjcuMCwgMi4wKSwgc2lnbikgKiAxMjguMDtcbiAgdGV4ZWwgPSBmbG9vcih0ZXhlbCk7XG4gIHRleGVsICo9IDAuMDAzOTIxNTY5OyAvLyAxLzI1NVxuICBfX0VOQ09ERTMyX0VORElBTk5FU1NfXztcbiAgcmV0dXJuIHRleGVsO1xufVxuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vZ3B1anMvZ3B1LmpzL3dpa2kvRW5jb2Rlci1kZXRhaWxzXG52ZWM0IGVuY29kZTMyKGZsb2F0IHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSAwLjApIHJldHVybiB2ZWM0KDAsIDAsIDAsIDApO1xuXG4gIGZsb2F0IGV4cG9uZW50O1xuICBmbG9hdCBtYW50aXNzYTtcbiAgdmVjNCAgcmVzdWx0O1xuICBmbG9hdCBzZ247XG5cbiAgc2duID0gc3RlcCgwLjAsIC12YWx1ZSk7XG4gIHZhbHVlID0gYWJzKHZhbHVlKTtcblxuICBleHBvbmVudCA9IGZsb29yKGxvZzIodmFsdWUpKTtcblxuICBtYW50aXNzYSA9IHZhbHVlKnBvdygyLjAsIC1leHBvbmVudCktMS4wO1xuICBleHBvbmVudCA9IGV4cG9uZW50KzEyNy4wO1xuICByZXN1bHQgICA9IHZlYzQoMCwwLDAsMCk7XG5cbiAgcmVzdWx0LmEgPSBmbG9vcihleHBvbmVudC8yLjApO1xuICBleHBvbmVudCA9IGV4cG9uZW50IC0gcmVzdWx0LmEqMi4wO1xuICByZXN1bHQuYSA9IHJlc3VsdC5hICsgMTI4LjAqc2duO1xuXG4gIHJlc3VsdC5iID0gZmxvb3IobWFudGlzc2EgKiAxMjguMCk7XG4gIG1hbnRpc3NhID0gbWFudGlzc2EgLSByZXN1bHQuYiAvIDEyOC4wO1xuICByZXN1bHQuYiA9IHJlc3VsdC5iICsgZXhwb25lbnQqMTI4LjA7XG5cbiAgcmVzdWx0LmcgPSBmbG9vcihtYW50aXNzYSozMjc2OC4wKTtcbiAgbWFudGlzc2EgPSBtYW50aXNzYSAtIHJlc3VsdC5nLzMyNzY4LjA7XG5cbiAgcmVzdWx0LnIgPSBmbG9vcihtYW50aXNzYSo4Mzg4NjA4LjApO1xuICByZXR1cm4gcmVzdWx0LzI1NS4wO1xufVxuLy8gRHJhZ29ucyBlbmQgaGVyZVxuXG5pbnQgaW5kZXg7XG5pdmVjMyB0aHJlYWRJZDtcblxuaXZlYzMgaW5kZXhUbzNEKGludCBpZHgsIGl2ZWMzIHRleERpbSkge1xuICBpbnQgeiA9IGludChpZHggLyAodGV4RGltLnggKiB0ZXhEaW0ueSkpO1xuICBpZHggLT0geiAqIGludCh0ZXhEaW0ueCAqIHRleERpbS55KTtcbiAgaW50IHkgPSBpbnQoaWR4IC8gdGV4RGltLngpO1xuICBpbnQgeCA9IGludChpbnRlZ2VyTW9kKGlkeCwgdGV4RGltLngpKTtcbiAgcmV0dXJuIGl2ZWMzKHgsIHksIHopO1xufVxuXG5mbG9hdCBnZXQzMihzYW1wbGVyMkQgdGV4LCBpdmVjMiB0ZXhTaXplLCBpdmVjMyB0ZXhEaW0sIGludCB6LCBpbnQgeSwgaW50IHgpIHtcbiAgaW50IGluZGV4ID0geCArIHRleERpbS54ICogKHkgKyB0ZXhEaW0ueSAqIHopO1xuICBpbnQgdyA9IHRleFNpemUueDtcbiAgdmVjMiBzdCA9IHZlYzIoZmxvYXQoaW50ZWdlck1vZChpbmRleCwgdykpLCBmbG9hdChpbmRleCAvIHcpKSArIDAuNTtcbiAgdmVjNCB0ZXhlbCA9IHRleHR1cmUodGV4LCBzdCAvIHZlYzIodGV4U2l6ZSkpO1xuICByZXR1cm4gZGVjb2RlMzIodGV4ZWwpO1xufVxuXG5mbG9hdCBnZXQxNihzYW1wbGVyMkQgdGV4LCBpdmVjMiB0ZXhTaXplLCBpdmVjMyB0ZXhEaW0sIGludCB6LCBpbnQgeSwgaW50IHgpIHtcbiAgaW50IGluZGV4ID0geCArICh0ZXhEaW0ueCAqICh5ICsgKHRleERpbS55ICogeikpKTtcbiAgaW50IHcgPSB0ZXhTaXplLnggKiAyO1xuICB2ZWMyIHN0ID0gdmVjMihmbG9hdChpbnRlZ2VyTW9kKGluZGV4LCB3KSksIGZsb2F0KGluZGV4IC8gdykpICsgMC41O1xuICB2ZWM0IHRleGVsID0gdGV4dHVyZSh0ZXgsIHN0IC8gdmVjMih0ZXhTaXplLnggKiAyLCB0ZXhTaXplLnkpKTtcbiAgcmV0dXJuIGRlY29kZTE2KHRleGVsLCBpbmRleCk7XG59XG5cbmZsb2F0IGdldDgoc2FtcGxlcjJEIHRleCwgaXZlYzIgdGV4U2l6ZSwgaXZlYzMgdGV4RGltLCBpbnQgeiwgaW50IHksIGludCB4KSB7XG4gIGludCBpbmRleCA9IHggKyAodGV4RGltLnggKiAoeSArICh0ZXhEaW0ueSAqIHopKSk7XG4gIGludCB3ID0gdGV4U2l6ZS54ICogNDtcbiAgdmVjMiBzdCA9IHZlYzIoZmxvYXQoaW50ZWdlck1vZChpbmRleCwgdykpLCBmbG9hdChpbmRleCAvIHcpKSArIDAuNTtcbiAgdmVjNCB0ZXhlbCA9IHRleHR1cmUodGV4LCBzdCAvIHZlYzIodGV4U2l6ZS54ICogNCwgdGV4U2l6ZS55KSk7XG4gIHJldHVybiBkZWNvZGU4KHRleGVsLCBpbmRleCk7XG59XG5cbmZsb2F0IGdldE1lbW9yeU9wdGltaXplZDMyKHNhbXBsZXIyRCB0ZXgsIGl2ZWMyIHRleFNpemUsIGl2ZWMzIHRleERpbSwgaW50IHosIGludCB5LCBpbnQgeCkge1xuICBpbnQgaW5kZXggPSB4ICsgKHRleERpbS54ICogKHkgKyAodGV4RGltLnkgKiB6KSkpO1xuICBpbnQgY2hhbm5lbCA9IGludGVnZXJNb2QoaW5kZXgsIDQpO1xuICBpbmRleCA9IGluZGV4IC8gNDtcbiAgaW50IHcgPSB0ZXhTaXplLng7XG4gIHZlYzIgc3QgPSB2ZWMyKGZsb2F0KGludGVnZXJNb2QoaW5kZXgsIHcpKSwgZmxvYXQoaW5kZXggLyB3KSkgKyAwLjU7XG4gIGluZGV4ID0gaW5kZXggLyA0O1xuICB2ZWM0IHRleGVsID0gdGV4dHVyZSh0ZXgsIHN0IC8gdmVjMih0ZXhTaXplKSk7XG4gIHJldHVybiB0ZXhlbFtjaGFubmVsXTtcbn1cblxudmVjNCBnZXRJbWFnZTJEKHNhbXBsZXIyRCB0ZXgsIGl2ZWMyIHRleFNpemUsIGl2ZWMzIHRleERpbSwgaW50IHosIGludCB5LCBpbnQgeCkge1xuICBpbnQgaW5kZXggPSB4ICsgdGV4RGltLnggKiAoeSArIHRleERpbS55ICogeik7XG4gIGludCB3ID0gdGV4U2l6ZS54O1xuICB2ZWMyIHN0ID0gdmVjMihmbG9hdChpbnRlZ2VyTW9kKGluZGV4LCB3KSksIGZsb2F0KGluZGV4IC8gdykpICsgMC41O1xuICByZXR1cm4gdGV4dHVyZSh0ZXgsIHN0IC8gdmVjMih0ZXhTaXplKSk7XG59XG5cbnZlYzQgZ2V0SW1hZ2UzRChzYW1wbGVyMkRBcnJheSB0ZXgsIGl2ZWMyIHRleFNpemUsIGl2ZWMzIHRleERpbSwgaW50IHosIGludCB5LCBpbnQgeCkge1xuICBpbnQgaW5kZXggPSB4ICsgdGV4RGltLnggKiAoeSArIHRleERpbS55ICogeik7XG4gIGludCB3ID0gdGV4U2l6ZS54O1xuICB2ZWMyIHN0ID0gdmVjMihmbG9hdChpbnRlZ2VyTW9kKGluZGV4LCB3KSksIGZsb2F0KGluZGV4IC8gdykpICsgMC41O1xuICByZXR1cm4gdGV4dHVyZSh0ZXgsIHZlYzMoc3QgLyB2ZWMyKHRleFNpemUpLCB6KSk7XG59XG5cbmZsb2F0IGdldEZsb2F0RnJvbVNhbXBsZXIyRChzYW1wbGVyMkQgdGV4LCBpdmVjMiB0ZXhTaXplLCBpdmVjMyB0ZXhEaW0sIGludCB6LCBpbnQgeSwgaW50IHgpIHtcbiAgdmVjNCByZXN1bHQgPSBnZXRJbWFnZTJEKHRleCwgdGV4U2l6ZSwgdGV4RGltLCB6LCB5LCB4KTtcbiAgcmV0dXJuIHJlc3VsdFswXTtcbn1cblxudmVjMiBnZXRWZWMyRnJvbVNhbXBsZXIyRChzYW1wbGVyMkQgdGV4LCBpdmVjMiB0ZXhTaXplLCBpdmVjMyB0ZXhEaW0sIGludCB6LCBpbnQgeSwgaW50IHgpIHtcbiAgdmVjNCByZXN1bHQgPSBnZXRJbWFnZTJEKHRleCwgdGV4U2l6ZSwgdGV4RGltLCB6LCB5LCB4KTtcbiAgcmV0dXJuIHZlYzIocmVzdWx0WzBdLCByZXN1bHRbMV0pO1xufVxuXG52ZWMyIGdldE1lbW9yeU9wdGltaXplZFZlYzIoc2FtcGxlcjJEIHRleCwgaXZlYzIgdGV4U2l6ZSwgaXZlYzMgdGV4RGltLCBpbnQgeiwgaW50IHksIGludCB4KSB7XG4gIGludCBpbmRleCA9IHggKyB0ZXhEaW0ueCAqICh5ICsgdGV4RGltLnkgKiB6KTtcbiAgaW50IGNoYW5uZWwgPSBpbnRlZ2VyTW9kKGluZGV4LCAyKTtcbiAgaW5kZXggPSBpbmRleCAvIDI7XG4gIGludCB3ID0gdGV4U2l6ZS54O1xuICB2ZWMyIHN0ID0gdmVjMihmbG9hdChpbnRlZ2VyTW9kKGluZGV4LCB3KSksIGZsb2F0KGluZGV4IC8gdykpICsgMC41O1xuICB2ZWM0IHRleGVsID0gdGV4dHVyZSh0ZXgsIHN0IC8gdmVjMih0ZXhTaXplKSk7XG4gIGlmIChjaGFubmVsID09IDApIHJldHVybiB2ZWMyKHRleGVsLnIsIHRleGVsLmcpO1xuICBpZiAoY2hhbm5lbCA9PSAxKSByZXR1cm4gdmVjMih0ZXhlbC5iLCB0ZXhlbC5hKTtcbiAgcmV0dXJuIHZlYzIoMC4wLCAwLjApO1xufVxuXG52ZWMzIGdldFZlYzNGcm9tU2FtcGxlcjJEKHNhbXBsZXIyRCB0ZXgsIGl2ZWMyIHRleFNpemUsIGl2ZWMzIHRleERpbSwgaW50IHosIGludCB5LCBpbnQgeCkge1xuICB2ZWM0IHJlc3VsdCA9IGdldEltYWdlMkQodGV4LCB0ZXhTaXplLCB0ZXhEaW0sIHosIHksIHgpO1xuICByZXR1cm4gdmVjMyhyZXN1bHRbMF0sIHJlc3VsdFsxXSwgcmVzdWx0WzJdKTtcbn1cblxudmVjMyBnZXRNZW1vcnlPcHRpbWl6ZWRWZWMzKHNhbXBsZXIyRCB0ZXgsIGl2ZWMyIHRleFNpemUsIGl2ZWMzIHRleERpbSwgaW50IHosIGludCB5LCBpbnQgeCkge1xuICBpbnQgZmllbGRJbmRleCA9IDMgKiAoeCArIHRleERpbS54ICogKHkgKyB0ZXhEaW0ueSAqIHopKTtcbiAgaW50IHZlY3RvckluZGV4ID0gZmllbGRJbmRleCAvIDQ7XG4gIGludCB2ZWN0b3JPZmZzZXQgPSBmaWVsZEluZGV4IC0gdmVjdG9ySW5kZXggKiA0O1xuICBpbnQgcmVhZFkgPSB2ZWN0b3JJbmRleCAvIHRleFNpemUueDtcbiAgaW50IHJlYWRYID0gdmVjdG9ySW5kZXggLSByZWFkWSAqIHRleFNpemUueDtcbiAgdmVjNCB0ZXgxID0gdGV4dHVyZSh0ZXgsICh2ZWMyKHJlYWRYLCByZWFkWSkgKyAwLjUpIC8gdmVjMih0ZXhTaXplKSk7XG5cbiAgaWYgKHZlY3Rvck9mZnNldCA9PSAwKSB7XG4gICAgcmV0dXJuIHRleDEueHl6O1xuICB9IGVsc2UgaWYgKHZlY3Rvck9mZnNldCA9PSAxKSB7XG4gICAgcmV0dXJuIHRleDEueXp3O1xuICB9IGVsc2Uge1xuICAgIHJlYWRYKys7XG4gICAgaWYgKHJlYWRYID49IHRleFNpemUueCkge1xuICAgICAgcmVhZFggPSAwO1xuICAgICAgcmVhZFkrKztcbiAgICB9XG4gICAgdmVjNCB0ZXgyID0gdGV4dHVyZSh0ZXgsIHZlYzIocmVhZFgsIHJlYWRZKSAvIHZlYzIodGV4U2l6ZSkpO1xuICAgIGlmICh2ZWN0b3JPZmZzZXQgPT0gMikge1xuICAgICAgcmV0dXJuIHZlYzModGV4MS56LCB0ZXgxLncsIHRleDIueCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB2ZWMzKHRleDEudywgdGV4Mi54LCB0ZXgyLnkpO1xuICAgIH1cbiAgfVxufVxuXG52ZWM0IGdldFZlYzRGcm9tU2FtcGxlcjJEKHNhbXBsZXIyRCB0ZXgsIGl2ZWMyIHRleFNpemUsIGl2ZWMzIHRleERpbSwgaW50IHosIGludCB5LCBpbnQgeCkge1xuICByZXR1cm4gZ2V0SW1hZ2UyRCh0ZXgsIHRleFNpemUsIHRleERpbSwgeiwgeSwgeCk7XG59XG5cbnZlYzQgZ2V0TWVtb3J5T3B0aW1pemVkVmVjNChzYW1wbGVyMkQgdGV4LCBpdmVjMiB0ZXhTaXplLCBpdmVjMyB0ZXhEaW0sIGludCB6LCBpbnQgeSwgaW50IHgpIHtcbiAgaW50IGluZGV4ID0geCArIHRleERpbS54ICogKHkgKyB0ZXhEaW0ueSAqIHopO1xuICBpbnQgY2hhbm5lbCA9IGludGVnZXJNb2QoaW5kZXgsIDIpO1xuICBpbnQgdyA9IHRleFNpemUueDtcbiAgdmVjMiBzdCA9IHZlYzIoZmxvYXQoaW50ZWdlck1vZChpbmRleCwgdykpLCBmbG9hdChpbmRleCAvIHcpKSArIDAuNTtcbiAgdmVjNCB0ZXhlbCA9IHRleHR1cmUodGV4LCBzdCAvIHZlYzIodGV4U2l6ZSkpO1xuICByZXR1cm4gdmVjNCh0ZXhlbC5yLCB0ZXhlbC5nLCB0ZXhlbC5iLCB0ZXhlbC5hKTtcbn1cblxudmVjNCBhY3R1YWxDb2xvcjtcbnZvaWQgY29sb3IoZmxvYXQgciwgZmxvYXQgZywgZmxvYXQgYiwgZmxvYXQgYSkge1xuICBhY3R1YWxDb2xvciA9IHZlYzQocixnLGIsYSk7XG59XG5cbnZvaWQgY29sb3IoZmxvYXQgciwgZmxvYXQgZywgZmxvYXQgYikge1xuICBjb2xvcihyLGcsYiwxLjApO1xufVxuXG5mbG9hdCBtb2R1bG8oZmxvYXQgbnVtYmVyLCBmbG9hdCBkaXZpc29yKSB7XG4gIGlmIChudW1iZXIgPCAwLjApIHtcbiAgICBudW1iZXIgPSBhYnMobnVtYmVyKTtcbiAgICBpZiAoZGl2aXNvciA8IDAuMCkge1xuICAgICAgZGl2aXNvciA9IGFicyhkaXZpc29yKTtcbiAgICB9XG4gICAgcmV0dXJuIC1tb2QobnVtYmVyLCBkaXZpc29yKTtcbiAgfVxuICBpZiAoZGl2aXNvciA8IDAuMCkge1xuICAgIGRpdmlzb3IgPSBhYnMoZGl2aXNvcik7XG4gIH1cbiAgcmV0dXJuIG1vZChudW1iZXIsIGRpdmlzb3IpO1xufVxuXG5fX0lOSkVDVEVEX05BVElWRV9fO1xuX19NQUlOX0NPTlNUQU5UU19fO1xuX19NQUlOX0FSR1VNRU5UU19fO1xuX19LRVJORUxfXztcblxudm9pZCBtYWluKHZvaWQpIHtcbiAgaW5kZXggPSBpbnQodlRleENvb3JkLnMgKiBmbG9hdCh1VGV4U2l6ZS54KSkgKyBpbnQodlRleENvb3JkLnQgKiBmbG9hdCh1VGV4U2l6ZS55KSkgKiB1VGV4U2l6ZS54O1xuICBfX01BSU5fUkVTVUxUX187XG59YDtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGZyYWdtZW50U2hhZGVyXG59O1xufSx7fV0sNzM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHsgV2ViR0xGdW5jdGlvbk5vZGUgfSA9IHJlcXVpcmUoJy4uL3dlYi1nbC9mdW5jdGlvbi1ub2RlJyk7XG5cbmNsYXNzIFdlYkdMMkZ1bmN0aW9uTm9kZSBleHRlbmRzIFdlYkdMRnVuY3Rpb25Ob2RlIHtcblxuICBhc3RJZGVudGlmaWVyRXhwcmVzc2lvbihpZHROb2RlLCByZXRBcnIpIHtcbiAgICBpZiAoaWR0Tm9kZS50eXBlICE9PSAnSWRlbnRpZmllcicpIHtcbiAgICAgIHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoXG4gICAgICAgICdJZGVudGlmaWVyRXhwcmVzc2lvbiAtIG5vdCBhbiBJZGVudGlmaWVyJyxcbiAgICAgICAgaWR0Tm9kZVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBjb25zdCB0eXBlID0gdGhpcy5nZXRUeXBlKGlkdE5vZGUpO1xuXG4gICAgY29uc3QgbmFtZSA9IHV0aWxzLnNhbml0aXplTmFtZShpZHROb2RlLm5hbWUpO1xuICAgIGlmIChpZHROb2RlLm5hbWUgPT09ICdJbmZpbml0eScpIHtcbiAgICAgIHJldEFyci5wdXNoKCdpbnRCaXRzVG9GbG9hdCgyMTM5MDk1MDM5KScpO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ0Jvb2xlYW4nKSB7XG4gICAgICBpZiAodGhpcy5hcmd1bWVudE5hbWVzLmluZGV4T2YobmFtZSkgPiAtMSkge1xuICAgICAgICByZXRBcnIucHVzaChgYm9vbCh1c2VyXyR7bmFtZX0pYCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXRBcnIucHVzaChgdXNlcl8ke25hbWV9YCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldEFyci5wdXNoKGB1c2VyXyR7bmFtZX1gKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0QXJyO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBXZWJHTDJGdW5jdGlvbk5vZGVcbn07XG59LHtcIi4uLy4uL3V0aWxzXCI6MTE0LFwiLi4vd2ViLWdsL2Z1bmN0aW9uLW5vZGVcIjozOH1dLDc0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgV2ViR0wyS2VybmVsVmFsdWVCb29sZWFuIH0gPSByZXF1aXJlKCcuL2tlcm5lbC12YWx1ZS9ib29sZWFuJyk7XG5jb25zdCB7IFdlYkdMMktlcm5lbFZhbHVlRmxvYXQgfSA9IHJlcXVpcmUoJy4va2VybmVsLXZhbHVlL2Zsb2F0Jyk7XG5jb25zdCB7IFdlYkdMMktlcm5lbFZhbHVlSW50ZWdlciB9ID0gcmVxdWlyZSgnLi9rZXJuZWwtdmFsdWUvaW50ZWdlcicpO1xuXG5jb25zdCB7IFdlYkdMMktlcm5lbFZhbHVlSFRNTEltYWdlIH0gPSByZXF1aXJlKCcuL2tlcm5lbC12YWx1ZS9odG1sLWltYWdlJyk7XG5jb25zdCB7IFdlYkdMMktlcm5lbFZhbHVlRHluYW1pY0hUTUxJbWFnZSB9ID0gcmVxdWlyZSgnLi9rZXJuZWwtdmFsdWUvZHluYW1pYy1odG1sLWltYWdlJyk7XG5cbmNvbnN0IHsgV2ViR0wyS2VybmVsVmFsdWVIVE1MSW1hZ2VBcnJheSB9ID0gcmVxdWlyZSgnLi9rZXJuZWwtdmFsdWUvaHRtbC1pbWFnZS1hcnJheScpO1xuY29uc3QgeyBXZWJHTDJLZXJuZWxWYWx1ZUR5bmFtaWNIVE1MSW1hZ2VBcnJheSB9ID0gcmVxdWlyZSgnLi9rZXJuZWwtdmFsdWUvZHluYW1pYy1odG1sLWltYWdlLWFycmF5Jyk7XG5cbmNvbnN0IHsgV2ViR0wyS2VybmVsVmFsdWVIVE1MVmlkZW8gfSA9IHJlcXVpcmUoJy4va2VybmVsLXZhbHVlL2h0bWwtdmlkZW8nKTtcbmNvbnN0IHsgV2ViR0wyS2VybmVsVmFsdWVEeW5hbWljSFRNTFZpZGVvIH0gPSByZXF1aXJlKCcuL2tlcm5lbC12YWx1ZS9keW5hbWljLWh0bWwtdmlkZW8nKTtcblxuY29uc3QgeyBXZWJHTDJLZXJuZWxWYWx1ZVNpbmdsZUlucHV0IH0gPSByZXF1aXJlKCcuL2tlcm5lbC12YWx1ZS9zaW5nbGUtaW5wdXQnKTtcbmNvbnN0IHsgV2ViR0wyS2VybmVsVmFsdWVEeW5hbWljU2luZ2xlSW5wdXQgfSA9IHJlcXVpcmUoJy4va2VybmVsLXZhbHVlL2R5bmFtaWMtc2luZ2xlLWlucHV0Jyk7XG5cbmNvbnN0IHsgV2ViR0wyS2VybmVsVmFsdWVVbnNpZ25lZElucHV0IH0gPSByZXF1aXJlKCcuL2tlcm5lbC12YWx1ZS91bnNpZ25lZC1pbnB1dCcpO1xuY29uc3QgeyBXZWJHTDJLZXJuZWxWYWx1ZUR5bmFtaWNVbnNpZ25lZElucHV0IH0gPSByZXF1aXJlKCcuL2tlcm5lbC12YWx1ZS9keW5hbWljLXVuc2lnbmVkLWlucHV0Jyk7XG5cbmNvbnN0IHsgV2ViR0wyS2VybmVsVmFsdWVNZW1vcnlPcHRpbWl6ZWROdW1iZXJUZXh0dXJlIH0gPSByZXF1aXJlKCcuL2tlcm5lbC12YWx1ZS9tZW1vcnktb3B0aW1pemVkLW51bWJlci10ZXh0dXJlJyk7XG5jb25zdCB7IFdlYkdMMktlcm5lbFZhbHVlRHluYW1pY01lbW9yeU9wdGltaXplZE51bWJlclRleHR1cmUgfSA9IHJlcXVpcmUoJy4va2VybmVsLXZhbHVlL2R5bmFtaWMtbWVtb3J5LW9wdGltaXplZC1udW1iZXItdGV4dHVyZScpO1xuXG5jb25zdCB7IFdlYkdMMktlcm5lbFZhbHVlTnVtYmVyVGV4dHVyZSB9ID0gcmVxdWlyZSgnLi9rZXJuZWwtdmFsdWUvbnVtYmVyLXRleHR1cmUnKTtcbmNvbnN0IHsgV2ViR0wyS2VybmVsVmFsdWVEeW5hbWljTnVtYmVyVGV4dHVyZSB9ID0gcmVxdWlyZSgnLi9rZXJuZWwtdmFsdWUvZHluYW1pYy1udW1iZXItdGV4dHVyZScpO1xuXG5jb25zdCB7IFdlYkdMMktlcm5lbFZhbHVlU2luZ2xlQXJyYXkgfSA9IHJlcXVpcmUoJy4va2VybmVsLXZhbHVlL3NpbmdsZS1hcnJheScpO1xuY29uc3QgeyBXZWJHTDJLZXJuZWxWYWx1ZUR5bmFtaWNTaW5nbGVBcnJheSB9ID0gcmVxdWlyZSgnLi9rZXJuZWwtdmFsdWUvZHluYW1pYy1zaW5nbGUtYXJyYXknKTtcblxuY29uc3QgeyBXZWJHTDJLZXJuZWxWYWx1ZVNpbmdsZUFycmF5MURJIH0gPSByZXF1aXJlKCcuL2tlcm5lbC12YWx1ZS9zaW5nbGUtYXJyYXkxZC1pJyk7XG5jb25zdCB7IFdlYkdMMktlcm5lbFZhbHVlRHluYW1pY1NpbmdsZUFycmF5MURJIH0gPSByZXF1aXJlKCcuL2tlcm5lbC12YWx1ZS9keW5hbWljLXNpbmdsZS1hcnJheTFkLWknKTtcblxuY29uc3QgeyBXZWJHTDJLZXJuZWxWYWx1ZVNpbmdsZUFycmF5MkRJIH0gPSByZXF1aXJlKCcuL2tlcm5lbC12YWx1ZS9zaW5nbGUtYXJyYXkyZC1pJyk7XG5jb25zdCB7IFdlYkdMMktlcm5lbFZhbHVlRHluYW1pY1NpbmdsZUFycmF5MkRJIH0gPSByZXF1aXJlKCcuL2tlcm5lbC12YWx1ZS9keW5hbWljLXNpbmdsZS1hcnJheTJkLWknKTtcblxuY29uc3QgeyBXZWJHTDJLZXJuZWxWYWx1ZVNpbmdsZUFycmF5M0RJIH0gPSByZXF1aXJlKCcuL2tlcm5lbC12YWx1ZS9zaW5nbGUtYXJyYXkzZC1pJyk7XG5jb25zdCB7IFdlYkdMMktlcm5lbFZhbHVlRHluYW1pY1NpbmdsZUFycmF5M0RJIH0gPSByZXF1aXJlKCcuL2tlcm5lbC12YWx1ZS9keW5hbWljLXNpbmdsZS1hcnJheTNkLWknKTtcblxuY29uc3QgeyBXZWJHTDJLZXJuZWxWYWx1ZUFycmF5MiB9ID0gcmVxdWlyZSgnLi9rZXJuZWwtdmFsdWUvYXJyYXkyJyk7XG5jb25zdCB7IFdlYkdMMktlcm5lbFZhbHVlQXJyYXkzIH0gPSByZXF1aXJlKCcuL2tlcm5lbC12YWx1ZS9hcnJheTMnKTtcbmNvbnN0IHsgV2ViR0wyS2VybmVsVmFsdWVBcnJheTQgfSA9IHJlcXVpcmUoJy4va2VybmVsLXZhbHVlL2FycmF5NCcpO1xuXG5jb25zdCB7IFdlYkdMMktlcm5lbFZhbHVlVW5zaWduZWRBcnJheSB9ID0gcmVxdWlyZSgnLi9rZXJuZWwtdmFsdWUvdW5zaWduZWQtYXJyYXknKTtcbmNvbnN0IHsgV2ViR0wyS2VybmVsVmFsdWVEeW5hbWljVW5zaWduZWRBcnJheSB9ID0gcmVxdWlyZSgnLi9rZXJuZWwtdmFsdWUvZHluYW1pYy11bnNpZ25lZC1hcnJheScpO1xuXG5jb25zdCBrZXJuZWxWYWx1ZU1hcHMgPSB7XG4gIHVuc2lnbmVkOiB7XG4gICAgZHluYW1pYzoge1xuICAgICAgJ0Jvb2xlYW4nOiBXZWJHTDJLZXJuZWxWYWx1ZUJvb2xlYW4sXG4gICAgICAnSW50ZWdlcic6IFdlYkdMMktlcm5lbFZhbHVlSW50ZWdlcixcbiAgICAgICdGbG9hdCc6IFdlYkdMMktlcm5lbFZhbHVlRmxvYXQsXG4gICAgICAnQXJyYXknOiBXZWJHTDJLZXJuZWxWYWx1ZUR5bmFtaWNVbnNpZ25lZEFycmF5LFxuICAgICAgJ0FycmF5KDIpJzogV2ViR0wyS2VybmVsVmFsdWVBcnJheTIsXG4gICAgICAnQXJyYXkoMyknOiBXZWJHTDJLZXJuZWxWYWx1ZUFycmF5MyxcbiAgICAgICdBcnJheSg0KSc6IFdlYkdMMktlcm5lbFZhbHVlQXJyYXk0LFxuICAgICAgJ0FycmF5MUQoMiknOiBmYWxzZSxcbiAgICAgICdBcnJheTFEKDMpJzogZmFsc2UsXG4gICAgICAnQXJyYXkxRCg0KSc6IGZhbHNlLFxuICAgICAgJ0FycmF5MkQoMiknOiBmYWxzZSxcbiAgICAgICdBcnJheTJEKDMpJzogZmFsc2UsXG4gICAgICAnQXJyYXkyRCg0KSc6IGZhbHNlLFxuICAgICAgJ0FycmF5M0QoMiknOiBmYWxzZSxcbiAgICAgICdBcnJheTNEKDMpJzogZmFsc2UsXG4gICAgICAnQXJyYXkzRCg0KSc6IGZhbHNlLFxuICAgICAgJ0lucHV0JzogV2ViR0wyS2VybmVsVmFsdWVEeW5hbWljVW5zaWduZWRJbnB1dCxcbiAgICAgICdOdW1iZXJUZXh0dXJlJzogV2ViR0wyS2VybmVsVmFsdWVEeW5hbWljTnVtYmVyVGV4dHVyZSxcbiAgICAgICdBcnJheVRleHR1cmUoMSknOiBXZWJHTDJLZXJuZWxWYWx1ZUR5bmFtaWNOdW1iZXJUZXh0dXJlLFxuICAgICAgJ0FycmF5VGV4dHVyZSgyKSc6IFdlYkdMMktlcm5lbFZhbHVlRHluYW1pY051bWJlclRleHR1cmUsXG4gICAgICAnQXJyYXlUZXh0dXJlKDMpJzogV2ViR0wyS2VybmVsVmFsdWVEeW5hbWljTnVtYmVyVGV4dHVyZSxcbiAgICAgICdBcnJheVRleHR1cmUoNCknOiBXZWJHTDJLZXJuZWxWYWx1ZUR5bmFtaWNOdW1iZXJUZXh0dXJlLFxuICAgICAgJ01lbW9yeU9wdGltaXplZE51bWJlclRleHR1cmUnOiBXZWJHTDJLZXJuZWxWYWx1ZUR5bmFtaWNNZW1vcnlPcHRpbWl6ZWROdW1iZXJUZXh0dXJlLFxuICAgICAgJ0hUTUxDYW52YXMnOiBXZWJHTDJLZXJuZWxWYWx1ZUR5bmFtaWNIVE1MSW1hZ2UsXG4gICAgICAnT2Zmc2NyZWVuQ2FudmFzJzogV2ViR0wyS2VybmVsVmFsdWVEeW5hbWljSFRNTEltYWdlLFxuICAgICAgJ0hUTUxJbWFnZSc6IFdlYkdMMktlcm5lbFZhbHVlRHluYW1pY0hUTUxJbWFnZSxcbiAgICAgICdJbWFnZUJpdG1hcCc6IFdlYkdMMktlcm5lbFZhbHVlRHluYW1pY0hUTUxJbWFnZSxcbiAgICAgICdJbWFnZURhdGEnOiBXZWJHTDJLZXJuZWxWYWx1ZUR5bmFtaWNIVE1MSW1hZ2UsXG4gICAgICAnSFRNTEltYWdlQXJyYXknOiBXZWJHTDJLZXJuZWxWYWx1ZUR5bmFtaWNIVE1MSW1hZ2VBcnJheSxcbiAgICAgICdIVE1MVmlkZW8nOiBXZWJHTDJLZXJuZWxWYWx1ZUR5bmFtaWNIVE1MVmlkZW8sXG4gICAgfSxcbiAgICBzdGF0aWM6IHtcbiAgICAgICdCb29sZWFuJzogV2ViR0wyS2VybmVsVmFsdWVCb29sZWFuLFxuICAgICAgJ0Zsb2F0JzogV2ViR0wyS2VybmVsVmFsdWVGbG9hdCxcbiAgICAgICdJbnRlZ2VyJzogV2ViR0wyS2VybmVsVmFsdWVJbnRlZ2VyLFxuICAgICAgJ0FycmF5JzogV2ViR0wyS2VybmVsVmFsdWVVbnNpZ25lZEFycmF5LFxuICAgICAgJ0FycmF5KDIpJzogV2ViR0wyS2VybmVsVmFsdWVBcnJheTIsXG4gICAgICAnQXJyYXkoMyknOiBXZWJHTDJLZXJuZWxWYWx1ZUFycmF5MyxcbiAgICAgICdBcnJheSg0KSc6IFdlYkdMMktlcm5lbFZhbHVlQXJyYXk0LFxuICAgICAgJ0FycmF5MUQoMiknOiBmYWxzZSxcbiAgICAgICdBcnJheTFEKDMpJzogZmFsc2UsXG4gICAgICAnQXJyYXkxRCg0KSc6IGZhbHNlLFxuICAgICAgJ0FycmF5MkQoMiknOiBmYWxzZSxcbiAgICAgICdBcnJheTJEKDMpJzogZmFsc2UsXG4gICAgICAnQXJyYXkyRCg0KSc6IGZhbHNlLFxuICAgICAgJ0FycmF5M0QoMiknOiBmYWxzZSxcbiAgICAgICdBcnJheTNEKDMpJzogZmFsc2UsXG4gICAgICAnQXJyYXkzRCg0KSc6IGZhbHNlLFxuICAgICAgJ0lucHV0JzogV2ViR0wyS2VybmVsVmFsdWVVbnNpZ25lZElucHV0LFxuICAgICAgJ051bWJlclRleHR1cmUnOiBXZWJHTDJLZXJuZWxWYWx1ZU51bWJlclRleHR1cmUsXG4gICAgICAnQXJyYXlUZXh0dXJlKDEpJzogV2ViR0wyS2VybmVsVmFsdWVOdW1iZXJUZXh0dXJlLFxuICAgICAgJ0FycmF5VGV4dHVyZSgyKSc6IFdlYkdMMktlcm5lbFZhbHVlTnVtYmVyVGV4dHVyZSxcbiAgICAgICdBcnJheVRleHR1cmUoMyknOiBXZWJHTDJLZXJuZWxWYWx1ZU51bWJlclRleHR1cmUsXG4gICAgICAnQXJyYXlUZXh0dXJlKDQpJzogV2ViR0wyS2VybmVsVmFsdWVOdW1iZXJUZXh0dXJlLFxuICAgICAgJ01lbW9yeU9wdGltaXplZE51bWJlclRleHR1cmUnOiBXZWJHTDJLZXJuZWxWYWx1ZUR5bmFtaWNNZW1vcnlPcHRpbWl6ZWROdW1iZXJUZXh0dXJlLFxuICAgICAgJ0hUTUxDYW52YXMnOiBXZWJHTDJLZXJuZWxWYWx1ZUhUTUxJbWFnZSxcbiAgICAgICdPZmZzY3JlZW5DYW52YXMnOiBXZWJHTDJLZXJuZWxWYWx1ZUhUTUxJbWFnZSxcbiAgICAgICdIVE1MSW1hZ2UnOiBXZWJHTDJLZXJuZWxWYWx1ZUhUTUxJbWFnZSxcbiAgICAgICdJbWFnZUJpdG1hcCc6IFdlYkdMMktlcm5lbFZhbHVlSFRNTEltYWdlLFxuICAgICAgJ0ltYWdlRGF0YSc6IFdlYkdMMktlcm5lbFZhbHVlSFRNTEltYWdlLFxuICAgICAgJ0hUTUxJbWFnZUFycmF5JzogV2ViR0wyS2VybmVsVmFsdWVIVE1MSW1hZ2VBcnJheSxcbiAgICAgICdIVE1MVmlkZW8nOiBXZWJHTDJLZXJuZWxWYWx1ZUhUTUxWaWRlbyxcbiAgICB9XG4gIH0sXG4gIHNpbmdsZToge1xuICAgIGR5bmFtaWM6IHtcbiAgICAgICdCb29sZWFuJzogV2ViR0wyS2VybmVsVmFsdWVCb29sZWFuLFxuICAgICAgJ0ludGVnZXInOiBXZWJHTDJLZXJuZWxWYWx1ZUludGVnZXIsXG4gICAgICAnRmxvYXQnOiBXZWJHTDJLZXJuZWxWYWx1ZUZsb2F0LFxuICAgICAgJ0FycmF5JzogV2ViR0wyS2VybmVsVmFsdWVEeW5hbWljU2luZ2xlQXJyYXksXG4gICAgICAnQXJyYXkoMiknOiBXZWJHTDJLZXJuZWxWYWx1ZUFycmF5MixcbiAgICAgICdBcnJheSgzKSc6IFdlYkdMMktlcm5lbFZhbHVlQXJyYXkzLFxuICAgICAgJ0FycmF5KDQpJzogV2ViR0wyS2VybmVsVmFsdWVBcnJheTQsXG4gICAgICAnQXJyYXkxRCgyKSc6IFdlYkdMMktlcm5lbFZhbHVlRHluYW1pY1NpbmdsZUFycmF5MURJLFxuICAgICAgJ0FycmF5MUQoMyknOiBXZWJHTDJLZXJuZWxWYWx1ZUR5bmFtaWNTaW5nbGVBcnJheTFESSxcbiAgICAgICdBcnJheTFEKDQpJzogV2ViR0wyS2VybmVsVmFsdWVEeW5hbWljU2luZ2xlQXJyYXkxREksXG4gICAgICAnQXJyYXkyRCgyKSc6IFdlYkdMMktlcm5lbFZhbHVlRHluYW1pY1NpbmdsZUFycmF5MkRJLFxuICAgICAgJ0FycmF5MkQoMyknOiBXZWJHTDJLZXJuZWxWYWx1ZUR5bmFtaWNTaW5nbGVBcnJheTJESSxcbiAgICAgICdBcnJheTJEKDQpJzogV2ViR0wyS2VybmVsVmFsdWVEeW5hbWljU2luZ2xlQXJyYXkyREksXG4gICAgICAnQXJyYXkzRCgyKSc6IFdlYkdMMktlcm5lbFZhbHVlRHluYW1pY1NpbmdsZUFycmF5M0RJLFxuICAgICAgJ0FycmF5M0QoMyknOiBXZWJHTDJLZXJuZWxWYWx1ZUR5bmFtaWNTaW5nbGVBcnJheTNESSxcbiAgICAgICdBcnJheTNEKDQpJzogV2ViR0wyS2VybmVsVmFsdWVEeW5hbWljU2luZ2xlQXJyYXkzREksXG4gICAgICAnSW5wdXQnOiBXZWJHTDJLZXJuZWxWYWx1ZUR5bmFtaWNTaW5nbGVJbnB1dCxcbiAgICAgICdOdW1iZXJUZXh0dXJlJzogV2ViR0wyS2VybmVsVmFsdWVEeW5hbWljTnVtYmVyVGV4dHVyZSxcbiAgICAgICdBcnJheVRleHR1cmUoMSknOiBXZWJHTDJLZXJuZWxWYWx1ZUR5bmFtaWNOdW1iZXJUZXh0dXJlLFxuICAgICAgJ0FycmF5VGV4dHVyZSgyKSc6IFdlYkdMMktlcm5lbFZhbHVlRHluYW1pY051bWJlclRleHR1cmUsXG4gICAgICAnQXJyYXlUZXh0dXJlKDMpJzogV2ViR0wyS2VybmVsVmFsdWVEeW5hbWljTnVtYmVyVGV4dHVyZSxcbiAgICAgICdBcnJheVRleHR1cmUoNCknOiBXZWJHTDJLZXJuZWxWYWx1ZUR5bmFtaWNOdW1iZXJUZXh0dXJlLFxuICAgICAgJ01lbW9yeU9wdGltaXplZE51bWJlclRleHR1cmUnOiBXZWJHTDJLZXJuZWxWYWx1ZUR5bmFtaWNNZW1vcnlPcHRpbWl6ZWROdW1iZXJUZXh0dXJlLFxuICAgICAgJ0hUTUxDYW52YXMnOiBXZWJHTDJLZXJuZWxWYWx1ZUR5bmFtaWNIVE1MSW1hZ2UsXG4gICAgICAnT2Zmc2NyZWVuQ2FudmFzJzogV2ViR0wyS2VybmVsVmFsdWVEeW5hbWljSFRNTEltYWdlLFxuICAgICAgJ0hUTUxJbWFnZSc6IFdlYkdMMktlcm5lbFZhbHVlRHluYW1pY0hUTUxJbWFnZSxcbiAgICAgICdJbWFnZUJpdG1hcCc6IFdlYkdMMktlcm5lbFZhbHVlRHluYW1pY0hUTUxJbWFnZSxcbiAgICAgICdJbWFnZURhdGEnOiBXZWJHTDJLZXJuZWxWYWx1ZUR5bmFtaWNIVE1MSW1hZ2UsXG4gICAgICAnSFRNTEltYWdlQXJyYXknOiBXZWJHTDJLZXJuZWxWYWx1ZUR5bmFtaWNIVE1MSW1hZ2VBcnJheSxcbiAgICAgICdIVE1MVmlkZW8nOiBXZWJHTDJLZXJuZWxWYWx1ZUR5bmFtaWNIVE1MVmlkZW8sXG4gICAgfSxcbiAgICBzdGF0aWM6IHtcbiAgICAgICdCb29sZWFuJzogV2ViR0wyS2VybmVsVmFsdWVCb29sZWFuLFxuICAgICAgJ0Zsb2F0JzogV2ViR0wyS2VybmVsVmFsdWVGbG9hdCxcbiAgICAgICdJbnRlZ2VyJzogV2ViR0wyS2VybmVsVmFsdWVJbnRlZ2VyLFxuICAgICAgJ0FycmF5JzogV2ViR0wyS2VybmVsVmFsdWVTaW5nbGVBcnJheSxcbiAgICAgICdBcnJheSgyKSc6IFdlYkdMMktlcm5lbFZhbHVlQXJyYXkyLFxuICAgICAgJ0FycmF5KDMpJzogV2ViR0wyS2VybmVsVmFsdWVBcnJheTMsXG4gICAgICAnQXJyYXkoNCknOiBXZWJHTDJLZXJuZWxWYWx1ZUFycmF5NCxcbiAgICAgICdBcnJheTFEKDIpJzogV2ViR0wyS2VybmVsVmFsdWVTaW5nbGVBcnJheTFESSxcbiAgICAgICdBcnJheTFEKDMpJzogV2ViR0wyS2VybmVsVmFsdWVTaW5nbGVBcnJheTFESSxcbiAgICAgICdBcnJheTFEKDQpJzogV2ViR0wyS2VybmVsVmFsdWVTaW5nbGVBcnJheTFESSxcbiAgICAgICdBcnJheTJEKDIpJzogV2ViR0wyS2VybmVsVmFsdWVTaW5nbGVBcnJheTJESSxcbiAgICAgICdBcnJheTJEKDMpJzogV2ViR0wyS2VybmVsVmFsdWVTaW5nbGVBcnJheTJESSxcbiAgICAgICdBcnJheTJEKDQpJzogV2ViR0wyS2VybmVsVmFsdWVTaW5nbGVBcnJheTJESSxcbiAgICAgICdBcnJheTNEKDIpJzogV2ViR0wyS2VybmVsVmFsdWVTaW5nbGVBcnJheTNESSxcbiAgICAgICdBcnJheTNEKDMpJzogV2ViR0wyS2VybmVsVmFsdWVTaW5nbGVBcnJheTNESSxcbiAgICAgICdBcnJheTNEKDQpJzogV2ViR0wyS2VybmVsVmFsdWVTaW5nbGVBcnJheTNESSxcbiAgICAgICdJbnB1dCc6IFdlYkdMMktlcm5lbFZhbHVlU2luZ2xlSW5wdXQsXG4gICAgICAnTnVtYmVyVGV4dHVyZSc6IFdlYkdMMktlcm5lbFZhbHVlTnVtYmVyVGV4dHVyZSxcbiAgICAgICdBcnJheVRleHR1cmUoMSknOiBXZWJHTDJLZXJuZWxWYWx1ZU51bWJlclRleHR1cmUsXG4gICAgICAnQXJyYXlUZXh0dXJlKDIpJzogV2ViR0wyS2VybmVsVmFsdWVOdW1iZXJUZXh0dXJlLFxuICAgICAgJ0FycmF5VGV4dHVyZSgzKSc6IFdlYkdMMktlcm5lbFZhbHVlTnVtYmVyVGV4dHVyZSxcbiAgICAgICdBcnJheVRleHR1cmUoNCknOiBXZWJHTDJLZXJuZWxWYWx1ZU51bWJlclRleHR1cmUsXG4gICAgICAnTWVtb3J5T3B0aW1pemVkTnVtYmVyVGV4dHVyZSc6IFdlYkdMMktlcm5lbFZhbHVlTWVtb3J5T3B0aW1pemVkTnVtYmVyVGV4dHVyZSxcbiAgICAgICdIVE1MQ2FudmFzJzogV2ViR0wyS2VybmVsVmFsdWVIVE1MSW1hZ2UsXG4gICAgICAnT2Zmc2NyZWVuQ2FudmFzJzogV2ViR0wyS2VybmVsVmFsdWVIVE1MSW1hZ2UsXG4gICAgICAnSFRNTEltYWdlJzogV2ViR0wyS2VybmVsVmFsdWVIVE1MSW1hZ2UsXG4gICAgICAnSW1hZ2VCaXRtYXAnOiBXZWJHTDJLZXJuZWxWYWx1ZUhUTUxJbWFnZSxcbiAgICAgICdJbWFnZURhdGEnOiBXZWJHTDJLZXJuZWxWYWx1ZUhUTUxJbWFnZSxcbiAgICAgICdIVE1MSW1hZ2VBcnJheSc6IFdlYkdMMktlcm5lbFZhbHVlSFRNTEltYWdlQXJyYXksXG4gICAgICAnSFRNTFZpZGVvJzogV2ViR0wyS2VybmVsVmFsdWVIVE1MVmlkZW8sXG4gICAgfVxuICB9LFxufTtcblxuZnVuY3Rpb24gbG9va3VwS2VybmVsVmFsdWVUeXBlKHR5cGUsIGR5bmFtaWMsIHByZWNpc2lvbiwgdmFsdWUpIHtcbiAgaWYgKCF0eXBlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd0eXBlIG1pc3NpbmcnKTtcbiAgfVxuICBpZiAoIWR5bmFtaWMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2R5bmFtaWMgbWlzc2luZycpO1xuICB9XG4gIGlmICghcHJlY2lzaW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcmVjaXNpb24gbWlzc2luZycpO1xuICB9XG4gIGlmICh2YWx1ZS50eXBlKSB7XG4gICAgdHlwZSA9IHZhbHVlLnR5cGU7XG4gIH1cbiAgY29uc3QgdHlwZXMgPSBrZXJuZWxWYWx1ZU1hcHNbcHJlY2lzaW9uXVtkeW5hbWljXTtcbiAgaWYgKHR5cGVzW3R5cGVdID09PSBmYWxzZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9IGVsc2UgaWYgKHR5cGVzW3R5cGVdID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBmaW5kIGEgS2VybmVsVmFsdWUgZm9yICR7IHR5cGUgfWApO1xuICB9XG4gIHJldHVybiB0eXBlc1t0eXBlXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGtlcm5lbFZhbHVlTWFwcyxcbiAgbG9va3VwS2VybmVsVmFsdWVUeXBlXG59O1xufSx7XCIuL2tlcm5lbC12YWx1ZS9hcnJheTJcIjo3NSxcIi4va2VybmVsLXZhbHVlL2FycmF5M1wiOjc2LFwiLi9rZXJuZWwtdmFsdWUvYXJyYXk0XCI6NzcsXCIuL2tlcm5lbC12YWx1ZS9ib29sZWFuXCI6NzgsXCIuL2tlcm5lbC12YWx1ZS9keW5hbWljLWh0bWwtaW1hZ2VcIjo4MCxcIi4va2VybmVsLXZhbHVlL2R5bmFtaWMtaHRtbC1pbWFnZS1hcnJheVwiOjc5LFwiLi9rZXJuZWwtdmFsdWUvZHluYW1pYy1odG1sLXZpZGVvXCI6ODEsXCIuL2tlcm5lbC12YWx1ZS9keW5hbWljLW1lbW9yeS1vcHRpbWl6ZWQtbnVtYmVyLXRleHR1cmVcIjo4MixcIi4va2VybmVsLXZhbHVlL2R5bmFtaWMtbnVtYmVyLXRleHR1cmVcIjo4MyxcIi4va2VybmVsLXZhbHVlL2R5bmFtaWMtc2luZ2xlLWFycmF5XCI6ODQsXCIuL2tlcm5lbC12YWx1ZS9keW5hbWljLXNpbmdsZS1hcnJheTFkLWlcIjo4NSxcIi4va2VybmVsLXZhbHVlL2R5bmFtaWMtc2luZ2xlLWFycmF5MmQtaVwiOjg2LFwiLi9rZXJuZWwtdmFsdWUvZHluYW1pYy1zaW5nbGUtYXJyYXkzZC1pXCI6ODcsXCIuL2tlcm5lbC12YWx1ZS9keW5hbWljLXNpbmdsZS1pbnB1dFwiOjg4LFwiLi9rZXJuZWwtdmFsdWUvZHluYW1pYy11bnNpZ25lZC1hcnJheVwiOjg5LFwiLi9rZXJuZWwtdmFsdWUvZHluYW1pYy11bnNpZ25lZC1pbnB1dFwiOjkwLFwiLi9rZXJuZWwtdmFsdWUvZmxvYXRcIjo5MSxcIi4va2VybmVsLXZhbHVlL2h0bWwtaW1hZ2VcIjo5MyxcIi4va2VybmVsLXZhbHVlL2h0bWwtaW1hZ2UtYXJyYXlcIjo5MixcIi4va2VybmVsLXZhbHVlL2h0bWwtdmlkZW9cIjo5NCxcIi4va2VybmVsLXZhbHVlL2ludGVnZXJcIjo5NSxcIi4va2VybmVsLXZhbHVlL21lbW9yeS1vcHRpbWl6ZWQtbnVtYmVyLXRleHR1cmVcIjo5NixcIi4va2VybmVsLXZhbHVlL251bWJlci10ZXh0dXJlXCI6OTcsXCIuL2tlcm5lbC12YWx1ZS9zaW5nbGUtYXJyYXlcIjo5OCxcIi4va2VybmVsLXZhbHVlL3NpbmdsZS1hcnJheTFkLWlcIjo5OSxcIi4va2VybmVsLXZhbHVlL3NpbmdsZS1hcnJheTJkLWlcIjoxMDAsXCIuL2tlcm5lbC12YWx1ZS9zaW5nbGUtYXJyYXkzZC1pXCI6MTAxLFwiLi9rZXJuZWwtdmFsdWUvc2luZ2xlLWlucHV0XCI6MTAyLFwiLi9rZXJuZWwtdmFsdWUvdW5zaWduZWQtYXJyYXlcIjoxMDMsXCIuL2tlcm5lbC12YWx1ZS91bnNpZ25lZC1pbnB1dFwiOjEwNH1dLDc1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgV2ViR0xLZXJuZWxWYWx1ZUFycmF5MiB9ID0gcmVxdWlyZSgnLi4vLi4vd2ViLWdsL2tlcm5lbC12YWx1ZS9hcnJheTInKTtcblxuY2xhc3MgV2ViR0wyS2VybmVsVmFsdWVBcnJheTIgZXh0ZW5kcyBXZWJHTEtlcm5lbFZhbHVlQXJyYXkyIHt9XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBXZWJHTDJLZXJuZWxWYWx1ZUFycmF5MlxufTtcbn0se1wiLi4vLi4vd2ViLWdsL2tlcm5lbC12YWx1ZS9hcnJheTJcIjo0MX1dLDc2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgV2ViR0xLZXJuZWxWYWx1ZUFycmF5MyB9ID0gcmVxdWlyZSgnLi4vLi4vd2ViLWdsL2tlcm5lbC12YWx1ZS9hcnJheTMnKTtcblxuY2xhc3MgV2ViR0wyS2VybmVsVmFsdWVBcnJheTMgZXh0ZW5kcyBXZWJHTEtlcm5lbFZhbHVlQXJyYXkzIHt9XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBXZWJHTDJLZXJuZWxWYWx1ZUFycmF5M1xufTtcbn0se1wiLi4vLi4vd2ViLWdsL2tlcm5lbC12YWx1ZS9hcnJheTNcIjo0Mn1dLDc3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgV2ViR0xLZXJuZWxWYWx1ZUFycmF5NCB9ID0gcmVxdWlyZSgnLi4vLi4vd2ViLWdsL2tlcm5lbC12YWx1ZS9hcnJheTQnKTtcblxuY2xhc3MgV2ViR0wyS2VybmVsVmFsdWVBcnJheTQgZXh0ZW5kcyBXZWJHTEtlcm5lbFZhbHVlQXJyYXk0IHt9XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBXZWJHTDJLZXJuZWxWYWx1ZUFycmF5NFxufTtcbn0se1wiLi4vLi4vd2ViLWdsL2tlcm5lbC12YWx1ZS9hcnJheTRcIjo0M31dLDc4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgV2ViR0xLZXJuZWxWYWx1ZUJvb2xlYW4gfSA9IHJlcXVpcmUoJy4uLy4uL3dlYi1nbC9rZXJuZWwtdmFsdWUvYm9vbGVhbicpO1xuXG5jbGFzcyBXZWJHTDJLZXJuZWxWYWx1ZUJvb2xlYW4gZXh0ZW5kcyBXZWJHTEtlcm5lbFZhbHVlQm9vbGVhbiB7fVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViR0wyS2VybmVsVmFsdWVCb29sZWFuXG59O1xufSx7XCIuLi8uLi93ZWItZ2wva2VybmVsLXZhbHVlL2Jvb2xlYW5cIjo0NH1dLDc5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzJyk7XG5jb25zdCB7IFdlYkdMMktlcm5lbFZhbHVlSFRNTEltYWdlQXJyYXkgfSA9IHJlcXVpcmUoJy4vaHRtbC1pbWFnZS1hcnJheScpO1xuXG5jbGFzcyBXZWJHTDJLZXJuZWxWYWx1ZUR5bmFtaWNIVE1MSW1hZ2VBcnJheSBleHRlbmRzIFdlYkdMMktlcm5lbFZhbHVlSFRNTEltYWdlQXJyYXkge1xuICBnZXRTb3VyY2UoKSB7XG4gICAgY29uc3QgdmFyaWFibGVQcmVjaXNpb24gPSB0aGlzLmdldFZhcmlhYmxlUHJlY2lzaW9uU3RyaW5nKCk7XG4gICAgcmV0dXJuIHV0aWxzLmxpbmVzVG9TdHJpbmcoW1xuICAgICAgYHVuaWZvcm0gJHsgdmFyaWFibGVQcmVjaXNpb24gfSBzYW1wbGVyMkRBcnJheSAke3RoaXMuaWR9YCxcbiAgICAgIGB1bmlmb3JtICR7IHZhcmlhYmxlUHJlY2lzaW9uIH0gaXZlYzIgJHt0aGlzLnNpemVJZH1gLFxuICAgICAgYHVuaWZvcm0gJHsgdmFyaWFibGVQcmVjaXNpb24gfSBpdmVjMyAke3RoaXMuZGltZW5zaW9uc0lkfWAsXG4gICAgXSk7XG4gIH1cblxuICB1cGRhdGVWYWx1ZShpbWFnZXMpIHtcbiAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IGltYWdlc1swXTtcbiAgICB0aGlzLmNoZWNrU2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICB0aGlzLmRpbWVuc2lvbnMgPSBbd2lkdGgsIGhlaWdodCwgaW1hZ2VzLmxlbmd0aF07XG4gICAgdGhpcy50ZXh0dXJlU2l6ZSA9IFt3aWR0aCwgaGVpZ2h0XTtcbiAgICB0aGlzLmtlcm5lbC5zZXRVbmlmb3JtM2l2KHRoaXMuZGltZW5zaW9uc0lkLCB0aGlzLmRpbWVuc2lvbnMpO1xuICAgIHRoaXMua2VybmVsLnNldFVuaWZvcm0yaXYodGhpcy5zaXplSWQsIHRoaXMudGV4dHVyZVNpemUpO1xuICAgIHN1cGVyLnVwZGF0ZVZhbHVlKGltYWdlcyk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFdlYkdMMktlcm5lbFZhbHVlRHluYW1pY0hUTUxJbWFnZUFycmF5XG59O1xufSx7XCIuLi8uLi8uLi91dGlsc1wiOjExNCxcIi4vaHRtbC1pbWFnZS1hcnJheVwiOjkyfV0sODA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHsgV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNIVE1MSW1hZ2UgfSA9IHJlcXVpcmUoJy4uLy4uL3dlYi1nbC9rZXJuZWwtdmFsdWUvZHluYW1pYy1odG1sLWltYWdlJyk7XG5cbmNsYXNzIFdlYkdMMktlcm5lbFZhbHVlRHluYW1pY0hUTUxJbWFnZSBleHRlbmRzIFdlYkdMS2VybmVsVmFsdWVEeW5hbWljSFRNTEltYWdlIHtcbiAgZ2V0U291cmNlKCkge1xuICAgIGNvbnN0IHZhcmlhYmxlUHJlY2lzaW9uID0gdGhpcy5nZXRWYXJpYWJsZVByZWNpc2lvblN0cmluZygpO1xuICAgIHJldHVybiB1dGlscy5saW5lc1RvU3RyaW5nKFtcbiAgICAgIGB1bmlmb3JtICR7IHZhcmlhYmxlUHJlY2lzaW9uIH0gc2FtcGxlcjJEICR7dGhpcy5pZH1gLFxuICAgICAgYHVuaWZvcm0gJHsgdmFyaWFibGVQcmVjaXNpb24gfSBpdmVjMiAke3RoaXMuc2l6ZUlkfWAsXG4gICAgICBgdW5pZm9ybSAkeyB2YXJpYWJsZVByZWNpc2lvbiB9IGl2ZWMzICR7dGhpcy5kaW1lbnNpb25zSWR9YCxcbiAgICBdKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViR0wyS2VybmVsVmFsdWVEeW5hbWljSFRNTEltYWdlXG59O1xufSx7XCIuLi8uLi8uLi91dGlsc1wiOjExNCxcIi4uLy4uL3dlYi1nbC9rZXJuZWwtdmFsdWUvZHluYW1pYy1odG1sLWltYWdlXCI6NDV9XSw4MTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xuY29uc3QgeyBXZWJHTDJLZXJuZWxWYWx1ZUR5bmFtaWNIVE1MSW1hZ2UgfSA9IHJlcXVpcmUoJy4vZHluYW1pYy1odG1sLWltYWdlJyk7XG5cbmNsYXNzIFdlYkdMMktlcm5lbFZhbHVlRHluYW1pY0hUTUxWaWRlbyBleHRlbmRzIFdlYkdMMktlcm5lbFZhbHVlRHluYW1pY0hUTUxJbWFnZSB7fVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViR0wyS2VybmVsVmFsdWVEeW5hbWljSFRNTFZpZGVvXG59O1xufSx7XCIuLi8uLi8uLi91dGlsc1wiOjExNCxcIi4vZHluYW1pYy1odG1sLWltYWdlXCI6ODB9XSw4MjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xuY29uc3QgeyBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY01lbW9yeU9wdGltaXplZE51bWJlclRleHR1cmUgfSA9IHJlcXVpcmUoJy4uLy4uL3dlYi1nbC9rZXJuZWwtdmFsdWUvZHluYW1pYy1tZW1vcnktb3B0aW1pemVkLW51bWJlci10ZXh0dXJlJyk7XG5cbmNsYXNzIFdlYkdMMktlcm5lbFZhbHVlRHluYW1pY01lbW9yeU9wdGltaXplZE51bWJlclRleHR1cmUgZXh0ZW5kcyBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY01lbW9yeU9wdGltaXplZE51bWJlclRleHR1cmUge1xuICBnZXRTb3VyY2UoKSB7XG4gICAgcmV0dXJuIHV0aWxzLmxpbmVzVG9TdHJpbmcoW1xuICAgICAgYHVuaWZvcm0gc2FtcGxlcjJEICR7dGhpcy5pZH1gLFxuICAgICAgYHVuaWZvcm0gaXZlYzIgJHt0aGlzLnNpemVJZH1gLFxuICAgICAgYHVuaWZvcm0gaXZlYzMgJHt0aGlzLmRpbWVuc2lvbnNJZH1gLFxuICAgIF0pO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBXZWJHTDJLZXJuZWxWYWx1ZUR5bmFtaWNNZW1vcnlPcHRpbWl6ZWROdW1iZXJUZXh0dXJlXG59O1xufSx7XCIuLi8uLi8uLi91dGlsc1wiOjExNCxcIi4uLy4uL3dlYi1nbC9rZXJuZWwtdmFsdWUvZHluYW1pYy1tZW1vcnktb3B0aW1pemVkLW51bWJlci10ZXh0dXJlXCI6NDd9XSw4MzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xuY29uc3QgeyBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY051bWJlclRleHR1cmUgfSA9IHJlcXVpcmUoJy4uLy4uL3dlYi1nbC9rZXJuZWwtdmFsdWUvZHluYW1pYy1udW1iZXItdGV4dHVyZScpO1xuXG5jbGFzcyBXZWJHTDJLZXJuZWxWYWx1ZUR5bmFtaWNOdW1iZXJUZXh0dXJlIGV4dGVuZHMgV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNOdW1iZXJUZXh0dXJlIHtcbiAgZ2V0U291cmNlKCkge1xuICAgIGNvbnN0IHZhcmlhYmxlUHJlY2lzaW9uID0gdGhpcy5nZXRWYXJpYWJsZVByZWNpc2lvblN0cmluZygpO1xuICAgIHJldHVybiB1dGlscy5saW5lc1RvU3RyaW5nKFtcbiAgICAgIGB1bmlmb3JtICR7IHZhcmlhYmxlUHJlY2lzaW9uIH0gc2FtcGxlcjJEICR7dGhpcy5pZH1gLFxuICAgICAgYHVuaWZvcm0gJHsgdmFyaWFibGVQcmVjaXNpb24gfSBpdmVjMiAke3RoaXMuc2l6ZUlkfWAsXG4gICAgICBgdW5pZm9ybSAkeyB2YXJpYWJsZVByZWNpc2lvbiB9IGl2ZWMzICR7dGhpcy5kaW1lbnNpb25zSWR9YCxcbiAgICBdKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViR0wyS2VybmVsVmFsdWVEeW5hbWljTnVtYmVyVGV4dHVyZVxufTtcbn0se1wiLi4vLi4vLi4vdXRpbHNcIjoxMTQsXCIuLi8uLi93ZWItZ2wva2VybmVsLXZhbHVlL2R5bmFtaWMtbnVtYmVyLXRleHR1cmVcIjo0OH1dLDg0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzJyk7XG5jb25zdCB7IFdlYkdMMktlcm5lbFZhbHVlU2luZ2xlQXJyYXkgfSA9IHJlcXVpcmUoJy4uLy4uL3dlYi1nbDIva2VybmVsLXZhbHVlL3NpbmdsZS1hcnJheScpO1xuXG5jbGFzcyBXZWJHTDJLZXJuZWxWYWx1ZUR5bmFtaWNTaW5nbGVBcnJheSBleHRlbmRzIFdlYkdMMktlcm5lbFZhbHVlU2luZ2xlQXJyYXkge1xuICBnZXRTb3VyY2UoKSB7XG4gICAgY29uc3QgdmFyaWFibGVQcmVjaXNpb24gPSB0aGlzLmdldFZhcmlhYmxlUHJlY2lzaW9uU3RyaW5nKCk7XG4gICAgcmV0dXJuIHV0aWxzLmxpbmVzVG9TdHJpbmcoW1xuICAgICAgYHVuaWZvcm0gJHsgdmFyaWFibGVQcmVjaXNpb24gfSBzYW1wbGVyMkQgJHt0aGlzLmlkfWAsXG4gICAgICBgdW5pZm9ybSAkeyB2YXJpYWJsZVByZWNpc2lvbiB9IGl2ZWMyICR7dGhpcy5zaXplSWR9YCxcbiAgICAgIGB1bmlmb3JtICR7IHZhcmlhYmxlUHJlY2lzaW9uIH0gaXZlYzMgJHt0aGlzLmRpbWVuc2lvbnNJZH1gLFxuICAgIF0pO1xuICB9XG5cbiAgdXBkYXRlVmFsdWUodmFsdWUpIHtcbiAgICB0aGlzLmRpbWVuc2lvbnMgPSB1dGlscy5nZXREaW1lbnNpb25zKHZhbHVlLCB0cnVlKTtcbiAgICB0aGlzLnRleHR1cmVTaXplID0gdXRpbHMuZ2V0TWVtb3J5T3B0aW1pemVkRmxvYXRUZXh0dXJlU2l6ZSh0aGlzLmRpbWVuc2lvbnMsIHRoaXMuYml0UmF0aW8pO1xuICAgIHRoaXMudXBsb2FkQXJyYXlMZW5ndGggPSB0aGlzLnRleHR1cmVTaXplWzBdICogdGhpcy50ZXh0dXJlU2l6ZVsxXSAqIHRoaXMuYml0UmF0aW87XG4gICAgdGhpcy5jaGVja1NpemUodGhpcy50ZXh0dXJlU2l6ZVswXSwgdGhpcy50ZXh0dXJlU2l6ZVsxXSk7XG4gICAgdGhpcy51cGxvYWRWYWx1ZSA9IG5ldyBGbG9hdDMyQXJyYXkodGhpcy51cGxvYWRBcnJheUxlbmd0aCk7XG4gICAgdGhpcy5rZXJuZWwuc2V0VW5pZm9ybTNpdih0aGlzLmRpbWVuc2lvbnNJZCwgdGhpcy5kaW1lbnNpb25zKTtcbiAgICB0aGlzLmtlcm5lbC5zZXRVbmlmb3JtMml2KHRoaXMuc2l6ZUlkLCB0aGlzLnRleHR1cmVTaXplKTtcbiAgICBzdXBlci51cGRhdGVWYWx1ZSh2YWx1ZSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFdlYkdMMktlcm5lbFZhbHVlRHluYW1pY1NpbmdsZUFycmF5XG59O1xufSx7XCIuLi8uLi8uLi91dGlsc1wiOjExNCxcIi4uLy4uL3dlYi1nbDIva2VybmVsLXZhbHVlL3NpbmdsZS1hcnJheVwiOjk4fV0sODU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHsgV2ViR0wyS2VybmVsVmFsdWVTaW5nbGVBcnJheTFESSB9ID0gcmVxdWlyZSgnLi4vLi4vd2ViLWdsMi9rZXJuZWwtdmFsdWUvc2luZ2xlLWFycmF5MWQtaScpO1xuXG5jbGFzcyBXZWJHTDJLZXJuZWxWYWx1ZUR5bmFtaWNTaW5nbGVBcnJheTFESSBleHRlbmRzIFdlYkdMMktlcm5lbFZhbHVlU2luZ2xlQXJyYXkxREkge1xuICBnZXRTb3VyY2UoKSB7XG4gICAgY29uc3QgdmFyaWFibGVQcmVjaXNpb24gPSB0aGlzLmdldFZhcmlhYmxlUHJlY2lzaW9uU3RyaW5nKCk7XG4gICAgcmV0dXJuIHV0aWxzLmxpbmVzVG9TdHJpbmcoW1xuICAgICAgYHVuaWZvcm0gJHsgdmFyaWFibGVQcmVjaXNpb24gfSBzYW1wbGVyMkQgJHt0aGlzLmlkfWAsXG4gICAgICBgdW5pZm9ybSAkeyB2YXJpYWJsZVByZWNpc2lvbiB9IGl2ZWMyICR7dGhpcy5zaXplSWR9YCxcbiAgICAgIGB1bmlmb3JtICR7IHZhcmlhYmxlUHJlY2lzaW9uIH0gaXZlYzMgJHt0aGlzLmRpbWVuc2lvbnNJZH1gLFxuICAgIF0pO1xuICB9XG5cbiAgdXBkYXRlVmFsdWUodmFsdWUpIHtcbiAgICB0aGlzLnNldFNoYXBlKHZhbHVlKTtcbiAgICB0aGlzLmtlcm5lbC5zZXRVbmlmb3JtM2l2KHRoaXMuZGltZW5zaW9uc0lkLCB0aGlzLmRpbWVuc2lvbnMpO1xuICAgIHRoaXMua2VybmVsLnNldFVuaWZvcm0yaXYodGhpcy5zaXplSWQsIHRoaXMudGV4dHVyZVNpemUpO1xuICAgIHN1cGVyLnVwZGF0ZVZhbHVlKHZhbHVlKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViR0wyS2VybmVsVmFsdWVEeW5hbWljU2luZ2xlQXJyYXkxRElcbn07XG59LHtcIi4uLy4uLy4uL3V0aWxzXCI6MTE0LFwiLi4vLi4vd2ViLWdsMi9rZXJuZWwtdmFsdWUvc2luZ2xlLWFycmF5MWQtaVwiOjk5fV0sODY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHsgV2ViR0wyS2VybmVsVmFsdWVTaW5nbGVBcnJheTJESSB9ID0gcmVxdWlyZSgnLi4vLi4vd2ViLWdsMi9rZXJuZWwtdmFsdWUvc2luZ2xlLWFycmF5MmQtaScpO1xuXG5jbGFzcyBXZWJHTDJLZXJuZWxWYWx1ZUR5bmFtaWNTaW5nbGVBcnJheTJESSBleHRlbmRzIFdlYkdMMktlcm5lbFZhbHVlU2luZ2xlQXJyYXkyREkge1xuICBnZXRTb3VyY2UoKSB7XG4gICAgY29uc3QgdmFyaWFibGVQcmVjaXNpb24gPSB0aGlzLmdldFZhcmlhYmxlUHJlY2lzaW9uU3RyaW5nKCk7XG4gICAgcmV0dXJuIHV0aWxzLmxpbmVzVG9TdHJpbmcoW1xuICAgICAgYHVuaWZvcm0gJHsgdmFyaWFibGVQcmVjaXNpb24gfSBzYW1wbGVyMkQgJHt0aGlzLmlkfWAsXG4gICAgICBgdW5pZm9ybSAkeyB2YXJpYWJsZVByZWNpc2lvbiB9IGl2ZWMyICR7dGhpcy5zaXplSWR9YCxcbiAgICAgIGB1bmlmb3JtICR7IHZhcmlhYmxlUHJlY2lzaW9uIH0gaXZlYzMgJHt0aGlzLmRpbWVuc2lvbnNJZH1gLFxuICAgIF0pO1xuICB9XG5cbiAgdXBkYXRlVmFsdWUodmFsdWUpIHtcbiAgICB0aGlzLnNldFNoYXBlKHZhbHVlKTtcbiAgICB0aGlzLmtlcm5lbC5zZXRVbmlmb3JtM2l2KHRoaXMuZGltZW5zaW9uc0lkLCB0aGlzLmRpbWVuc2lvbnMpO1xuICAgIHRoaXMua2VybmVsLnNldFVuaWZvcm0yaXYodGhpcy5zaXplSWQsIHRoaXMudGV4dHVyZVNpemUpO1xuICAgIHN1cGVyLnVwZGF0ZVZhbHVlKHZhbHVlKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViR0wyS2VybmVsVmFsdWVEeW5hbWljU2luZ2xlQXJyYXkyRElcbn07XG59LHtcIi4uLy4uLy4uL3V0aWxzXCI6MTE0LFwiLi4vLi4vd2ViLWdsMi9rZXJuZWwtdmFsdWUvc2luZ2xlLWFycmF5MmQtaVwiOjEwMH1dLDg3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzJyk7XG5jb25zdCB7IFdlYkdMMktlcm5lbFZhbHVlU2luZ2xlQXJyYXkzREkgfSA9IHJlcXVpcmUoJy4uLy4uL3dlYi1nbDIva2VybmVsLXZhbHVlL3NpbmdsZS1hcnJheTNkLWknKTtcblxuY2xhc3MgV2ViR0wyS2VybmVsVmFsdWVEeW5hbWljU2luZ2xlQXJyYXkzREkgZXh0ZW5kcyBXZWJHTDJLZXJuZWxWYWx1ZVNpbmdsZUFycmF5M0RJIHtcbiAgZ2V0U291cmNlKCkge1xuICAgIGNvbnN0IHZhcmlhYmxlUHJlY2lzaW9uID0gdGhpcy5nZXRWYXJpYWJsZVByZWNpc2lvblN0cmluZygpO1xuICAgIHJldHVybiB1dGlscy5saW5lc1RvU3RyaW5nKFtcbiAgICAgIGB1bmlmb3JtICR7IHZhcmlhYmxlUHJlY2lzaW9uIH0gc2FtcGxlcjJEICR7dGhpcy5pZH1gLFxuICAgICAgYHVuaWZvcm0gJHsgdmFyaWFibGVQcmVjaXNpb24gfSBpdmVjMiAke3RoaXMuc2l6ZUlkfWAsXG4gICAgICBgdW5pZm9ybSAkeyB2YXJpYWJsZVByZWNpc2lvbiB9IGl2ZWMzICR7dGhpcy5kaW1lbnNpb25zSWR9YCxcbiAgICBdKTtcbiAgfVxuXG4gIHVwZGF0ZVZhbHVlKHZhbHVlKSB7XG4gICAgdGhpcy5zZXRTaGFwZSh2YWx1ZSk7XG4gICAgdGhpcy5rZXJuZWwuc2V0VW5pZm9ybTNpdih0aGlzLmRpbWVuc2lvbnNJZCwgdGhpcy5kaW1lbnNpb25zKTtcbiAgICB0aGlzLmtlcm5lbC5zZXRVbmlmb3JtMml2KHRoaXMuc2l6ZUlkLCB0aGlzLnRleHR1cmVTaXplKTtcbiAgICBzdXBlci51cGRhdGVWYWx1ZSh2YWx1ZSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFdlYkdMMktlcm5lbFZhbHVlRHluYW1pY1NpbmdsZUFycmF5M0RJXG59O1xufSx7XCIuLi8uLi8uLi91dGlsc1wiOjExNCxcIi4uLy4uL3dlYi1nbDIva2VybmVsLXZhbHVlL3NpbmdsZS1hcnJheTNkLWlcIjoxMDF9XSw4ODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xuY29uc3QgeyBXZWJHTDJLZXJuZWxWYWx1ZVNpbmdsZUlucHV0IH0gPSByZXF1aXJlKCcuLi8uLi93ZWItZ2wyL2tlcm5lbC12YWx1ZS9zaW5nbGUtaW5wdXQnKTtcblxuY2xhc3MgV2ViR0wyS2VybmVsVmFsdWVEeW5hbWljU2luZ2xlSW5wdXQgZXh0ZW5kcyBXZWJHTDJLZXJuZWxWYWx1ZVNpbmdsZUlucHV0IHtcbiAgZ2V0U291cmNlKCkge1xuICAgIGNvbnN0IHZhcmlhYmxlUHJlY2lzaW9uID0gdGhpcy5nZXRWYXJpYWJsZVByZWNpc2lvblN0cmluZygpO1xuICAgIHJldHVybiB1dGlscy5saW5lc1RvU3RyaW5nKFtcbiAgICAgIGB1bmlmb3JtICR7IHZhcmlhYmxlUHJlY2lzaW9uIH0gc2FtcGxlcjJEICR7dGhpcy5pZH1gLFxuICAgICAgYHVuaWZvcm0gJHsgdmFyaWFibGVQcmVjaXNpb24gfSBpdmVjMiAke3RoaXMuc2l6ZUlkfWAsXG4gICAgICBgdW5pZm9ybSAkeyB2YXJpYWJsZVByZWNpc2lvbiB9IGl2ZWMzICR7dGhpcy5kaW1lbnNpb25zSWR9YCxcbiAgICBdKTtcbiAgfVxuXG4gIHVwZGF0ZVZhbHVlKHZhbHVlKSB7XG4gICAgbGV0IFt3LCBoLCBkXSA9IHZhbHVlLnNpemU7XG4gICAgdGhpcy5kaW1lbnNpb25zID0gbmV3IEludDMyQXJyYXkoW3cgfHwgMSwgaCB8fCAxLCBkIHx8IDFdKTtcbiAgICB0aGlzLnRleHR1cmVTaXplID0gdXRpbHMuZ2V0TWVtb3J5T3B0aW1pemVkRmxvYXRUZXh0dXJlU2l6ZSh0aGlzLmRpbWVuc2lvbnMsIHRoaXMuYml0UmF0aW8pO1xuICAgIHRoaXMudXBsb2FkQXJyYXlMZW5ndGggPSB0aGlzLnRleHR1cmVTaXplWzBdICogdGhpcy50ZXh0dXJlU2l6ZVsxXSAqIHRoaXMuYml0UmF0aW87XG4gICAgdGhpcy5jaGVja1NpemUodGhpcy50ZXh0dXJlU2l6ZVswXSwgdGhpcy50ZXh0dXJlU2l6ZVsxXSk7XG4gICAgdGhpcy51cGxvYWRWYWx1ZSA9IG5ldyBGbG9hdDMyQXJyYXkodGhpcy51cGxvYWRBcnJheUxlbmd0aCk7XG4gICAgdGhpcy5rZXJuZWwuc2V0VW5pZm9ybTNpdih0aGlzLmRpbWVuc2lvbnNJZCwgdGhpcy5kaW1lbnNpb25zKTtcbiAgICB0aGlzLmtlcm5lbC5zZXRVbmlmb3JtMml2KHRoaXMuc2l6ZUlkLCB0aGlzLnRleHR1cmVTaXplKTtcbiAgICBzdXBlci51cGRhdGVWYWx1ZSh2YWx1ZSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFdlYkdMMktlcm5lbFZhbHVlRHluYW1pY1NpbmdsZUlucHV0XG59O1xufSx7XCIuLi8uLi8uLi91dGlsc1wiOjExNCxcIi4uLy4uL3dlYi1nbDIva2VybmVsLXZhbHVlL3NpbmdsZS1pbnB1dFwiOjEwMn1dLDg5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzJyk7XG5jb25zdCB7IFdlYkdMS2VybmVsVmFsdWVEeW5hbWljVW5zaWduZWRBcnJheSB9ID0gcmVxdWlyZSgnLi4vLi4vd2ViLWdsL2tlcm5lbC12YWx1ZS9keW5hbWljLXVuc2lnbmVkLWFycmF5Jyk7XG5cbmNsYXNzIFdlYkdMMktlcm5lbFZhbHVlRHluYW1pY1Vuc2lnbmVkQXJyYXkgZXh0ZW5kcyBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY1Vuc2lnbmVkQXJyYXkge1xuICBnZXRTb3VyY2UoKSB7XG4gICAgY29uc3QgdmFyaWFibGVQcmVjaXNpb24gPSB0aGlzLmdldFZhcmlhYmxlUHJlY2lzaW9uU3RyaW5nKCk7XG4gICAgcmV0dXJuIHV0aWxzLmxpbmVzVG9TdHJpbmcoW1xuICAgICAgYHVuaWZvcm0gJHsgdmFyaWFibGVQcmVjaXNpb24gfSBzYW1wbGVyMkQgJHt0aGlzLmlkfWAsXG4gICAgICBgdW5pZm9ybSAkeyB2YXJpYWJsZVByZWNpc2lvbiB9IGl2ZWMyICR7dGhpcy5zaXplSWR9YCxcbiAgICAgIGB1bmlmb3JtICR7IHZhcmlhYmxlUHJlY2lzaW9uIH0gaXZlYzMgJHt0aGlzLmRpbWVuc2lvbnNJZH1gLFxuICAgIF0pO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBXZWJHTDJLZXJuZWxWYWx1ZUR5bmFtaWNVbnNpZ25lZEFycmF5XG59O1xufSx7XCIuLi8uLi8uLi91dGlsc1wiOjExNCxcIi4uLy4uL3dlYi1nbC9rZXJuZWwtdmFsdWUvZHluYW1pYy11bnNpZ25lZC1hcnJheVwiOjU0fV0sOTA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHsgV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNVbnNpZ25lZElucHV0IH0gPSByZXF1aXJlKCcuLi8uLi93ZWItZ2wva2VybmVsLXZhbHVlL2R5bmFtaWMtdW5zaWduZWQtaW5wdXQnKTtcblxuY2xhc3MgV2ViR0wyS2VybmVsVmFsdWVEeW5hbWljVW5zaWduZWRJbnB1dCBleHRlbmRzIFdlYkdMS2VybmVsVmFsdWVEeW5hbWljVW5zaWduZWRJbnB1dCB7XG4gIGdldFNvdXJjZSgpIHtcbiAgICBjb25zdCB2YXJpYWJsZVByZWNpc2lvbiA9IHRoaXMuZ2V0VmFyaWFibGVQcmVjaXNpb25TdHJpbmcoKTtcbiAgICByZXR1cm4gdXRpbHMubGluZXNUb1N0cmluZyhbXG4gICAgICBgdW5pZm9ybSAkeyB2YXJpYWJsZVByZWNpc2lvbiB9IHNhbXBsZXIyRCAke3RoaXMuaWR9YCxcbiAgICAgIGB1bmlmb3JtICR7IHZhcmlhYmxlUHJlY2lzaW9uIH0gaXZlYzIgJHt0aGlzLnNpemVJZH1gLFxuICAgICAgYHVuaWZvcm0gJHsgdmFyaWFibGVQcmVjaXNpb24gfSBpdmVjMyAke3RoaXMuZGltZW5zaW9uc0lkfWAsXG4gICAgXSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFdlYkdMMktlcm5lbFZhbHVlRHluYW1pY1Vuc2lnbmVkSW5wdXRcbn07XG59LHtcIi4uLy4uLy4uL3V0aWxzXCI6MTE0LFwiLi4vLi4vd2ViLWdsL2tlcm5lbC12YWx1ZS9keW5hbWljLXVuc2lnbmVkLWlucHV0XCI6NTV9XSw5MTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xuY29uc3QgeyBXZWJHTEtlcm5lbFZhbHVlRmxvYXQgfSA9IHJlcXVpcmUoJy4uLy4uL3dlYi1nbC9rZXJuZWwtdmFsdWUvZmxvYXQnKTtcblxuY2xhc3MgV2ViR0wyS2VybmVsVmFsdWVGbG9hdCBleHRlbmRzIFdlYkdMS2VybmVsVmFsdWVGbG9hdCB7fVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViR0wyS2VybmVsVmFsdWVGbG9hdFxufTtcbn0se1wiLi4vLi4vLi4vdXRpbHNcIjoxMTQsXCIuLi8uLi93ZWItZ2wva2VybmVsLXZhbHVlL2Zsb2F0XCI6NTZ9XSw5MjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xuY29uc3QgeyBXZWJHTEtlcm5lbEFycmF5IH0gPSByZXF1aXJlKCcuLi8uLi93ZWItZ2wva2VybmVsLXZhbHVlL2FycmF5Jyk7XG5cbmNsYXNzIFdlYkdMMktlcm5lbFZhbHVlSFRNTEltYWdlQXJyYXkgZXh0ZW5kcyBXZWJHTEtlcm5lbEFycmF5IHtcbiAgY29uc3RydWN0b3IodmFsdWUsIHNldHRpbmdzKSB7XG4gICAgc3VwZXIodmFsdWUsIHNldHRpbmdzKTtcbiAgICB0aGlzLmNoZWNrU2l6ZSh2YWx1ZVswXS53aWR0aCwgdmFsdWVbMF0uaGVpZ2h0KTtcbiAgICB0aGlzLmRpbWVuc2lvbnMgPSBbdmFsdWVbMF0ud2lkdGgsIHZhbHVlWzBdLmhlaWdodCwgdmFsdWUubGVuZ3RoXTtcbiAgICB0aGlzLnRleHR1cmVTaXplID0gW3ZhbHVlWzBdLndpZHRoLCB2YWx1ZVswXS5oZWlnaHRdO1xuICB9XG4gIGRlZmluZVRleHR1cmUoKSB7XG4gICAgY29uc3QgeyBjb250ZXh0OiBnbCB9ID0gdGhpcztcbiAgICBnbC5hY3RpdmVUZXh0dXJlKHRoaXMuY29udGV4dEhhbmRsZSk7XG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRF9BUlJBWSwgdGhpcy50ZXh0dXJlKTtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkRfQVJSQVksIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTkVBUkVTVCk7XG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJEX0FSUkFZLCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLk5FQVJFU1QpO1xuICB9XG5cbiAgZ2V0U3RyaW5nVmFsdWVIYW5kbGVyKCkge1xuICAgIHJldHVybiBgY29uc3QgdXBsb2FkVmFsdWVfJHt0aGlzLm5hbWV9ID0gJHt0aGlzLnZhck5hbWV9O1xcbmA7XG4gIH1cbiAgZ2V0U291cmNlKCkge1xuICAgIGNvbnN0IHZhcmlhYmxlUHJlY2lzaW9uID0gdGhpcy5nZXRWYXJpYWJsZVByZWNpc2lvblN0cmluZygpO1xuICAgIHJldHVybiB1dGlscy5saW5lc1RvU3RyaW5nKFtcbiAgICAgIGB1bmlmb3JtICR7IHZhcmlhYmxlUHJlY2lzaW9uIH0gc2FtcGxlcjJEQXJyYXkgJHt0aGlzLmlkfWAsXG4gICAgICBgJHsgdmFyaWFibGVQcmVjaXNpb24gfSBpdmVjMiAke3RoaXMuc2l6ZUlkfSA9IGl2ZWMyKCR7dGhpcy50ZXh0dXJlU2l6ZVswXX0sICR7dGhpcy50ZXh0dXJlU2l6ZVsxXX0pYCxcbiAgICAgIGAkeyB2YXJpYWJsZVByZWNpc2lvbiB9IGl2ZWMzICR7dGhpcy5kaW1lbnNpb25zSWR9ID0gaXZlYzMoJHt0aGlzLmRpbWVuc2lvbnNbMF19LCAke3RoaXMuZGltZW5zaW9uc1sxXX0sICR7dGhpcy5kaW1lbnNpb25zWzJdfSlgLFxuICAgIF0pO1xuICB9XG5cbiAgdXBkYXRlVmFsdWUoaW1hZ2VzKSB7XG4gICAgY29uc3QgeyBjb250ZXh0OiBnbCB9ID0gdGhpcztcbiAgICBnbC5hY3RpdmVUZXh0dXJlKHRoaXMuY29udGV4dEhhbmRsZSk7XG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRF9BUlJBWSwgdGhpcy50ZXh0dXJlKTtcbiAgICBnbC5waXhlbFN0b3JlaShnbC5VTlBBQ0tfRkxJUF9ZX1dFQkdMLCB0cnVlKTtcbiAgICBnbC50ZXhJbWFnZTNEKFxuICAgICAgZ2wuVEVYVFVSRV8yRF9BUlJBWSxcbiAgICAgIDAsXG4gICAgICBnbC5SR0JBLFxuICAgICAgaW1hZ2VzWzBdLndpZHRoLFxuICAgICAgaW1hZ2VzWzBdLmhlaWdodCxcbiAgICAgIGltYWdlcy5sZW5ndGgsXG4gICAgICAwLFxuICAgICAgZ2wuUkdCQSxcbiAgICAgIGdsLlVOU0lHTkVEX0JZVEUsXG4gICAgICBudWxsXG4gICAgKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGltYWdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgeE9mZnNldCA9IDA7XG4gICAgICBjb25zdCB5T2Zmc2V0ID0gMDtcbiAgICAgIGNvbnN0IGltYWdlRGVwdGggPSAxO1xuICAgICAgZ2wudGV4U3ViSW1hZ2UzRChcbiAgICAgICAgZ2wuVEVYVFVSRV8yRF9BUlJBWSxcbiAgICAgICAgMCxcbiAgICAgICAgeE9mZnNldCxcbiAgICAgICAgeU9mZnNldCxcbiAgICAgICAgaSxcbiAgICAgICAgaW1hZ2VzW2ldLndpZHRoLFxuICAgICAgICBpbWFnZXNbaV0uaGVpZ2h0LFxuICAgICAgICBpbWFnZURlcHRoLFxuICAgICAgICBnbC5SR0JBLFxuICAgICAgICBnbC5VTlNJR05FRF9CWVRFLFxuICAgICAgICB0aGlzLnVwbG9hZFZhbHVlID0gaW1hZ2VzW2ldXG4gICAgICApO1xuICAgIH1cbiAgICB0aGlzLmtlcm5lbC5zZXRVbmlmb3JtMWkodGhpcy5pZCwgdGhpcy5pbmRleCk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFdlYkdMMktlcm5lbFZhbHVlSFRNTEltYWdlQXJyYXlcbn07XG59LHtcIi4uLy4uLy4uL3V0aWxzXCI6MTE0LFwiLi4vLi4vd2ViLWdsL2tlcm5lbC12YWx1ZS9hcnJheVwiOjQwfV0sOTM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHsgV2ViR0xLZXJuZWxWYWx1ZUhUTUxJbWFnZSB9ID0gcmVxdWlyZSgnLi4vLi4vd2ViLWdsL2tlcm5lbC12YWx1ZS9odG1sLWltYWdlJyk7XG5cbmNsYXNzIFdlYkdMMktlcm5lbFZhbHVlSFRNTEltYWdlIGV4dGVuZHMgV2ViR0xLZXJuZWxWYWx1ZUhUTUxJbWFnZSB7XG4gIGdldFNvdXJjZSgpIHtcbiAgICBjb25zdCB2YXJpYWJsZVByZWNpc2lvbiA9IHRoaXMuZ2V0VmFyaWFibGVQcmVjaXNpb25TdHJpbmcoKTtcbiAgICByZXR1cm4gdXRpbHMubGluZXNUb1N0cmluZyhbXG4gICAgICBgdW5pZm9ybSAkeyB2YXJpYWJsZVByZWNpc2lvbiB9IHNhbXBsZXIyRCAke3RoaXMuaWR9YCxcbiAgICAgIGAkeyB2YXJpYWJsZVByZWNpc2lvbiB9IGl2ZWMyICR7dGhpcy5zaXplSWR9ID0gaXZlYzIoJHt0aGlzLnRleHR1cmVTaXplWzBdfSwgJHt0aGlzLnRleHR1cmVTaXplWzFdfSlgLFxuICAgICAgYCR7IHZhcmlhYmxlUHJlY2lzaW9uIH0gaXZlYzMgJHt0aGlzLmRpbWVuc2lvbnNJZH0gPSBpdmVjMygke3RoaXMuZGltZW5zaW9uc1swXX0sICR7dGhpcy5kaW1lbnNpb25zWzFdfSwgJHt0aGlzLmRpbWVuc2lvbnNbMl19KWAsXG4gICAgXSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFdlYkdMMktlcm5lbFZhbHVlSFRNTEltYWdlXG59O1xufSx7XCIuLi8uLi8uLi91dGlsc1wiOjExNCxcIi4uLy4uL3dlYi1nbC9rZXJuZWwtdmFsdWUvaHRtbC1pbWFnZVwiOjU3fV0sOTQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHsgV2ViR0wyS2VybmVsVmFsdWVIVE1MSW1hZ2UgfSA9IHJlcXVpcmUoJy4vaHRtbC1pbWFnZScpO1xuXG5jbGFzcyBXZWJHTDJLZXJuZWxWYWx1ZUhUTUxWaWRlbyBleHRlbmRzIFdlYkdMMktlcm5lbFZhbHVlSFRNTEltYWdlIHt9XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBXZWJHTDJLZXJuZWxWYWx1ZUhUTUxWaWRlb1xufTtcbn0se1wiLi4vLi4vLi4vdXRpbHNcIjoxMTQsXCIuL2h0bWwtaW1hZ2VcIjo5M31dLDk1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgV2ViR0xLZXJuZWxWYWx1ZUludGVnZXIgfSA9IHJlcXVpcmUoJy4uLy4uL3dlYi1nbC9rZXJuZWwtdmFsdWUvaW50ZWdlcicpO1xuXG5jbGFzcyBXZWJHTDJLZXJuZWxWYWx1ZUludGVnZXIgZXh0ZW5kcyBXZWJHTEtlcm5lbFZhbHVlSW50ZWdlciB7XG4gIGdldFNvdXJjZSh2YWx1ZSkge1xuICAgIGNvbnN0IHZhcmlhYmxlUHJlY2lzaW9uID0gdGhpcy5nZXRWYXJpYWJsZVByZWNpc2lvblN0cmluZygpO1xuICAgIGlmICh0aGlzLm9yaWdpbiA9PT0gJ2NvbnN0YW50cycpIHtcbiAgICAgIHJldHVybiBgY29uc3QgJHsgdmFyaWFibGVQcmVjaXNpb24gfSBpbnQgJHt0aGlzLmlkfSA9ICR7IHBhcnNlSW50KHZhbHVlKSB9O1xcbmA7XG4gICAgfVxuICAgIHJldHVybiBgdW5pZm9ybSAkeyB2YXJpYWJsZVByZWNpc2lvbiB9IGludCAke3RoaXMuaWR9O1xcbmA7XG4gIH1cblxuICB1cGRhdGVWYWx1ZSh2YWx1ZSkge1xuICAgIGlmICh0aGlzLm9yaWdpbiA9PT0gJ2NvbnN0YW50cycpIHJldHVybjtcbiAgICB0aGlzLmtlcm5lbC5zZXRVbmlmb3JtMWkodGhpcy5pZCwgdGhpcy51cGxvYWRWYWx1ZSA9IHZhbHVlKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViR0wyS2VybmVsVmFsdWVJbnRlZ2VyXG59O1xufSx7XCIuLi8uLi93ZWItZ2wva2VybmVsLXZhbHVlL2ludGVnZXJcIjo2MH1dLDk2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzJyk7XG5jb25zdCB7IFdlYkdMS2VybmVsVmFsdWVNZW1vcnlPcHRpbWl6ZWROdW1iZXJUZXh0dXJlIH0gPSByZXF1aXJlKCcuLi8uLi93ZWItZ2wva2VybmVsLXZhbHVlL21lbW9yeS1vcHRpbWl6ZWQtbnVtYmVyLXRleHR1cmUnKTtcblxuY2xhc3MgV2ViR0wyS2VybmVsVmFsdWVNZW1vcnlPcHRpbWl6ZWROdW1iZXJUZXh0dXJlIGV4dGVuZHMgV2ViR0xLZXJuZWxWYWx1ZU1lbW9yeU9wdGltaXplZE51bWJlclRleHR1cmUge1xuICBnZXRTb3VyY2UoKSB7XG4gICAgY29uc3QgeyBpZCwgc2l6ZUlkLCB0ZXh0dXJlU2l6ZSwgZGltZW5zaW9uc0lkLCBkaW1lbnNpb25zIH0gPSB0aGlzO1xuICAgIGNvbnN0IHZhcmlhYmxlUHJlY2lzaW9uID0gdGhpcy5nZXRWYXJpYWJsZVByZWNpc2lvblN0cmluZygpO1xuICAgIHJldHVybiB1dGlscy5saW5lc1RvU3RyaW5nKFtcbiAgICAgIGB1bmlmb3JtIHNhbXBsZXIyRCAke2lkfWAsXG4gICAgICBgJHsgdmFyaWFibGVQcmVjaXNpb24gfSBpdmVjMiAke3NpemVJZH0gPSBpdmVjMigke3RleHR1cmVTaXplWzBdfSwgJHt0ZXh0dXJlU2l6ZVsxXX0pYCxcbiAgICAgIGAkeyB2YXJpYWJsZVByZWNpc2lvbiB9IGl2ZWMzICR7ZGltZW5zaW9uc0lkfSA9IGl2ZWMzKCR7ZGltZW5zaW9uc1swXX0sICR7ZGltZW5zaW9uc1sxXX0sICR7ZGltZW5zaW9uc1syXX0pYCxcbiAgICBdKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViR0wyS2VybmVsVmFsdWVNZW1vcnlPcHRpbWl6ZWROdW1iZXJUZXh0dXJlXG59O1xufSx7XCIuLi8uLi8uLi91dGlsc1wiOjExNCxcIi4uLy4uL3dlYi1nbC9rZXJuZWwtdmFsdWUvbWVtb3J5LW9wdGltaXplZC1udW1iZXItdGV4dHVyZVwiOjYxfV0sOTc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHsgV2ViR0xLZXJuZWxWYWx1ZU51bWJlclRleHR1cmUgfSA9IHJlcXVpcmUoJy4uLy4uL3dlYi1nbC9rZXJuZWwtdmFsdWUvbnVtYmVyLXRleHR1cmUnKTtcblxuY2xhc3MgV2ViR0wyS2VybmVsVmFsdWVOdW1iZXJUZXh0dXJlIGV4dGVuZHMgV2ViR0xLZXJuZWxWYWx1ZU51bWJlclRleHR1cmUge1xuICBnZXRTb3VyY2UoKSB7XG4gICAgY29uc3QgeyBpZCwgc2l6ZUlkLCB0ZXh0dXJlU2l6ZSwgZGltZW5zaW9uc0lkLCBkaW1lbnNpb25zIH0gPSB0aGlzO1xuICAgIGNvbnN0IHZhcmlhYmxlUHJlY2lzaW9uID0gdGhpcy5nZXRWYXJpYWJsZVByZWNpc2lvblN0cmluZygpO1xuICAgIHJldHVybiB1dGlscy5saW5lc1RvU3RyaW5nKFtcbiAgICAgIGB1bmlmb3JtICR7IHZhcmlhYmxlUHJlY2lzaW9uIH0gc2FtcGxlcjJEICR7aWR9YCxcbiAgICAgIGAkeyB2YXJpYWJsZVByZWNpc2lvbiB9IGl2ZWMyICR7c2l6ZUlkfSA9IGl2ZWMyKCR7dGV4dHVyZVNpemVbMF19LCAke3RleHR1cmVTaXplWzFdfSlgLFxuICAgICAgYCR7IHZhcmlhYmxlUHJlY2lzaW9uIH0gaXZlYzMgJHtkaW1lbnNpb25zSWR9ID0gaXZlYzMoJHtkaW1lbnNpb25zWzBdfSwgJHtkaW1lbnNpb25zWzFdfSwgJHtkaW1lbnNpb25zWzJdfSlgLFxuICAgIF0pO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBXZWJHTDJLZXJuZWxWYWx1ZU51bWJlclRleHR1cmVcbn07XG59LHtcIi4uLy4uLy4uL3V0aWxzXCI6MTE0LFwiLi4vLi4vd2ViLWdsL2tlcm5lbC12YWx1ZS9udW1iZXItdGV4dHVyZVwiOjYyfV0sOTg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHsgV2ViR0xLZXJuZWxWYWx1ZVNpbmdsZUFycmF5IH0gPSByZXF1aXJlKCcuLi8uLi93ZWItZ2wva2VybmVsLXZhbHVlL3NpbmdsZS1hcnJheScpO1xuXG5jbGFzcyBXZWJHTDJLZXJuZWxWYWx1ZVNpbmdsZUFycmF5IGV4dGVuZHMgV2ViR0xLZXJuZWxWYWx1ZVNpbmdsZUFycmF5IHtcbiAgZ2V0U291cmNlKCkge1xuICAgIGNvbnN0IHZhcmlhYmxlUHJlY2lzaW9uID0gdGhpcy5nZXRWYXJpYWJsZVByZWNpc2lvblN0cmluZygpO1xuICAgIHJldHVybiB1dGlscy5saW5lc1RvU3RyaW5nKFtcbiAgICAgIGB1bmlmb3JtICR7IHZhcmlhYmxlUHJlY2lzaW9uIH0gc2FtcGxlcjJEICR7dGhpcy5pZH1gLFxuICAgICAgYCR7IHZhcmlhYmxlUHJlY2lzaW9uIH0gaXZlYzIgJHt0aGlzLnNpemVJZH0gPSBpdmVjMigke3RoaXMudGV4dHVyZVNpemVbMF19LCAke3RoaXMudGV4dHVyZVNpemVbMV19KWAsXG4gICAgICBgJHsgdmFyaWFibGVQcmVjaXNpb24gfSBpdmVjMyAke3RoaXMuZGltZW5zaW9uc0lkfSA9IGl2ZWMzKCR7dGhpcy5kaW1lbnNpb25zWzBdfSwgJHt0aGlzLmRpbWVuc2lvbnNbMV19LCAke3RoaXMuZGltZW5zaW9uc1syXX0pYCxcbiAgICBdKTtcbiAgfVxuXG4gIHVwZGF0ZVZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlLmNvbnN0cnVjdG9yICE9PSB0aGlzLmluaXRpYWxWYWx1ZUNvbnN0cnVjdG9yKSB7XG4gICAgICB0aGlzLm9uVXBkYXRlVmFsdWVNaXNtYXRjaCh2YWx1ZS5jb25zdHJ1Y3Rvcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHsgY29udGV4dDogZ2wgfSA9IHRoaXM7XG4gICAgdXRpbHMuZmxhdHRlblRvKHZhbHVlLCB0aGlzLnVwbG9hZFZhbHVlKTtcbiAgICBnbC5hY3RpdmVUZXh0dXJlKHRoaXMuY29udGV4dEhhbmRsZSk7XG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy50ZXh0dXJlKTtcbiAgICBnbC5waXhlbFN0b3JlaShnbC5VTlBBQ0tfRkxJUF9ZX1dFQkdMLCBmYWxzZSk7XG4gICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBMzJGLCB0aGlzLnRleHR1cmVTaXplWzBdLCB0aGlzLnRleHR1cmVTaXplWzFdLCAwLCBnbC5SR0JBLCBnbC5GTE9BVCwgdGhpcy51cGxvYWRWYWx1ZSk7XG4gICAgdGhpcy5rZXJuZWwuc2V0VW5pZm9ybTFpKHRoaXMuaWQsIHRoaXMuaW5kZXgpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBXZWJHTDJLZXJuZWxWYWx1ZVNpbmdsZUFycmF5XG59O1xufSx7XCIuLi8uLi8uLi91dGlsc1wiOjExNCxcIi4uLy4uL3dlYi1nbC9rZXJuZWwtdmFsdWUvc2luZ2xlLWFycmF5XCI6NjN9XSw5OTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xuY29uc3QgeyBXZWJHTEtlcm5lbFZhbHVlU2luZ2xlQXJyYXkxREkgfSA9IHJlcXVpcmUoJy4uLy4uL3dlYi1nbC9rZXJuZWwtdmFsdWUvc2luZ2xlLWFycmF5MWQtaScpO1xuXG5jbGFzcyBXZWJHTDJLZXJuZWxWYWx1ZVNpbmdsZUFycmF5MURJIGV4dGVuZHMgV2ViR0xLZXJuZWxWYWx1ZVNpbmdsZUFycmF5MURJIHtcbiAgdXBkYXRlVmFsdWUodmFsdWUpIHtcbiAgICBpZiAodmFsdWUuY29uc3RydWN0b3IgIT09IHRoaXMuaW5pdGlhbFZhbHVlQ29uc3RydWN0b3IpIHtcbiAgICAgIHRoaXMub25VcGRhdGVWYWx1ZU1pc21hdGNoKHZhbHVlLmNvbnN0cnVjdG9yKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgeyBjb250ZXh0OiBnbCB9ID0gdGhpcztcbiAgICB1dGlscy5mbGF0dGVuVG8odmFsdWUsIHRoaXMudXBsb2FkVmFsdWUpO1xuICAgIGdsLmFjdGl2ZVRleHR1cmUodGhpcy5jb250ZXh0SGFuZGxlKTtcbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0aGlzLnRleHR1cmUpO1xuICAgIGdsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19GTElQX1lfV0VCR0wsIGZhbHNlKTtcbiAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEzMkYsIHRoaXMudGV4dHVyZVNpemVbMF0sIHRoaXMudGV4dHVyZVNpemVbMV0sIDAsIGdsLlJHQkEsIGdsLkZMT0FULCB0aGlzLnVwbG9hZFZhbHVlKTtcbiAgICB0aGlzLmtlcm5lbC5zZXRVbmlmb3JtMWkodGhpcy5pZCwgdGhpcy5pbmRleCk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFdlYkdMMktlcm5lbFZhbHVlU2luZ2xlQXJyYXkxRElcbn07XG59LHtcIi4uLy4uLy4uL3V0aWxzXCI6MTE0LFwiLi4vLi4vd2ViLWdsL2tlcm5lbC12YWx1ZS9zaW5nbGUtYXJyYXkxZC1pXCI6NjR9XSwxMDA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHsgV2ViR0xLZXJuZWxWYWx1ZVNpbmdsZUFycmF5MkRJIH0gPSByZXF1aXJlKCcuLi8uLi93ZWItZ2wva2VybmVsLXZhbHVlL3NpbmdsZS1hcnJheTJkLWknKTtcblxuY2xhc3MgV2ViR0wyS2VybmVsVmFsdWVTaW5nbGVBcnJheTJESSBleHRlbmRzIFdlYkdMS2VybmVsVmFsdWVTaW5nbGVBcnJheTJESSB7XG4gIHVwZGF0ZVZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlLmNvbnN0cnVjdG9yICE9PSB0aGlzLmluaXRpYWxWYWx1ZUNvbnN0cnVjdG9yKSB7XG4gICAgICB0aGlzLm9uVXBkYXRlVmFsdWVNaXNtYXRjaCh2YWx1ZS5jb25zdHJ1Y3Rvcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHsgY29udGV4dDogZ2wgfSA9IHRoaXM7XG4gICAgdXRpbHMuZmxhdHRlblRvKHZhbHVlLCB0aGlzLnVwbG9hZFZhbHVlKTtcbiAgICBnbC5hY3RpdmVUZXh0dXJlKHRoaXMuY29udGV4dEhhbmRsZSk7XG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy50ZXh0dXJlKTtcbiAgICBnbC5waXhlbFN0b3JlaShnbC5VTlBBQ0tfRkxJUF9ZX1dFQkdMLCBmYWxzZSk7XG4gICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBMzJGLCB0aGlzLnRleHR1cmVTaXplWzBdLCB0aGlzLnRleHR1cmVTaXplWzFdLCAwLCBnbC5SR0JBLCBnbC5GTE9BVCwgdGhpcy51cGxvYWRWYWx1ZSk7XG4gICAgdGhpcy5rZXJuZWwuc2V0VW5pZm9ybTFpKHRoaXMuaWQsIHRoaXMuaW5kZXgpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBXZWJHTDJLZXJuZWxWYWx1ZVNpbmdsZUFycmF5MkRJXG59O1xufSx7XCIuLi8uLi8uLi91dGlsc1wiOjExNCxcIi4uLy4uL3dlYi1nbC9rZXJuZWwtdmFsdWUvc2luZ2xlLWFycmF5MmQtaVwiOjY1fV0sMTAxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzJyk7XG5jb25zdCB7IFdlYkdMS2VybmVsVmFsdWVTaW5nbGVBcnJheTNESSB9ID0gcmVxdWlyZSgnLi4vLi4vd2ViLWdsL2tlcm5lbC12YWx1ZS9zaW5nbGUtYXJyYXkzZC1pJyk7XG5cbmNsYXNzIFdlYkdMMktlcm5lbFZhbHVlU2luZ2xlQXJyYXkzREkgZXh0ZW5kcyBXZWJHTEtlcm5lbFZhbHVlU2luZ2xlQXJyYXkzREkge1xuICB1cGRhdGVWYWx1ZSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZS5jb25zdHJ1Y3RvciAhPT0gdGhpcy5pbml0aWFsVmFsdWVDb25zdHJ1Y3Rvcikge1xuICAgICAgdGhpcy5vblVwZGF0ZVZhbHVlTWlzbWF0Y2godmFsdWUuY29uc3RydWN0b3IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7IGNvbnRleHQ6IGdsIH0gPSB0aGlzO1xuICAgIHV0aWxzLmZsYXR0ZW5Ubyh2YWx1ZSwgdGhpcy51cGxvYWRWYWx1ZSk7XG4gICAgZ2wuYWN0aXZlVGV4dHVyZSh0aGlzLmNvbnRleHRIYW5kbGUpO1xuICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMudGV4dHVyZSk7XG4gICAgZ2wucGl4ZWxTdG9yZWkoZ2wuVU5QQUNLX0ZMSVBfWV9XRUJHTCwgZmFsc2UpO1xuICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQTMyRiwgdGhpcy50ZXh0dXJlU2l6ZVswXSwgdGhpcy50ZXh0dXJlU2l6ZVsxXSwgMCwgZ2wuUkdCQSwgZ2wuRkxPQVQsIHRoaXMudXBsb2FkVmFsdWUpO1xuICAgIHRoaXMua2VybmVsLnNldFVuaWZvcm0xaSh0aGlzLmlkLCB0aGlzLmluZGV4KTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViR0wyS2VybmVsVmFsdWVTaW5nbGVBcnJheTNESVxufTtcbn0se1wiLi4vLi4vLi4vdXRpbHNcIjoxMTQsXCIuLi8uLi93ZWItZ2wva2VybmVsLXZhbHVlL3NpbmdsZS1hcnJheTNkLWlcIjo2Nn1dLDEwMjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xuY29uc3QgeyBXZWJHTEtlcm5lbFZhbHVlU2luZ2xlSW5wdXQgfSA9IHJlcXVpcmUoJy4uLy4uL3dlYi1nbC9rZXJuZWwtdmFsdWUvc2luZ2xlLWlucHV0Jyk7XG5cbmNsYXNzIFdlYkdMMktlcm5lbFZhbHVlU2luZ2xlSW5wdXQgZXh0ZW5kcyBXZWJHTEtlcm5lbFZhbHVlU2luZ2xlSW5wdXQge1xuICBnZXRTb3VyY2UoKSB7XG4gICAgY29uc3QgdmFyaWFibGVQcmVjaXNpb24gPSB0aGlzLmdldFZhcmlhYmxlUHJlY2lzaW9uU3RyaW5nKCk7XG4gICAgcmV0dXJuIHV0aWxzLmxpbmVzVG9TdHJpbmcoW1xuICAgICAgYHVuaWZvcm0gJHsgdmFyaWFibGVQcmVjaXNpb24gfSBzYW1wbGVyMkQgJHt0aGlzLmlkfWAsXG4gICAgICBgJHsgdmFyaWFibGVQcmVjaXNpb24gfSBpdmVjMiAke3RoaXMuc2l6ZUlkfSA9IGl2ZWMyKCR7dGhpcy50ZXh0dXJlU2l6ZVswXX0sICR7dGhpcy50ZXh0dXJlU2l6ZVsxXX0pYCxcbiAgICAgIGAkeyB2YXJpYWJsZVByZWNpc2lvbiB9IGl2ZWMzICR7dGhpcy5kaW1lbnNpb25zSWR9ID0gaXZlYzMoJHt0aGlzLmRpbWVuc2lvbnNbMF19LCAke3RoaXMuZGltZW5zaW9uc1sxXX0sICR7dGhpcy5kaW1lbnNpb25zWzJdfSlgLFxuICAgIF0pO1xuICB9XG5cbiAgdXBkYXRlVmFsdWUoaW5wdXQpIHtcbiAgICBjb25zdCB7IGNvbnRleHQ6IGdsIH0gPSB0aGlzO1xuICAgIHV0aWxzLmZsYXR0ZW5UbyhpbnB1dC52YWx1ZSwgdGhpcy51cGxvYWRWYWx1ZSk7XG4gICAgZ2wuYWN0aXZlVGV4dHVyZSh0aGlzLmNvbnRleHRIYW5kbGUpO1xuICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMudGV4dHVyZSk7XG4gICAgZ2wucGl4ZWxTdG9yZWkoZ2wuVU5QQUNLX0ZMSVBfWV9XRUJHTCwgZmFsc2UpO1xuICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQTMyRiwgdGhpcy50ZXh0dXJlU2l6ZVswXSwgdGhpcy50ZXh0dXJlU2l6ZVsxXSwgMCwgZ2wuUkdCQSwgZ2wuRkxPQVQsIHRoaXMudXBsb2FkVmFsdWUpO1xuICAgIHRoaXMua2VybmVsLnNldFVuaWZvcm0xaSh0aGlzLmlkLCB0aGlzLmluZGV4KTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViR0wyS2VybmVsVmFsdWVTaW5nbGVJbnB1dFxufTtcbn0se1wiLi4vLi4vLi4vdXRpbHNcIjoxMTQsXCIuLi8uLi93ZWItZ2wva2VybmVsLXZhbHVlL3NpbmdsZS1pbnB1dFwiOjY3fV0sMTAzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzJyk7XG5jb25zdCB7IFdlYkdMS2VybmVsVmFsdWVVbnNpZ25lZEFycmF5IH0gPSByZXF1aXJlKCcuLi8uLi93ZWItZ2wva2VybmVsLXZhbHVlL3Vuc2lnbmVkLWFycmF5Jyk7XG5cbmNsYXNzIFdlYkdMMktlcm5lbFZhbHVlVW5zaWduZWRBcnJheSBleHRlbmRzIFdlYkdMS2VybmVsVmFsdWVVbnNpZ25lZEFycmF5IHtcbiAgZ2V0U291cmNlKCkge1xuICAgIGNvbnN0IHZhcmlhYmxlUHJlY2lzaW9uID0gdGhpcy5nZXRWYXJpYWJsZVByZWNpc2lvblN0cmluZygpO1xuICAgIHJldHVybiB1dGlscy5saW5lc1RvU3RyaW5nKFtcbiAgICAgIGB1bmlmb3JtICR7IHZhcmlhYmxlUHJlY2lzaW9uIH0gc2FtcGxlcjJEICR7dGhpcy5pZH1gLFxuICAgICAgYCR7IHZhcmlhYmxlUHJlY2lzaW9uIH0gaXZlYzIgJHt0aGlzLnNpemVJZH0gPSBpdmVjMigke3RoaXMudGV4dHVyZVNpemVbMF19LCAke3RoaXMudGV4dHVyZVNpemVbMV19KWAsXG4gICAgICBgJHsgdmFyaWFibGVQcmVjaXNpb24gfSBpdmVjMyAke3RoaXMuZGltZW5zaW9uc0lkfSA9IGl2ZWMzKCR7dGhpcy5kaW1lbnNpb25zWzBdfSwgJHt0aGlzLmRpbWVuc2lvbnNbMV19LCAke3RoaXMuZGltZW5zaW9uc1syXX0pYCxcbiAgICBdKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViR0wyS2VybmVsVmFsdWVVbnNpZ25lZEFycmF5XG59O1xufSx7XCIuLi8uLi8uLi91dGlsc1wiOjExNCxcIi4uLy4uL3dlYi1nbC9rZXJuZWwtdmFsdWUvdW5zaWduZWQtYXJyYXlcIjo2OH1dLDEwNDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xuY29uc3QgeyBXZWJHTEtlcm5lbFZhbHVlVW5zaWduZWRJbnB1dCB9ID0gcmVxdWlyZSgnLi4vLi4vd2ViLWdsL2tlcm5lbC12YWx1ZS91bnNpZ25lZC1pbnB1dCcpO1xuXG5jbGFzcyBXZWJHTDJLZXJuZWxWYWx1ZVVuc2lnbmVkSW5wdXQgZXh0ZW5kcyBXZWJHTEtlcm5lbFZhbHVlVW5zaWduZWRJbnB1dCB7XG4gIGdldFNvdXJjZSgpIHtcbiAgICBjb25zdCB2YXJpYWJsZVByZWNpc2lvbiA9IHRoaXMuZ2V0VmFyaWFibGVQcmVjaXNpb25TdHJpbmcoKTtcbiAgICByZXR1cm4gdXRpbHMubGluZXNUb1N0cmluZyhbXG4gICAgICBgdW5pZm9ybSAkeyB2YXJpYWJsZVByZWNpc2lvbiB9IHNhbXBsZXIyRCAke3RoaXMuaWR9YCxcbiAgICAgIGAkeyB2YXJpYWJsZVByZWNpc2lvbiB9IGl2ZWMyICR7dGhpcy5zaXplSWR9ID0gaXZlYzIoJHt0aGlzLnRleHR1cmVTaXplWzBdfSwgJHt0aGlzLnRleHR1cmVTaXplWzFdfSlgLFxuICAgICAgYCR7IHZhcmlhYmxlUHJlY2lzaW9uIH0gaXZlYzMgJHt0aGlzLmRpbWVuc2lvbnNJZH0gPSBpdmVjMygke3RoaXMuZGltZW5zaW9uc1swXX0sICR7dGhpcy5kaW1lbnNpb25zWzFdfSwgJHt0aGlzLmRpbWVuc2lvbnNbMl19KWAsXG4gICAgXSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFdlYkdMMktlcm5lbFZhbHVlVW5zaWduZWRJbnB1dFxufTtcbn0se1wiLi4vLi4vLi4vdXRpbHNcIjoxMTQsXCIuLi8uLi93ZWItZ2wva2VybmVsLXZhbHVlL3Vuc2lnbmVkLWlucHV0XCI6Njl9XSwxMDU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyBXZWJHTEtlcm5lbCB9ID0gcmVxdWlyZSgnLi4vd2ViLWdsL2tlcm5lbCcpO1xuY29uc3QgeyBXZWJHTDJGdW5jdGlvbk5vZGUgfSA9IHJlcXVpcmUoJy4vZnVuY3Rpb24tbm9kZScpO1xuY29uc3QgeyBGdW5jdGlvbkJ1aWxkZXIgfSA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9uLWJ1aWxkZXInKTtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzJyk7XG5jb25zdCB7IGZyYWdtZW50U2hhZGVyIH0gPSByZXF1aXJlKCcuL2ZyYWdtZW50LXNoYWRlcicpO1xuY29uc3QgeyB2ZXJ0ZXhTaGFkZXIgfSA9IHJlcXVpcmUoJy4vdmVydGV4LXNoYWRlcicpO1xuY29uc3QgeyBsb29rdXBLZXJuZWxWYWx1ZVR5cGUgfSA9IHJlcXVpcmUoJy4va2VybmVsLXZhbHVlLW1hcHMnKTtcblxubGV0IGlzU3VwcG9ydGVkID0gbnVsbDtcbmxldCB0ZXN0Q2FudmFzID0gbnVsbDtcbmxldCB0ZXN0Q29udGV4dCA9IG51bGw7XG5sZXQgdGVzdEV4dGVuc2lvbnMgPSBudWxsO1xuXG5sZXQgZmVhdHVyZXMgPSBudWxsO1xuXG5jbGFzcyBXZWJHTDJLZXJuZWwgZXh0ZW5kcyBXZWJHTEtlcm5lbCB7XG4gIHN0YXRpYyBnZXQgaXNTdXBwb3J0ZWQoKSB7XG4gICAgaWYgKGlzU3VwcG9ydGVkICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gaXNTdXBwb3J0ZWQ7XG4gICAgfVxuICAgIHRoaXMuc2V0dXBGZWF0dXJlQ2hlY2tzKCk7XG4gICAgaXNTdXBwb3J0ZWQgPSB0aGlzLmlzQ29udGV4dE1hdGNoKHRlc3RDb250ZXh0KTtcbiAgICByZXR1cm4gaXNTdXBwb3J0ZWQ7XG4gIH1cblxuICBzdGF0aWMgc2V0dXBGZWF0dXJlQ2hlY2tzKCkge1xuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0ZXN0Q2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgT2Zmc2NyZWVuQ2FudmFzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdGVzdENhbnZhcyA9IG5ldyBPZmZzY3JlZW5DYW52YXMoMCwgMCk7XG4gICAgfVxuICAgIGlmICghdGVzdENhbnZhcykgcmV0dXJuO1xuICAgIHRlc3RDb250ZXh0ID0gdGVzdENhbnZhcy5nZXRDb250ZXh0KCd3ZWJnbDInKTtcbiAgICBpZiAoIXRlc3RDb250ZXh0IHx8ICF0ZXN0Q29udGV4dC5nZXRFeHRlbnNpb24pIHJldHVybjtcbiAgICB0ZXN0RXh0ZW5zaW9ucyA9IHtcbiAgICAgIEVYVF9jb2xvcl9idWZmZXJfZmxvYXQ6IHRlc3RDb250ZXh0LmdldEV4dGVuc2lvbignRVhUX2NvbG9yX2J1ZmZlcl9mbG9hdCcpLFxuICAgICAgT0VTX3RleHR1cmVfZmxvYXRfbGluZWFyOiB0ZXN0Q29udGV4dC5nZXRFeHRlbnNpb24oJ09FU190ZXh0dXJlX2Zsb2F0X2xpbmVhcicpLFxuICAgIH07XG4gICAgZmVhdHVyZXMgPSB0aGlzLmdldEZlYXR1cmVzKCk7XG4gIH1cblxuICBzdGF0aWMgaXNDb250ZXh0TWF0Y2goY29udGV4dCkge1xuICAgIGlmICh0eXBlb2YgV2ViR0wyUmVuZGVyaW5nQ29udGV4dCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiBjb250ZXh0IGluc3RhbmNlb2YgV2ViR0wyUmVuZGVyaW5nQ29udGV4dDtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgc3RhdGljIGdldEZlYXR1cmVzKCkge1xuICAgIGNvbnN0IGdsID0gdGhpcy50ZXN0Q29udGV4dDtcbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICBpc0Zsb2F0UmVhZDogdGhpcy5nZXRJc0Zsb2F0UmVhZCgpLFxuICAgICAgaXNJbnRlZ2VyRGl2aXNpb25BY2N1cmF0ZTogdGhpcy5nZXRJc0ludGVnZXJEaXZpc2lvbkFjY3VyYXRlKCksXG4gICAgICBpc1NwZWVkVGFjdGljU3VwcG9ydGVkOiB0aGlzLmdldElzU3BlZWRUYWN0aWNTdXBwb3J0ZWQoKSxcbiAgICAgIGtlcm5lbE1hcDogdHJ1ZSxcbiAgICAgIGlzVGV4dHVyZUZsb2F0OiB0cnVlLFxuICAgICAgaXNEcmF3QnVmZmVyczogdHJ1ZSxcbiAgICAgIGNoYW5uZWxDb3VudDogdGhpcy5nZXRDaGFubmVsQ291bnQoKSxcbiAgICAgIG1heFRleHR1cmVTaXplOiB0aGlzLmdldE1heFRleHR1cmVTaXplKCksXG4gICAgICBsb3dJbnRQcmVjaXNpb246IGdsLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdChnbC5GUkFHTUVOVF9TSEFERVIsIGdsLkxPV19JTlQpLFxuICAgICAgbG93RmxvYXRQcmVjaXNpb246IGdsLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdChnbC5GUkFHTUVOVF9TSEFERVIsIGdsLkxPV19GTE9BVCksXG4gICAgICBtZWRpdW1JbnRQcmVjaXNpb246IGdsLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdChnbC5GUkFHTUVOVF9TSEFERVIsIGdsLk1FRElVTV9JTlQpLFxuICAgICAgbWVkaXVtRmxvYXRQcmVjaXNpb246IGdsLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdChnbC5GUkFHTUVOVF9TSEFERVIsIGdsLk1FRElVTV9GTE9BVCksXG4gICAgICBoaWdoSW50UHJlY2lzaW9uOiBnbC5nZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXQoZ2wuRlJBR01FTlRfU0hBREVSLCBnbC5ISUdIX0lOVCksXG4gICAgICBoaWdoRmxvYXRQcmVjaXNpb246IGdsLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdChnbC5GUkFHTUVOVF9TSEFERVIsIGdsLkhJR0hfRkxPQVQpLFxuICAgIH0pO1xuICB9XG5cbiAgc3RhdGljIGdldElzVGV4dHVyZUZsb2F0KCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgc3RhdGljIGdldENoYW5uZWxDb3VudCgpIHtcbiAgICByZXR1cm4gdGVzdENvbnRleHQuZ2V0UGFyYW1ldGVyKHRlc3RDb250ZXh0Lk1BWF9EUkFXX0JVRkZFUlMpO1xuICB9XG5cbiAgc3RhdGljIGdldE1heFRleHR1cmVTaXplKCkge1xuICAgIHJldHVybiB0ZXN0Q29udGV4dC5nZXRQYXJhbWV0ZXIodGVzdENvbnRleHQuTUFYX1RFWFRVUkVfU0laRSk7XG4gIH1cblxuICBzdGF0aWMgbG9va3VwS2VybmVsVmFsdWVUeXBlKHR5cGUsIGR5bmFtaWMsIHByZWNpc2lvbiwgdmFsdWUpIHtcbiAgICByZXR1cm4gbG9va3VwS2VybmVsVmFsdWVUeXBlKHR5cGUsIGR5bmFtaWMsIHByZWNpc2lvbiwgdmFsdWUpO1xuICB9XG5cbiAgc3RhdGljIGdldCB0ZXN0Q2FudmFzKCkge1xuICAgIHJldHVybiB0ZXN0Q2FudmFzO1xuICB9XG5cbiAgc3RhdGljIGdldCB0ZXN0Q29udGV4dCgpIHtcbiAgICByZXR1cm4gdGVzdENvbnRleHQ7XG4gIH1cblxuICBzdGF0aWMgZ2V0IGZlYXR1cmVzKCkge1xuICAgIHJldHVybiBmZWF0dXJlcztcbiAgfVxuXG4gIHN0YXRpYyBnZXQgZnJhZ21lbnRTaGFkZXIoKSB7XG4gICAgcmV0dXJuIGZyYWdtZW50U2hhZGVyO1xuICB9XG4gIHN0YXRpYyBnZXQgdmVydGV4U2hhZGVyKCkge1xuICAgIHJldHVybiB2ZXJ0ZXhTaGFkZXI7XG4gIH1cblxuICBpbml0Q29udGV4dCgpIHtcbiAgICBjb25zdCBzZXR0aW5ncyA9IHtcbiAgICAgIGFscGhhOiBmYWxzZSxcbiAgICAgIGRlcHRoOiBmYWxzZSxcbiAgICAgIGFudGlhbGlhczogZmFsc2VcbiAgICB9O1xuICAgIHJldHVybiB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KCd3ZWJnbDInLCBzZXR0aW5ncyk7XG4gIH1cblxuICBpbml0RXh0ZW5zaW9ucygpIHtcbiAgICB0aGlzLmV4dGVuc2lvbnMgPSB7XG4gICAgICBFWFRfY29sb3JfYnVmZmVyX2Zsb2F0OiB0aGlzLmNvbnRleHQuZ2V0RXh0ZW5zaW9uKCdFWFRfY29sb3JfYnVmZmVyX2Zsb2F0JyksXG4gICAgICBPRVNfdGV4dHVyZV9mbG9hdF9saW5lYXI6IHRoaXMuY29udGV4dC5nZXRFeHRlbnNpb24oJ09FU190ZXh0dXJlX2Zsb2F0X2xpbmVhcicpLFxuICAgIH07XG4gIH1cblxuICB2YWxpZGF0ZVNldHRpbmdzKGFyZ3MpIHtcbiAgICBpZiAoIXRoaXMudmFsaWRhdGUpIHtcbiAgICAgIHRoaXMudGV4U2l6ZSA9IHV0aWxzLmdldEtlcm5lbFRleHR1cmVTaXplKHtcbiAgICAgICAgb3B0aW1pemVGbG9hdE1lbW9yeTogdGhpcy5vcHRpbWl6ZUZsb2F0TWVtb3J5LFxuICAgICAgICBwcmVjaXNpb246IHRoaXMucHJlY2lzaW9uLFxuICAgICAgfSwgdGhpcy5vdXRwdXQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHsgZmVhdHVyZXMgfSA9IHRoaXMuY29uc3RydWN0b3I7XG4gICAgaWYgKHRoaXMucHJlY2lzaW9uID09PSAnc2luZ2xlJyAmJiAhZmVhdHVyZXMuaXNGbG9hdFJlYWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRmxvYXQgdGV4dHVyZSBvdXRwdXRzIGFyZSBub3Qgc3VwcG9ydGVkJyk7XG4gICAgfSBlbHNlIGlmICghdGhpcy5ncmFwaGljYWwgJiYgdGhpcy5wcmVjaXNpb24gPT09IG51bGwpIHtcbiAgICAgIHRoaXMucHJlY2lzaW9uID0gZmVhdHVyZXMuaXNGbG9hdFJlYWQgPyAnc2luZ2xlJyA6ICd1bnNpZ25lZCc7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZml4SW50ZWdlckRpdmlzaW9uQWNjdXJhY3kgPT09IG51bGwpIHtcbiAgICAgIHRoaXMuZml4SW50ZWdlckRpdmlzaW9uQWNjdXJhY3kgPSAhZmVhdHVyZXMuaXNJbnRlZ2VyRGl2aXNpb25BY2N1cmF0ZTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuZml4SW50ZWdlckRpdmlzaW9uQWNjdXJhY3kgJiYgZmVhdHVyZXMuaXNJbnRlZ2VyRGl2aXNpb25BY2N1cmF0ZSkge1xuICAgICAgdGhpcy5maXhJbnRlZ2VyRGl2aXNpb25BY2N1cmFjeSA9IGZhbHNlO1xuICAgIH1cblxuICAgIHRoaXMuY2hlY2tPdXRwdXQoKTtcblxuICAgIGlmICghdGhpcy5vdXRwdXQgfHwgdGhpcy5vdXRwdXQubGVuZ3RoID09PSAwKSB7XG4gICAgICBpZiAoYXJncy5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBdXRvIG91dHB1dCBvbmx5IHN1cHBvcnRlZCBmb3Iga2VybmVscyB3aXRoIG9ubHkgb25lIGlucHV0Jyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGFyZ1R5cGUgPSB1dGlscy5nZXRWYXJpYWJsZVR5cGUoYXJnc1swXSwgdGhpcy5zdHJpY3RJbnRlZ2Vycyk7XG4gICAgICBzd2l0Y2ggKGFyZ1R5cGUpIHtcbiAgICAgICAgY2FzZSAnQXJyYXknOlxuICAgICAgICAgIHRoaXMub3V0cHV0ID0gdXRpbHMuZ2V0RGltZW5zaW9ucyhhcmdUeXBlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnTnVtYmVyVGV4dHVyZSc6XG4gICAgICAgIGNhc2UgJ01lbW9yeU9wdGltaXplZE51bWJlclRleHR1cmUnOlxuICAgICAgICBjYXNlICdBcnJheVRleHR1cmUoMSknOlxuICAgICAgICBjYXNlICdBcnJheVRleHR1cmUoMiknOlxuICAgICAgICBjYXNlICdBcnJheVRleHR1cmUoMyknOlxuICAgICAgICBjYXNlICdBcnJheVRleHR1cmUoNCknOlxuICAgICAgICAgIHRoaXMub3V0cHV0ID0gYXJnc1swXS5vdXRwdXQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBdXRvIG91dHB1dCBub3Qgc3VwcG9ydGVkIGZvciBpbnB1dCB0eXBlOiAnICsgYXJnVHlwZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZ3JhcGhpY2FsKSB7XG4gICAgICBpZiAodGhpcy5vdXRwdXQubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignT3V0cHV0IG11c3QgaGF2ZSAyIGRpbWVuc2lvbnMgb24gZ3JhcGhpY2FsIG1vZGUnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMucHJlY2lzaW9uID09PSAnc2luZ2xlJykge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0Nhbm5vdCB1c2UgZ3JhcGhpY2FsIG1vZGUgYW5kIHNpbmdsZSBwcmVjaXNpb24gYXQgdGhlIHNhbWUgdGltZScpO1xuICAgICAgICB0aGlzLnByZWNpc2lvbiA9ICd1bnNpZ25lZCc7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudGV4U2l6ZSA9IHV0aWxzLmNsb25lKHRoaXMub3V0cHV0KTtcbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2UgaWYgKCF0aGlzLmdyYXBoaWNhbCAmJiB0aGlzLnByZWNpc2lvbiA9PT0gbnVsbCAmJiBmZWF0dXJlcy5pc1RleHR1cmVGbG9hdCkge1xuICAgICAgdGhpcy5wcmVjaXNpb24gPSAnc2luZ2xlJztcbiAgICB9XG5cbiAgICB0aGlzLnRleFNpemUgPSB1dGlscy5nZXRLZXJuZWxUZXh0dXJlU2l6ZSh7XG4gICAgICBvcHRpbWl6ZUZsb2F0TWVtb3J5OiB0aGlzLm9wdGltaXplRmxvYXRNZW1vcnksXG4gICAgICBwcmVjaXNpb246IHRoaXMucHJlY2lzaW9uLFxuICAgIH0sIHRoaXMub3V0cHV0KTtcblxuICAgIHRoaXMuY2hlY2tUZXh0dXJlU2l6ZSgpO1xuICB9XG5cbiAgdHJhbnNsYXRlU291cmNlKCkge1xuICAgIGNvbnN0IGZ1bmN0aW9uQnVpbGRlciA9IEZ1bmN0aW9uQnVpbGRlci5mcm9tS2VybmVsKHRoaXMsIFdlYkdMMkZ1bmN0aW9uTm9kZSwge1xuICAgICAgZml4SW50ZWdlckRpdmlzaW9uQWNjdXJhY3k6IHRoaXMuZml4SW50ZWdlckRpdmlzaW9uQWNjdXJhY3lcbiAgICB9KTtcbiAgICB0aGlzLnRyYW5zbGF0ZWRTb3VyY2UgPSBmdW5jdGlvbkJ1aWxkZXIuZ2V0UHJvdG90eXBlU3RyaW5nKCdrZXJuZWwnKTtcbiAgICB0aGlzLnNldHVwUmV0dXJuVHlwZXMoZnVuY3Rpb25CdWlsZGVyKTtcbiAgfVxuXG4gIGRyYXdCdWZmZXJzKCkge1xuICAgIHRoaXMuY29udGV4dC5kcmF3QnVmZmVycyh0aGlzLmRyYXdCdWZmZXJzTWFwKTtcbiAgfVxuXG4gIGdldFRleHR1cmVGb3JtYXQoKSB7XG4gICAgY29uc3QgeyBjb250ZXh0OiBnbCB9ID0gdGhpcztcbiAgICBzd2l0Y2ggKHRoaXMuZ2V0SW50ZXJuYWxGb3JtYXQoKSkge1xuICAgICAgY2FzZSBnbC5SMzJGOlxuICAgICAgICByZXR1cm4gZ2wuUkVEO1xuICAgICAgY2FzZSBnbC5SRzMyRjpcbiAgICAgICAgcmV0dXJuIGdsLlJHO1xuICAgICAgY2FzZSBnbC5SR0JBMzJGOlxuICAgICAgICByZXR1cm4gZ2wuUkdCQTtcbiAgICAgIGNhc2UgZ2wuUkdCQTpcbiAgICAgICAgcmV0dXJuIGdsLlJHQkE7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gaW50ZXJuYWwgZm9ybWF0Jyk7XG4gICAgfVxuICB9XG4gIGdldEludGVybmFsRm9ybWF0KCkge1xuICAgIGNvbnN0IHsgY29udGV4dDogZ2wgfSA9IHRoaXM7XG5cbiAgICBpZiAodGhpcy5wcmVjaXNpb24gPT09ICdzaW5nbGUnKSB7XG4gICAgICBpZiAodGhpcy5waXBlbGluZSkge1xuICAgICAgICBzd2l0Y2ggKHRoaXMucmV0dXJuVHlwZSkge1xuICAgICAgICAgIGNhc2UgJ051bWJlcic6XG4gICAgICAgICAgY2FzZSAnRmxvYXQnOlxuICAgICAgICAgIGNhc2UgJ0ludGVnZXInOlxuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW1pemVGbG9hdE1lbW9yeSkge1xuICAgICAgICAgICAgICByZXR1cm4gZ2wuUkdCQTMyRjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBnbC5SMzJGO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnQXJyYXkoMiknOlxuICAgICAgICAgICAgICByZXR1cm4gZ2wuUkczMkY7XG4gICAgICAgICAgICBjYXNlICdBcnJheSgzKSc6IFxuICAgICAgICAgICAgY2FzZSAnQXJyYXkoNCknOlxuICAgICAgICAgICAgICByZXR1cm4gZ2wuUkdCQTMyRjtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5oYW5kbGVkIHJldHVybiB0eXBlJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBnbC5SR0JBMzJGO1xuICAgIH1cbiAgICByZXR1cm4gZ2wuUkdCQTtcbiAgfVxuXG4gIF9zZXR1cE91dHB1dFRleHR1cmUoKSB7XG4gICAgY29uc3QgZ2wgPSB0aGlzLmNvbnRleHQ7XG4gICAgaWYgKHRoaXMudGV4dHVyZSkge1xuICAgICAgZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoZ2wuRlJBTUVCVUZGRVIsIGdsLkNPTE9SX0FUVEFDSE1FTlQwLCBnbC5URVhUVVJFXzJELCB0aGlzLnRleHR1cmUudGV4dHVyZSwgMCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgdGhpcy5mcmFtZWJ1ZmZlcik7XG4gICAgY29uc3QgdGV4dHVyZSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcbiAgICBjb25zdCB0ZXhTaXplID0gdGhpcy50ZXhTaXplO1xuICAgIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTAgKyB0aGlzLmNvbnN0YW50VGV4dHVyZUNvdW50ICsgdGhpcy5hcmd1bWVudFRleHR1cmVDb3VudCk7XG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSk7XG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuUkVQRUFUKTtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5SRVBFQVQpO1xuICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5ORUFSRVNUKTtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTkVBUkVTVCk7XG4gICAgY29uc3QgZm9ybWF0ID0gdGhpcy5nZXRJbnRlcm5hbEZvcm1hdCgpO1xuICAgIGlmICh0aGlzLnByZWNpc2lvbiA9PT0gJ3NpbmdsZScpIHtcbiAgICAgIGdsLnRleFN0b3JhZ2UyRChnbC5URVhUVVJFXzJELCAxLCBmb3JtYXQsIHRleFNpemVbMF0sIHRleFNpemVbMV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGZvcm1hdCwgdGV4U2l6ZVswXSwgdGV4U2l6ZVsxXSwgMCwgZm9ybWF0LCBnbC5VTlNJR05FRF9CWVRFLCBudWxsKTtcbiAgICB9XG4gICAgZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoZ2wuRlJBTUVCVUZGRVIsIGdsLkNPTE9SX0FUVEFDSE1FTlQwLCBnbC5URVhUVVJFXzJELCB0ZXh0dXJlLCAwKTtcbiAgICB0aGlzLnRleHR1cmUgPSBuZXcgdGhpcy5UZXh0dXJlQ29uc3RydWN0b3Ioe1xuICAgICAgdGV4dHVyZSxcbiAgICAgIHNpemU6IHRleFNpemUsXG4gICAgICBkaW1lbnNpb25zOiB0aGlzLnRocmVhZERpbSxcbiAgICAgIG91dHB1dDogdGhpcy5vdXRwdXQsXG4gICAgICBjb250ZXh0OiB0aGlzLmNvbnRleHQsXG4gICAgICBpbnRlcm5hbEZvcm1hdDogdGhpcy5nZXRJbnRlcm5hbEZvcm1hdCgpLFxuICAgICAgdGV4dHVyZUZvcm1hdDogdGhpcy5nZXRUZXh0dXJlRm9ybWF0KCksXG4gICAgICBrZXJuZWw6IHRoaXMsXG4gICAgfSk7XG4gIH1cblxuICBfc2V0dXBTdWJPdXRwdXRUZXh0dXJlcygpIHtcbiAgICBjb25zdCBnbCA9IHRoaXMuY29udGV4dDtcbiAgICBpZiAodGhpcy5tYXBwZWRUZXh0dXJlcykge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnN1Yktlcm5lbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoZ2wuRlJBTUVCVUZGRVIsIGdsLkNPTE9SX0FUVEFDSE1FTlQwICsgaSArIDEsIGdsLlRFWFRVUkVfMkQsIHRoaXMubWFwcGVkVGV4dHVyZXNbaV0udGV4dHVyZSwgMCk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHRleFNpemUgPSB0aGlzLnRleFNpemU7XG4gICAgdGhpcy5kcmF3QnVmZmVyc01hcCA9IFtnbC5DT0xPUl9BVFRBQ0hNRU5UMF07XG4gICAgdGhpcy5tYXBwZWRUZXh0dXJlcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zdWJLZXJuZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCB0ZXh0dXJlID0gdGhpcy5jcmVhdGVUZXh0dXJlKCk7XG4gICAgICB0aGlzLmRyYXdCdWZmZXJzTWFwLnB1c2goZ2wuQ09MT1JfQVRUQUNITUVOVDAgKyBpICsgMSk7XG4gICAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwICsgdGhpcy5jb25zdGFudFRleHR1cmVDb3VudCArIHRoaXMuYXJndW1lbnRUZXh0dXJlQ291bnQgKyBpKTtcbiAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmUpO1xuICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFKTtcbiAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5ORUFSRVNUKTtcbiAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5ORUFSRVNUKTtcbiAgICAgIGNvbnN0IGZvcm1hdCA9IHRoaXMuZ2V0SW50ZXJuYWxGb3JtYXQoKTtcbiAgICAgIGlmICh0aGlzLnByZWNpc2lvbiA9PT0gJ3NpbmdsZScpIHtcbiAgICAgICAgZ2wudGV4U3RvcmFnZTJEKGdsLlRFWFRVUkVfMkQsIDEsIGZvcm1hdCwgdGV4U2l6ZVswXSwgdGV4U2l6ZVsxXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIHRleFNpemVbMF0sIHRleFNpemVbMV0sIDAsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIG51bGwpO1xuICAgICAgfVxuICAgICAgZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoZ2wuRlJBTUVCVUZGRVIsIGdsLkNPTE9SX0FUVEFDSE1FTlQwICsgaSArIDEsIGdsLlRFWFRVUkVfMkQsIHRleHR1cmUsIDApO1xuXG4gICAgICB0aGlzLm1hcHBlZFRleHR1cmVzLnB1c2gobmV3IHRoaXMuVGV4dHVyZUNvbnN0cnVjdG9yKHtcbiAgICAgICAgdGV4dHVyZSxcbiAgICAgICAgc2l6ZTogdGV4U2l6ZSxcbiAgICAgICAgZGltZW5zaW9uczogdGhpcy50aHJlYWREaW0sXG4gICAgICAgIG91dHB1dDogdGhpcy5vdXRwdXQsXG4gICAgICAgIGNvbnRleHQ6IHRoaXMuY29udGV4dCxcbiAgICAgICAgaW50ZXJuYWxGb3JtYXQ6IHRoaXMuZ2V0SW50ZXJuYWxGb3JtYXQoKSxcbiAgICAgICAgdGV4dHVyZUZvcm1hdDogdGhpcy5nZXRUZXh0dXJlRm9ybWF0KCksXG4gICAgICAgIGtlcm5lbDogdGhpcyxcbiAgICAgIH0pKTtcbiAgICB9XG4gIH1cblxuICBfZ2V0SGVhZGVyU3RyaW5nKCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIF9nZXRUZXh0dXJlQ29vcmRpbmF0ZSgpIHtcbiAgICBjb25zdCBzdWJLZXJuZWxzID0gdGhpcy5zdWJLZXJuZWxzO1xuICAgIGNvbnN0IHZhcmlhYmxlUHJlY2lzaW9uID0gdGhpcy5nZXRWYXJpYWJsZVByZWNpc2lvblN0cmluZyh0aGlzLnRleFNpemUsIHRoaXMudGFjdGljKTtcbiAgICBpZiAoc3ViS2VybmVscyA9PT0gbnVsbCB8fCBzdWJLZXJuZWxzLmxlbmd0aCA8IDEpIHtcbiAgICAgIHJldHVybiBgaW4gJHsgdmFyaWFibGVQcmVjaXNpb24gfSB2ZWMyIHZUZXhDb29yZDtcXG5gO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYG91dCAkeyB2YXJpYWJsZVByZWNpc2lvbiB9IHZlYzIgdlRleENvb3JkO1xcbmA7XG4gICAgfVxuICB9XG5cbiAgX2dldE1haW5Bcmd1bWVudHNTdHJpbmcoYXJncykge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGNvbnN0IGFyZ3VtZW50TmFtZXMgPSB0aGlzLmFyZ3VtZW50TmFtZXM7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcmd1bWVudE5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICByZXN1bHQucHVzaCh0aGlzLmtlcm5lbEFyZ3VtZW50c1tpXS5nZXRTb3VyY2UoYXJnc1tpXSkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0LmpvaW4oJycpO1xuICB9XG5cbiAgZ2V0S2VybmVsU3RyaW5nKCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IFt0aGlzLmdldEtlcm5lbFJlc3VsdERlY2xhcmF0aW9uKCldO1xuICAgIGNvbnN0IHN1Yktlcm5lbHMgPSB0aGlzLnN1Yktlcm5lbHM7XG4gICAgaWYgKHN1Yktlcm5lbHMgIT09IG51bGwpIHtcbiAgICAgIHJlc3VsdC5wdXNoKFxuICAgICAgICAnbGF5b3V0KGxvY2F0aW9uID0gMCkgb3V0IHZlYzQgZGF0YTAnXG4gICAgICApO1xuICAgICAgc3dpdGNoICh0aGlzLnJldHVyblR5cGUpIHtcbiAgICAgICAgY2FzZSAnTnVtYmVyJzpcbiAgICAgICAgY2FzZSAnRmxvYXQnOlxuICAgICAgICBjYXNlICdJbnRlZ2VyJzpcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN1Yktlcm5lbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHN1Yktlcm5lbCA9IHN1Yktlcm5lbHNbaV07XG4gICAgICAgICAgICByZXN1bHQucHVzaChcbiAgICAgICAgICAgICAgc3ViS2VybmVsLnJldHVyblR5cGUgPT09ICdJbnRlZ2VyJyA/XG4gICAgICAgICAgICAgIGBpbnQgc3ViS2VybmVsUmVzdWx0XyR7IHN1Yktlcm5lbC5uYW1lIH0gPSAwYCA6XG4gICAgICAgICAgICAgIGBmbG9hdCBzdWJLZXJuZWxSZXN1bHRfJHsgc3ViS2VybmVsLm5hbWUgfSA9IDAuMGAsXG4gICAgICAgICAgICAgIGBsYXlvdXQobG9jYXRpb24gPSAkeyBpICsgMSB9KSBvdXQgdmVjNCBkYXRhJHsgaSArIDEgfWBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdBcnJheSgyKSc6XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdWJLZXJuZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChcbiAgICAgICAgICAgICAgYHZlYzIgc3ViS2VybmVsUmVzdWx0XyR7IHN1Yktlcm5lbHNbaV0ubmFtZSB9YCxcbiAgICAgICAgICAgICAgYGxheW91dChsb2NhdGlvbiA9ICR7IGkgKyAxIH0pIG91dCB2ZWM0IGRhdGEkeyBpICsgMSB9YFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ0FycmF5KDMpJzpcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN1Yktlcm5lbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKFxuICAgICAgICAgICAgICBgdmVjMyBzdWJLZXJuZWxSZXN1bHRfJHsgc3ViS2VybmVsc1tpXS5uYW1lIH1gLFxuICAgICAgICAgICAgICBgbGF5b3V0KGxvY2F0aW9uID0gJHsgaSArIDEgfSkgb3V0IHZlYzQgZGF0YSR7IGkgKyAxIH1gXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnQXJyYXkoNCknOlxuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3ViS2VybmVscy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goXG4gICAgICAgICAgICAgIGB2ZWM0IHN1Yktlcm5lbFJlc3VsdF8keyBzdWJLZXJuZWxzW2ldLm5hbWUgfWAsXG4gICAgICAgICAgICAgIGBsYXlvdXQobG9jYXRpb24gPSAkeyBpICsgMSB9KSBvdXQgdmVjNCBkYXRhJHsgaSArIDEgfWBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQucHVzaChcbiAgICAgICAgJ291dCB2ZWM0IGRhdGEwJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdXRpbHMubGluZXNUb1N0cmluZyhyZXN1bHQpICsgdGhpcy50cmFuc2xhdGVkU291cmNlO1xuICB9XG5cbiAgZ2V0TWFpblJlc3VsdEdyYXBoaWNhbCgpIHtcbiAgICByZXR1cm4gdXRpbHMubGluZXNUb1N0cmluZyhbXG4gICAgICAnICB0aHJlYWRJZCA9IGluZGV4VG8zRChpbmRleCwgdU91dHB1dERpbSknLFxuICAgICAgJyAga2VybmVsKCknLFxuICAgICAgJyAgZGF0YTAgPSBhY3R1YWxDb2xvcicsXG4gICAgXSk7XG4gIH1cblxuICBnZXRNYWluUmVzdWx0UGFja2VkUGl4ZWxzKCkge1xuICAgIHN3aXRjaCAodGhpcy5yZXR1cm5UeXBlKSB7XG4gICAgICBjYXNlICdMaXRlcmFsSW50ZWdlcic6XG4gICAgICBjYXNlICdOdW1iZXInOlxuICAgICAgY2FzZSAnSW50ZWdlcic6XG4gICAgICBjYXNlICdGbG9hdCc6XG4gICAgICAgIHJldHVybiB0aGlzLmdldE1haW5SZXN1bHRLZXJuZWxQYWNrZWRQaXhlbHMoKSArXG4gICAgICAgICAgdGhpcy5nZXRNYWluUmVzdWx0U3ViS2VybmVsUGFja2VkUGl4ZWxzKCk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHBhY2tlZCBvdXRwdXQgb25seSB1c2FibGUgd2l0aCBOdW1iZXJzLCBcIiR7dGhpcy5yZXR1cm5UeXBlfVwiIHNwZWNpZmllZGApO1xuICAgIH1cbiAgfVxuXG4gIGdldE1haW5SZXN1bHRLZXJuZWxQYWNrZWRQaXhlbHMoKSB7XG4gICAgcmV0dXJuIHV0aWxzLmxpbmVzVG9TdHJpbmcoW1xuICAgICAgJyAgdGhyZWFkSWQgPSBpbmRleFRvM0QoaW5kZXgsIHVPdXRwdXREaW0pJyxcbiAgICAgICcgIGtlcm5lbCgpJyxcbiAgICAgIGAgIGRhdGEwID0gJHt0aGlzLnVzZUxlZ2FjeUVuY29kZXIgPyAnbGVnYWN5RW5jb2RlMzInIDogJ2VuY29kZTMyJ30oa2VybmVsUmVzdWx0KWBcbiAgICBdKTtcbiAgfVxuXG4gIGdldE1haW5SZXN1bHRTdWJLZXJuZWxQYWNrZWRQaXhlbHMoKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgaWYgKCF0aGlzLnN1Yktlcm5lbHMpIHJldHVybiAnJztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc3ViS2VybmVscy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qgc3ViS2VybmVsID0gdGhpcy5zdWJLZXJuZWxzW2ldO1xuICAgICAgaWYgKHN1Yktlcm5lbC5yZXR1cm5UeXBlID09PSAnSW50ZWdlcicpIHtcbiAgICAgICAgcmVzdWx0LnB1c2goXG4gICAgICAgICAgYCAgZGF0YSR7aSArIDF9ID0gJHt0aGlzLnVzZUxlZ2FjeUVuY29kZXIgPyAnbGVnYWN5RW5jb2RlMzInIDogJ2VuY29kZTMyJ30oZmxvYXQoc3ViS2VybmVsUmVzdWx0XyR7dGhpcy5zdWJLZXJuZWxzW2ldLm5hbWV9KSlgXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQucHVzaChcbiAgICAgICAgICBgICBkYXRhJHtpICsgMX0gPSAke3RoaXMudXNlTGVnYWN5RW5jb2RlciA/ICdsZWdhY3lFbmNvZGUzMicgOiAnZW5jb2RlMzInfShzdWJLZXJuZWxSZXN1bHRfJHt0aGlzLnN1Yktlcm5lbHNbaV0ubmFtZX0pYFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdXRpbHMubGluZXNUb1N0cmluZyhyZXN1bHQpO1xuICB9XG5cbiAgZ2V0TWFpblJlc3VsdEtlcm5lbE1lbW9yeU9wdGltaXplZEZsb2F0cyhyZXN1bHQsIGNoYW5uZWwpIHtcbiAgICByZXN1bHQucHVzaChcbiAgICAgICcgIHRocmVhZElkID0gaW5kZXhUbzNEKGluZGV4LCB1T3V0cHV0RGltKScsXG4gICAgICAnICBrZXJuZWwoKScsXG4gICAgICBgICBkYXRhMC4ke2NoYW5uZWx9ID0ga2VybmVsUmVzdWx0YFxuICAgICk7XG4gIH1cblxuICBnZXRNYWluUmVzdWx0U3ViS2VybmVsTWVtb3J5T3B0aW1pemVkRmxvYXRzKHJlc3VsdCwgY2hhbm5lbCkge1xuICAgIGlmICghdGhpcy5zdWJLZXJuZWxzKSByZXR1cm4gcmVzdWx0O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zdWJLZXJuZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBzdWJLZXJuZWwgPSB0aGlzLnN1Yktlcm5lbHNbaV07XG4gICAgICBpZiAoc3ViS2VybmVsLnJldHVyblR5cGUgPT09ICdJbnRlZ2VyJykge1xuICAgICAgICByZXN1bHQucHVzaChcbiAgICAgICAgICBgICBkYXRhJHtpICsgMX0uJHtjaGFubmVsfSA9IGZsb2F0KHN1Yktlcm5lbFJlc3VsdF8ke3N1Yktlcm5lbC5uYW1lfSlgXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQucHVzaChcbiAgICAgICAgICBgICBkYXRhJHtpICsgMX0uJHtjaGFubmVsfSA9IHN1Yktlcm5lbFJlc3VsdF8ke3N1Yktlcm5lbC5uYW1lfWBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBnZXRNYWluUmVzdWx0S2VybmVsTnVtYmVyVGV4dHVyZSgpIHtcbiAgICByZXR1cm4gW1xuICAgICAgJyAgdGhyZWFkSWQgPSBpbmRleFRvM0QoaW5kZXgsIHVPdXRwdXREaW0pJyxcbiAgICAgICcgIGtlcm5lbCgpJyxcbiAgICAgICcgIGRhdGEwWzBdID0ga2VybmVsUmVzdWx0JyxcbiAgICBdO1xuICB9XG5cbiAgZ2V0TWFpblJlc3VsdFN1Yktlcm5lbE51bWJlclRleHR1cmUoKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgaWYgKCF0aGlzLnN1Yktlcm5lbHMpIHJldHVybiByZXN1bHQ7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnN1Yktlcm5lbHMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGNvbnN0IHN1Yktlcm5lbCA9IHRoaXMuc3ViS2VybmVsc1tpXTtcbiAgICAgIGlmIChzdWJLZXJuZWwucmV0dXJuVHlwZSA9PT0gJ0ludGVnZXInKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKFxuICAgICAgICAgIGAgIGRhdGEke2kgKyAxfVswXSA9IGZsb2F0KHN1Yktlcm5lbFJlc3VsdF8ke3N1Yktlcm5lbC5uYW1lfSlgXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQucHVzaChcbiAgICAgICAgICBgICBkYXRhJHtpICsgMX1bMF0gPSBzdWJLZXJuZWxSZXN1bHRfJHtzdWJLZXJuZWwubmFtZX1gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBnZXRNYWluUmVzdWx0S2VybmVsQXJyYXkyVGV4dHVyZSgpIHtcbiAgICByZXR1cm4gW1xuICAgICAgJyAgdGhyZWFkSWQgPSBpbmRleFRvM0QoaW5kZXgsIHVPdXRwdXREaW0pJyxcbiAgICAgICcgIGtlcm5lbCgpJyxcbiAgICAgICcgIGRhdGEwWzBdID0ga2VybmVsUmVzdWx0WzBdJyxcbiAgICAgICcgIGRhdGEwWzFdID0ga2VybmVsUmVzdWx0WzFdJyxcbiAgICBdO1xuICB9XG5cbiAgZ2V0TWFpblJlc3VsdFN1Yktlcm5lbEFycmF5MlRleHR1cmUoKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgaWYgKCF0aGlzLnN1Yktlcm5lbHMpIHJldHVybiByZXN1bHQ7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnN1Yktlcm5lbHMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGNvbnN0IHN1Yktlcm5lbCA9IHRoaXMuc3ViS2VybmVsc1tpXTtcbiAgICAgIHJlc3VsdC5wdXNoKFxuICAgICAgICBgICBkYXRhJHtpICsgMX1bMF0gPSBzdWJLZXJuZWxSZXN1bHRfJHtzdWJLZXJuZWwubmFtZX1bMF1gLFxuICAgICAgICBgICBkYXRhJHtpICsgMX1bMV0gPSBzdWJLZXJuZWxSZXN1bHRfJHtzdWJLZXJuZWwubmFtZX1bMV1gXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZ2V0TWFpblJlc3VsdEtlcm5lbEFycmF5M1RleHR1cmUoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICcgIHRocmVhZElkID0gaW5kZXhUbzNEKGluZGV4LCB1T3V0cHV0RGltKScsXG4gICAgICAnICBrZXJuZWwoKScsXG4gICAgICAnICBkYXRhMFswXSA9IGtlcm5lbFJlc3VsdFswXScsXG4gICAgICAnICBkYXRhMFsxXSA9IGtlcm5lbFJlc3VsdFsxXScsXG4gICAgICAnICBkYXRhMFsyXSA9IGtlcm5lbFJlc3VsdFsyXScsXG4gICAgXTtcbiAgfVxuXG4gIGdldE1haW5SZXN1bHRTdWJLZXJuZWxBcnJheTNUZXh0dXJlKCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGlmICghdGhpcy5zdWJLZXJuZWxzKSByZXR1cm4gcmVzdWx0O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zdWJLZXJuZWxzLmxlbmd0aDsgKytpKSB7XG4gICAgICBjb25zdCBzdWJLZXJuZWwgPSB0aGlzLnN1Yktlcm5lbHNbaV07XG4gICAgICByZXN1bHQucHVzaChcbiAgICAgICAgYCAgZGF0YSR7aSArIDF9WzBdID0gc3ViS2VybmVsUmVzdWx0XyR7c3ViS2VybmVsLm5hbWV9WzBdYCxcbiAgICAgICAgYCAgZGF0YSR7aSArIDF9WzFdID0gc3ViS2VybmVsUmVzdWx0XyR7c3ViS2VybmVsLm5hbWV9WzFdYCxcbiAgICAgICAgYCAgZGF0YSR7aSArIDF9WzJdID0gc3ViS2VybmVsUmVzdWx0XyR7c3ViS2VybmVsLm5hbWV9WzJdYFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGdldE1haW5SZXN1bHRLZXJuZWxBcnJheTRUZXh0dXJlKCkge1xuICAgIHJldHVybiBbXG4gICAgICAnICB0aHJlYWRJZCA9IGluZGV4VG8zRChpbmRleCwgdU91dHB1dERpbSknLFxuICAgICAgJyAga2VybmVsKCknLFxuICAgICAgJyAgZGF0YTAgPSBrZXJuZWxSZXN1bHQnLFxuICAgIF07XG4gIH1cblxuICBnZXRNYWluUmVzdWx0U3ViS2VybmVsQXJyYXk0VGV4dHVyZSgpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBpZiAoIXRoaXMuc3ViS2VybmVscykgcmV0dXJuIHJlc3VsdDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc3ViS2VybmVscy5sZW5ndGg7ICsraSkge1xuICAgICAgcmVzdWx0LnB1c2goXG4gICAgICAgIGAgIGRhdGEke2kgKyAxfSA9IHN1Yktlcm5lbFJlc3VsdF8ke3RoaXMuc3ViS2VybmVsc1tpXS5uYW1lfWBcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBkZXN0cm95RXh0ZW5zaW9ucygpIHtcbiAgICB0aGlzLmV4dGVuc2lvbnMuRVhUX2NvbG9yX2J1ZmZlcl9mbG9hdCA9IG51bGw7XG4gICAgdGhpcy5leHRlbnNpb25zLk9FU190ZXh0dXJlX2Zsb2F0X2xpbmVhciA9IG51bGw7XG4gIH1cblxuICB0b0pTT04oKSB7XG4gICAgY29uc3QganNvbiA9IHN1cGVyLnRvSlNPTigpO1xuICAgIGpzb24uZnVuY3Rpb25Ob2RlcyA9IEZ1bmN0aW9uQnVpbGRlci5mcm9tS2VybmVsKHRoaXMsIFdlYkdMMkZ1bmN0aW9uTm9kZSkudG9KU09OKCk7XG4gICAganNvbi5zZXR0aW5ncy50aHJlYWREaW0gPSB0aGlzLnRocmVhZERpbTtcbiAgICByZXR1cm4ganNvbjtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViR0wyS2VybmVsXG59O1xufSx7XCIuLi8uLi91dGlsc1wiOjExNCxcIi4uL2Z1bmN0aW9uLWJ1aWxkZXJcIjo5LFwiLi4vd2ViLWdsL2tlcm5lbFwiOjcwLFwiLi9mcmFnbWVudC1zaGFkZXJcIjo3MixcIi4vZnVuY3Rpb24tbm9kZVwiOjczLFwiLi9rZXJuZWwtdmFsdWUtbWFwc1wiOjc0LFwiLi92ZXJ0ZXgtc2hhZGVyXCI6MTA2fV0sMTA2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHZlcnRleFNoYWRlciA9IGAjdmVyc2lvbiAzMDAgZXNcbl9fRkxPQVRfVEFDVElDX0RFQ0xBUkFUSU9OX187XG5fX0lOVF9UQUNUSUNfREVDTEFSQVRJT05fXztcbl9fU0FNUExFUl8yRF9UQUNUSUNfREVDTEFSQVRJT05fXztcblxuaW4gdmVjMiBhUG9zO1xuaW4gdmVjMiBhVGV4Q29vcmQ7XG5cbm91dCB2ZWMyIHZUZXhDb29yZDtcbnVuaWZvcm0gdmVjMiByYXRpbztcblxudm9pZCBtYWluKHZvaWQpIHtcbiAgZ2xfUG9zaXRpb24gPSB2ZWM0KChhUG9zICsgdmVjMigxKSkgKiByYXRpbyArIHZlYzIoLTEpLCAwLCAxKTtcbiAgdlRleENvb3JkID0gYVRleENvb3JkO1xufWA7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICB2ZXJ0ZXhTaGFkZXJcbn07XG59LHt9XSwxMDc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgbGliID0gcmVxdWlyZSgnLi9pbmRleCcpO1xuY29uc3QgR1BVID0gbGliLkdQVTtcbmZvciAoY29uc3QgcCBpbiBsaWIpIHtcbiAgaWYgKCFsaWIuaGFzT3duUHJvcGVydHkocCkpIGNvbnRpbnVlO1xuICBpZiAocCA9PT0gJ0dQVScpIGNvbnRpbnVlOyBcbiAgR1BVW3BdID0gbGliW3BdO1xufVxuXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgYmluZFRvKHdpbmRvdyk7XG59XG5pZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSB7XG4gIGJpbmRUbyhzZWxmKTtcbn1cblxuZnVuY3Rpb24gYmluZFRvKHRhcmdldCkge1xuICBpZiAodGFyZ2V0LkdQVSkgcmV0dXJuO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCAnR1BVJywge1xuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiBHUFU7XG4gICAgfVxuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaWI7XG59LHtcIi4vaW5kZXhcIjoxMDl9XSwxMDg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyBncHVNb2NrIH0gPSByZXF1aXJlKCdncHUtbW9jay5qcycpO1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi91dGlscycpO1xuY29uc3QgeyBLZXJuZWwgfSA9IHJlcXVpcmUoJy4vYmFja2VuZC9rZXJuZWwnKTtcbmNvbnN0IHsgQ1BVS2VybmVsIH0gPSByZXF1aXJlKCcuL2JhY2tlbmQvY3B1L2tlcm5lbCcpO1xuY29uc3QgeyBIZWFkbGVzc0dMS2VybmVsIH0gPSByZXF1aXJlKCcuL2JhY2tlbmQvaGVhZGxlc3MtZ2wva2VybmVsJyk7XG5jb25zdCB7IFdlYkdMMktlcm5lbCB9ID0gcmVxdWlyZSgnLi9iYWNrZW5kL3dlYi1nbDIva2VybmVsJyk7XG5jb25zdCB7IFdlYkdMS2VybmVsIH0gPSByZXF1aXJlKCcuL2JhY2tlbmQvd2ViLWdsL2tlcm5lbCcpO1xuY29uc3QgeyBrZXJuZWxSdW5TaG9ydGN1dCB9ID0gcmVxdWlyZSgnLi9rZXJuZWwtcnVuLXNob3J0Y3V0Jyk7XG5cblxuY29uc3Qga2VybmVsT3JkZXIgPSBbSGVhZGxlc3NHTEtlcm5lbCwgV2ViR0wyS2VybmVsLCBXZWJHTEtlcm5lbF07XG5cbmNvbnN0IGtlcm5lbFR5cGVzID0gWydncHUnLCAnY3B1J107XG5cbmNvbnN0IGludGVybmFsS2VybmVscyA9IHtcbiAgJ2hlYWRsZXNzZ2wnOiBIZWFkbGVzc0dMS2VybmVsLFxuICAnd2ViZ2wyJzogV2ViR0wyS2VybmVsLFxuICAnd2ViZ2wnOiBXZWJHTEtlcm5lbCxcbn07XG5cbmxldCB2YWxpZGF0ZSA9IHRydWU7XG5cbmNsYXNzIEdQVSB7XG4gIHN0YXRpYyBkaXNhYmxlVmFsaWRhdGlvbigpIHtcbiAgICB2YWxpZGF0ZSA9IGZhbHNlO1xuICB9XG5cbiAgc3RhdGljIGVuYWJsZVZhbGlkYXRpb24oKSB7XG4gICAgdmFsaWRhdGUgPSB0cnVlO1xuICB9XG5cbiAgc3RhdGljIGdldCBpc0dQVVN1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4ga2VybmVsT3JkZXIuc29tZShLZXJuZWwgPT4gS2VybmVsLmlzU3VwcG9ydGVkKTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgaXNLZXJuZWxNYXBTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIGtlcm5lbE9yZGVyLnNvbWUoS2VybmVsID0+IEtlcm5lbC5pc1N1cHBvcnRlZCAmJiBLZXJuZWwuZmVhdHVyZXMua2VybmVsTWFwKTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgaXNPZmZzY3JlZW5DYW52YXNTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuICh0eXBlb2YgV29ya2VyICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgT2Zmc2NyZWVuQ2FudmFzICE9PSAndW5kZWZpbmVkJykgfHwgdHlwZW9mIGltcG9ydFNjcmlwdHMgIT09ICd1bmRlZmluZWQnO1xuICB9XG5cbiAgc3RhdGljIGdldCBpc1dlYkdMU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiBXZWJHTEtlcm5lbC5pc1N1cHBvcnRlZDtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgaXNXZWJHTDJTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIFdlYkdMMktlcm5lbC5pc1N1cHBvcnRlZDtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgaXNIZWFkbGVzc0dMU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiBIZWFkbGVzc0dMS2VybmVsLmlzU3VwcG9ydGVkO1xuICB9XG5cbiAgc3RhdGljIGdldCBpc0NhbnZhc1N1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gdHlwZW9mIEhUTUxDYW52YXNFbGVtZW50ICE9PSAndW5kZWZpbmVkJztcbiAgfVxuXG4gIHN0YXRpYyBnZXQgaXNHUFVIVE1MSW1hZ2VBcnJheVN1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gV2ViR0wyS2VybmVsLmlzU3VwcG9ydGVkO1xuICB9XG5cbiAgc3RhdGljIGdldCBpc1NpbmdsZVByZWNpc2lvblN1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4ga2VybmVsT3JkZXIuc29tZShLZXJuZWwgPT4gS2VybmVsLmlzU3VwcG9ydGVkICYmIEtlcm5lbC5mZWF0dXJlcy5pc0Zsb2F0UmVhZCAmJiBLZXJuZWwuZmVhdHVyZXMuaXNUZXh0dXJlRmxvYXQpO1xuICB9XG5cbiAgY29uc3RydWN0b3Ioc2V0dGluZ3MpIHtcbiAgICBzZXR0aW5ncyA9IHNldHRpbmdzIHx8IHt9O1xuICAgIHRoaXMuY2FudmFzID0gc2V0dGluZ3MuY2FudmFzIHx8IG51bGw7XG4gICAgdGhpcy5jb250ZXh0ID0gc2V0dGluZ3MuY29udGV4dCB8fCBudWxsO1xuICAgIHRoaXMubW9kZSA9IHNldHRpbmdzLm1vZGU7XG4gICAgdGhpcy5LZXJuZWwgPSBudWxsO1xuICAgIHRoaXMua2VybmVscyA9IFtdO1xuICAgIHRoaXMuZnVuY3Rpb25zID0gW107XG4gICAgdGhpcy5uYXRpdmVGdW5jdGlvbnMgPSBbXTtcbiAgICB0aGlzLmluamVjdGVkTmF0aXZlID0gbnVsbDtcbiAgICBpZiAodGhpcy5tb2RlID09PSAnZGV2JykgcmV0dXJuO1xuICAgIHRoaXMuY2hvb3NlS2VybmVsKCk7XG4gICAgaWYgKHNldHRpbmdzLmZ1bmN0aW9ucykge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZXR0aW5ncy5mdW5jdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5hZGRGdW5jdGlvbihzZXR0aW5ncy5mdW5jdGlvbnNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzZXR0aW5ncy5uYXRpdmVGdW5jdGlvbnMpIHtcbiAgICAgIGZvciAoY29uc3QgcCBpbiBzZXR0aW5ncy5uYXRpdmVGdW5jdGlvbnMpIHtcbiAgICAgICAgaWYgKCFzZXR0aW5ncy5uYXRpdmVGdW5jdGlvbnMuaGFzT3duUHJvcGVydHkocCkpIGNvbnRpbnVlO1xuICAgICAgICBjb25zdCBzID0gc2V0dGluZ3MubmF0aXZlRnVuY3Rpb25zW3BdO1xuICAgICAgICBjb25zdCB7IG5hbWUsIHNvdXJjZSB9ID0gcztcbiAgICAgICAgdGhpcy5hZGROYXRpdmVGdW5jdGlvbihuYW1lLCBzb3VyY2UsIHMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGNob29zZUtlcm5lbCgpIHtcbiAgICBpZiAodGhpcy5LZXJuZWwpIHJldHVybjtcblxuICAgIGxldCBLZXJuZWwgPSBudWxsO1xuXG4gICAgaWYgKHRoaXMuY29udGV4dCkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXJuZWxPcmRlci5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBFeHRlcm5hbEtlcm5lbCA9IGtlcm5lbE9yZGVyW2ldO1xuICAgICAgICBpZiAoRXh0ZXJuYWxLZXJuZWwuaXNDb250ZXh0TWF0Y2godGhpcy5jb250ZXh0KSkge1xuICAgICAgICAgIGlmICghRXh0ZXJuYWxLZXJuZWwuaXNTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgS2VybmVsIHR5cGUgJHtFeHRlcm5hbEtlcm5lbC5uYW1lfSBub3Qgc3VwcG9ydGVkYCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIEtlcm5lbCA9IEV4dGVybmFsS2VybmVsO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoS2VybmVsID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndW5rbm93biBDb250ZXh0Jyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLm1vZGUpIHtcbiAgICAgIGlmICh0aGlzLm1vZGUgaW4gaW50ZXJuYWxLZXJuZWxzKSB7XG4gICAgICAgIGlmICghdmFsaWRhdGUgfHwgaW50ZXJuYWxLZXJuZWxzW3RoaXMubW9kZV0uaXNTdXBwb3J0ZWQpIHtcbiAgICAgICAgICBLZXJuZWwgPSBpbnRlcm5hbEtlcm5lbHNbdGhpcy5tb2RlXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0aGlzLm1vZGUgPT09ICdncHUnKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2VybmVsT3JkZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoa2VybmVsT3JkZXJbaV0uaXNTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgIEtlcm5lbCA9IGtlcm5lbE9yZGVyW2ldO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRoaXMubW9kZSA9PT0gJ2NwdScpIHtcbiAgICAgICAgS2VybmVsID0gQ1BVS2VybmVsO1xuICAgICAgfVxuICAgICAgaWYgKCFLZXJuZWwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBIHJlcXVlc3RlZCBtb2RlIG9mIFwiJHt0aGlzLm1vZGV9XCIgYW5kIGlzIG5vdCBzdXBwb3J0ZWRgKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXJuZWxPcmRlci5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoa2VybmVsT3JkZXJbaV0uaXNTdXBwb3J0ZWQpIHtcbiAgICAgICAgICBLZXJuZWwgPSBrZXJuZWxPcmRlcltpXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFLZXJuZWwpIHtcbiAgICAgICAgS2VybmVsID0gQ1BVS2VybmVsO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghdGhpcy5tb2RlKSB7XG4gICAgICB0aGlzLm1vZGUgPSBLZXJuZWwubW9kZTtcbiAgICB9XG4gICAgdGhpcy5LZXJuZWwgPSBLZXJuZWw7XG4gIH1cblxuICBjcmVhdGVLZXJuZWwoc291cmNlLCBzZXR0aW5ncykge1xuICAgIGlmICh0eXBlb2Ygc291cmNlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHNvdXJjZSBwYXJhbWV0ZXInKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBzb3VyY2UgIT09ICdvYmplY3QnICYmICF1dGlscy5pc0Z1bmN0aW9uKHNvdXJjZSkgJiYgdHlwZW9mIHNvdXJjZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignc291cmNlIHBhcmFtZXRlciBub3QgYSBmdW5jdGlvbicpO1xuICAgIH1cblxuICAgIGNvbnN0IGtlcm5lbHMgPSB0aGlzLmtlcm5lbHM7XG4gICAgaWYgKHRoaXMubW9kZSA9PT0gJ2RldicpIHtcbiAgICAgIGNvbnN0IGRldktlcm5lbCA9IGdwdU1vY2soc291cmNlLCB1cGdyYWRlRGVwcmVjYXRlZENyZWF0ZUtlcm5lbFNldHRpbmdzKHNldHRpbmdzKSk7XG4gICAgICBrZXJuZWxzLnB1c2goZGV2S2VybmVsKTtcbiAgICAgIHJldHVybiBkZXZLZXJuZWw7XG4gICAgfVxuXG4gICAgc291cmNlID0gdHlwZW9mIHNvdXJjZSA9PT0gJ2Z1bmN0aW9uJyA/IHNvdXJjZS50b1N0cmluZygpIDogc291cmNlO1xuICAgIGNvbnN0IHN3aXRjaGFibGVLZXJuZWxzID0ge307XG4gICAgY29uc3Qgc2V0dGluZ3NDb3B5ID0gdXBncmFkZURlcHJlY2F0ZWRDcmVhdGVLZXJuZWxTZXR0aW5ncyhzZXR0aW5ncykgfHwge307XG4gICAgaWYgKHNldHRpbmdzICYmIHR5cGVvZiBzZXR0aW5ncy5hcmd1bWVudFR5cGVzID09PSAnb2JqZWN0Jykge1xuICAgICAgc2V0dGluZ3NDb3B5LmFyZ3VtZW50VHlwZXMgPSBPYmplY3Qua2V5cyhzZXR0aW5ncy5hcmd1bWVudFR5cGVzKS5tYXAoYXJndW1lbnROYW1lID0+IHNldHRpbmdzLmFyZ3VtZW50VHlwZXNbYXJndW1lbnROYW1lXSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25SZXF1ZXN0RmFsbGJhY2soYXJncykge1xuICAgICAgY29uc29sZS53YXJuKCdGYWxsaW5nIGJhY2sgdG8gQ1BVJyk7XG4gICAgICBjb25zdCBmYWxsYmFja0tlcm5lbCA9IG5ldyBDUFVLZXJuZWwoc291cmNlLCB7XG4gICAgICAgIGFyZ3VtZW50VHlwZXM6IGtlcm5lbFJ1bi5hcmd1bWVudFR5cGVzLFxuICAgICAgICBjb25zdGFudFR5cGVzOiBrZXJuZWxSdW4uY29uc3RhbnRUeXBlcyxcbiAgICAgICAgZ3JhcGhpY2FsOiBrZXJuZWxSdW4uZ3JhcGhpY2FsLFxuICAgICAgICBsb29wTWF4SXRlcmF0aW9uczoga2VybmVsUnVuLmxvb3BNYXhJdGVyYXRpb25zLFxuICAgICAgICBjb25zdGFudHM6IGtlcm5lbFJ1bi5jb25zdGFudHMsXG4gICAgICAgIGR5bmFtaWNPdXRwdXQ6IGtlcm5lbFJ1bi5keW5hbWljT3V0cHV0LFxuICAgICAgICBkeW5hbWljQXJndW1lbnQ6IGtlcm5lbFJ1bi5keW5hbWljQXJndW1lbnRzLFxuICAgICAgICBvdXRwdXQ6IGtlcm5lbFJ1bi5vdXRwdXQsXG4gICAgICAgIHByZWNpc2lvbjoga2VybmVsUnVuLnByZWNpc2lvbixcbiAgICAgICAgcGlwZWxpbmU6IGtlcm5lbFJ1bi5waXBlbGluZSxcbiAgICAgICAgaW1tdXRhYmxlOiBrZXJuZWxSdW4uaW1tdXRhYmxlLFxuICAgICAgICBvcHRpbWl6ZUZsb2F0TWVtb3J5OiBrZXJuZWxSdW4ub3B0aW1pemVGbG9hdE1lbW9yeSxcbiAgICAgICAgZml4SW50ZWdlckRpdmlzaW9uQWNjdXJhY3k6IGtlcm5lbFJ1bi5maXhJbnRlZ2VyRGl2aXNpb25BY2N1cmFjeSxcbiAgICAgICAgZnVuY3Rpb25zOiBrZXJuZWxSdW4uZnVuY3Rpb25zLFxuICAgICAgICBuYXRpdmVGdW5jdGlvbnM6IGtlcm5lbFJ1bi5uYXRpdmVGdW5jdGlvbnMsXG4gICAgICAgIGluamVjdGVkTmF0aXZlOiBrZXJuZWxSdW4uaW5qZWN0ZWROYXRpdmUsXG4gICAgICAgIHN1Yktlcm5lbHM6IGtlcm5lbFJ1bi5zdWJLZXJuZWxzLFxuICAgICAgICBzdHJpY3RJbnRlZ2Vyczoga2VybmVsUnVuLnN0cmljdEludGVnZXJzLFxuICAgICAgICBkZWJ1Zzoga2VybmVsUnVuLmRlYnVnLFxuICAgICAgfSk7XG4gICAgICBmYWxsYmFja0tlcm5lbC5idWlsZC5hcHBseShmYWxsYmFja0tlcm5lbCwgYXJncyk7XG4gICAgICBjb25zdCByZXN1bHQgPSBmYWxsYmFja0tlcm5lbC5ydW4uYXBwbHkoZmFsbGJhY2tLZXJuZWwsIGFyZ3MpO1xuICAgICAga2VybmVsUnVuLnJlcGxhY2VLZXJuZWwoZmFsbGJhY2tLZXJuZWwpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvblJlcXVlc3RTd2l0Y2hLZXJuZWwocmVhc29ucywgYXJncywgX2tlcm5lbCkge1xuICAgICAgaWYgKF9rZXJuZWwuZGVidWcpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdTd2l0Y2hpbmcga2VybmVscycpO1xuICAgICAgfVxuICAgICAgbGV0IG5ld091dHB1dCA9IG51bGw7XG4gICAgICBpZiAoX2tlcm5lbC5zaWduYXR1cmUgJiYgIXN3aXRjaGFibGVLZXJuZWxzW19rZXJuZWwuc2lnbmF0dXJlXSkge1xuICAgICAgICBzd2l0Y2hhYmxlS2VybmVsc1tfa2VybmVsLnNpZ25hdHVyZV0gPSBfa2VybmVsO1xuICAgICAgfVxuICAgICAgaWYgKF9rZXJuZWwuZHluYW1pY091dHB1dCkge1xuICAgICAgICBmb3IgKGxldCBpID0gcmVhc29ucy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIGNvbnN0IHJlYXNvbiA9IHJlYXNvbnNbaV07XG4gICAgICAgICAgaWYgKHJlYXNvbi50eXBlID09PSAnb3V0cHV0UHJlY2lzaW9uTWlzbWF0Y2gnKSB7XG4gICAgICAgICAgICBuZXdPdXRwdXQgPSByZWFzb24ubmVlZGVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCBDb25zdHJ1Y3RvciA9IF9rZXJuZWwuY29uc3RydWN0b3I7XG4gICAgICBjb25zdCBhcmd1bWVudFR5cGVzID0gQ29uc3RydWN0b3IuZ2V0QXJndW1lbnRUeXBlcyhfa2VybmVsLCBhcmdzKTtcbiAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IENvbnN0cnVjdG9yLmdldFNpZ25hdHVyZShfa2VybmVsLCBhcmd1bWVudFR5cGVzKTtcbiAgICAgIGNvbnN0IGV4aXN0aW5nS2VybmVsID0gc3dpdGNoYWJsZUtlcm5lbHNbc2lnbmF0dXJlXTtcbiAgICAgIGlmIChleGlzdGluZ0tlcm5lbCkge1xuICAgICAgICBleGlzdGluZ0tlcm5lbC5vbkFjdGl2YXRlKF9rZXJuZWwpO1xuICAgICAgICByZXR1cm4gZXhpc3RpbmdLZXJuZWw7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG5ld0tlcm5lbCA9IHN3aXRjaGFibGVLZXJuZWxzW3NpZ25hdHVyZV0gPSBuZXcgQ29uc3RydWN0b3Ioc291cmNlLCB7XG4gICAgICAgIGFyZ3VtZW50VHlwZXMsXG4gICAgICAgIGNvbnN0YW50VHlwZXM6IF9rZXJuZWwuY29uc3RhbnRUeXBlcyxcbiAgICAgICAgZ3JhcGhpY2FsOiBfa2VybmVsLmdyYXBoaWNhbCxcbiAgICAgICAgbG9vcE1heEl0ZXJhdGlvbnM6IF9rZXJuZWwubG9vcE1heEl0ZXJhdGlvbnMsXG4gICAgICAgIGNvbnN0YW50czogX2tlcm5lbC5jb25zdGFudHMsXG4gICAgICAgIGR5bmFtaWNPdXRwdXQ6IF9rZXJuZWwuZHluYW1pY091dHB1dCxcbiAgICAgICAgZHluYW1pY0FyZ3VtZW50OiBfa2VybmVsLmR5bmFtaWNBcmd1bWVudHMsXG4gICAgICAgIGNvbnRleHQ6IF9rZXJuZWwuY29udGV4dCxcbiAgICAgICAgY2FudmFzOiBfa2VybmVsLmNhbnZhcyxcbiAgICAgICAgb3V0cHV0OiBuZXdPdXRwdXQgfHwgX2tlcm5lbC5vdXRwdXQsXG4gICAgICAgIHByZWNpc2lvbjogX2tlcm5lbC5wcmVjaXNpb24sXG4gICAgICAgIHBpcGVsaW5lOiBfa2VybmVsLnBpcGVsaW5lLFxuICAgICAgICBpbW11dGFibGU6IF9rZXJuZWwuaW1tdXRhYmxlLFxuICAgICAgICBvcHRpbWl6ZUZsb2F0TWVtb3J5OiBfa2VybmVsLm9wdGltaXplRmxvYXRNZW1vcnksXG4gICAgICAgIGZpeEludGVnZXJEaXZpc2lvbkFjY3VyYWN5OiBfa2VybmVsLmZpeEludGVnZXJEaXZpc2lvbkFjY3VyYWN5LFxuICAgICAgICBmdW5jdGlvbnM6IF9rZXJuZWwuZnVuY3Rpb25zLFxuICAgICAgICBuYXRpdmVGdW5jdGlvbnM6IF9rZXJuZWwubmF0aXZlRnVuY3Rpb25zLFxuICAgICAgICBpbmplY3RlZE5hdGl2ZTogX2tlcm5lbC5pbmplY3RlZE5hdGl2ZSxcbiAgICAgICAgc3ViS2VybmVsczogX2tlcm5lbC5zdWJLZXJuZWxzLFxuICAgICAgICBzdHJpY3RJbnRlZ2VyczogX2tlcm5lbC5zdHJpY3RJbnRlZ2VycyxcbiAgICAgICAgZGVidWc6IF9rZXJuZWwuZGVidWcsXG4gICAgICAgIGdwdTogX2tlcm5lbC5ncHUsXG4gICAgICAgIHZhbGlkYXRlLFxuICAgICAgICByZXR1cm5UeXBlOiBfa2VybmVsLnJldHVyblR5cGUsXG4gICAgICAgIHRhY3RpYzogX2tlcm5lbC50YWN0aWMsXG4gICAgICAgIG9uUmVxdWVzdEZhbGxiYWNrLFxuICAgICAgICBvblJlcXVlc3RTd2l0Y2hLZXJuZWwsXG4gICAgICAgIHRleHR1cmU6IF9rZXJuZWwudGV4dHVyZSxcbiAgICAgICAgbWFwcGVkVGV4dHVyZXM6IF9rZXJuZWwubWFwcGVkVGV4dHVyZXMsXG4gICAgICAgIGRyYXdCdWZmZXJzTWFwOiBfa2VybmVsLmRyYXdCdWZmZXJzTWFwLFxuICAgICAgfSk7XG4gICAgICBuZXdLZXJuZWwuYnVpbGQuYXBwbHkobmV3S2VybmVsLCBhcmdzKTtcbiAgICAgIGtlcm5lbFJ1bi5yZXBsYWNlS2VybmVsKG5ld0tlcm5lbCk7XG4gICAgICBrZXJuZWxzLnB1c2gobmV3S2VybmVsKTtcbiAgICAgIHJldHVybiBuZXdLZXJuZWw7XG4gICAgfVxuICAgIGNvbnN0IG1lcmdlZFNldHRpbmdzID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICBjb250ZXh0OiB0aGlzLmNvbnRleHQsXG4gICAgICBjYW52YXM6IHRoaXMuY2FudmFzLFxuICAgICAgZnVuY3Rpb25zOiB0aGlzLmZ1bmN0aW9ucyxcbiAgICAgIG5hdGl2ZUZ1bmN0aW9uczogdGhpcy5uYXRpdmVGdW5jdGlvbnMsXG4gICAgICBpbmplY3RlZE5hdGl2ZTogdGhpcy5pbmplY3RlZE5hdGl2ZSxcbiAgICAgIGdwdTogdGhpcyxcbiAgICAgIHZhbGlkYXRlLFxuICAgICAgb25SZXF1ZXN0RmFsbGJhY2ssXG4gICAgICBvblJlcXVlc3RTd2l0Y2hLZXJuZWxcbiAgICB9LCBzZXR0aW5nc0NvcHkpO1xuXG4gICAgY29uc3Qga2VybmVsID0gbmV3IHRoaXMuS2VybmVsKHNvdXJjZSwgbWVyZ2VkU2V0dGluZ3MpO1xuICAgIGNvbnN0IGtlcm5lbFJ1biA9IGtlcm5lbFJ1blNob3J0Y3V0KGtlcm5lbCk7XG5cbiAgICBpZiAoIXRoaXMuY2FudmFzKSB7XG4gICAgICB0aGlzLmNhbnZhcyA9IGtlcm5lbC5jYW52YXM7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmNvbnRleHQpIHtcbiAgICAgIHRoaXMuY29udGV4dCA9IGtlcm5lbC5jb250ZXh0O1xuICAgIH1cblxuICAgIGtlcm5lbHMucHVzaChrZXJuZWwpO1xuXG4gICAgcmV0dXJuIGtlcm5lbFJ1bjtcbiAgfVxuXG4gIGNyZWF0ZUtlcm5lbE1hcCgpIHtcbiAgICBsZXQgZm47XG4gICAgbGV0IHNldHRpbmdzO1xuICAgIGNvbnN0IGFyZ3VtZW50MlR5cGUgPSB0eXBlb2YgYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGggLSAyXTtcbiAgICBpZiAoYXJndW1lbnQyVHlwZSA9PT0gJ2Z1bmN0aW9uJyB8fCBhcmd1bWVudDJUeXBlID09PSAnc3RyaW5nJykge1xuICAgICAgZm4gPSBhcmd1bWVudHNbYXJndW1lbnRzLmxlbmd0aCAtIDJdO1xuICAgICAgc2V0dGluZ3MgPSBhcmd1bWVudHNbYXJndW1lbnRzLmxlbmd0aCAtIDFdO1xuICAgIH0gZWxzZSB7XG4gICAgICBmbiA9IGFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoIC0gMV07XG4gICAgfVxuXG4gICAgaWYgKHRoaXMubW9kZSAhPT0gJ2RldicpIHtcbiAgICAgIGlmICghdGhpcy5LZXJuZWwuaXNTdXBwb3J0ZWQgfHwgIXRoaXMuS2VybmVsLmZlYXR1cmVzLmtlcm5lbE1hcCkge1xuICAgICAgICBpZiAodGhpcy5tb2RlICYmIGtlcm5lbFR5cGVzLmluZGV4T2YodGhpcy5tb2RlKSA8IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGtlcm5lbE1hcCBub3Qgc3VwcG9ydGVkIG9uICR7dGhpcy5LZXJuZWwubmFtZX1gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHNldHRpbmdzQ29weSA9IHVwZ3JhZGVEZXByZWNhdGVkQ3JlYXRlS2VybmVsU2V0dGluZ3Moc2V0dGluZ3MpO1xuICAgIGlmIChzZXR0aW5ncyAmJiB0eXBlb2Ygc2V0dGluZ3MuYXJndW1lbnRUeXBlcyA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHNldHRpbmdzQ29weS5hcmd1bWVudFR5cGVzID0gT2JqZWN0LmtleXMoc2V0dGluZ3MuYXJndW1lbnRUeXBlcykubWFwKGFyZ3VtZW50TmFtZSA9PiBzZXR0aW5ncy5hcmd1bWVudFR5cGVzW2FyZ3VtZW50TmFtZV0pO1xuICAgIH1cblxuICAgIGlmIChBcnJheS5pc0FycmF5KGFyZ3VtZW50c1swXSkpIHtcbiAgICAgIHNldHRpbmdzQ29weS5zdWJLZXJuZWxzID0gW107XG4gICAgICBjb25zdCBmdW5jdGlvbnMgPSBhcmd1bWVudHNbMF07XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZ1bmN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBzb3VyY2UgPSBmdW5jdGlvbnNbaV0udG9TdHJpbmcoKTtcbiAgICAgICAgY29uc3QgbmFtZSA9IHV0aWxzLmdldEZ1bmN0aW9uTmFtZUZyb21TdHJpbmcoc291cmNlKTtcbiAgICAgICAgc2V0dGluZ3NDb3B5LnN1Yktlcm5lbHMucHVzaCh7XG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgICBzb3VyY2UsXG4gICAgICAgICAgcHJvcGVydHk6IGksXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzZXR0aW5nc0NvcHkuc3ViS2VybmVscyA9IFtdO1xuICAgICAgY29uc3QgZnVuY3Rpb25zID0gYXJndW1lbnRzWzBdO1xuICAgICAgZm9yIChsZXQgcCBpbiBmdW5jdGlvbnMpIHtcbiAgICAgICAgaWYgKCFmdW5jdGlvbnMuaGFzT3duUHJvcGVydHkocCkpIGNvbnRpbnVlO1xuICAgICAgICBjb25zdCBzb3VyY2UgPSBmdW5jdGlvbnNbcF0udG9TdHJpbmcoKTtcbiAgICAgICAgY29uc3QgbmFtZSA9IHV0aWxzLmdldEZ1bmN0aW9uTmFtZUZyb21TdHJpbmcoc291cmNlKTtcbiAgICAgICAgc2V0dGluZ3NDb3B5LnN1Yktlcm5lbHMucHVzaCh7XG4gICAgICAgICAgbmFtZTogbmFtZSB8fCBwLFxuICAgICAgICAgIHNvdXJjZSxcbiAgICAgICAgICBwcm9wZXJ0eTogcCxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNyZWF0ZUtlcm5lbChmbiwgc2V0dGluZ3NDb3B5KTtcbiAgfVxuXG4gIGNvbWJpbmVLZXJuZWxzKCkge1xuICAgIGNvbnN0IGZpcnN0S2VybmVsID0gYXJndW1lbnRzWzBdO1xuICAgIGNvbnN0IGNvbWJpbmVkS2VybmVsID0gYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGggLSAxXTtcbiAgICBpZiAoZmlyc3RLZXJuZWwua2VybmVsLmNvbnN0cnVjdG9yLm1vZGUgPT09ICdjcHUnKSByZXR1cm4gY29tYmluZWRLZXJuZWw7XG4gICAgY29uc3QgY2FudmFzID0gYXJndW1lbnRzWzBdLmNhbnZhcztcbiAgICBjb25zdCBjb250ZXh0ID0gYXJndW1lbnRzWzBdLmNvbnRleHQ7XG4gICAgY29uc3QgbWF4ID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXg7IGkrKykge1xuICAgICAgYXJndW1lbnRzW2ldXG4gICAgICAgIC5zZXRDYW52YXMoY2FudmFzKVxuICAgICAgICAuc2V0Q29udGV4dChjb250ZXh0KVxuICAgICAgICAuc2V0UGlwZWxpbmUodHJ1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgY29uc3QgdGV4dHVyZSA9IGNvbWJpbmVkS2VybmVsLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICBpZiAodGV4dHVyZS50b0FycmF5KSB7XG4gICAgICAgIHJldHVybiB0ZXh0dXJlLnRvQXJyYXkoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0ZXh0dXJlO1xuICAgIH07XG4gIH1cblxuICBzZXRGdW5jdGlvbnMoZnVuY3Rpb25zKSB7XG4gICAgdGhpcy5mdW5jdGlvbnMgPSBmdW5jdGlvbnM7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBzZXROYXRpdmVGdW5jdGlvbnMobmF0aXZlRnVuY3Rpb25zKSB7XG4gICAgdGhpcy5uYXRpdmVGdW5jdGlvbnMgPSBuYXRpdmVGdW5jdGlvbnM7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBhZGRGdW5jdGlvbihzb3VyY2UsIHNldHRpbmdzKSB7XG4gICAgdGhpcy5mdW5jdGlvbnMucHVzaCh7IHNvdXJjZSwgc2V0dGluZ3MgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBhZGROYXRpdmVGdW5jdGlvbihuYW1lLCBzb3VyY2UsIHNldHRpbmdzKSB7XG4gICAgaWYgKHRoaXMua2VybmVscy5sZW5ndGggPiAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjYWxsIFwiYWRkTmF0aXZlRnVuY3Rpb25cIiBhZnRlciBcImNyZWF0ZUtlcm5lbHNcIiBoYXMgYmVlbiBjYWxsZWQuJyk7XG4gICAgfVxuICAgIHRoaXMubmF0aXZlRnVuY3Rpb25zLnB1c2goT2JqZWN0LmFzc2lnbih7IG5hbWUsIHNvdXJjZSB9LCBzZXR0aW5ncykpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgaW5qZWN0TmF0aXZlKHNvdXJjZSkge1xuICAgIHRoaXMuaW5qZWN0ZWROYXRpdmUgPSBzb3VyY2U7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBpZiAoIXRoaXMua2VybmVscykge1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMua2VybmVscy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5rZXJuZWxzW2ldLmRlc3Ryb3kodHJ1ZSk7IFxuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgZmlyc3RLZXJuZWwgPSB0aGlzLmtlcm5lbHNbMF07XG4gICAgICAgICAgaWYgKGZpcnN0S2VybmVsKSB7XG4gICAgICAgICAgICBpZiAoZmlyc3RLZXJuZWwua2VybmVsKSB7XG4gICAgICAgICAgICAgIGZpcnN0S2VybmVsID0gZmlyc3RLZXJuZWwua2VybmVsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZpcnN0S2VybmVsLmNvbnN0cnVjdG9yLmRlc3Ryb3lDb250ZXh0KSB7XG4gICAgICAgICAgICAgIGZpcnN0S2VybmVsLmNvbnN0cnVjdG9yLmRlc3Ryb3lDb250ZXh0KHRoaXMuY29udGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICB9XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH0sIDApO1xuICAgIH0pO1xuICB9XG59XG5cblxuZnVuY3Rpb24gdXBncmFkZURlcHJlY2F0ZWRDcmVhdGVLZXJuZWxTZXR0aW5ncyhzZXR0aW5ncykge1xuICBpZiAoIXNldHRpbmdzKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG4gIGNvbnN0IHVwZ3JhZGVkU2V0dGluZ3MgPSBPYmplY3QuYXNzaWduKHt9LCBzZXR0aW5ncyk7XG5cbiAgaWYgKHNldHRpbmdzLmhhc093blByb3BlcnR5KCdmbG9hdE91dHB1dCcpKSB7XG4gICAgdXRpbHMud2FybkRlcHJlY2F0ZWQoJ3NldHRpbmcnLCAnZmxvYXRPdXRwdXQnLCAncHJlY2lzaW9uJyk7XG4gICAgdXBncmFkZWRTZXR0aW5ncy5wcmVjaXNpb24gPSBzZXR0aW5ncy5mbG9hdE91dHB1dCA/ICdzaW5nbGUnIDogJ3Vuc2lnbmVkJztcbiAgfVxuICBpZiAoc2V0dGluZ3MuaGFzT3duUHJvcGVydHkoJ291dHB1dFRvVGV4dHVyZScpKSB7XG4gICAgdXRpbHMud2FybkRlcHJlY2F0ZWQoJ3NldHRpbmcnLCAnb3V0cHV0VG9UZXh0dXJlJywgJ3BpcGVsaW5lJyk7XG4gICAgdXBncmFkZWRTZXR0aW5ncy5waXBlbGluZSA9IEJvb2xlYW4oc2V0dGluZ3Mub3V0cHV0VG9UZXh0dXJlKTtcbiAgfVxuICBpZiAoc2V0dGluZ3MuaGFzT3duUHJvcGVydHkoJ291dHB1dEltbXV0YWJsZScpKSB7XG4gICAgdXRpbHMud2FybkRlcHJlY2F0ZWQoJ3NldHRpbmcnLCAnb3V0cHV0SW1tdXRhYmxlJywgJ2ltbXV0YWJsZScpO1xuICAgIHVwZ3JhZGVkU2V0dGluZ3MuaW1tdXRhYmxlID0gQm9vbGVhbihzZXR0aW5ncy5vdXRwdXRJbW11dGFibGUpO1xuICB9XG4gIGlmIChzZXR0aW5ncy5oYXNPd25Qcm9wZXJ0eSgnZmxvYXRUZXh0dXJlcycpKSB7XG4gICAgdXRpbHMud2FybkRlcHJlY2F0ZWQoJ3NldHRpbmcnLCAnZmxvYXRUZXh0dXJlcycsICdvcHRpbWl6ZUZsb2F0TWVtb3J5Jyk7XG4gICAgdXBncmFkZWRTZXR0aW5ncy5vcHRpbWl6ZUZsb2F0TWVtb3J5ID0gQm9vbGVhbihzZXR0aW5ncy5mbG9hdFRleHR1cmVzKTtcbiAgfVxuICByZXR1cm4gdXBncmFkZWRTZXR0aW5ncztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEdQVSxcbiAga2VybmVsT3JkZXIsXG4gIGtlcm5lbFR5cGVzXG59O1xufSx7XCIuL2JhY2tlbmQvY3B1L2tlcm5lbFwiOjgsXCIuL2JhY2tlbmQvaGVhZGxlc3MtZ2wva2VybmVsXCI6MzQsXCIuL2JhY2tlbmQva2VybmVsXCI6MzYsXCIuL2JhY2tlbmQvd2ViLWdsL2tlcm5lbFwiOjcwLFwiLi9iYWNrZW5kL3dlYi1nbDIva2VybmVsXCI6MTA1LFwiLi9rZXJuZWwtcnVuLXNob3J0Y3V0XCI6MTExLFwiLi91dGlsc1wiOjExNCxcImdwdS1tb2NrLmpzXCI6NH1dLDEwOTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IEdQVSB9ID0gcmVxdWlyZSgnLi9ncHUnKTtcbmNvbnN0IHsgYWxpYXMgfSA9IHJlcXVpcmUoJy4vYWxpYXMnKTtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbmNvbnN0IHsgSW5wdXQsIGlucHV0IH0gPSByZXF1aXJlKCcuL2lucHV0Jyk7XG5jb25zdCB7IFRleHR1cmUgfSA9IHJlcXVpcmUoJy4vdGV4dHVyZScpO1xuY29uc3QgeyBGdW5jdGlvbkJ1aWxkZXIgfSA9IHJlcXVpcmUoJy4vYmFja2VuZC9mdW5jdGlvbi1idWlsZGVyJyk7XG5jb25zdCB7IEZ1bmN0aW9uTm9kZSB9ID0gcmVxdWlyZSgnLi9iYWNrZW5kL2Z1bmN0aW9uLW5vZGUnKTtcbmNvbnN0IHsgQ1BVRnVuY3Rpb25Ob2RlIH0gPSByZXF1aXJlKCcuL2JhY2tlbmQvY3B1L2Z1bmN0aW9uLW5vZGUnKTtcbmNvbnN0IHsgQ1BVS2VybmVsIH0gPSByZXF1aXJlKCcuL2JhY2tlbmQvY3B1L2tlcm5lbCcpO1xuXG5jb25zdCB7IEhlYWRsZXNzR0xLZXJuZWwgfSA9IHJlcXVpcmUoJy4vYmFja2VuZC9oZWFkbGVzcy1nbC9rZXJuZWwnKTtcblxuY29uc3QgeyBXZWJHTEZ1bmN0aW9uTm9kZSB9ID0gcmVxdWlyZSgnLi9iYWNrZW5kL3dlYi1nbC9mdW5jdGlvbi1ub2RlJyk7XG5jb25zdCB7IFdlYkdMS2VybmVsIH0gPSByZXF1aXJlKCcuL2JhY2tlbmQvd2ViLWdsL2tlcm5lbCcpO1xuY29uc3QgeyBrZXJuZWxWYWx1ZU1hcHM6IHdlYkdMS2VybmVsVmFsdWVNYXBzIH0gPSByZXF1aXJlKCcuL2JhY2tlbmQvd2ViLWdsL2tlcm5lbC12YWx1ZS1tYXBzJyk7XG5cbmNvbnN0IHsgV2ViR0wyRnVuY3Rpb25Ob2RlIH0gPSByZXF1aXJlKCcuL2JhY2tlbmQvd2ViLWdsMi9mdW5jdGlvbi1ub2RlJyk7XG5jb25zdCB7IFdlYkdMMktlcm5lbCB9ID0gcmVxdWlyZSgnLi9iYWNrZW5kL3dlYi1nbDIva2VybmVsJyk7XG5jb25zdCB7IGtlcm5lbFZhbHVlTWFwczogd2ViR0wyS2VybmVsVmFsdWVNYXBzIH0gPSByZXF1aXJlKCcuL2JhY2tlbmQvd2ViLWdsMi9rZXJuZWwtdmFsdWUtbWFwcycpO1xuXG5jb25zdCB7IEdMS2VybmVsIH0gPSByZXF1aXJlKCcuL2JhY2tlbmQvZ2wva2VybmVsJyk7XG5cbmNvbnN0IHsgS2VybmVsIH0gPSByZXF1aXJlKCcuL2JhY2tlbmQva2VybmVsJyk7XG5cbmNvbnN0IHsgRnVuY3Rpb25UcmFjZXIgfSA9IHJlcXVpcmUoJy4vYmFja2VuZC9mdW5jdGlvbi10cmFjZXInKTtcblxuY29uc3QgbWF0aFJhbmRvbSA9IHJlcXVpcmUoJy4vcGx1Z2lucy9tYXRoLXJhbmRvbS11bmlmb3JtbHktZGlzdHJpYnV0ZWQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGFsaWFzLFxuICBDUFVGdW5jdGlvbk5vZGUsXG4gIENQVUtlcm5lbCxcbiAgR1BVLFxuICBGdW5jdGlvbkJ1aWxkZXIsXG4gIEZ1bmN0aW9uTm9kZSxcbiAgSGVhZGxlc3NHTEtlcm5lbCxcbiAgSW5wdXQsXG4gIGlucHV0LFxuICBUZXh0dXJlLFxuICB1dGlscyxcblxuICBXZWJHTDJGdW5jdGlvbk5vZGUsXG4gIFdlYkdMMktlcm5lbCxcbiAgd2ViR0wyS2VybmVsVmFsdWVNYXBzLFxuXG4gIFdlYkdMRnVuY3Rpb25Ob2RlLFxuICBXZWJHTEtlcm5lbCxcbiAgd2ViR0xLZXJuZWxWYWx1ZU1hcHMsXG5cbiAgR0xLZXJuZWwsXG4gIEtlcm5lbCxcbiAgRnVuY3Rpb25UcmFjZXIsXG5cbiAgcGx1Z2luczoge1xuICAgIG1hdGhSYW5kb21cbiAgfVxufTtcbn0se1wiLi9hbGlhc1wiOjUsXCIuL2JhY2tlbmQvY3B1L2Z1bmN0aW9uLW5vZGVcIjo2LFwiLi9iYWNrZW5kL2NwdS9rZXJuZWxcIjo4LFwiLi9iYWNrZW5kL2Z1bmN0aW9uLWJ1aWxkZXJcIjo5LFwiLi9iYWNrZW5kL2Z1bmN0aW9uLW5vZGVcIjoxMCxcIi4vYmFja2VuZC9mdW5jdGlvbi10cmFjZXJcIjoxMSxcIi4vYmFja2VuZC9nbC9rZXJuZWxcIjoxMyxcIi4vYmFja2VuZC9oZWFkbGVzcy1nbC9rZXJuZWxcIjozNCxcIi4vYmFja2VuZC9rZXJuZWxcIjozNixcIi4vYmFja2VuZC93ZWItZ2wvZnVuY3Rpb24tbm9kZVwiOjM4LFwiLi9iYWNrZW5kL3dlYi1nbC9rZXJuZWxcIjo3MCxcIi4vYmFja2VuZC93ZWItZ2wva2VybmVsLXZhbHVlLW1hcHNcIjozOSxcIi4vYmFja2VuZC93ZWItZ2wyL2Z1bmN0aW9uLW5vZGVcIjo3MyxcIi4vYmFja2VuZC93ZWItZ2wyL2tlcm5lbFwiOjEwNSxcIi4vYmFja2VuZC93ZWItZ2wyL2tlcm5lbC12YWx1ZS1tYXBzXCI6NzQsXCIuL2dwdVwiOjEwOCxcIi4vaW5wdXRcIjoxMTAsXCIuL3BsdWdpbnMvbWF0aC1yYW5kb20tdW5pZm9ybWx5LWRpc3RyaWJ1dGVkXCI6MTEyLFwiLi90ZXh0dXJlXCI6MTEzLFwiLi91dGlsc1wiOjExNH1dLDExMDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jbGFzcyBJbnB1dCB7XG4gIGNvbnN0cnVjdG9yKHZhbHVlLCBzaXplKSB7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHNpemUpKSB7XG4gICAgICB0aGlzLnNpemUgPSBzaXplO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNpemUgPSBuZXcgSW50MzJBcnJheSgzKTtcbiAgICAgIGlmIChzaXplLnopIHtcbiAgICAgICAgdGhpcy5zaXplID0gbmV3IEludDMyQXJyYXkoW3NpemUueCwgc2l6ZS55LCBzaXplLnpdKTtcbiAgICAgIH0gZWxzZSBpZiAoc2l6ZS55KSB7XG4gICAgICAgIHRoaXMuc2l6ZSA9IG5ldyBJbnQzMkFycmF5KFtzaXplLngsIHNpemUueV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zaXplID0gbmV3IEludDMyQXJyYXkoW3NpemUueF0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IFt3LCBoLCBkXSA9IHRoaXMuc2l6ZTtcbiAgICBpZiAoZCkge1xuICAgICAgaWYgKHRoaXMudmFsdWUubGVuZ3RoICE9PSAodyAqIGggKiBkKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYElucHV0IHNpemUgJHt0aGlzLnZhbHVlLmxlbmd0aH0gZG9lcyBub3QgbWF0Y2ggJHt3fSAqICR7aH0gKiAke2R9ID0gJHsoaCAqIHcgKiBkKX1gKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGgpIHtcbiAgICAgIGlmICh0aGlzLnZhbHVlLmxlbmd0aCAhPT0gKHcgKiBoKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYElucHV0IHNpemUgJHt0aGlzLnZhbHVlLmxlbmd0aH0gZG9lcyBub3QgbWF0Y2ggJHt3fSAqICR7aH0gPSAkeyhoICogdyl9YCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0aGlzLnZhbHVlLmxlbmd0aCAhPT0gdykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYElucHV0IHNpemUgJHt0aGlzLnZhbHVlLmxlbmd0aH0gZG9lcyBub3QgbWF0Y2ggJHt3fWApO1xuICAgICAgfVxuICAgIH1cblxuICB9XG5cbiAgdG9BcnJheSgpIHtcbiAgICBjb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuL3V0aWxzJyk7XG4gICAgY29uc3QgW3csIGgsIGRdID0gdGhpcy5zaXplO1xuICAgIGlmIChkKSB7XG4gICAgICByZXR1cm4gdXRpbHMuZXJlY3RNZW1vcnlPcHRpbWl6ZWQzREZsb2F0KHRoaXMudmFsdWUuc3ViYXJyYXkgPyB0aGlzLnZhbHVlIDogbmV3IEZsb2F0MzJBcnJheSh0aGlzLnZhbHVlKSwgdywgaCwgZCk7XG4gICAgfSBlbHNlIGlmIChoKSB7XG4gICAgICByZXR1cm4gdXRpbHMuZXJlY3RNZW1vcnlPcHRpbWl6ZWQyREZsb2F0KHRoaXMudmFsdWUuc3ViYXJyYXkgPyB0aGlzLnZhbHVlIDogbmV3IEZsb2F0MzJBcnJheSh0aGlzLnZhbHVlKSwgdywgaCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpbnB1dCh2YWx1ZSwgc2l6ZSkge1xuICByZXR1cm4gbmV3IElucHV0KHZhbHVlLCBzaXplKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIElucHV0LFxuICBpbnB1dFxufTtcbn0se1wiLi91dGlsc1wiOjExNH1dLDExMTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5cbmZ1bmN0aW9uIGtlcm5lbFJ1blNob3J0Y3V0KGtlcm5lbCkge1xuICBsZXQgcnVuID0gZnVuY3Rpb24oKSB7XG4gICAga2VybmVsLmJ1aWxkLmFwcGx5KGtlcm5lbCwgYXJndW1lbnRzKTtcbiAgICBydW4gPSBmdW5jdGlvbigpIHtcbiAgICAgIGxldCByZXN1bHQgPSBrZXJuZWwucnVuLmFwcGx5KGtlcm5lbCwgYXJndW1lbnRzKTtcbiAgICAgIGlmIChrZXJuZWwuc3dpdGNoaW5nS2VybmVscykge1xuICAgICAgICBjb25zdCByZWFzb25zID0ga2VybmVsLnJlc2V0U3dpdGNoaW5nS2VybmVscygpO1xuICAgICAgICBjb25zdCBuZXdLZXJuZWwgPSBrZXJuZWwub25SZXF1ZXN0U3dpdGNoS2VybmVsKHJlYXNvbnMsIGFyZ3VtZW50cywga2VybmVsKTtcbiAgICAgICAgc2hvcnRjdXQua2VybmVsID0ga2VybmVsID0gbmV3S2VybmVsO1xuICAgICAgICByZXN1bHQgPSBuZXdLZXJuZWwucnVuLmFwcGx5KG5ld0tlcm5lbCwgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICAgIGlmIChrZXJuZWwucmVuZGVyS2VybmVscykge1xuICAgICAgICByZXR1cm4ga2VybmVsLnJlbmRlcktlcm5lbHMoKTtcbiAgICAgIH0gZWxzZSBpZiAoa2VybmVsLnJlbmRlck91dHB1dCkge1xuICAgICAgICByZXR1cm4ga2VybmVsLnJlbmRlck91dHB1dCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBydW4uYXBwbHkoa2VybmVsLCBhcmd1bWVudHMpO1xuICB9O1xuICBjb25zdCBzaG9ydGN1dCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBydW4uYXBwbHkoa2VybmVsLCBhcmd1bWVudHMpO1xuICB9O1xuICBzaG9ydGN1dC5leGVjID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChhY2NlcHQsIHJlamVjdCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgYWNjZXB0KHJ1bi5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuICBzaG9ydGN1dC5yZXBsYWNlS2VybmVsID0gZnVuY3Rpb24ocmVwbGFjZW1lbnRLZXJuZWwpIHtcbiAgICBrZXJuZWwgPSByZXBsYWNlbWVudEtlcm5lbDtcbiAgICBiaW5kS2VybmVsVG9TaG9ydGN1dChrZXJuZWwsIHNob3J0Y3V0KTtcbiAgfTtcblxuICBiaW5kS2VybmVsVG9TaG9ydGN1dChrZXJuZWwsIHNob3J0Y3V0KTtcbiAgcmV0dXJuIHNob3J0Y3V0O1xufVxuXG5mdW5jdGlvbiBiaW5kS2VybmVsVG9TaG9ydGN1dChrZXJuZWwsIHNob3J0Y3V0KSB7XG4gIGlmIChzaG9ydGN1dC5rZXJuZWwpIHtcbiAgICBzaG9ydGN1dC5rZXJuZWwgPSBrZXJuZWw7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHByb3BlcnRpZXMgPSB1dGlscy5hbGxQcm9wZXJ0aWVzT2Yoa2VybmVsKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgcHJvcGVydHkgPSBwcm9wZXJ0aWVzW2ldO1xuICAgIGlmIChwcm9wZXJ0eVswXSA9PT0gJ18nICYmIHByb3BlcnR5WzFdID09PSAnXycpIGNvbnRpbnVlO1xuICAgIGlmICh0eXBlb2Yga2VybmVsW3Byb3BlcnR5XSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKHByb3BlcnR5LnN1YnN0cmluZygwLCAzKSA9PT0gJ2FkZCcgfHwgcHJvcGVydHkuc3Vic3RyaW5nKDAsIDMpID09PSAnc2V0Jykge1xuICAgICAgICBzaG9ydGN1dFtwcm9wZXJ0eV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICBzaG9ydGN1dC5rZXJuZWxbcHJvcGVydHldLmFwcGx5KHNob3J0Y3V0Lmtlcm5lbCwgYXJndW1lbnRzKTtcbiAgICAgICAgICByZXR1cm4gc2hvcnRjdXQ7XG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzaG9ydGN1dFtwcm9wZXJ0eV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gc2hvcnRjdXQua2VybmVsW3Byb3BlcnR5XS5hcHBseShzaG9ydGN1dC5rZXJuZWwsIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHNob3J0Y3V0Ll9fZGVmaW5lR2V0dGVyX18ocHJvcGVydHksICgpID0+IHNob3J0Y3V0Lmtlcm5lbFtwcm9wZXJ0eV0pO1xuICAgICAgc2hvcnRjdXQuX19kZWZpbmVTZXR0ZXJfXyhwcm9wZXJ0eSwgKHZhbHVlKSA9PiB7XG4gICAgICAgIHNob3J0Y3V0Lmtlcm5lbFtwcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBzaG9ydGN1dC5rZXJuZWwgPSBrZXJuZWw7XG59XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAga2VybmVsUnVuU2hvcnRjdXRcbn07XG59LHtcIi4vdXRpbHNcIjoxMTR9XSwxMTI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3Qgc291cmNlID0gYC8vIGh0dHBzOi8vd3d3LnNoYWRlcnRveS5jb20vdmlldy80dDJTRGhcbi8vbm90ZTogdW5pZm9ybWx5IGRpc3RyaWJ1dGVkLCBub3JtYWxpemVkIHJhbmQsIFswLDFdXG5oaWdocCBmbG9hdCByYW5kb21TZWVkU2hpZnQgPSAxLjA7XG5oaWdocCBmbG9hdCBzbGlkZSA9IDEuMDtcbnVuaWZvcm0gaGlnaHAgZmxvYXQgcmFuZG9tU2VlZDE7XG51bmlmb3JtIGhpZ2hwIGZsb2F0IHJhbmRvbVNlZWQyO1xuXG5oaWdocCBmbG9hdCBucmFuZChoaWdocCB2ZWMyIG4pIHtcbiAgaGlnaHAgZmxvYXQgcmVzdWx0ID0gZnJhY3Qoc2luKGRvdCgobi54eSArIDEuMCkgKiB2ZWMyKHJhbmRvbVNlZWQxICogc2xpZGUsIHJhbmRvbVNlZWQyICogcmFuZG9tU2VlZFNoaWZ0KSwgdmVjMigxMi45ODk4LCA3OC4yMzMpKSkgKiA0Mzc1OC41NDUzKTtcbiAgcmFuZG9tU2VlZFNoaWZ0ID0gcmVzdWx0O1xuICBpZiAocmFuZG9tU2VlZFNoaWZ0ID4gMC41KSB7XG4gICAgc2xpZGUgKz0gMC4wMDAwOTsgXG4gIH0gZWxzZSB7XG4gICAgc2xpZGUgKz0gMC4wMDA5O1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59YDtcblxuY29uc3QgbmFtZSA9ICdtYXRoLXJhbmRvbS11bmlmb3JtbHktZGlzdHJpYnV0ZWQnO1xuXG5jb25zdCBmdW5jdGlvbk1hdGNoID0gYE1hdGgucmFuZG9tKClgO1xuXG5jb25zdCBmdW5jdGlvblJlcGxhY2UgPSBgbnJhbmQodlRleENvb3JkKWA7XG5cbmNvbnN0IGZ1bmN0aW9uUmV0dXJuVHlwZSA9ICdOdW1iZXInO1xuY29uc3Qgb25CZWZvcmVSdW4gPSAoa2VybmVsKSA9PiB7XG4gIGtlcm5lbC5zZXRVbmlmb3JtMWYoJ3JhbmRvbVNlZWQxJywgTWF0aC5yYW5kb20oKSk7XG4gIGtlcm5lbC5zZXRVbmlmb3JtMWYoJ3JhbmRvbVNlZWQyJywgTWF0aC5yYW5kb20oKSk7XG59O1xuXG5jb25zdCBwbHVnaW4gPSB7XG4gIG5hbWUsXG4gIG9uQmVmb3JlUnVuLFxuICBmdW5jdGlvbk1hdGNoLFxuICBmdW5jdGlvblJlcGxhY2UsXG4gIGZ1bmN0aW9uUmV0dXJuVHlwZSxcbiAgc291cmNlXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBsdWdpbjtcbn0se31dLDExMzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jbGFzcyBUZXh0dXJlIHtcbiAgY29uc3RydWN0b3Ioc2V0dGluZ3MpIHtcbiAgICBjb25zdCB7XG4gICAgICB0ZXh0dXJlLFxuICAgICAgc2l6ZSxcbiAgICAgIGRpbWVuc2lvbnMsXG4gICAgICBvdXRwdXQsXG4gICAgICBjb250ZXh0LFxuICAgICAgdHlwZSA9ICdOdW1iZXJUZXh0dXJlJyxcbiAgICAgIGtlcm5lbCxcbiAgICAgIGludGVybmFsRm9ybWF0LFxuICAgICAgdGV4dHVyZUZvcm1hdFxuICAgIH0gPSBzZXR0aW5ncztcbiAgICBpZiAoIW91dHB1dCkgdGhyb3cgbmV3IEVycm9yKCdzZXR0aW5ncyBwcm9wZXJ0eSBcIm91dHB1dFwiIHJlcXVpcmVkLicpO1xuICAgIGlmICghY29udGV4dCkgdGhyb3cgbmV3IEVycm9yKCdzZXR0aW5ncyBwcm9wZXJ0eSBcImNvbnRleHRcIiByZXF1aXJlZC4nKTtcbiAgICBpZiAoIXRleHR1cmUpIHRocm93IG5ldyBFcnJvcignc2V0dGluZ3MgcHJvcGVydHkgXCJ0ZXh0dXJlXCIgcmVxdWlyZWQuJyk7XG4gICAgaWYgKCFrZXJuZWwpIHRocm93IG5ldyBFcnJvcignc2V0dGluZ3MgcHJvcGVydHkgXCJrZXJuZWxcIiByZXF1aXJlZC4nKTtcbiAgICB0aGlzLnRleHR1cmUgPSB0ZXh0dXJlO1xuICAgIGlmICh0ZXh0dXJlLl9yZWZzKSB7XG4gICAgICB0ZXh0dXJlLl9yZWZzKys7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRleHR1cmUuX3JlZnMgPSAxO1xuICAgIH1cbiAgICB0aGlzLnNpemUgPSBzaXplO1xuICAgIHRoaXMuZGltZW5zaW9ucyA9IGRpbWVuc2lvbnM7XG4gICAgdGhpcy5vdXRwdXQgPSBvdXRwdXQ7XG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICB0aGlzLmtlcm5lbCA9IGtlcm5lbDtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMuX2RlbGV0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLmludGVybmFsRm9ybWF0ID0gaW50ZXJuYWxGb3JtYXQ7XG4gICAgdGhpcy50ZXh0dXJlRm9ybWF0ID0gdGV4dHVyZUZvcm1hdDtcbiAgfVxuXG4gIHRvQXJyYXkoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBOb3QgaW1wbGVtZW50ZWQgb24gJHt0aGlzLmNvbnN0cnVjdG9yLm5hbWV9YCk7XG4gIH1cblxuICBjbG9uZSgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYE5vdCBpbXBsZW1lbnRlZCBvbiAke3RoaXMuY29uc3RydWN0b3IubmFtZX1gKTtcbiAgfVxuXG4gIGRlbGV0ZSgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYE5vdCBpbXBsZW1lbnRlZCBvbiAke3RoaXMuY29uc3RydWN0b3IubmFtZX1gKTtcbiAgfVxuXG4gIGNsZWFyKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgTm90IGltcGxlbWVudGVkIG9uICR7dGhpcy5jb25zdHJ1Y3Rvci5uYW1lfWApO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBUZXh0dXJlXG59O1xufSx7fV0sMTE0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IGFjb3JuID0gcmVxdWlyZSgnYWNvcm4nKTtcbmNvbnN0IHsgSW5wdXQgfSA9IHJlcXVpcmUoJy4vaW5wdXQnKTtcbmNvbnN0IHsgVGV4dHVyZSB9ID0gcmVxdWlyZSgnLi90ZXh0dXJlJyk7XG5cbmNvbnN0IEZVTkNUSU9OX05BTUUgPSAvZnVuY3Rpb24gKFteKF0qKS87XG5jb25zdCBTVFJJUF9DT01NRU5UUyA9IC8oKFxcL1xcLy4qJCl8KFxcL1xcKltcXHNcXFNdKj9cXCpcXC8pKS9tZztcbmNvbnN0IEFSR1VNRU5UX05BTUVTID0gLyhbXlxccyxdKykvZztcblxuY29uc3QgdXRpbHMgPSB7XG4gIHN5c3RlbUVuZGlhbm5lc3MoKSB7XG4gICAgcmV0dXJuIF9zeXN0ZW1FbmRpYW5uZXNzO1xuICB9LFxuICBnZXRTeXN0ZW1FbmRpYW5uZXNzKCkge1xuICAgIGNvbnN0IGIgPSBuZXcgQXJyYXlCdWZmZXIoNCk7XG4gICAgY29uc3QgYSA9IG5ldyBVaW50MzJBcnJheShiKTtcbiAgICBjb25zdCBjID0gbmV3IFVpbnQ4QXJyYXkoYik7XG4gICAgYVswXSA9IDB4ZGVhZGJlZWY7XG4gICAgaWYgKGNbMF0gPT09IDB4ZWYpIHJldHVybiAnTEUnO1xuICAgIGlmIChjWzBdID09PSAweGRlKSByZXR1cm4gJ0JFJztcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd24gZW5kaWFubmVzcycpO1xuICB9LFxuXG4gIGlzRnVuY3Rpb24oZnVuY09iaikge1xuICAgIHJldHVybiB0eXBlb2YoZnVuY09iaikgPT09ICdmdW5jdGlvbic7XG4gIH0sXG5cbiAgaXNGdW5jdGlvblN0cmluZyhmbikge1xuICAgIGlmICh0eXBlb2YgZm4gPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gKGZuXG4gICAgICAgIC5zbGljZSgwLCAnZnVuY3Rpb24nLmxlbmd0aClcbiAgICAgICAgLnRvTG93ZXJDYXNlKCkgPT09ICdmdW5jdGlvbicpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG5cbiAgZ2V0RnVuY3Rpb25OYW1lRnJvbVN0cmluZyhmdW5jU3RyKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gRlVOQ1RJT05fTkFNRS5leGVjKGZ1bmNTdHIpO1xuICAgIGlmICghcmVzdWx0IHx8IHJlc3VsdC5sZW5ndGggPT09IDApIHJldHVybiBudWxsO1xuICAgIHJldHVybiByZXN1bHRbMV0udHJpbSgpO1xuICB9LFxuXG4gIGdldEZ1bmN0aW9uQm9keUZyb21TdHJpbmcoZnVuY1N0cikge1xuICAgIHJldHVybiBmdW5jU3RyLnN1YnN0cmluZyhmdW5jU3RyLmluZGV4T2YoJ3snKSArIDEsIGZ1bmNTdHIubGFzdEluZGV4T2YoJ30nKSk7XG4gIH0sXG5cbiAgZ2V0QXJndW1lbnROYW1lc0Zyb21TdHJpbmcoZm4pIHtcbiAgICBjb25zdCBmblN0ciA9IGZuLnJlcGxhY2UoU1RSSVBfQ09NTUVOVFMsICcnKTtcbiAgICBsZXQgcmVzdWx0ID0gZm5TdHIuc2xpY2UoZm5TdHIuaW5kZXhPZignKCcpICsgMSwgZm5TdHIuaW5kZXhPZignKScpKS5tYXRjaChBUkdVTUVOVF9OQU1FUyk7XG4gICAgaWYgKHJlc3VsdCA9PT0gbnVsbCkge1xuICAgICAgcmVzdWx0ID0gW107XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sXG5cbiAgY2xvbmUob2JqKSB7XG4gICAgaWYgKG9iaiA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqICE9PSAnb2JqZWN0JyB8fCBvYmouaGFzT3duUHJvcGVydHkoJ2lzQWN0aXZlQ2xvbmUnKSkgcmV0dXJuIG9iajtcblxuICAgIGNvbnN0IHRlbXAgPSBvYmouY29uc3RydWN0b3IoKTsgXG5cbiAgICBmb3IgKGxldCBrZXkgaW4gb2JqKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgICBvYmouaXNBY3RpdmVDbG9uZSA9IG51bGw7XG4gICAgICAgIHRlbXBba2V5XSA9IHV0aWxzLmNsb25lKG9ialtrZXldKTtcbiAgICAgICAgZGVsZXRlIG9iai5pc0FjdGl2ZUNsb25lO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0ZW1wO1xuICB9LFxuXG4gIGlzQXJyYXkoYXJyYXkpIHtcbiAgICByZXR1cm4gIWlzTmFOKGFycmF5Lmxlbmd0aCk7XG4gIH0sXG5cbiAgZ2V0VmFyaWFibGVUeXBlKHZhbHVlLCBzdHJpY3RJbnRlZ2Vycykge1xuICAgIGlmICh1dGlscy5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgaWYgKHZhbHVlLmxlbmd0aCA+IDAgJiYgdmFsdWVbMF0ubm9kZU5hbWUgPT09ICdJTUcnKSB7XG4gICAgICAgIHJldHVybiAnSFRNTEltYWdlQXJyYXknO1xuICAgICAgfVxuICAgICAgcmV0dXJuICdBcnJheSc7XG4gICAgfVxuXG4gICAgc3dpdGNoICh2YWx1ZS5jb25zdHJ1Y3Rvcikge1xuICAgICAgY2FzZSBCb29sZWFuOlxuICAgICAgICByZXR1cm4gJ0Jvb2xlYW4nO1xuICAgICAgY2FzZSBOdW1iZXI6XG4gICAgICAgIGlmIChzdHJpY3RJbnRlZ2VycyAmJiBOdW1iZXIuaXNJbnRlZ2VyKHZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiAnSW50ZWdlcic7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICdGbG9hdCc7XG4gICAgICBjYXNlIFRleHR1cmU6XG4gICAgICAgIHJldHVybiB2YWx1ZS50eXBlO1xuICAgICAgY2FzZSBJbnB1dDpcbiAgICAgICAgcmV0dXJuICdJbnB1dCc7XG4gICAgfVxuICAgIGlmICgnbm9kZU5hbWUnICBpbiB2YWx1ZSkge1xuICAgICAgc3dpdGNoICh2YWx1ZS5ub2RlTmFtZSkge1xuICAgICAgICBjYXNlICdJTUcnOlxuICAgICAgICAgIHJldHVybiAnSFRNTEltYWdlJztcbiAgICAgICAgY2FzZSAnQ0FOVkFTJzpcbiAgICAgICAgICByZXR1cm4gJ0hUTUxJbWFnZSc7XG4gICAgICAgIGNhc2UgJ1ZJREVPJzpcbiAgICAgICAgICByZXR1cm4gJ0hUTUxWaWRlbyc7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh2YWx1ZS5oYXNPd25Qcm9wZXJ0eSgndHlwZScpKSB7XG4gICAgICByZXR1cm4gdmFsdWUudHlwZTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBPZmZzY3JlZW5DYW52YXMgIT09ICd1bmRlZmluZWQnICYmIHZhbHVlIGluc3RhbmNlb2YgT2Zmc2NyZWVuQ2FudmFzKSB7XG4gICAgICByZXR1cm4gJ09mZnNjcmVlbkNhbnZhcyc7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgSW1hZ2VCaXRtYXAgIT09ICd1bmRlZmluZWQnICYmIHZhbHVlIGluc3RhbmNlb2YgSW1hZ2VCaXRtYXApIHtcbiAgICAgIHJldHVybiAnSW1hZ2VCaXRtYXAnO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIEltYWdlRGF0YSAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsdWUgaW5zdGFuY2VvZiBJbWFnZURhdGEpIHtcbiAgICAgIHJldHVybiAnSW1hZ2VEYXRhJztcbiAgICB9XG4gICAgcmV0dXJuICdVbmtub3duJztcbiAgfSxcblxuICBnZXRLZXJuZWxUZXh0dXJlU2l6ZShzZXR0aW5ncywgZGltZW5zaW9ucykge1xuICAgIGxldCBbdywgaCwgZF0gPSBkaW1lbnNpb25zO1xuICAgIGxldCB0ZXhlbENvdW50ID0gKHcgfHwgMSkgKiAoaCB8fCAxKSAqIChkIHx8IDEpO1xuXG4gICAgaWYgKHNldHRpbmdzLm9wdGltaXplRmxvYXRNZW1vcnkgJiYgc2V0dGluZ3MucHJlY2lzaW9uID09PSAnc2luZ2xlJykge1xuICAgICAgdyA9IHRleGVsQ291bnQgPSBNYXRoLmNlaWwodGV4ZWxDb3VudCAvIDQpO1xuICAgIH1cbiAgICBpZiAoaCA+IDEgJiYgdyAqIGggPT09IHRleGVsQ291bnQpIHtcbiAgICAgIHJldHVybiBuZXcgSW50MzJBcnJheShbdywgaF0pO1xuICAgIH1cbiAgICByZXR1cm4gdXRpbHMuY2xvc2VzdFNxdWFyZURpbWVuc2lvbnModGV4ZWxDb3VudCk7XG4gIH0sXG5cbiAgY2xvc2VzdFNxdWFyZURpbWVuc2lvbnMobGVuZ3RoKSB7XG4gICAgY29uc3Qgc3FydCA9IE1hdGguc3FydChsZW5ndGgpO1xuICAgIGxldCBoaWdoID0gTWF0aC5jZWlsKHNxcnQpO1xuICAgIGxldCBsb3cgPSBNYXRoLmZsb29yKHNxcnQpO1xuICAgIHdoaWxlIChoaWdoICogbG93IDwgbGVuZ3RoKSB7XG4gICAgICBoaWdoLS07XG4gICAgICBsb3cgPSBNYXRoLmNlaWwobGVuZ3RoIC8gaGlnaCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgSW50MzJBcnJheShbbG93LCBNYXRoLmNlaWwobGVuZ3RoIC8gbG93KV0pO1xuICB9LFxuXG4gIGdldE1lbW9yeU9wdGltaXplZEZsb2F0VGV4dHVyZVNpemUoZGltZW5zaW9ucywgYml0UmF0aW8pIHtcbiAgICBjb25zdCB0b3RhbEFyZWEgPSB1dGlscy5yb3VuZFRvKChkaW1lbnNpb25zWzBdIHx8IDEpICogKGRpbWVuc2lvbnNbMV0gfHwgMSkgKiAoZGltZW5zaW9uc1syXSB8fCAxKSAqIChkaW1lbnNpb25zWzNdIHx8IDEpLCA0KTtcbiAgICBjb25zdCB0ZXhlbENvdW50ID0gdG90YWxBcmVhIC8gYml0UmF0aW87XG4gICAgcmV0dXJuIHV0aWxzLmNsb3Nlc3RTcXVhcmVEaW1lbnNpb25zKHRleGVsQ291bnQpO1xuICB9LFxuXG4gIGdldE1lbW9yeU9wdGltaXplZFBhY2tlZFRleHR1cmVTaXplKGRpbWVuc2lvbnMsIGJpdFJhdGlvKSB7XG4gICAgY29uc3QgW3csIGgsIGRdID0gZGltZW5zaW9ucztcbiAgICBjb25zdCB0b3RhbEFyZWEgPSB1dGlscy5yb3VuZFRvKCh3IHx8IDEpICogKGggfHwgMSkgKiAoZCB8fCAxKSwgNCk7XG4gICAgY29uc3QgdGV4ZWxDb3VudCA9IHRvdGFsQXJlYSAvICg0IC8gYml0UmF0aW8pO1xuICAgIHJldHVybiB1dGlscy5jbG9zZXN0U3F1YXJlRGltZW5zaW9ucyh0ZXhlbENvdW50KTtcbiAgfSxcblxuICByb3VuZFRvKG4sIGQpIHtcbiAgICByZXR1cm4gTWF0aC5mbG9vcigobiArIGQgLSAxKSAvIGQpICogZDtcbiAgfSxcbiAgZ2V0RGltZW5zaW9ucyh4LCBwYWQpIHtcbiAgICBsZXQgcmV0O1xuICAgIGlmICh1dGlscy5pc0FycmF5KHgpKSB7XG4gICAgICBjb25zdCBkaW0gPSBbXTtcbiAgICAgIGxldCB0ZW1wID0geDtcbiAgICAgIHdoaWxlICh1dGlscy5pc0FycmF5KHRlbXApKSB7XG4gICAgICAgIGRpbS5wdXNoKHRlbXAubGVuZ3RoKTtcbiAgICAgICAgdGVtcCA9IHRlbXBbMF07XG4gICAgICB9XG4gICAgICByZXQgPSBkaW0ucmV2ZXJzZSgpO1xuICAgIH0gZWxzZSBpZiAoeCBpbnN0YW5jZW9mIFRleHR1cmUpIHtcbiAgICAgIHJldCA9IHgub3V0cHV0O1xuICAgIH0gZWxzZSBpZiAoeCBpbnN0YW5jZW9mIElucHV0KSB7XG4gICAgICByZXQgPSB4LnNpemU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBkaW1lbnNpb25zIG9mICR7eH1gKTtcbiAgICB9XG5cbiAgICBpZiAocGFkKSB7XG4gICAgICByZXQgPSBBcnJheS5mcm9tKHJldCk7XG4gICAgICB3aGlsZSAocmV0Lmxlbmd0aCA8IDMpIHtcbiAgICAgICAgcmV0LnB1c2goMSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBJbnQzMkFycmF5KHJldCk7XG4gIH0sXG5cbiAgZmxhdHRlbjJkQXJyYXlUbyhhcnJheSwgdGFyZ2V0KSB7XG4gICAgbGV0IG9mZnNldCA9IDA7XG4gICAgZm9yIChsZXQgeSA9IDA7IHkgPCBhcnJheS5sZW5ndGg7IHkrKykge1xuICAgICAgdGFyZ2V0LnNldChhcnJheVt5XSwgb2Zmc2V0KTtcbiAgICAgIG9mZnNldCArPSBhcnJheVt5XS5sZW5ndGg7XG4gICAgfVxuICB9LFxuXG4gIGZsYXR0ZW4zZEFycmF5VG8oYXJyYXksIHRhcmdldCkge1xuICAgIGxldCBvZmZzZXQgPSAwO1xuICAgIGZvciAobGV0IHogPSAwOyB6IDwgYXJyYXkubGVuZ3RoOyB6KyspIHtcbiAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgYXJyYXlbel0ubGVuZ3RoOyB5KyspIHtcbiAgICAgICAgdGFyZ2V0LnNldChhcnJheVt6XVt5XSwgb2Zmc2V0KTtcbiAgICAgICAgb2Zmc2V0ICs9IGFycmF5W3pdW3ldLmxlbmd0aDtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgZmxhdHRlbjRkQXJyYXlUbyhhcnJheSwgdGFyZ2V0KSB7XG4gICAgbGV0IG9mZnNldCA9IDA7XG4gICAgZm9yIChsZXQgbCA9IDA7IGwgPCBhcnJheS5sZW5ndGg7IGwrKykge1xuICAgICAgZm9yIChsZXQgeiA9IDA7IHogPCBhcnJheVtsXS5sZW5ndGg7IHorKykge1xuICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IGFycmF5W2xdW3pdLmxlbmd0aDsgeSsrKSB7XG4gICAgICAgICAgdGFyZ2V0LnNldChhcnJheVtsXVt6XVt5XSwgb2Zmc2V0KTtcbiAgICAgICAgICBvZmZzZXQgKz0gYXJyYXlbbF1bel1beV0ubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGZsYXR0ZW5UbyhhcnJheSwgdGFyZ2V0KSB7XG4gICAgaWYgKHV0aWxzLmlzQXJyYXkoYXJyYXlbMF0pKSB7XG4gICAgICBpZiAodXRpbHMuaXNBcnJheShhcnJheVswXVswXSkpIHtcbiAgICAgICAgaWYgKHV0aWxzLmlzQXJyYXkoYXJyYXlbMF1bMF1bMF0pKSB7XG4gICAgICAgICAgdXRpbHMuZmxhdHRlbjRkQXJyYXlUbyhhcnJheSwgdGFyZ2V0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB1dGlscy5mbGF0dGVuM2RBcnJheVRvKGFycmF5LCB0YXJnZXQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1dGlscy5mbGF0dGVuMmRBcnJheVRvKGFycmF5LCB0YXJnZXQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0YXJnZXQuc2V0KGFycmF5KTtcbiAgICB9XG4gIH0sXG5cbiAgc3BsaXRBcnJheShhcnJheSwgcGFydCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpICs9IHBhcnQpIHtcbiAgICAgIHJlc3VsdC5wdXNoKG5ldyBhcnJheS5jb25zdHJ1Y3RvcihhcnJheS5idWZmZXIsIGkgKiA0ICsgYXJyYXkuYnl0ZU9mZnNldCwgcGFydCkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LFxuXG4gIGdldEFzdFN0cmluZyhzb3VyY2UsIGFzdCkge1xuICAgIGNvbnN0IGxpbmVzID0gQXJyYXkuaXNBcnJheShzb3VyY2UpID8gc291cmNlIDogc291cmNlLnNwbGl0KC9cXHI/XFxuL2cpO1xuICAgIGNvbnN0IHN0YXJ0ID0gYXN0LmxvYy5zdGFydDtcbiAgICBjb25zdCBlbmQgPSBhc3QubG9jLmVuZDtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBpZiAoc3RhcnQubGluZSA9PT0gZW5kLmxpbmUpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGxpbmVzW3N0YXJ0LmxpbmUgLSAxXS5zdWJzdHJpbmcoc3RhcnQuY29sdW1uLCBlbmQuY29sdW1uKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5wdXNoKGxpbmVzW3N0YXJ0LmxpbmUgLSAxXS5zbGljZShzdGFydC5jb2x1bW4pKTtcbiAgICAgIGZvciAobGV0IGkgPSBzdGFydC5saW5lOyBpIDwgZW5kLmxpbmU7IGkrKykge1xuICAgICAgICByZXN1bHQucHVzaChsaW5lc1tpXSk7XG4gICAgICB9XG4gICAgICByZXN1bHQucHVzaChsaW5lc1tlbmQubGluZSAtIDFdLnNsaWNlKDAsIGVuZC5jb2x1bW4pKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdC5qb2luKCdcXG4nKTtcbiAgfSxcblxuICBhbGxQcm9wZXJ0aWVzT2Yob2JqKSB7XG4gICAgY29uc3QgcHJvcHMgPSBbXTtcblxuICAgIGRvIHtcbiAgICAgIHByb3BzLnB1c2guYXBwbHkocHJvcHMsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9iaikpO1xuICAgIH0gd2hpbGUgKG9iaiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmopKTtcblxuICAgIHJldHVybiBwcm9wcztcbiAgfSxcblxuICBsaW5lc1RvU3RyaW5nKGxpbmVzKSB7XG4gICAgaWYgKGxpbmVzLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiBsaW5lcy5qb2luKCc7XFxuJykgKyAnO1xcbic7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAnXFxuJztcbiAgICB9XG4gIH0sXG4gIHdhcm5EZXByZWNhdGVkKHR5cGUsIG9sZE5hbWUsIG5ld05hbWUpIHtcbiAgICBpZiAobmV3TmFtZSkge1xuICAgICAgY29uc29sZS53YXJuKGBZb3UgYXJlIHVzaW5nIGEgZGVwcmVjYXRlZCAkeyB0eXBlIH0gXCIkeyBvbGROYW1lIH1cIi4gSXQgaGFzIGJlZW4gcmVwbGFjZWQgd2l0aCBcIiR7IG5ld05hbWUgfVwiLiBGaXhpbmcsIGJ1dCBwbGVhc2UgdXBncmFkZSBhcyBpdCB3aWxsIHNvb24gYmUgcmVtb3ZlZC5gKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS53YXJuKGBZb3UgYXJlIHVzaW5nIGEgZGVwcmVjYXRlZCAkeyB0eXBlIH0gXCIkeyBvbGROYW1lIH1cIi4gSXQgaGFzIGJlZW4gcmVtb3ZlZC4gRml4aW5nLCBidXQgcGxlYXNlIHVwZ3JhZGUgYXMgaXQgd2lsbCBzb29uIGJlIHJlbW92ZWQuYCk7XG4gICAgfVxuICB9LFxuICBmbGlwUGl4ZWxzOiAocGl4ZWxzLCB3aWR0aCwgaGVpZ2h0KSA9PiB7XG4gICAgY29uc3QgaGFsZkhlaWdodCA9IGhlaWdodCAvIDIgfCAwOyBcbiAgICBjb25zdCBieXRlc1BlclJvdyA9IHdpZHRoICogNDtcbiAgICBjb25zdCB0ZW1wID0gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KHdpZHRoICogNCk7XG4gICAgY29uc3QgcmVzdWx0ID0gcGl4ZWxzLnNsaWNlKDApO1xuICAgIGZvciAobGV0IHkgPSAwOyB5IDwgaGFsZkhlaWdodDsgKyt5KSB7XG4gICAgICBjb25zdCB0b3BPZmZzZXQgPSB5ICogYnl0ZXNQZXJSb3c7XG4gICAgICBjb25zdCBib3R0b21PZmZzZXQgPSAoaGVpZ2h0IC0geSAtIDEpICogYnl0ZXNQZXJSb3c7XG5cbiAgICAgIHRlbXAuc2V0KHJlc3VsdC5zdWJhcnJheSh0b3BPZmZzZXQsIHRvcE9mZnNldCArIGJ5dGVzUGVyUm93KSk7XG5cbiAgICAgIHJlc3VsdC5jb3B5V2l0aGluKHRvcE9mZnNldCwgYm90dG9tT2Zmc2V0LCBib3R0b21PZmZzZXQgKyBieXRlc1BlclJvdyk7XG5cbiAgICAgIHJlc3VsdC5zZXQodGVtcCwgYm90dG9tT2Zmc2V0KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSxcbiAgZXJlY3RQYWNrZWRGbG9hdDogKGFycmF5LCB3aWR0aCkgPT4ge1xuICAgIHJldHVybiBhcnJheS5zdWJhcnJheSgwLCB3aWR0aCk7XG4gIH0sXG4gIGVyZWN0MkRQYWNrZWRGbG9hdDogKGFycmF5LCB3aWR0aCwgaGVpZ2h0KSA9PiB7XG4gICAgY29uc3QgeVJlc3VsdHMgPSBuZXcgQXJyYXkoaGVpZ2h0KTtcbiAgICBmb3IgKGxldCB5ID0gMDsgeSA8IGhlaWdodDsgeSsrKSB7XG4gICAgICBjb25zdCB4U3RhcnQgPSB5ICogd2lkdGg7XG4gICAgICBjb25zdCB4RW5kID0geFN0YXJ0ICsgd2lkdGg7XG4gICAgICB5UmVzdWx0c1t5XSA9IGFycmF5LnN1YmFycmF5KHhTdGFydCwgeEVuZCk7XG4gICAgfVxuICAgIHJldHVybiB5UmVzdWx0cztcbiAgfSxcbiAgZXJlY3QzRFBhY2tlZEZsb2F0OiAoYXJyYXksIHdpZHRoLCBoZWlnaHQsIGRlcHRoKSA9PiB7XG4gICAgY29uc3QgelJlc3VsdHMgPSBuZXcgQXJyYXkoZGVwdGgpO1xuICAgIGZvciAobGV0IHogPSAwOyB6IDwgZGVwdGg7IHorKykge1xuICAgICAgY29uc3QgeVJlc3VsdHMgPSBuZXcgQXJyYXkoaGVpZ2h0KTtcbiAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgaGVpZ2h0OyB5KyspIHtcbiAgICAgICAgY29uc3QgeFN0YXJ0ID0gKHogKiBoZWlnaHQgKiB3aWR0aCkgKyB5ICogd2lkdGg7XG4gICAgICAgIGNvbnN0IHhFbmQgPSB4U3RhcnQgKyB3aWR0aDtcbiAgICAgICAgeVJlc3VsdHNbeV0gPSBhcnJheS5zdWJhcnJheSh4U3RhcnQsIHhFbmQpO1xuICAgICAgfVxuICAgICAgelJlc3VsdHNbel0gPSB5UmVzdWx0cztcbiAgICB9XG4gICAgcmV0dXJuIHpSZXN1bHRzO1xuICB9LFxuICBlcmVjdE1lbW9yeU9wdGltaXplZEZsb2F0OiAoYXJyYXksIHdpZHRoKSA9PiB7XG4gICAgcmV0dXJuIGFycmF5LnN1YmFycmF5KDAsIHdpZHRoKTtcbiAgfSxcbiAgZXJlY3RNZW1vcnlPcHRpbWl6ZWQyREZsb2F0OiAoYXJyYXksIHdpZHRoLCBoZWlnaHQpID0+IHtcbiAgICBjb25zdCB5UmVzdWx0cyA9IG5ldyBBcnJheShoZWlnaHQpO1xuICAgIGZvciAobGV0IHkgPSAwOyB5IDwgaGVpZ2h0OyB5KyspIHtcbiAgICAgIGNvbnN0IG9mZnNldCA9IHkgKiB3aWR0aDtcbiAgICAgIHlSZXN1bHRzW3ldID0gYXJyYXkuc3ViYXJyYXkob2Zmc2V0LCBvZmZzZXQgKyB3aWR0aCk7XG4gICAgfVxuICAgIHJldHVybiB5UmVzdWx0cztcbiAgfSxcbiAgZXJlY3RNZW1vcnlPcHRpbWl6ZWQzREZsb2F0OiAoYXJyYXksIHdpZHRoLCBoZWlnaHQsIGRlcHRoKSA9PiB7XG4gICAgY29uc3QgelJlc3VsdHMgPSBuZXcgQXJyYXkoZGVwdGgpO1xuICAgIGZvciAobGV0IHogPSAwOyB6IDwgZGVwdGg7IHorKykge1xuICAgICAgY29uc3QgeVJlc3VsdHMgPSBuZXcgQXJyYXkoaGVpZ2h0KTtcbiAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgaGVpZ2h0OyB5KyspIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gKHogKiBoZWlnaHQgKiB3aWR0aCkgKyAoeSAqIHdpZHRoKTtcbiAgICAgICAgeVJlc3VsdHNbeV0gPSBhcnJheS5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIHdpZHRoKTtcbiAgICAgIH1cbiAgICAgIHpSZXN1bHRzW3pdID0geVJlc3VsdHM7XG4gICAgfVxuICAgIHJldHVybiB6UmVzdWx0cztcbiAgfSxcbiAgZXJlY3RGbG9hdDogKGFycmF5LCB3aWR0aCkgPT4ge1xuICAgIGNvbnN0IHhSZXN1bHRzID0gbmV3IEZsb2F0MzJBcnJheSh3aWR0aCk7XG4gICAgbGV0IGkgPSAwO1xuICAgIGZvciAobGV0IHggPSAwOyB4IDwgd2lkdGg7IHgrKykge1xuICAgICAgeFJlc3VsdHNbeF0gPSBhcnJheVtpXTtcbiAgICAgIGkgKz0gNDtcbiAgICB9XG4gICAgcmV0dXJuIHhSZXN1bHRzO1xuICB9LFxuICBlcmVjdDJERmxvYXQ6IChhcnJheSwgd2lkdGgsIGhlaWdodCkgPT4ge1xuICAgIGNvbnN0IHlSZXN1bHRzID0gbmV3IEFycmF5KGhlaWdodCk7XG4gICAgbGV0IGkgPSAwO1xuICAgIGZvciAobGV0IHkgPSAwOyB5IDwgaGVpZ2h0OyB5KyspIHtcbiAgICAgIGNvbnN0IHhSZXN1bHRzID0gbmV3IEZsb2F0MzJBcnJheSh3aWR0aCk7XG4gICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHdpZHRoOyB4KyspIHtcbiAgICAgICAgeFJlc3VsdHNbeF0gPSBhcnJheVtpXTtcbiAgICAgICAgaSArPSA0O1xuICAgICAgfVxuICAgICAgeVJlc3VsdHNbeV0gPSB4UmVzdWx0cztcbiAgICB9XG4gICAgcmV0dXJuIHlSZXN1bHRzO1xuICB9LFxuICBlcmVjdDNERmxvYXQ6IChhcnJheSwgd2lkdGgsIGhlaWdodCwgZGVwdGgpID0+IHtcbiAgICBjb25zdCB6UmVzdWx0cyA9IG5ldyBBcnJheShkZXB0aCk7XG4gICAgbGV0IGkgPSAwO1xuICAgIGZvciAobGV0IHogPSAwOyB6IDwgZGVwdGg7IHorKykge1xuICAgICAgY29uc3QgeVJlc3VsdHMgPSBuZXcgQXJyYXkoaGVpZ2h0KTtcbiAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgaGVpZ2h0OyB5KyspIHtcbiAgICAgICAgY29uc3QgeFJlc3VsdHMgPSBuZXcgRmxvYXQzMkFycmF5KHdpZHRoKTtcbiAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCB3aWR0aDsgeCsrKSB7XG4gICAgICAgICAgeFJlc3VsdHNbeF0gPSBhcnJheVtpXTtcbiAgICAgICAgICBpICs9IDQ7XG4gICAgICAgIH1cbiAgICAgICAgeVJlc3VsdHNbeV0gPSB4UmVzdWx0cztcbiAgICAgIH1cbiAgICAgIHpSZXN1bHRzW3pdID0geVJlc3VsdHM7XG4gICAgfVxuICAgIHJldHVybiB6UmVzdWx0cztcbiAgfSxcbiAgZXJlY3RBcnJheTI6IChhcnJheSwgd2lkdGgpID0+IHtcbiAgICBjb25zdCB4UmVzdWx0cyA9IG5ldyBBcnJheSh3aWR0aCk7XG4gICAgY29uc3QgeFJlc3VsdHNNYXggPSB3aWR0aCAqIDQ7XG4gICAgbGV0IGkgPSAwO1xuICAgIGZvciAobGV0IHggPSAwOyB4IDwgeFJlc3VsdHNNYXg7IHggKz0gNCkge1xuICAgICAgeFJlc3VsdHNbaSsrXSA9IGFycmF5LnN1YmFycmF5KHgsIHggKyAyKTtcbiAgICB9XG4gICAgcmV0dXJuIHhSZXN1bHRzO1xuICB9LFxuICBlcmVjdDJEQXJyYXkyOiAoYXJyYXksIHdpZHRoLCBoZWlnaHQpID0+IHtcbiAgICBjb25zdCB5UmVzdWx0cyA9IG5ldyBBcnJheShoZWlnaHQpO1xuICAgIGNvbnN0IFhSZXN1bHRzTWF4ID0gd2lkdGggKiA0O1xuICAgIGZvciAobGV0IHkgPSAwOyB5IDwgaGVpZ2h0OyB5KyspIHtcbiAgICAgIGNvbnN0IHhSZXN1bHRzID0gbmV3IEFycmF5KHdpZHRoKTtcbiAgICAgIGNvbnN0IG9mZnNldCA9IHkgKiBYUmVzdWx0c01heDtcbiAgICAgIGxldCBpID0gMDtcbiAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgWFJlc3VsdHNNYXg7IHggKz0gNCkge1xuICAgICAgICB4UmVzdWx0c1tpKytdID0gYXJyYXkuc3ViYXJyYXkoeCArIG9mZnNldCwgeCArIG9mZnNldCArIDIpO1xuICAgICAgfVxuICAgICAgeVJlc3VsdHNbeV0gPSB4UmVzdWx0cztcbiAgICB9XG4gICAgcmV0dXJuIHlSZXN1bHRzO1xuICB9LFxuICBlcmVjdDNEQXJyYXkyOiAoYXJyYXksIHdpZHRoLCBoZWlnaHQsIGRlcHRoKSA9PiB7XG4gICAgY29uc3QgeFJlc3VsdHNNYXggPSB3aWR0aCAqIDQ7XG4gICAgY29uc3QgelJlc3VsdHMgPSBuZXcgQXJyYXkoZGVwdGgpO1xuICAgIGZvciAobGV0IHogPSAwOyB6IDwgZGVwdGg7IHorKykge1xuICAgICAgY29uc3QgeVJlc3VsdHMgPSBuZXcgQXJyYXkoaGVpZ2h0KTtcbiAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgaGVpZ2h0OyB5KyspIHtcbiAgICAgICAgY29uc3QgeFJlc3VsdHMgPSBuZXcgQXJyYXkod2lkdGgpO1xuICAgICAgICBjb25zdCBvZmZzZXQgPSAoeiAqIHhSZXN1bHRzTWF4ICogaGVpZ2h0KSArICh5ICogeFJlc3VsdHNNYXgpO1xuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgeFJlc3VsdHNNYXg7IHggKz0gNCkge1xuICAgICAgICAgIHhSZXN1bHRzW2krK10gPSBhcnJheS5zdWJhcnJheSh4ICsgb2Zmc2V0LCB4ICsgb2Zmc2V0ICsgMik7XG4gICAgICAgIH1cbiAgICAgICAgeVJlc3VsdHNbeV0gPSB4UmVzdWx0cztcbiAgICAgIH1cbiAgICAgIHpSZXN1bHRzW3pdID0geVJlc3VsdHM7XG4gICAgfVxuICAgIHJldHVybiB6UmVzdWx0cztcbiAgfSxcbiAgZXJlY3RBcnJheTM6IChhcnJheSwgd2lkdGgpID0+IHtcbiAgICBjb25zdCB4UmVzdWx0cyA9IG5ldyBBcnJheSh3aWR0aCk7XG4gICAgY29uc3QgeFJlc3VsdHNNYXggPSB3aWR0aCAqIDQ7XG4gICAgbGV0IGkgPSAwO1xuICAgIGZvciAobGV0IHggPSAwOyB4IDwgeFJlc3VsdHNNYXg7IHggKz0gNCkge1xuICAgICAgeFJlc3VsdHNbaSsrXSA9IGFycmF5LnN1YmFycmF5KHgsIHggKyAzKTtcbiAgICB9XG4gICAgcmV0dXJuIHhSZXN1bHRzO1xuICB9LFxuICBlcmVjdDJEQXJyYXkzOiAoYXJyYXksIHdpZHRoLCBoZWlnaHQpID0+IHtcbiAgICBjb25zdCB4UmVzdWx0c01heCA9IHdpZHRoICogNDtcbiAgICBjb25zdCB5UmVzdWx0cyA9IG5ldyBBcnJheShoZWlnaHQpO1xuICAgIGZvciAobGV0IHkgPSAwOyB5IDwgaGVpZ2h0OyB5KyspIHtcbiAgICAgIGNvbnN0IHhSZXN1bHRzID0gbmV3IEFycmF5KHdpZHRoKTtcbiAgICAgIGNvbnN0IG9mZnNldCA9IHkgKiB4UmVzdWx0c01heDtcbiAgICAgIGxldCBpID0gMDtcbiAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgeFJlc3VsdHNNYXg7IHggKz0gNCkge1xuICAgICAgICB4UmVzdWx0c1tpKytdID0gYXJyYXkuc3ViYXJyYXkoeCArIG9mZnNldCwgeCArIG9mZnNldCArIDMpO1xuICAgICAgfVxuICAgICAgeVJlc3VsdHNbeV0gPSB4UmVzdWx0cztcbiAgICB9XG4gICAgcmV0dXJuIHlSZXN1bHRzO1xuICB9LFxuICBlcmVjdDNEQXJyYXkzOiAoYXJyYXksIHdpZHRoLCBoZWlnaHQsIGRlcHRoKSA9PiB7XG4gICAgY29uc3QgeFJlc3VsdHNNYXggPSB3aWR0aCAqIDQ7XG4gICAgY29uc3QgelJlc3VsdHMgPSBuZXcgQXJyYXkoZGVwdGgpO1xuICAgIGZvciAobGV0IHogPSAwOyB6IDwgZGVwdGg7IHorKykge1xuICAgICAgY29uc3QgeVJlc3VsdHMgPSBuZXcgQXJyYXkoaGVpZ2h0KTtcbiAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgaGVpZ2h0OyB5KyspIHtcbiAgICAgICAgY29uc3QgeFJlc3VsdHMgPSBuZXcgQXJyYXkod2lkdGgpO1xuICAgICAgICBjb25zdCBvZmZzZXQgPSAoeiAqIHhSZXN1bHRzTWF4ICogaGVpZ2h0KSArICh5ICogeFJlc3VsdHNNYXgpO1xuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgeFJlc3VsdHNNYXg7IHggKz0gNCkge1xuICAgICAgICAgIHhSZXN1bHRzW2krK10gPSBhcnJheS5zdWJhcnJheSh4ICsgb2Zmc2V0LCB4ICsgb2Zmc2V0ICsgMyk7XG4gICAgICAgIH1cbiAgICAgICAgeVJlc3VsdHNbeV0gPSB4UmVzdWx0cztcbiAgICAgIH1cbiAgICAgIHpSZXN1bHRzW3pdID0geVJlc3VsdHM7XG4gICAgfVxuICAgIHJldHVybiB6UmVzdWx0cztcbiAgfSxcbiAgZXJlY3RBcnJheTQ6IChhcnJheSwgd2lkdGgpID0+IHtcbiAgICBjb25zdCB4UmVzdWx0cyA9IG5ldyBBcnJheShhcnJheSk7XG4gICAgY29uc3QgeFJlc3VsdHNNYXggPSB3aWR0aCAqIDQ7XG4gICAgbGV0IGkgPSAwO1xuICAgIGZvciAobGV0IHggPSAwOyB4IDwgeFJlc3VsdHNNYXg7IHggKz0gNCkge1xuICAgICAgeFJlc3VsdHNbaSsrXSA9IGFycmF5LnN1YmFycmF5KHgsIHggKyA0KTtcbiAgICB9XG4gICAgcmV0dXJuIHhSZXN1bHRzO1xuICB9LFxuICBlcmVjdDJEQXJyYXk0OiAoYXJyYXksIHdpZHRoLCBoZWlnaHQpID0+IHtcbiAgICBjb25zdCB4UmVzdWx0c01heCA9IHdpZHRoICogNDtcbiAgICBjb25zdCB5UmVzdWx0cyA9IG5ldyBBcnJheShoZWlnaHQpO1xuICAgIGZvciAobGV0IHkgPSAwOyB5IDwgaGVpZ2h0OyB5KyspIHtcbiAgICAgIGNvbnN0IHhSZXN1bHRzID0gbmV3IEFycmF5KHdpZHRoKTtcbiAgICAgIGNvbnN0IG9mZnNldCA9IHkgKiB4UmVzdWx0c01heDtcbiAgICAgIGxldCBpID0gMDtcbiAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgeFJlc3VsdHNNYXg7IHggKz0gNCkge1xuICAgICAgICB4UmVzdWx0c1tpKytdID0gYXJyYXkuc3ViYXJyYXkoeCArIG9mZnNldCwgeCArIG9mZnNldCArIDQpO1xuICAgICAgfVxuICAgICAgeVJlc3VsdHNbeV0gPSB4UmVzdWx0cztcbiAgICB9XG4gICAgcmV0dXJuIHlSZXN1bHRzO1xuICB9LFxuICBlcmVjdDNEQXJyYXk0OiAoYXJyYXksIHdpZHRoLCBoZWlnaHQsIGRlcHRoKSA9PiB7XG4gICAgY29uc3QgeFJlc3VsdHNNYXggPSB3aWR0aCAqIDQ7XG4gICAgY29uc3QgelJlc3VsdHMgPSBuZXcgQXJyYXkoZGVwdGgpO1xuICAgIGZvciAobGV0IHogPSAwOyB6IDwgZGVwdGg7IHorKykge1xuICAgICAgY29uc3QgeVJlc3VsdHMgPSBuZXcgQXJyYXkoaGVpZ2h0KTtcbiAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgaGVpZ2h0OyB5KyspIHtcbiAgICAgICAgY29uc3QgeFJlc3VsdHMgPSBuZXcgQXJyYXkod2lkdGgpO1xuICAgICAgICBjb25zdCBvZmZzZXQgPSAoeiAqIHhSZXN1bHRzTWF4ICogaGVpZ2h0KSArICh5ICogeFJlc3VsdHNNYXgpO1xuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgeFJlc3VsdHNNYXg7IHggKz0gNCkge1xuICAgICAgICAgIHhSZXN1bHRzW2krK10gPSBhcnJheS5zdWJhcnJheSh4ICsgb2Zmc2V0LCB4ICsgb2Zmc2V0ICsgNCk7XG4gICAgICAgIH1cbiAgICAgICAgeVJlc3VsdHNbeV0gPSB4UmVzdWx0cztcbiAgICAgIH1cbiAgICAgIHpSZXN1bHRzW3pdID0geVJlc3VsdHM7XG4gICAgfVxuICAgIHJldHVybiB6UmVzdWx0cztcbiAgfSxcblxuICBmbGF0dGVuRnVuY3Rpb25Ub1N0cmluZzogKHNvdXJjZSwgc2V0dGluZ3MpID0+IHtcbiAgICBjb25zdCB7IGZpbmREZXBlbmRlbmN5LCB0aGlzTG9va3VwLCBkb05vdERlZmluZSB9ID0gc2V0dGluZ3M7XG4gICAgbGV0IGZsYXR0ZW5lZCA9IHNldHRpbmdzLmZsYXR0ZW5lZDtcbiAgICBpZiAoIWZsYXR0ZW5lZCkge1xuICAgICAgZmxhdHRlbmVkID0gc2V0dGluZ3MuZmxhdHRlbmVkID0ge307XG4gICAgfVxuICAgIGNvbnN0IGFzdCA9IGFjb3JuLnBhcnNlKHNvdXJjZSk7XG4gICAgY29uc3QgZnVuY3Rpb25EZXBlbmRlbmNpZXMgPSBbXTtcbiAgICBsZXQgaW5kZW50ID0gMDtcblxuICAgIGZ1bmN0aW9uIGZsYXR0ZW4oYXN0KSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShhc3QpKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICByZXN1bHRzLnB1c2goZmxhdHRlbihhc3RbaV0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0cy5qb2luKCcnKTtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAoYXN0LnR5cGUpIHtcbiAgICAgICAgY2FzZSAnUHJvZ3JhbSc6XG4gICAgICAgICAgcmV0dXJuIGZsYXR0ZW4oYXN0LmJvZHkpICsgKGFzdC5ib2R5WzBdLnR5cGUgPT09ICdWYXJpYWJsZURlY2xhcmF0aW9uJyA/ICc7JyA6ICcnKTtcbiAgICAgICAgY2FzZSAnRnVuY3Rpb25EZWNsYXJhdGlvbic6XG4gICAgICAgICAgcmV0dXJuIGBmdW5jdGlvbiAke2FzdC5pZC5uYW1lfSgke2FzdC5wYXJhbXMubWFwKGZsYXR0ZW4pLmpvaW4oJywgJyl9KSAkeyBmbGF0dGVuKGFzdC5ib2R5KSB9YDtcbiAgICAgICAgY2FzZSAnQmxvY2tTdGF0ZW1lbnQnOiB7XG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgICAgaW5kZW50ICs9IDI7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhc3QuYm9keS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgZmxhdCA9IGZsYXR0ZW4oYXN0LmJvZHlbaV0pO1xuICAgICAgICAgICAgaWYgKGZsYXQpIHtcbiAgICAgICAgICAgICAgcmVzdWx0LnB1c2goJyAnLnJlcGVhdChpbmRlbnQpICsgZmxhdCwgJztcXG4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaW5kZW50IC09IDI7XG4gICAgICAgICAgcmV0dXJuIGB7XFxuJHtyZXN1bHQuam9pbignJyl9fWA7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnVmFyaWFibGVEZWNsYXJhdGlvbic6XG4gICAgICAgICAgY29uc3QgZGVjbGFyYXRpb25zID0gdXRpbHMubm9ybWFsaXplRGVjbGFyYXRpb25zKGFzdClcbiAgICAgICAgICAgIC5tYXAoZmxhdHRlbilcbiAgICAgICAgICAgIC5maWx0ZXIociA9PiByICE9PSBudWxsKTtcbiAgICAgICAgICBpZiAoZGVjbGFyYXRpb25zLmxlbmd0aCA8IDEpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGAke2FzdC5raW5kfSAke2RlY2xhcmF0aW9ucy5qb2luKCcsJyl9YDtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAnVmFyaWFibGVEZWNsYXJhdG9yJzpcbiAgICAgICAgICAgIGlmIChhc3QuaW5pdC5vYmplY3QgJiYgYXN0LmluaXQub2JqZWN0LnR5cGUgPT09ICdUaGlzRXhwcmVzc2lvbicpIHtcbiAgICAgICAgICAgICAgY29uc3QgbG9va3VwID0gdGhpc0xvb2t1cChhc3QuaW5pdC5wcm9wZXJ0eS5uYW1lLCB0cnVlKTtcbiAgICAgICAgICAgICAgaWYgKGxvb2t1cCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBgJHthc3QuaWQubmFtZX0gPSAke2ZsYXR0ZW4oYXN0LmluaXQpfWA7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBgJHthc3QuaWQubmFtZX0gPSAke2ZsYXR0ZW4oYXN0LmluaXQpfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdDYWxsRXhwcmVzc2lvbic6IHtcbiAgICAgICAgICAgICAgaWYgKGFzdC5jYWxsZWUucHJvcGVydHkubmFtZSA9PT0gJ3N1YmFycmF5Jykge1xuICAgICAgICAgICAgICAgIHJldHVybiBgJHtmbGF0dGVuKGFzdC5jYWxsZWUub2JqZWN0KX0uJHtmbGF0dGVuKGFzdC5jYWxsZWUucHJvcGVydHkpfSgke2FzdC5hcmd1bWVudHMubWFwKHZhbHVlID0+IGZsYXR0ZW4odmFsdWUpKS5qb2luKCcsICcpfSlgO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChhc3QuY2FsbGVlLm9iamVjdC5uYW1lID09PSAnZ2wnIHx8IGFzdC5jYWxsZWUub2JqZWN0Lm5hbWUgPT09ICdjb250ZXh0Jykge1xuICAgICAgICAgICAgICAgIHJldHVybiBgJHtmbGF0dGVuKGFzdC5jYWxsZWUub2JqZWN0KX0uJHtmbGF0dGVuKGFzdC5jYWxsZWUucHJvcGVydHkpfSgke2FzdC5hcmd1bWVudHMubWFwKHZhbHVlID0+IGZsYXR0ZW4odmFsdWUpKS5qb2luKCcsICcpfSlgO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChhc3QuY2FsbGVlLm9iamVjdC50eXBlID09PSAnVGhpc0V4cHJlc3Npb24nKSB7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb25EZXBlbmRlbmNpZXMucHVzaChmaW5kRGVwZW5kZW5jeSgndGhpcycsIGFzdC5jYWxsZWUucHJvcGVydHkubmFtZSkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBgJHthc3QuY2FsbGVlLnByb3BlcnR5Lm5hbWV9KCR7YXN0LmFyZ3VtZW50cy5tYXAodmFsdWUgPT4gZmxhdHRlbih2YWx1ZSkpLmpvaW4oJywgJyl9KWA7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoYXN0LmNhbGxlZS5vYmplY3QubmFtZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZvdW5kU291cmNlID0gZmluZERlcGVuZGVuY3koYXN0LmNhbGxlZS5vYmplY3QubmFtZSwgYXN0LmNhbGxlZS5wcm9wZXJ0eS5uYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAoZm91bmRTb3VyY2UgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBgJHthc3QuY2FsbGVlLm9iamVjdC5uYW1lfS4ke2FzdC5jYWxsZWUucHJvcGVydHkubmFtZX0oJHthc3QuYXJndW1lbnRzLm1hcCh2YWx1ZSA9PiBmbGF0dGVuKHZhbHVlKSkuam9pbignLCAnKX0pYDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgZnVuY3Rpb25EZXBlbmRlbmNpZXMucHVzaChmb3VuZFNvdXJjZSk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gYCR7YXN0LmNhbGxlZS5wcm9wZXJ0eS5uYW1lfSgke2FzdC5hcmd1bWVudHMubWFwKHZhbHVlID0+IGZsYXR0ZW4odmFsdWUpKS5qb2luKCcsICcpfSlgO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChhc3QuY2FsbGVlLm9iamVjdC50eXBlID09PSAnTWVtYmVyRXhwcmVzc2lvbicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYCR7ZmxhdHRlbihhc3QuY2FsbGVlLm9iamVjdCl9LiR7YXN0LmNhbGxlZS5wcm9wZXJ0eS5uYW1lfSgke2FzdC5hcmd1bWVudHMubWFwKHZhbHVlID0+IGZsYXR0ZW4odmFsdWUpKS5qb2luKCcsICcpfSlgO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndW5rbm93biBhc3QuY2FsbGVlJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ1JldHVyblN0YXRlbWVudCc6XG4gICAgICAgICAgICAgIHJldHVybiBgcmV0dXJuICR7ZmxhdHRlbihhc3QuYXJndW1lbnQpfWA7XG4gICAgICAgICAgICBjYXNlICdCaW5hcnlFeHByZXNzaW9uJzpcbiAgICAgICAgICAgICAgcmV0dXJuIGAoJHtmbGF0dGVuKGFzdC5sZWZ0KX0ke2FzdC5vcGVyYXRvcn0ke2ZsYXR0ZW4oYXN0LnJpZ2h0KX0pYDtcbiAgICAgICAgICAgIGNhc2UgJ1VuYXJ5RXhwcmVzc2lvbic6XG4gICAgICAgICAgICAgIGlmIChhc3QucHJlZml4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGAke2FzdC5vcGVyYXRvcn0gJHtmbGF0dGVuKGFzdC5hcmd1bWVudCl9YDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYCR7ZmxhdHRlbihhc3QuYXJndW1lbnQpfSAke2FzdC5vcGVyYXRvcn1gO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNhc2UgJ0V4cHJlc3Npb25TdGF0ZW1lbnQnOlxuICAgICAgICAgICAgICAgIHJldHVybiBgJHtmbGF0dGVuKGFzdC5leHByZXNzaW9uKX1gO1xuICAgICAgICAgICAgICBjYXNlICdTZXF1ZW5jZUV4cHJlc3Npb24nOlxuICAgICAgICAgICAgICAgIHJldHVybiBgKCR7ZmxhdHRlbihhc3QuZXhwcmVzc2lvbnMpfSlgO1xuICAgICAgICAgICAgICBjYXNlICdBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGAoJHthc3QucGFyYW1zLm1hcChmbGF0dGVuKS5qb2luKCcsICcpfSkgPT4gJHtmbGF0dGVuKGFzdC5ib2R5KX1gO1xuICAgICAgICAgICAgICBjYXNlICdMaXRlcmFsJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gYXN0LnJhdztcbiAgICAgICAgICAgICAgY2FzZSAnSWRlbnRpZmllcic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFzdC5uYW1lO1xuICAgICAgICAgICAgICBjYXNlICdNZW1iZXJFeHByZXNzaW9uJzpcbiAgICAgICAgICAgICAgICBpZiAoYXN0Lm9iamVjdC50eXBlID09PSAnVGhpc0V4cHJlc3Npb24nKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdGhpc0xvb2t1cChhc3QucHJvcGVydHkubmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChhc3QuY29tcHV0ZWQpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBgJHtmbGF0dGVuKGFzdC5vYmplY3QpfVske2ZsYXR0ZW4oYXN0LnByb3BlcnR5KX1dYDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZsYXR0ZW4oYXN0Lm9iamVjdCkgKyAnLicgKyBmbGF0dGVuKGFzdC5wcm9wZXJ0eSk7XG4gICAgICAgICAgICAgIGNhc2UgJ1RoaXNFeHByZXNzaW9uJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3RoaXMnO1xuICAgICAgICAgICAgICBjYXNlICdOZXdFeHByZXNzaW9uJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gYG5ldyAke2ZsYXR0ZW4oYXN0LmNhbGxlZSl9KCR7YXN0LmFyZ3VtZW50cy5tYXAodmFsdWUgPT4gZmxhdHRlbih2YWx1ZSkpLmpvaW4oJywgJyl9KWA7XG4gICAgICAgICAgICAgIGNhc2UgJ0ZvclN0YXRlbWVudCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGBmb3IgKCR7ZmxhdHRlbihhc3QuaW5pdCl9OyR7ZmxhdHRlbihhc3QudGVzdCl9OyR7ZmxhdHRlbihhc3QudXBkYXRlKX0pICR7ZmxhdHRlbihhc3QuYm9keSl9YDtcbiAgICAgICAgICAgICAgY2FzZSAnQXNzaWdubWVudEV4cHJlc3Npb24nOlxuICAgICAgICAgICAgICAgIHJldHVybiBgJHtmbGF0dGVuKGFzdC5sZWZ0KX0ke2FzdC5vcGVyYXRvcn0ke2ZsYXR0ZW4oYXN0LnJpZ2h0KX1gO1xuICAgICAgICAgICAgICBjYXNlICdVcGRhdGVFeHByZXNzaW9uJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gYCR7ZmxhdHRlbihhc3QuYXJndW1lbnQpfSR7YXN0Lm9wZXJhdG9yfWA7XG4gICAgICAgICAgICAgIGNhc2UgJ0lmU3RhdGVtZW50JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gYGlmICgke2ZsYXR0ZW4oYXN0LnRlc3QpfSkgJHtmbGF0dGVuKGFzdC5jb25zZXF1ZW50KX1gO1xuICAgICAgICAgICAgICBjYXNlICdUaHJvd1N0YXRlbWVudCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGB0aHJvdyAke2ZsYXR0ZW4oYXN0LmFyZ3VtZW50KX1gO1xuICAgICAgICAgICAgICBjYXNlICdPYmplY3RQYXR0ZXJuJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gYXN0LnByb3BlcnRpZXMubWFwKGZsYXR0ZW4pLmpvaW4oJywgJyk7XG4gICAgICAgICAgICAgIGNhc2UgJ0FycmF5UGF0dGVybic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFzdC5lbGVtZW50cy5tYXAoZmxhdHRlbikuam9pbignLCAnKTtcbiAgICAgICAgICAgICAgY2FzZSAnRGVidWdnZXJTdGF0ZW1lbnQnOlxuICAgICAgICAgICAgICAgIHJldHVybiAnZGVidWdnZXI7JztcbiAgICAgICAgICAgICAgY2FzZSAnQ29uZGl0aW9uYWxFeHByZXNzaW9uJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gYCR7ZmxhdHRlbihhc3QudGVzdCl9PyR7ZmxhdHRlbihhc3QuY29uc2VxdWVudCl9OiR7ZmxhdHRlbihhc3QuYWx0ZXJuYXRlKX1gO1xuICAgICAgICAgICAgICBjYXNlICdQcm9wZXJ0eSc6XG4gICAgICAgICAgICAgICAgaWYgKGFzdC5raW5kID09PSAnaW5pdCcpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmbGF0dGVuKGFzdC5rZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcihgdW5oYW5kbGVkIGFzdC50eXBlIG9mICR7IGFzdC50eXBlIH1gKTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gZmxhdHRlbihhc3QpO1xuICAgIGlmIChmdW5jdGlvbkRlcGVuZGVuY2llcy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBmbGF0dGVuZWRGdW5jdGlvbkRlcGVuZGVuY2llcyA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmdW5jdGlvbkRlcGVuZGVuY2llcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBmdW5jdGlvbkRlcGVuZGVuY3kgPSBmdW5jdGlvbkRlcGVuZGVuY2llc1tpXTtcbiAgICAgICAgaWYgKCFmbGF0dGVuZWRbZnVuY3Rpb25EZXBlbmRlbmN5XSkge1xuICAgICAgICAgIGZsYXR0ZW5lZFtmdW5jdGlvbkRlcGVuZGVuY3ldID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbkRlcGVuZGVuY3kgPyBmbGF0dGVuZWRGdW5jdGlvbkRlcGVuZGVuY2llcy5wdXNoKHV0aWxzLmZsYXR0ZW5GdW5jdGlvblRvU3RyaW5nKGZ1bmN0aW9uRGVwZW5kZW5jeSwgc2V0dGluZ3MpICsgJ1xcbicpIDogJyc7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmxhdHRlbmVkRnVuY3Rpb25EZXBlbmRlbmNpZXMuam9pbignJykgKyByZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sXG5cbiAgbm9ybWFsaXplRGVjbGFyYXRpb25zOiAoYXN0KSA9PiB7XG4gICAgaWYgKGFzdC50eXBlICE9PSAnVmFyaWFibGVEZWNsYXJhdGlvbicpIHRocm93IG5ldyBFcnJvcignQXN0IGlzIG5vdCBvZiB0eXBlIFwiVmFyaWFibGVEZWNsYXJhdGlvblwiJyk7XG4gICAgY29uc3Qgbm9ybWFsaXplZERlY2xhcmF0aW9ucyA9IFtdO1xuICAgIGZvciAobGV0IGRlY2xhcmF0aW9uSW5kZXggPSAwOyBkZWNsYXJhdGlvbkluZGV4IDwgYXN0LmRlY2xhcmF0aW9ucy5sZW5ndGg7IGRlY2xhcmF0aW9uSW5kZXgrKykge1xuICAgICAgY29uc3QgZGVjbGFyYXRpb24gPSBhc3QuZGVjbGFyYXRpb25zW2RlY2xhcmF0aW9uSW5kZXhdO1xuICAgICAgaWYgKGRlY2xhcmF0aW9uLmlkICYmIGRlY2xhcmF0aW9uLmlkLnR5cGUgPT09ICdPYmplY3RQYXR0ZXJuJyAmJiBkZWNsYXJhdGlvbi5pZC5wcm9wZXJ0aWVzKSB7XG4gICAgICAgIGNvbnN0IHsgcHJvcGVydGllcyB9ID0gZGVjbGFyYXRpb24uaWQ7XG4gICAgICAgIGZvciAobGV0IHByb3BlcnR5SW5kZXggPSAwOyBwcm9wZXJ0eUluZGV4IDwgcHJvcGVydGllcy5sZW5ndGg7IHByb3BlcnR5SW5kZXgrKykge1xuICAgICAgICAgIGNvbnN0IHByb3BlcnR5ID0gcHJvcGVydGllc1twcm9wZXJ0eUluZGV4XTtcbiAgICAgICAgICBpZiAocHJvcGVydHkudmFsdWUudHlwZSA9PT0gJ09iamVjdFBhdHRlcm4nICYmIHByb3BlcnR5LnZhbHVlLnByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIGZvciAobGV0IHN1YlByb3BlcnR5SW5kZXggPSAwOyBzdWJQcm9wZXJ0eUluZGV4IDwgcHJvcGVydHkudmFsdWUucHJvcGVydGllcy5sZW5ndGg7IHN1YlByb3BlcnR5SW5kZXgrKykge1xuICAgICAgICAgICAgICBjb25zdCBzdWJQcm9wZXJ0eSA9IHByb3BlcnR5LnZhbHVlLnByb3BlcnRpZXNbc3ViUHJvcGVydHlJbmRleF07XG4gICAgICAgICAgICAgIGlmIChzdWJQcm9wZXJ0eS50eXBlID09PSAnUHJvcGVydHknKSB7XG4gICAgICAgICAgICAgICAgbm9ybWFsaXplZERlY2xhcmF0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6ICdWYXJpYWJsZURlY2xhcmF0b3InLFxuICAgICAgICAgICAgICAgICAgaWQ6IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ0lkZW50aWZpZXInLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBzdWJQcm9wZXJ0eS5rZXkubmFtZVxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIGluaXQ6IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ01lbWJlckV4cHJlc3Npb24nLFxuICAgICAgICAgICAgICAgICAgICBvYmplY3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnTWVtYmVyRXhwcmVzc2lvbicsXG4gICAgICAgICAgICAgICAgICAgICAgb2JqZWN0OiBkZWNsYXJhdGlvbi5pbml0LFxuICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnR5OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnSWRlbnRpZmllcicsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBwcm9wZXJ0eS5rZXkubmFtZVxuICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgY29tcHV0ZWQ6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnR5OiB7XG4gICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ0lkZW50aWZpZXInLFxuICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHN1YlByb3BlcnR5LmtleS5uYW1lXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGNvbXB1dGVkOiBmYWxzZVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndW5leHBlY3RlZCBzdGF0ZScpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChwcm9wZXJ0eS52YWx1ZS50eXBlID09PSAnSWRlbnRpZmllcicpIHtcbiAgICAgICAgICAgIG5vcm1hbGl6ZWREZWNsYXJhdGlvbnMucHVzaCh7XG4gICAgICAgICAgICAgIHR5cGU6ICdWYXJpYWJsZURlY2xhcmF0b3InLFxuICAgICAgICAgICAgICBpZDoge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdJZGVudGlmaWVyJyxcbiAgICAgICAgICAgICAgICBuYW1lOiBwcm9wZXJ0eS52YWx1ZSAmJiBwcm9wZXJ0eS52YWx1ZS5uYW1lID8gcHJvcGVydHkudmFsdWUubmFtZSA6IHByb3BlcnR5LmtleS5uYW1lXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGluaXQ6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnTWVtYmVyRXhwcmVzc2lvbicsXG4gICAgICAgICAgICAgICAgb2JqZWN0OiBkZWNsYXJhdGlvbi5pbml0LFxuICAgICAgICAgICAgICAgIHByb3BlcnR5OiB7XG4gICAgICAgICAgICAgICAgICB0eXBlOiAnSWRlbnRpZmllcicsXG4gICAgICAgICAgICAgICAgICBuYW1lOiBwcm9wZXJ0eS5rZXkubmFtZVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgY29tcHV0ZWQ6IGZhbHNlXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VuZXhwZWN0ZWQgc3RhdGUnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZGVjbGFyYXRpb24uaWQgJiYgZGVjbGFyYXRpb24uaWQudHlwZSA9PT0gJ0FycmF5UGF0dGVybicgJiYgZGVjbGFyYXRpb24uaWQuZWxlbWVudHMpIHtcbiAgICAgICAgY29uc3QgeyBlbGVtZW50cyB9ID0gZGVjbGFyYXRpb24uaWQ7XG4gICAgICAgIGZvciAobGV0IGVsZW1lbnRJbmRleCA9IDA7IGVsZW1lbnRJbmRleCA8IGVsZW1lbnRzLmxlbmd0aDsgZWxlbWVudEluZGV4KyspIHtcbiAgICAgICAgICBjb25zdCBlbGVtZW50ID0gZWxlbWVudHNbZWxlbWVudEluZGV4XTtcbiAgICAgICAgICBpZiAoZWxlbWVudC50eXBlID09PSAnSWRlbnRpZmllcicpIHtcbiAgICAgICAgICAgIG5vcm1hbGl6ZWREZWNsYXJhdGlvbnMucHVzaCh7XG4gICAgICAgICAgICAgIHR5cGU6ICdWYXJpYWJsZURlY2xhcmF0b3InLFxuICAgICAgICAgICAgICBpZDoge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdJZGVudGlmaWVyJyxcbiAgICAgICAgICAgICAgICBuYW1lOiBlbGVtZW50Lm5hbWVcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgaW5pdDoge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdNZW1iZXJFeHByZXNzaW9uJyxcbiAgICAgICAgICAgICAgICBvYmplY3Q6IGRlY2xhcmF0aW9uLmluaXQsXG4gICAgICAgICAgICAgICAgcHJvcGVydHk6IHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6ICdMaXRlcmFsJyxcbiAgICAgICAgICAgICAgICAgIHZhbHVlOiBlbGVtZW50SW5kZXgsXG4gICAgICAgICAgICAgICAgICByYXc6IGVsZW1lbnRJbmRleC50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgICAgc3RhcnQ6IGVsZW1lbnQuc3RhcnQsXG4gICAgICAgICAgICAgICAgICBlbmQ6IGVsZW1lbnQuZW5kXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBjb21wdXRlZDogdHJ1ZVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmV4cGVjdGVkIHN0YXRlJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub3JtYWxpemVkRGVjbGFyYXRpb25zLnB1c2goZGVjbGFyYXRpb24pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbm9ybWFsaXplZERlY2xhcmF0aW9ucztcbiAgfSxcblxuICBzcGxpdEhUTUxJbWFnZVRvUkdCOiAoZ3B1LCBpbWFnZSkgPT4ge1xuICAgIGNvbnN0IHJLZXJuZWwgPSBncHUuY3JlYXRlS2VybmVsKGZ1bmN0aW9uKGEpIHtcbiAgICAgIGNvbnN0IHBpeGVsID0gYVt0aGlzLnRocmVhZC55XVt0aGlzLnRocmVhZC54XTtcbiAgICAgIHJldHVybiBwaXhlbC5yICogMjU1O1xuICAgIH0sIHtcbiAgICAgIG91dHB1dDogW2ltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHRdLFxuICAgICAgcHJlY2lzaW9uOiAndW5zaWduZWQnLFxuICAgICAgYXJndW1lbnRUeXBlczogeyBhOiAnSFRNTEltYWdlJyB9LFxuICAgIH0pO1xuICAgIGNvbnN0IGdLZXJuZWwgPSBncHUuY3JlYXRlS2VybmVsKGZ1bmN0aW9uKGEpIHtcbiAgICAgIGNvbnN0IHBpeGVsID0gYVt0aGlzLnRocmVhZC55XVt0aGlzLnRocmVhZC54XTtcbiAgICAgIHJldHVybiBwaXhlbC5nICogMjU1O1xuICAgIH0sIHtcbiAgICAgIG91dHB1dDogW2ltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHRdLFxuICAgICAgcHJlY2lzaW9uOiAndW5zaWduZWQnLFxuICAgICAgYXJndW1lbnRUeXBlczogeyBhOiAnSFRNTEltYWdlJyB9LFxuICAgIH0pO1xuICAgIGNvbnN0IGJLZXJuZWwgPSBncHUuY3JlYXRlS2VybmVsKGZ1bmN0aW9uKGEpIHtcbiAgICAgIGNvbnN0IHBpeGVsID0gYVt0aGlzLnRocmVhZC55XVt0aGlzLnRocmVhZC54XTtcbiAgICAgIHJldHVybiBwaXhlbC5iICogMjU1O1xuICAgIH0sIHtcbiAgICAgIG91dHB1dDogW2ltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHRdLFxuICAgICAgcHJlY2lzaW9uOiAndW5zaWduZWQnLFxuICAgICAgYXJndW1lbnRUeXBlczogeyBhOiAnSFRNTEltYWdlJyB9LFxuICAgIH0pO1xuICAgIGNvbnN0IGFLZXJuZWwgPSBncHUuY3JlYXRlS2VybmVsKGZ1bmN0aW9uKGEpIHtcbiAgICAgIGNvbnN0IHBpeGVsID0gYVt0aGlzLnRocmVhZC55XVt0aGlzLnRocmVhZC54XTtcbiAgICAgIHJldHVybiBwaXhlbC5hICogMjU1O1xuICAgIH0sIHtcbiAgICAgIG91dHB1dDogW2ltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHRdLFxuICAgICAgcHJlY2lzaW9uOiAndW5zaWduZWQnLFxuICAgICAgYXJndW1lbnRUeXBlczogeyBhOiAnSFRNTEltYWdlJyB9LFxuICAgIH0pO1xuICAgIGNvbnN0IHJlc3VsdCA9IFtcbiAgICAgIHJLZXJuZWwoaW1hZ2UpLFxuICAgICAgZ0tlcm5lbChpbWFnZSksXG4gICAgICBiS2VybmVsKGltYWdlKSxcbiAgICAgIGFLZXJuZWwoaW1hZ2UpLFxuICAgIF07XG4gICAgcmVzdWx0LnJLZXJuZWwgPSByS2VybmVsO1xuICAgIHJlc3VsdC5nS2VybmVsID0gZ0tlcm5lbDtcbiAgICByZXN1bHQuYktlcm5lbCA9IGJLZXJuZWw7XG4gICAgcmVzdWx0LmFLZXJuZWwgPSBhS2VybmVsO1xuICAgIHJlc3VsdC5ncHUgPSBncHU7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSxcblxuICBzcGxpdFJHQkFUb0NhbnZhc2VzOiAoZ3B1LCByZ2JhLCB3aWR0aCwgaGVpZ2h0KSA9PiB7XG4gICAgY29uc3QgdmlzdWFsS2VybmVsUiA9IGdwdS5jcmVhdGVLZXJuZWwoZnVuY3Rpb24odikge1xuICAgICAgY29uc3QgcGl4ZWwgPSB2W3RoaXMudGhyZWFkLnldW3RoaXMudGhyZWFkLnhdO1xuICAgICAgdGhpcy5jb2xvcihwaXhlbC5yIC8gMjU1LCAwLCAwLCAyNTUpO1xuICAgIH0sIHtcbiAgICAgIG91dHB1dDogW3dpZHRoLCBoZWlnaHRdLFxuICAgICAgZ3JhcGhpY2FsOiB0cnVlLFxuICAgICAgYXJndW1lbnRUeXBlczogeyB2OiAnQXJyYXkyRCg0KScgfVxuICAgIH0pO1xuICAgIHZpc3VhbEtlcm5lbFIocmdiYSk7XG5cbiAgICBjb25zdCB2aXN1YWxLZXJuZWxHID0gZ3B1LmNyZWF0ZUtlcm5lbChmdW5jdGlvbih2KSB7XG4gICAgICBjb25zdCBwaXhlbCA9IHZbdGhpcy50aHJlYWQueV1bdGhpcy50aHJlYWQueF07XG4gICAgICB0aGlzLmNvbG9yKDAsIHBpeGVsLmcgLyAyNTUsIDAsIDI1NSk7XG4gICAgfSwge1xuICAgICAgb3V0cHV0OiBbd2lkdGgsIGhlaWdodF0sXG4gICAgICBncmFwaGljYWw6IHRydWUsXG4gICAgICBhcmd1bWVudFR5cGVzOiB7IHY6ICdBcnJheTJEKDQpJyB9XG4gICAgfSk7XG4gICAgdmlzdWFsS2VybmVsRyhyZ2JhKTtcblxuICAgIGNvbnN0IHZpc3VhbEtlcm5lbEIgPSBncHUuY3JlYXRlS2VybmVsKGZ1bmN0aW9uKHYpIHtcbiAgICAgIGNvbnN0IHBpeGVsID0gdlt0aGlzLnRocmVhZC55XVt0aGlzLnRocmVhZC54XTtcbiAgICAgIHRoaXMuY29sb3IoMCwgMCwgcGl4ZWwuYiAvIDI1NSwgMjU1KTtcbiAgICB9LCB7XG4gICAgICBvdXRwdXQ6IFt3aWR0aCwgaGVpZ2h0XSxcbiAgICAgIGdyYXBoaWNhbDogdHJ1ZSxcbiAgICAgIGFyZ3VtZW50VHlwZXM6IHsgdjogJ0FycmF5MkQoNCknIH1cbiAgICB9KTtcbiAgICB2aXN1YWxLZXJuZWxCKHJnYmEpO1xuXG4gICAgY29uc3QgdmlzdWFsS2VybmVsQSA9IGdwdS5jcmVhdGVLZXJuZWwoZnVuY3Rpb24odikge1xuICAgICAgY29uc3QgcGl4ZWwgPSB2W3RoaXMudGhyZWFkLnldW3RoaXMudGhyZWFkLnhdO1xuICAgICAgdGhpcy5jb2xvcigyNTUsIDI1NSwgMjU1LCBwaXhlbC5hIC8gMjU1KTtcbiAgICB9LCB7XG4gICAgICBvdXRwdXQ6IFt3aWR0aCwgaGVpZ2h0XSxcbiAgICAgIGdyYXBoaWNhbDogdHJ1ZSxcbiAgICAgIGFyZ3VtZW50VHlwZXM6IHsgdjogJ0FycmF5MkQoNCknIH1cbiAgICB9KTtcbiAgICB2aXN1YWxLZXJuZWxBKHJnYmEpO1xuICAgIHJldHVybiBbXG4gICAgICB2aXN1YWxLZXJuZWxSLmNhbnZhcyxcbiAgICAgIHZpc3VhbEtlcm5lbEcuY2FudmFzLFxuICAgICAgdmlzdWFsS2VybmVsQi5jYW52YXMsXG4gICAgICB2aXN1YWxLZXJuZWxBLmNhbnZhcyxcbiAgICBdO1xuICB9LFxuXG4gIGdldE1pbmlmeVNhZmVOYW1lOiAoZm4pID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgYXN0ID0gYWNvcm4ucGFyc2UoYGNvbnN0IHZhbHVlID0gJHtmbi50b1N0cmluZygpfWApO1xuICAgICAgY29uc3QgeyBpbml0IH0gPSBhc3QuYm9keVswXS5kZWNsYXJhdGlvbnNbMF07XG4gICAgICByZXR1cm4gaW5pdC5ib2R5Lm5hbWUgfHwgaW5pdC5ib2R5LmJvZHlbMF0uYXJndW1lbnQubmFtZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VucmVjb2duaXplZCBmdW5jdGlvbiB0eXBlLiAgUGxlYXNlIHVzZSBgKCkgPT4geW91ckZ1bmN0aW9uVmFyaWFibGVIZXJlYCBvciBmdW5jdGlvbigpIHsgcmV0dXJuIHlvdXJGdW5jdGlvblZhcmlhYmxlSGVyZTsgfScpO1xuICAgIH1cbiAgfSxcbiAgc2FuaXRpemVOYW1lOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgaWYgKGRvbGxhclNpZ24udGVzdChuYW1lKSkge1xuICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZShkb2xsYXJTaWduLCAnU19TJyk7XG4gICAgfVxuICAgIGlmIChkb3VibGVVbmRlcnNjb3JlLnRlc3QobmFtZSkpIHtcbiAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoZG91YmxlVW5kZXJzY29yZSwgJ1VfVScpO1xuICAgIH0gZWxzZSBpZiAoc2luZ2xlVW5kZXJzY29yZS50ZXN0KG5hbWUpKSB7XG4gICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKHNpbmdsZVVuZGVyc2NvcmUsICd1X3UnKTtcbiAgICB9XG4gICAgcmV0dXJuIG5hbWU7XG4gIH1cbn07XG5cbmNvbnN0IGRvbGxhclNpZ24gPSAvXFwkLztcbmNvbnN0IGRvdWJsZVVuZGVyc2NvcmUgPSAvX18vO1xuY29uc3Qgc2luZ2xlVW5kZXJzY29yZSA9IC9fLztcblxuY29uc3QgX3N5c3RlbUVuZGlhbm5lc3MgPSB1dGlscy5nZXRTeXN0ZW1FbmRpYW5uZXNzKCk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICB1dGlsc1xufTtcblxufSx7XCIuL2lucHV0XCI6MTEwLFwiLi90ZXh0dXJlXCI6MTEzLFwiYWNvcm5cIjoxfV19LHt9LFsxMDddKSgxMDcpXG59KTtcbiIsImltcG9ydCB7XHJcbiAgSUtlcm5lbEZ1bmN0aW9uVGhpcyxcclxuICBJS2VybmVsUnVuU2hvcnRjdXQsXHJcbiAgSUNvbnN0YW50c1RoaXMsXHJcbiAgR1BVLFxyXG4gIFRocmVhZEtlcm5lbFZhcmlhYmxlLFxyXG4gIEtlcm5lbCxcclxuICBGdW5jdGlvbk5vZGUsXHJcbn0gZnJvbSAnZ3B1LmpzJ1xyXG5cclxuaW50ZXJmYWNlIFJlZHJhdyB7XHJcbiAgKCk6IHZvaWRcclxuICBjaGFuZ2U6IElLZXJuZWxSdW5TaG9ydGN1dFxyXG59XHJcblxyXG5pbnRlcmZhY2UgUmVuZGVyVmFsdWVzIHtcclxuICBtb3VzZVg6IG51bWJlclxyXG4gIG1vdXNlWTogbnVtYmVyXHJcbn1cclxuXHJcbmludGVyZmFjZSBJS2VybmVsRnVuY3Rpb24gZXh0ZW5kcyBJS2VybmVsRnVuY3Rpb25UaGlzIHtcclxuICBudW0oYTogdW5rbm93bik6IG51bWJlclxyXG4gIGRpc3QoeDogbnVtYmVyLCB5OiBudW1iZXIpOiBudW1iZXJcclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIFJlbmRlcmVyIHtcclxuICBwcml2YXRlIHJlbmRlclNldHRpbmdzOiBSZW5kZXJWYWx1ZXMgPSB7XHJcbiAgICBtb3VzZVg6IDEsXHJcbiAgICBtb3VzZVk6IDEsXHJcbiAgfVxyXG5cclxuICBwcm90ZWN0ZWQgaXNEcmF3aW5nOiBib29sZWFuID0gZmFsc2VcclxuICBwdWJsaWMgcmVkcmF3OiBSZWRyYXdcclxuXHJcbiAgcHJvdGVjdGVkIGFzeW5jIGNyZWF0ZVJlbmRlcmVyKGdwdTogR1BVLCBjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50KSB7XHJcbiAgICBjb25zdCByZWRyID0gZ3B1XHJcbiAgICAgIC5jcmVhdGVLZXJuZWwoZnVuY3Rpb24gKG1vdXNlWCwgbW91c2VZKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZGlzdCh4OiBudW1iZXIsIHk6IG51bWJlcikge1xyXG4gICAgICAgICAgcmV0dXJuIE1hdGguc3FydCh4ICogeCArIHkgKiB5KVxyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgZHN0MSA9IGRpc3QoXHJcbiAgICAgICAgICB0aGlzLnRocmVhZC54IC0gKG1vdXNlWCBhcyBudW1iZXIpLFxyXG4gICAgICAgICAgdGhpcy50aHJlYWQueSAtIChtb3VzZVkgYXMgbnVtYmVyKVxyXG4gICAgICAgIClcclxuICAgICAgICAvKlxyXG4gICAgICAgICAgZGlzdChcclxuICAgICAgICAgICAgdGhpcy50aHJlYWQueCAtIChtb3VzZVggYXMgbnVtYmVyKSxcclxuICAgICAgICAgICAgdGhpcy50aHJlYWQueSAtIChtb3VzZVkgYXMgbnVtYmVyKVxyXG4gICAgICAgICAgKSAvIGRpc3QodGhpcy5vdXRwdXQueCwgdGhpcy5vdXRwdXQueSkqL1xyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICBNYXRoLnNxcnQoXHJcbiAgICAgICAgICAgICh0aGlzLnRocmVhZC54IC0gbnVtKG1vdXNlWCkpICpcclxuICAgICAgICAgICAgICAodGhpcy50aHJlYWQueCAtIChtb3VzZVggYXMgbnVtYmVyKSkgK1xyXG4gICAgICAgICAgICAgICh0aGlzLm91dHB1dC55IC0gdGhpcy50aHJlYWQueSAtIChtb3VzZVkgYXMgbnVtYmVyKSkgKlxyXG4gICAgICAgICAgICAgICAgKHRoaXMub3V0cHV0LnkgLSB0aGlzLnRocmVhZC55IC0gKG1vdXNlWSBhcyBudW1iZXIpKVxyXG4gICAgICAgICAgKSAvXHJcbiAgICAgICAgICBNYXRoLnNxcnQoXHJcbiAgICAgICAgICAgIHRoaXMub3V0cHV0LnggKiB0aGlzLm91dHB1dC54ICsgdGhpcy5vdXRwdXQueSAqIHRoaXMub3V0cHV0LnlcclxuICAgICAgICAgICkqL1xyXG4gICAgICAgIHRoaXMuY29sb3IoMC4zLCBNYXRoLm1heCgxIC0gMiAqIGRzdDEsIDApLCBNYXRoLm1heCgxIC0gMiAqIGRzdDEsIDApLCAxKVxyXG4gICAgICB9KVxyXG4gICAgICAuc2V0T3V0cHV0KFtjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHRdKVxyXG4gICAgICAuc2V0RHluYW1pY091dHB1dCh0cnVlKVxyXG4gICAgICAuc2V0R3JhcGhpY2FsKHRydWUpXHJcbiAgICAgIC5zZXREZWJ1Zyh0cnVlKVxyXG5cclxuICAgIGxldCByZWRyYXcgPSAoKCkgPT4ge1xyXG4gICAgICByZWRyKHRoaXMucmVuZGVyU2V0dGluZ3MubW91c2VYLCB0aGlzLnJlbmRlclNldHRpbmdzLm1vdXNlWSlcclxuICAgIH0pIGFzIFJlZHJhd1xyXG4gICAgcmVkcmF3LmNoYW5nZSA9IHJlZHJcclxuICAgIHRoaXMucmVkcmF3ID0gcmVkcmF3XHJcbiAgICByZWRyYXcoKVxyXG4gIH1cclxuXHJcbiAgcHJvdGVjdGVkIHNldFZhcihuYW1lOiBrZXlvZiBSZW5kZXJWYWx1ZXMsIHZhbDogbnVtYmVyKSB7XHJcbiAgICB0aGlzLnJlbmRlclNldHRpbmdzW2Ake25hbWUgYXMga2V5b2YgUmVuZGVyVmFsdWVzfWBdID0gdmFsXHJcbiAgfVxyXG59XHJcbiIsIi8vIFRoZSBtb2R1bGUgY2FjaGVcbnZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcblxuLy8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbmZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG5cdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuXHRpZiAoY2FjaGVkTW9kdWxlICE9PSB1bmRlZmluZWQpIHtcblx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG5cdH1cblx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcblx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG5cdFx0Ly8gbm8gbW9kdWxlLmlkIG5lZWRlZFxuXHRcdC8vIG5vIG1vZHVsZS5sb2FkZWQgbmVlZGVkXG5cdFx0ZXhwb3J0czoge31cblx0fTtcblxuXHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cblx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0obW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cblx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcblx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xufVxuXG4iLCIvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuX193ZWJwYWNrX3JlcXVpcmVfXy5uID0gKG1vZHVsZSkgPT4ge1xuXHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cblx0XHQoKSA9PiAobW9kdWxlWydkZWZhdWx0J10pIDpcblx0XHQoKSA9PiAobW9kdWxlKTtcblx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgeyBhOiBnZXR0ZXIgfSk7XG5cdHJldHVybiBnZXR0ZXI7XG59OyIsIi8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb25zIGZvciBoYXJtb255IGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uZCA9IChleHBvcnRzLCBkZWZpbml0aW9uKSA9PiB7XG5cdGZvcih2YXIga2V5IGluIGRlZmluaXRpb24pIHtcblx0XHRpZihfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZGVmaW5pdGlvbiwga2V5KSAmJiAhX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIGtleSkpIHtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBkZWZpbml0aW9uW2tleV0gfSk7XG5cdFx0fVxuXHR9XG59OyIsIl9fd2VicGFja19yZXF1aXJlX18ubyA9IChvYmosIHByb3ApID0+IChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKSkiLCIvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSAoZXhwb3J0cykgPT4ge1xuXHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcblx0fVxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xufTsiLCJpbXBvcnQgeyBHUFUsIElLZXJuZWxSdW5TaG9ydGN1dCB9IGZyb20gJ2dwdS5qcydcclxuaW1wb3J0IHsgUmVuZGVyZXIgfSBmcm9tICdAL3JlbmRlcmVyJ1xyXG5cclxuLy8gaW50ZXJmYWNlIFBoeXNpY3Mge31cclxuXHJcbmNsYXNzIERyYXdpbmdBcHAgZXh0ZW5kcyBSZW5kZXJlciB7XHJcbiAgcHJpdmF0ZSBncHU6IEdQVVxyXG4gIHByaXZhdGUgY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudFxyXG4gIC8vIHByaXZhdGUgY29udGV4dDogV2ViR0wyUmVuZGVyaW5nQ29udGV4dFxyXG5cclxuICBwcml2YXRlIHByZXNzZWQ6IGJvb2xlYW4gPSBmYWxzZVxyXG4gIHByaXZhdGUgY2xpY2tYOiBudW1iZXJcclxuICBwcml2YXRlIGNsaWNrWTogbnVtYmVyXHJcblxyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgc3VwZXIoKVxyXG4gICAgbGV0IGJvZHkgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnYm9keScpWzBdXHJcbiAgICBsZXQgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJylcclxuICAgIGxldCBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJ3dlYmdsMicpXHJcbiAgICBsZXQgZ3B1ID0gbmV3IEdQVSh7IGNhbnZhcywgY29udGV4dCB9KVxyXG5cclxuICAgIGJvZHkuc3R5bGUubWFyZ2luID0gJzBweCdcclxuICAgIGJvZHkuc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJ1xyXG4gICAgYm9keS5hcHBlbmRDaGlsZChjYW52YXMpXHJcblxyXG4gICAgY2FudmFzLndpZHRoID0gd2luZG93LmlubmVyV2lkdGhcclxuICAgIGNhbnZhcy5oZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHRcclxuXHJcbiAgICB0aGlzLmNhbnZhcyA9IGNhbnZhc1xyXG4gICAgLy8gdGhpcy5jb250ZXh0ID0gY29udGV4dFxyXG4gICAgdGhpcy5ncHUgPSBncHVcclxuXHJcbiAgICB0aGlzLmNyZWF0ZVVzZXJFdmVudHMoKVxyXG4gICAgdGhpcy5jcmVhdGVSZW5kZXJlcihncHUsIGNhbnZhcylcclxuICB9XHJcblxyXG4gIHByaXZhdGUgY3JlYXRlVXNlckV2ZW50cygpIHtcclxuICAgIGxldCBjYW52YXMgPSB0aGlzLmNhbnZhc1xyXG5cclxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZScsIHRoaXMuZm9jdXNFdmVudEhhbmRsZXIpXHJcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVyb3V0JywgKCkgPT4gKHRoaXMuaXNEcmF3aW5nID0gZmFsc2UpKVxyXG5cclxuICAgIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLnByZXNzRXZlbnRIYW5kbGVyKVxyXG4gICAgY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMuZHJhZ0V2ZW50SGFuZGxlcilcclxuICAgIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5yZWxlYXNlRXZlbnRIYW5kbGVyKVxyXG4gICAgY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlb3V0JywgdGhpcy5jYW5jZWxFdmVudEhhbmRsZXIpXHJcblxyXG4gICAgY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCB0aGlzLnByZXNzRXZlbnRIYW5kbGVyKVxyXG4gICAgY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMuZHJhZ0V2ZW50SGFuZGxlcilcclxuICAgIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMucmVsZWFzZUV2ZW50SGFuZGxlcilcclxuICAgIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGNhbmNlbCcsIHRoaXMuY2FuY2VsRXZlbnRIYW5kbGVyKVxyXG5cclxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLnJlc2l6ZUV2ZW50SGFuZGxlcilcclxuICB9XHJcblxyXG4gIHByaXZhdGUgZm9jdXNFdmVudEhhbmRsZXIgPSAoKSA9PiB7XHJcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5yZWRyYXcpXHJcbiAgfVxyXG5cclxuICBwcml2YXRlIHJlc2l6ZUV2ZW50SGFuZGxlciA9ICgpID0+IHtcclxuICAgIHRoaXMucmVkcmF3LmNoYW5nZS5zZXRPdXRwdXQoW3dpbmRvdy5pbm5lcldpZHRoLCB3aW5kb3cuaW5uZXJIZWlnaHRdKVxyXG4gICAgdGhpcy5jYW52YXMud2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aFxyXG4gICAgdGhpcy5jYW52YXMuaGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIHJlbGVhc2VFdmVudEhhbmRsZXIgPSAoKSA9PiB7XHJcbiAgICB0aGlzLnByZXNzZWQgPSBmYWxzZVxyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBjYW5jZWxFdmVudEhhbmRsZXIgPSAoKSA9PiB7XHJcbiAgICB0aGlzLnByZXNzZWQgPSBmYWxzZVxyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBwcmVzc0V2ZW50SGFuZGxlciA9IChlOiBNb3VzZUV2ZW50IHwgVG91Y2hFdmVudCkgPT4ge1xyXG4gICAgbGV0IG1vdXNlWCA9IChlIGFzIFRvdWNoRXZlbnQpLmNoYW5nZWRUb3VjaGVzXHJcbiAgICAgID8gKGUgYXMgVG91Y2hFdmVudCkuY2hhbmdlZFRvdWNoZXNbMF0ucGFnZVhcclxuICAgICAgOiAoZSBhcyBNb3VzZUV2ZW50KS5wYWdlWFxyXG4gICAgbGV0IG1vdXNlWSA9IChlIGFzIFRvdWNoRXZlbnQpLmNoYW5nZWRUb3VjaGVzXHJcbiAgICAgID8gKGUgYXMgVG91Y2hFdmVudCkuY2hhbmdlZFRvdWNoZXNbMF0ucGFnZVlcclxuICAgICAgOiAoZSBhcyBNb3VzZUV2ZW50KS5wYWdlWVxyXG4gICAgbW91c2VYIC09IHRoaXMuY2FudmFzLm9mZnNldExlZnRcclxuICAgIG1vdXNlWSAtPSB0aGlzLmNhbnZhcy5vZmZzZXRUb3BcclxuXHJcbiAgICB0aGlzLnByZXNzZWQgPSB0cnVlXHJcbiAgICB0aGlzLmNsaWNrWCA9IG1vdXNlWFxyXG4gICAgdGhpcy5jbGlja1kgPSBtb3VzZVlcclxuICAgIHRoaXMuc2V0VmFyKCdtb3VzZVgnLCBtb3VzZVgpXHJcbiAgICB0aGlzLnNldFZhcignbW91c2VZJywgbW91c2VZKVxyXG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpXHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGRyYWdFdmVudEhhbmRsZXIgPSAoZTogTW91c2VFdmVudCB8IFRvdWNoRXZlbnQpID0+IHtcclxuICAgIGxldCBtb3VzZVggPSAoZSBhcyBUb3VjaEV2ZW50KS5jaGFuZ2VkVG91Y2hlc1xyXG4gICAgICA/IChlIGFzIFRvdWNoRXZlbnQpLmNoYW5nZWRUb3VjaGVzWzBdLnBhZ2VYXHJcbiAgICAgIDogKGUgYXMgTW91c2VFdmVudCkucGFnZVhcclxuICAgIGxldCBtb3VzZVkgPSAoZSBhcyBUb3VjaEV2ZW50KS5jaGFuZ2VkVG91Y2hlc1xyXG4gICAgICA/IChlIGFzIFRvdWNoRXZlbnQpLmNoYW5nZWRUb3VjaGVzWzBdLnBhZ2VZXHJcbiAgICAgIDogKGUgYXMgTW91c2VFdmVudCkucGFnZVlcclxuICAgIG1vdXNlWCAtPSB0aGlzLmNhbnZhcy5vZmZzZXRMZWZ0XHJcbiAgICBtb3VzZVkgLT0gdGhpcy5jYW52YXMub2Zmc2V0VG9wXHJcblxyXG4gICAgaWYgKHRoaXMucHJlc3NlZCkge1xyXG4gICAgICB0aGlzLmNsaWNrWCA9IG1vdXNlWFxyXG4gICAgICB0aGlzLmNsaWNrWSA9IG1vdXNlWVxyXG4gICAgICB0aGlzLnNldFZhcignbW91c2VYJywgbW91c2VYKVxyXG4gICAgICB0aGlzLnNldFZhcignbW91c2VZJywgbW91c2VZKVxyXG4gICAgfVxyXG4gICAgLy8gZ2FtZS5yZWRyYXcoKVxyXG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpXHJcbiAgfVxyXG59XHJcblxyXG5jb25zdCBnYW1lID0gbmV3IERyYXdpbmdBcHAoKVxyXG47KGZ1bmN0aW9uIGxvb3AoKSB7XHJcbiAgZ2FtZS5yZWRyYXcoKVxyXG4gIHJlcXVlc3RBbmltYXRpb25GcmFtZShsb29wKVxyXG59KSgpXHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==